MACRO ASSEMBLER BLHELI                                      05/26/15 14:36:45 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=96) OBJECT(OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
  0002                 142     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       143     $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                       650     ENDIF
                       651     
                       652     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       656     
                       657     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       661     
                       662     IF BESC == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       666     
                       667     
                       668     ;**** **** **** **** ****
                       669     ; TX programming defaults
                       670     ;
                       671     ; Parameter dependencies:
                       672     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       673     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       674     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       675     ; - Damping force is only used if DampedLight or Damped is selected
                       676     ;
                       677     ; Main
  0007                 678     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 679     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 680     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 681     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 682     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 683     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 684     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 685     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 686     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 687     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 688     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 689     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 690     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 691     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 692     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 693     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 694     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 695     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 696     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       697     ; Tail
  0003                 698     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 699     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 700     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 701     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 702     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 703     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 704     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       705     IF DAMPED_MODE_ENABLE == 1
  0004                 706     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       707     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 710     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 711     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 712     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 713     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 714     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 715     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       716     ; Multi
  0009                 717     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 718     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 719     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 720     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 721     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 722     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 723     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 724     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 725     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 726     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       727     IF DAMPED_MODE_ENABLE == 1
  0001                 728     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       729     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 732     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 733     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 734     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0014                 735     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 20	; Beep strength
  0014                 736     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 20	; Beacon strength
  0005                 737     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       738     ; Common
  0000                 739     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 740     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 741     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 742     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 743     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       744     
                       745     ;**** **** **** **** ****
                       746     ; Constant definitions for main
                       747     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       769     ; Constant definitions for tail
                       770     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       791     ; Constant definitions for multi
                       792     IF MODE == 2
                       793     
  0001                 794     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       795     
  000A                 796     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 797     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 798     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 799     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 800     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 801     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 802     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 803     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       804     
  0032                 805     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 806     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       807     
  000A                 808     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 809     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       810     
  0008                 811     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       812     
                       813     ENDIF
                       814     
                       815     ;**** **** **** **** ****
                       816     ; Temporary register definitions
  REG                  817     TEMP1		EQU	R0
  REG                  818     TEMP2		EQU	R1
  REG                  819     TEMP3		EQU	R2
  REG                  820     TEMP4		EQU	R3
  REG                  821     TEMP5		EQU	R4
  REG                  822     TEMP6		EQU	R5
  REG                  823     TEMP7		EQU	R6
  REG                  824     TEMP8		EQU	R7
                       825     
                       826     ;**** **** **** **** ****
                       827     ; Register definitions
------                 828     DSEG AT 20H					; Variables segment 
                       829     
0020                   830     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   831     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       832     
0022                   833     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   834     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   835     CURRENT_PWM: 				DS	1		; Current pwm
0025                   836     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   837     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   838     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   839     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   840     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   841     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       842     
002B                   843     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 844     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 845     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 846     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 847     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 848     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       849     ;						EQU 	5
                       850     ;						EQU 	6
                       851     ;						EQU 	7
                       852     
002C                   853     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 854     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 855     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 856     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 857     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 858     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 859     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 860     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       861     ;						EQU 	7
                       862     
002D                   863     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 864     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 865     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 866     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 867     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 868     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 869     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       870     ;						EQU 	6	
                       871     ;						EQU 	7	
                       872     
002E                   873     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 874     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 875     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 876     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 877     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 878     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 879     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 880     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 881     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       882     
                       883     ;**** **** **** **** ****
                       884     ; RAM definitions
------                 885     DSEG AT 30H						; Ram data segment, direct addressing
                       886     
0030                   887     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       888     
0031                   889     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   890     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       891     
0033                   892     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   893     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   894     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   895     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   896     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   897     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   898     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       899     
003A                   900     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   901     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   902     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   903     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   904     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   905     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       906     
0040                   907     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   908     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   909     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   910     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   911     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   912     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   913     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   914     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   915     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   916     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       917     
004A                   918     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   919     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   920     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   921     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   922     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   923     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   924     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   925     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       926     
0052                   927     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   928     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   929     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   930     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   931     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   932     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   933     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   934     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   935     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   936     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   937     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   938     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       939     
005E                   940     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   941     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   942     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   943     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   944     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   945     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       946     
0064                   947     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   948     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       949     
0066                   950     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   951     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       952     
0068                   953     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   954     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   955     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   956     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   957     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       958     
006D                   959     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       960     
006E                   961     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   962     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       963     
0070                   964     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   965     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   966     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       967     
                       968     
                       969     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       970     ;
                       971     ; Skypup 2015.05.25
                       972     ; 宏定义
                       973     ;
                       974     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       975     ;
  0002                 976     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 977     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       978     ;
  00FF                 979     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                 980     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                       981     ;
  0004                 982     HOLD_FULL_H		EQU	04H	; 1075 0x0433 高位, Futaba SB6208 15S
  0033                 983     HOLD_FULL_L		EQU	33H	; 1075 0x0433 低位, Futaba SB6208 15S
  0075                 984     HOLD_CRUISE_H		EQU	75H	; 30000 0x7530 高位, Futaba SB6208 7min
  0030                 985     HOLD_CRUISE_L		EQU	30H	; 30000 0x7530 低位, Futaba SB6208 7min
                       986     
                       987     
                       988     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       989     ;
                       990     ; Skypup 2015.05.25
                       991     ; 变量定义
                       992     ;
                       993     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       994     ;
0073                   995     FLAG_BEFORE_ARM: 			DS	1		; 标记在解锁前需要 New_Rcp 为一个较大的值
0074                   996     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                       997     ;
0075                   998     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                 999     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1000     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1001     ;
0076                  1002     NHOLD_L: 					DS	1		; nHold 低位
0077                  1003     NHOLD_H: 					DS	1		; nHold 高位
                      1004     ;
0078                  1005     CSTATE: 					DS	1		; 状态
                      1006     ;
                      1007     ;	State 状态矩阵
                      1008     ; 
                      1009     ;	00   ->   10   ->   20   ->   00
                      1010     ; 
                      1011     ;	00:Wait          -> 10
                      1012     ;	10:Full          -> 20
                      1013     ;	20:Cruise        -> 00
  0000                1014     STATE_WAIT		EQU	00H
  0010                1015     STATE_FULL		EQU	10H
  0020                1016     STATE_CRUISE		EQU	20H
                      1017     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1018     
                      1019     ; Indirect addressing data segment. The variables below must be in this sequence
------                1020     ISEG AT 080H					
0080                  1021     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1022     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1023     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1024     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1025     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1026     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1027     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1028     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1029     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1030     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1031     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1032     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1033     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1034     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1035     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1036     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1037     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1038     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1039     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1040     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1041     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1042     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1043     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1044     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1045     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1046     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1047     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1048     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1049     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1050     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1051     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1052     
                      1053     ; The sequence of the variables below is no longer of importance
009F                  1054     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1055     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1056     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1057     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1058     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1059     
                      1060     
                      1061     ; Indirect addressing data segment
------                1062     ISEG AT 0D0H					
00D0                  1063     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1064     
                      1065     
                      1066     ;**** **** **** **** ****
------                1067     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1068     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1069     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1070     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1071     
1A00    0B            1072     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1073     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1074     EEP_LAYOUT_REVISION:  DB 17 
                      1075     
                      1076     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1109     
                      1110     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1143     
                      1144     IF MODE == 2
1A03    09            1145     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1146     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1147     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1148     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1149     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1150     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1151     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1152     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1153     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1154     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1155     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1156     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1157     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1158     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1159     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1160     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1161     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1162     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1163     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1164     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1165     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1166     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1167     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1168     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    14            1169     EEP_PGM_BEEP_STRENGTH:  DB 20 
1A1C    14            1170     EEP_PGM_BEACON_STRENGTH:  DB 20 
1A1D    05            1171     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1172     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1173     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1174     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1175     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1176     ENDIF
                      1177     
                      1178     
1A22    FF            1179     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1180     
------                1181     CSEG AT 1A60H
1A60    6F72672E      1182     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1183     
                      1184     ;**** **** **** **** ****
                      1185             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1185+1   CSEG AT 0  ; CODE SEGMENT START
0000    021326        1185+1   JMP RESET 
------                1185+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1185+1   JMP T0_INT 
------                1185+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1185+1   JMP T2_INT 
------                1185+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1185+1   JMP PCA_INT 
------                1185+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1185+1   JMP T3_INT 
------                1186     CSEG AT 80H			; Code segment after interrupt vectors 
                      1187     
                      1188     ;**** **** **** **** ****
                      1189     
                      1190     ; Table definitions
0080    02030406      1191     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1192     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1193     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1194     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1195     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1198     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1206     IF MODE == 2
                      1207       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1208     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1209       ENDIF
                      1210       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1213     ENDIF
                      1214     
                      1215     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1216     ;
                      1217     ; Timer0 interrupt routine
                      1218     ;
                      1219     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1220     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1221     ;
                      1222     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1223     T0_INT: 	; Used for pwm control
00BA    C2AF          1224     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1225     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1226     	PUSH	ACC		
                      1227     	; Check if pwm is on
00C0    205A10        1228     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1229     
                      1230     	; Do not execute pwm when stopped
00C3    30600A        1231     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1232     	; Do not execute pwm on during demag recovery
00C6    205C07        1233     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1234     	; Pwm on cycle. 
00C9    302F02        1235     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1236     
                      1237     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1238     	CLR	A					
00CD    73            1239     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1240     
                      1241     T0_INT_PWM_ON_LOW_PWM: 
                      1242     
                      1243     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1244     	JMP	T0_INT_PWM_ON_EXECUTE
                      1245     ENDIF
                      1246     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1263     
                      1264     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1265     	JMP	T0_INT_PWM_ON_EXIT
                      1266     
                      1267     
                      1268     T0_INT_PWM_OFF: 
00D3    306306        1269     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1270     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    D297          1270+1   SETB P1 . 7 
00D8    D295          1270+1   SETB P1 . 5 
00DA    D293          1270+1   SETB P1 . 3 
                      1271     T0_INT_PWM_OFF_START_CHECKED: 
                      1272     	; Pwm off cycle
00DC    85258A        1273     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1274     	; Clear pwm on flag
00DF    C25A          1275     CLR FLAGS0 . 2 
                      1276     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1277     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1278     	CPL	A						; Full pwm?
00E4    7002          1279     	JNZ	($+4)					; No - branch
00E6    21C6          1280     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1281     
00E8    0563          1282     	INC	PWM_OFF_CNT				; Increment event counter
                      1283     	; Do not execute pwm when stopped
00EA    306013        1284     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1285     
                      1286     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1287     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1288     
                      1289     	; Separate exit commands here for minimum delay
00F0    758B00        1290     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1291     	POP	ACC			; Restore preserved registers
00F5    D0D0          1292     	POP	PSW
                      1293     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    D297          1293+1   SETB P1 . 7 
00F9    D295          1293+1   SETB P1 . 5 
00FB    D293          1293+1   SETB P1 . 3 
00FD    D2AF          1294     	SETB	EA			; Enable all interrupts
00FF    32            1295     	RETI
                      1296     
                      1297     T0_INT_PWM_OFF_STOPPED: 
                      1298     	ALL_NFETS_OFF 					; Switch off all nfets
0100    D297          1298+1   SETB P1 . 7 
0102    D295          1298+1   SETB P1 . 5 
0104    D293          1298+1   SETB P1 . 3 
0106    0201B6        1299     	JMP	T0_INT_PWM_OFF_EXIT
                      1300     
                      1301     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1302     SETB FLAGS1 . 5 
010B    C266          1303     CLR FLAGS1 . 6 
010D    E567          1304     	MOV	A, DAMPING_ON
010F    601C          1305     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1306     
0111    C3            1307     	CLR	C
0112    E563          1308     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1309     	DEC	A
0115    9567          1310     	SUBB	A, DAMPING_ON
0117    4014          1311     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1312     
0119    C265          1313     CLR FLAGS1 . 5 
011B    D266          1314     SETB FLAGS1 . 6 
011D    C3            1315     	CLR	C
011E    E563          1316     	MOV	A, PWM_OFF_CNT					
0120    9566          1317     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1318     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1319     
0124    0201B6        1320     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1321     
                      1322     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1323     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1324     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1325     
                      1326     T0_INT_PWM_OFF_DO_DAMPED: 
                      1327     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1328     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1329     
                      1330     	ALL_NFETS_OFF 					; Switch off all nfets
0130    D297          1330+1   SETB P1 . 7 
0132    D295          1330+1   SETB P1 . 5 
0134    D293          1330+1   SETB P1 . 3 
0136    7406          1331     MOV A , # 6 
0138    D5E0FD        1332     	DJNZ	ACC, $	
                      1333     	ALL_PFETS_ON 					; Switch on all pfets
013B    D296          1333+1   SETB P1 . 6 
013D    D294          1333+1   SETB P1 . 4 
013F    D292          1333+1   SETB P1 . 2 
0141    0201B6        1334     	JMP	T0_INT_PWM_OFF_EXIT
                      1335     
                      1336     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1337     IF DAMPED_MODE_ENABLE == 1
0144    D266          1338     SETB FLAGS1 . 6 
                      1339     ENDIF
                      1340     	ALL_NFETS_OFF 					; Switch off all nfets
0146    D297          1340+1   SETB P1 . 7 
0148    D295          1340+1   SETB P1 . 5 
014A    D293          1340+1   SETB P1 . 3 
014C    E53E          1341     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1342     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1343     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1344     
                      1345     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1348     MOV A , # 6 
0156    D5E0FD        1349     	DJNZ	ACC, $	
                      1350     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1350+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D292          1350+1   SETB P1 . 2 
015E    307502        1350+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D296          1350+1   SETB P1 . 6 
                      1351     ENDIF
0163    0201B6        1352     	JMP	T0_INT_PWM_OFF_EXIT
                      1353     
                      1354     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1355     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1356     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1359     MOV A , # 6 
016B    D5E0FD        1360     	DJNZ	ACC, $	
                      1361     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1361+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D292          1361+1   SETB P1 . 2 
0173    307502        1361+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D296          1361+1   SETB P1 . 6 
                      1362     ENDIF
0178    0201B6        1363     	JMP	T0_INT_PWM_OFF_EXIT
                      1364     
                      1365     T0_INT_PWM_OFF_COMM_3: 
                      1366     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1369     MOV A , # 6 
017D    D5E0FD        1370     	DJNZ	ACC, $	
                      1371     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1371+1   SETB P1 . 4 
                      1372     ENDIF
0182    0201B6        1373     	JMP	T0_INT_PWM_OFF_EXIT
                      1374     
                      1375     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1376     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1377     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1378     
                      1379     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1382     MOV A , # 6 
018D    D5E0FD        1383     	DJNZ	ACC, $	
                      1384     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1384+1   SETB P1 . 4 
                      1385     ENDIF
0192    0201B6        1386     	JMP	T0_INT_PWM_OFF_EXIT
                      1387     
                      1388     T0_INT_PWM_OFF_COMM_5: 
                      1389     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1392     MOV A , # 6 
0197    D5E0FD        1393     	DJNZ	ACC, $	
                      1394     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1394+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D296          1394+1   SETB P1 . 6 
019F    307502        1394+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D292          1394+1   SETB P1 . 2 
                      1395     ENDIF
01A4    0201B6        1396     	JMP	T0_INT_PWM_OFF_EXIT
                      1397     
                      1398     T0_INT_PWM_OFF_COMM_6: 
                      1399     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1402     MOV A , # 6 
01A9    D5E0FD        1403     	DJNZ	ACC, $	
                      1404     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1404+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D296          1404+1   SETB P1 . 6 
01B1    307502        1404+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D292          1404+1   SETB P1 . 2 
                      1405     ENDIF
                      1406     
                      1407     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1408     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1409     	POP	ACC			; Restore preserved registers
01BB    D0D0          1410     	POP	PSW
                      1411     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    D297          1411+1   SETB P1 . 7 
01BF    D295          1411+1   SETB P1 . 5 
01C1    D293          1411+1   SETB P1 . 3 
01C3    D2AF          1412     	SETB	EA			; Enable all interrupts
01C5    32            1413     	RETI
                      1414     
                      1415     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1416     	POP	ACC			; Restore preserved registers
01C8    D0D0          1417     	POP	PSW
01CA    D2AF          1418     	SETB	EA			; Enable all interrupts
01CC    32            1419     	RETI
                      1420     
                      1421     
                      1422     
                      1423     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1424     	AJMP	T0_INT_PWM_ON_EXIT
                      1425     
                      1426     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1427     	ANFET_ON	
01CF    E525          1427+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1427+1   JZ ( $+12 ) 
01D3    207502        1427+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    C297          1427+1   CLR P1 . 7 
01D8    307502        1427+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    C293          1427+1   CLR P1 . 3 
                      1428     	BNFET_OFF
01DD    D295          1428+1   SETB P1 . 5 
01DF    61D3          1429     	AJMP	T0_INT_PWM_ON_EXIT
                      1430     
                      1431     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1432     	BNFET_ON
01E1    E525          1432+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1432+1   JZ ( $+4 ) 
01E5    C295          1432+1   CLR P1 . 5 
                      1433     	CNFET_OFF
01E7    207502        1433+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    D293          1433+1   SETB P1 . 3 
01EC    307502        1433+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    D297          1433+1   SETB P1 . 7 
01F1    61D3          1434     	AJMP	T0_INT_PWM_ON_EXIT
                      1435     
                      1436     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1437     	CNFET_ON
01F3    E525          1437+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1437+1   JZ ( $+12 ) 
01F7    207502        1437+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    C293          1437+1   CLR P1 . 3 
01FC    307502        1437+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    C297          1437+1   CLR P1 . 7 
                      1438     	ANFET_OFF
0201    207502        1438+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    D297          1438+1   SETB P1 . 7 
0206    307502        1438+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    D293          1438+1   SETB P1 . 3 
020B    61D3          1439     	AJMP	T0_INT_PWM_ON_EXIT
                      1440     
                      1441     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1442     	APFET_OFF
020D    207502        1442+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C296          1442+1   CLR P1 . 6 
0212    307502        1442+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C292          1442+1   CLR P1 . 2 
                      1443     	ANFET_ON								; Switch nFETs
0217    E525          1443+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1443+1   JZ ( $+12 ) 
021B    207502        1443+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    C297          1443+1   CLR P1 . 7 
0220    307502        1443+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    C293          1443+1   CLR P1 . 3 
                      1444     	CPFET_OFF
0225    207502        1444+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C292          1444+1   CLR P1 . 2 
022A    307502        1444+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C296          1444+1   CLR P1 . 6 
                      1445     	BNFET_OFF 							
022F    D295          1445+1   SETB P1 . 5 
0231    61D3          1446     	AJMP	T0_INT_PWM_ON_EXIT
                      1447     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1448     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1449     	APFET_OFF
0233    207502        1449+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C296          1449+1   CLR P1 . 6 
0238    307502        1449+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C292          1449+1   CLR P1 . 2 
                      1450     	CPFET_OFF
023D    207502        1450+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C292          1450+1   CLR P1 . 2 
0242    307502        1450+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C296          1450+1   CLR P1 . 6 
0247    7406          1451     MOV A , # 6 
0249    D5E0FD        1452     	DJNZ ACC,	$
                      1453     	ANFET_ON								; Switch nFETs
024C    E525          1453+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1453+1   JZ ( $+12 ) 
0250    207502        1453+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    C297          1453+1   CLR P1 . 7 
0255    307502        1453+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    C293          1453+1   CLR P1 . 3 
                      1454     	BNFET_OFF 							
025A    D295          1454+1   SETB P1 . 5 
025C    61D3          1455     	AJMP	T0_INT_PWM_ON_EXIT
                      1456     
                      1457     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1458     	APFET_OFF
025E    207502        1458+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C296          1458+1   CLR P1 . 6 
0263    307502        1458+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C292          1458+1   CLR P1 . 2 
                      1459     	ANFET_ON								; Switch nFETs
0268    E525          1459+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1459+1   JZ ( $+12 ) 
026C    207502        1459+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    C297          1459+1   CLR P1 . 7 
0271    307502        1459+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    C293          1459+1   CLR P1 . 3 
                      1460     	BPFET_OFF
0276    C294          1460+1   CLR P1 . 4 
                      1461     	BNFET_OFF								
0278    D295          1461+1   SETB P1 . 5 
027A    61D3          1462     	AJMP	T0_INT_PWM_ON_EXIT
                      1463     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1464     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1465     	APFET_OFF
027C    207502        1465+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C296          1465+1   CLR P1 . 6 
0281    307502        1465+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C292          1465+1   CLR P1 . 2 
                      1466     	BPFET_OFF
0286    C294          1466+1   CLR P1 . 4 
0288    7406          1467     MOV A , # 6 
028A    D5E0FD        1468     	DJNZ ACC,	$
                      1469     	ANFET_ON								; Switch nFETs
028D    E525          1469+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1469+1   JZ ( $+12 ) 
0291    207502        1469+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    C297          1469+1   CLR P1 . 7 
0296    307502        1469+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    C293          1469+1   CLR P1 . 3 
                      1470     	BNFET_OFF								
029B    D295          1470+1   SETB P1 . 5 
029D    61D3          1471     	AJMP	T0_INT_PWM_ON_EXIT
                      1472     
                      1473     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1474     	BPFET_OFF
029F    C294          1474+1   CLR P1 . 4 
                      1475     	BNFET_ON								; Switch nFETs
02A1    E525          1475+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1475+1   JZ ( $+4 ) 
02A5    C295          1475+1   CLR P1 . 5 
                      1476     	APFET_OFF
02A7    207502        1476+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C296          1476+1   CLR P1 . 6 
02AC    307502        1476+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C292          1476+1   CLR P1 . 2 
                      1477     	CNFET_OFF								
02B1    207502        1477+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    D293          1477+1   SETB P1 . 3 
02B6    307502        1477+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    D297          1477+1   SETB P1 . 7 
02BB    61D3          1478     	AJMP	T0_INT_PWM_ON_EXIT
                      1479     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1480     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1481     	BPFET_OFF
02BD    C294          1481+1   CLR P1 . 4 
                      1482     	APFET_OFF
02BF    207502        1482+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C296          1482+1   CLR P1 . 6 
02C4    307502        1482+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C292          1482+1   CLR P1 . 2 
02C9    7406          1483     MOV A , # 6 
02CB    D5E0FD        1484     	DJNZ ACC,	$
                      1485     	BNFET_ON								; Switch nFETs
02CE    E525          1485+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1485+1   JZ ( $+4 ) 
02D2    C295          1485+1   CLR P1 . 5 
                      1486     	CNFET_OFF								
02D4    207502        1486+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    D293          1486+1   SETB P1 . 3 
02D9    307502        1486+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    D297          1486+1   SETB P1 . 7 
02DE    61D3          1487     	AJMP	T0_INT_PWM_ON_EXIT
                      1488     
                      1489     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1490     	BPFET_OFF
02E0    C294          1490+1   CLR P1 . 4 
                      1491     	BNFET_ON								; Switch nFETs
02E2    E525          1491+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1491+1   JZ ( $+4 ) 
02E6    C295          1491+1   CLR P1 . 5 
                      1492     	CPFET_OFF
02E8    207502        1492+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C292          1492+1   CLR P1 . 2 
02ED    307502        1492+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C296          1492+1   CLR P1 . 6 
                      1493     	CNFET_OFF								
02F2    207502        1493+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    D293          1493+1   SETB P1 . 3 
02F7    307502        1493+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    D297          1493+1   SETB P1 . 7 
02FC    61D3          1494     	AJMP	T0_INT_PWM_ON_EXIT
                      1495     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1496     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1497     	BPFET_OFF
02FE    C294          1497+1   CLR P1 . 4 
                      1498     	CPFET_OFF
0300    207502        1498+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C292          1498+1   CLR P1 . 2 
0305    307502        1498+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C296          1498+1   CLR P1 . 6 
030A    7406          1499     MOV A , # 6 
030C    D5E0FD        1500     	DJNZ ACC,	$
                      1501     	BNFET_ON								; Switch nFETs
030F    E525          1501+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1501+1   JZ ( $+4 ) 
0313    C295          1501+1   CLR P1 . 5 
                      1502     	CNFET_OFF								
0315    207502        1502+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    D293          1502+1   SETB P1 . 3 
031A    307502        1502+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    D297          1502+1   SETB P1 . 7 
031F    61D3          1503     	AJMP	T0_INT_PWM_ON_EXIT
                      1504     
                      1505     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1506     	CPFET_OFF
0321    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C292          1506+1   CLR P1 . 2 
0326    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C296          1506+1   CLR P1 . 6 
                      1507     	CNFET_ON								; Switch nFETs
032B    E525          1507+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1507+1   JZ ( $+12 ) 
032F    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    C293          1507+1   CLR P1 . 3 
0334    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    C297          1507+1   CLR P1 . 7 
                      1508     	BPFET_OFF
0339    C294          1508+1   CLR P1 . 4 
                      1509     	ANFET_OFF								
033B    207502        1509+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    D297          1509+1   SETB P1 . 7 
0340    307502        1509+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    D293          1509+1   SETB P1 . 3 
0345    61D3          1510     	AJMP	T0_INT_PWM_ON_EXIT
                      1511     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1512     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1513     	CPFET_OFF
0347    207502        1513+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C292          1513+1   CLR P1 . 2 
034C    307502        1513+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C296          1513+1   CLR P1 . 6 
                      1514     	BPFET_OFF
0351    C294          1514+1   CLR P1 . 4 
0353    7406          1515     MOV A , # 6 
0355    D5E0FD        1516     	DJNZ ACC,	$
                      1517     	CNFET_ON								; Switch nFETs
0358    E525          1517+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1517+1   JZ ( $+12 ) 
035C    207502        1517+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    C293          1517+1   CLR P1 . 3 
0361    307502        1517+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    C297          1517+1   CLR P1 . 7 
                      1518     	ANFET_OFF								
0366    207502        1518+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    D297          1518+1   SETB P1 . 7 
036B    307502        1518+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    D293          1518+1   SETB P1 . 3 
0370    61D3          1519     	AJMP	T0_INT_PWM_ON_EXIT
                      1520     
                      1521     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1522     	CPFET_OFF
0372    207502        1522+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C292          1522+1   CLR P1 . 2 
0377    307502        1522+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C296          1522+1   CLR P1 . 6 
                      1523     	CNFET_ON								; Switch nFETs
037C    E525          1523+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1523+1   JZ ( $+12 ) 
0380    207502        1523+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    C293          1523+1   CLR P1 . 3 
0385    307502        1523+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    C297          1523+1   CLR P1 . 7 
                      1524     	APFET_OFF
038A    207502        1524+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C296          1524+1   CLR P1 . 6 
038F    307502        1524+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C292          1524+1   CLR P1 . 2 
                      1525     	ANFET_OFF								
0394    207502        1525+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    D297          1525+1   SETB P1 . 7 
0399    307502        1525+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    D293          1525+1   SETB P1 . 3 
039E    61D3          1526     	AJMP	T0_INT_PWM_ON_EXIT
                      1527     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1528     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1529     	CPFET_OFF
03A0    207502        1529+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C292          1529+1   CLR P1 . 2 
03A5    307502        1529+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C296          1529+1   CLR P1 . 6 
                      1530     	APFET_OFF
03AA    207502        1530+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C296          1530+1   CLR P1 . 6 
03AF    307502        1530+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C292          1530+1   CLR P1 . 2 
03B4    7406          1531     MOV A , # 6 
03B6    D5E0FD        1532     	DJNZ ACC,	$
                      1533     	CNFET_ON								; Switch nFETs
03B9    E525          1533+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1533+1   JZ ( $+12 ) 
03BD    207502        1533+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    C293          1533+1   CLR P1 . 3 
03C2    307502        1533+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    C297          1533+1   CLR P1 . 7 
                      1534     	ANFET_OFF								
03C7    207502        1534+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    D297          1534+1   SETB P1 . 7 
03CC    307502        1534+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    D293          1534+1   SETB P1 . 3 
03D1    61D3          1535     	AJMP	T0_INT_PWM_ON_EXIT
                      1536     
                      1537     T0_INT_PWM_ON_EXIT: 
                      1538     	; Set timer for coming on cycle length
03D3    E525          1539     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1540     	CPL	A						; cpl is 255-x
03D6    F58A          1541     	MOV	TL0, A					; Write start point for timer
                      1542     	; Set other variables
03D8    758B00        1543     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1544     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1545     SETB FLAGS0 . 2 
                      1546     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1547     	; Exit interrupt
03E0    D0E0          1548     	POP	ACC			; Restore preserved registers
03E2    D0D0          1549     	POP	PSW
03E4    D2AF          1550     	SETB	EA			; Enable all interrupts
03E6    32            1551     	RETI
                      1552     
                      1553     
                      1554     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1555     ;
                      1556     ; Timer2 interrupt routine
                      1557     ;
                      1558     ; No assumptions
                      1559     ;
                      1560     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1561     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1562     	CLR	EA
03E9    C2AD          1563     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1564     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1565     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1566     	PUSH	ACC
03F2    D2D3          1567     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1568     	SETB	EA
                      1569     	; Clear low byte interrupt flag
03F6    C2CE          1570     	CLR	TF2L						; Clear interrupt flag
                      1571     	; Check RC pulse timeout counter
03F8    E528          1572     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1573     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1574     
                      1575     	; Decrement timeout counter (if PWM)
03FC    741F          1576     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1577     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1578     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1579     
0402    1528          1580     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1581     	AJMP	T2_INT_SKIP_START
                      1582     
                      1583     T2_INT_PULSES_ABSENT: 
                      1584     	; Timeout counter has reached zero, pulses are absent
0406    7800          1585     MOV R0 , # 0 
0408    7900          1586     MOV R1 , # 0 
                      1587     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1587+1   MOV A , P0 
040C    307601        1587+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1587+1   CPL A  ; YES - INVERT
0410    30E502        1588     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1589     MOV R0 , # 255 
                      1590     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1590+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1590+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1590+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1590+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1590+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1591     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1591+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1592     CLR FLAGS2 . 1 
                      1593     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1593+1   MOV A , P0 
042A    307601        1593+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1593+1   CPL A  ; YES - INVERT
042E    30E502        1594     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1595     MOV R1 , # 255 
0433    C3            1596     	CLR	C
0434    E8            1597     MOV A , R0 
0435    99            1598     SUBB A , R1 
0436    70CE          1599     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1600     
0438    305903        1601     JNB FLAGS0 . 1 , ( $+6 ) 
                      1602     
043B    752818        1603     MOV RCP_TIMEOUT_CNT , # 24 
                      1604     
043E    741F          1605     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1606     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1607     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1608     
0444    752818        1609     MOV RCP_TIMEOUT_CNT , # 24 
                      1610     
                      1611     
                      1612     T2_INT_PPM_TIMEOUT_SET: 
                      1613     
                      1614     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1615     ; 
                      1616     ; 对 RCP 信号处理
                      1617     ; 1 小于 1500us 最低油门
                      1618     ; 2 大于 1500us 正常处理
                      1619     ; 
                      1620     ;	clr C
                      1621     ;	mov A, Temp1
                      1622     ;	subb A, #80h
                      1623     ;	jnc skypup_01
                      1624     ;	mov	Temp1, #RCP_MIN
                      1625     ; skypup_01:
                      1626     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1627     MOV NEW_RCP , R0 
0449    D268          1628     SETB FLAGS2 . 0 
                      1629     
                      1630     T2_INT_SKIP_START: 
                      1631     	; Check RC pulse skip counter
044B    E529          1632     	MOV	A, RCP_SKIP_CNT			
044D    6004          1633     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1634     	
                      1635     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1636     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1637     	AJMP	T2_INT_RCP_UPDATE_START
                      1638     
                      1639     T2_INT_SKIP_END: 
0453    741F          1640     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1641     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1642     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1643     
                      1644     	; Skip counter has reached zero, start looking for RC pulses again
                      1645     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1645+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1646     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1646+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1647     	
                      1648     T2_INT_RCP_UPDATE_START: 
                      1649     	; Process updated RC pulse
045E    206802        1650     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1651     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1652     
0463    E559          1653     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1654     MOV R0 , A 
0466    C268          1655     CLR FLAGS2 . 0 
                      1656     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1657     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1658     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1659     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1660     
                      1661     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1664     
                      1665     IF MODE == 2	; Multi
046E    7982          1666     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1667     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1668     ENDIF
                      1669     
                      1670     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1671     	CLR	C
0474    E8            1672     MOV A , R0 
0475    94F0          1673     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1674     	JC	T2_INT_RCP_UPDATE_MULT
                      1675     
0479    74F0          1676     	MOV	A, #240			; Set requested pwm to max
047B    F8            1677     MOV R0 , A 
                      1678     
                      1679     T2_INT_RCP_UPDATE_MULT: 	
                      1680     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1681     MOV A , R0 
047D    C4            1682     	SWAP	A			; After this "0.0625"
047E    540F          1683     	ANL	A, #0FH
0480    28            1684     ADD A , R0 
0481    F8            1685     MOV R0 , A 
                      1686     	; Adjust tail gain
0482    7984          1687     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1688     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1689     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1690     
0489    C3            1691     	CLR	C
048A    13            1692     	RRC	A			; After this "0.5"
048B    C3            1693     	CLR	C
048C    13            1694     	RRC	A			; After this "0.25"
048D    8721          1695     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1696     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1697     
0492    C3            1698     	CLR	C
0493    13            1699     	RRC	A			; After this "0.125"
                      1700     
                      1701     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1702     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1703     
0497    C3            1704     	CLR	C
0498    C8            1705     XCH A , R0 
0499    98            1706     SUBB A , R0 
049A    F8            1707     MOV R0 , A 
049B    81A4          1708     	AJMP	T2_INT_PWM_MIN_RUN
                      1709     
                      1710     T2_INT_RCP_GAIN_POS: 
049D    28            1711     ADD A , R0 
049E    F8            1712     MOV R0 , A 
049F    5003          1713     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1714     
04A1    74FF          1715     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1716     MOV R0 , A 
                      1717     
                      1718     T2_INT_PWM_MIN_RUN:  
                      1719     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1729     
                      1730     T2_INT_PWM_UPDATE:  
                      1731     	; Check if any startup phase flags are set
04A4    E52C          1732     	MOV	A, FLAGS1
04A6    5406          1733     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1734     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1735     
                      1736     	; Update requested_pwm
04AA    8822          1737     MOV REQUESTED_PWM , R0 
                      1738     	; Limit pwm during direct start
04AC    30630A        1739     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1740     
04AF    C3            1741     	CLR	C
04B0    E522          1742     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1743     	SUBB	A, PWM_LIMIT
04B4    4003          1744     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1745     
04B6    855E22        1746     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1747     
                      1748     T2_INT_CURRENT_PWM_UPDATE:  
                      1749     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1750     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1751     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1752     ENDIF
                      1753     
                      1754     	; Update current pwm, with limited throttle change rate
04BE    C3            1755     	CLR	C
04BF    E522          1756     	MOV	A, REQUESTED_PWM	 
04C1    9524          1757     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1758     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1759     
                      1760     	; 缓启动
04C5    78A1          1761     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1762     	;mov	Temp1, #1
04C7    96            1763     SUBB A , @ R0 
                      1764     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1765     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1766     
04CA    E524          1767     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1768     ADD A , @ R0 
                      1769     	; add	A, Temp1
04CD    F524          1770     	MOV	CURRENT_PWM, A
04CF    5009          1771     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1772     
04D1    7524FF        1773     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1774     	JMP	T2_INT_CURRENT_PWM_DONE
                      1775     
                      1776     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1777     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1778     T2_INT_CURRENT_PWM_DONE: 
                      1779     IF MODE >= 1	; Tail or multi
                      1780     	; Set current_pwm_limited
04DA    A824          1781     MOV R0 , CURRENT_PWM 
04DC    C3            1782     	CLR	C
04DD    E524          1783     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1784     	SUBB	A, PWM_LIMIT
04E1    4002          1785     	JC	($+4)					; If current pwm below limit - branch
                      1786     
04E3    A85E          1787     MOV R0 , PWM_LIMIT 
                      1788     
04E5    8825          1789     MOV CURRENT_PWM_LIMITED , R0 
                      1790     ENDIF
                      1791     T2_INT_PWM_EXIT: 	
                      1792     	; Check if high byte flag is set
04E7    20CF0C        1793     	JB	TF2H, T2H_INT		
04EA    D0E0          1794     	POP	ACC			; Restore preserved registers
04EC    D0D0          1795     	POP	PSW
04EE    C2D3          1796     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1797     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1798     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1799     	RETI
                      1800     
                      1801     T2H_INT: 
                      1802     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1803     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1804     MOV R0 , # 1 
                      1805     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1806     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1807     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1808     
                      1809     	; Decrement timeout counter (if PPM)
04FE    741F          1810     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1811     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1812     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1813     
0504    1528          1814     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1815     
                      1816     T2H_INT_RCP_STOP_CHECK: 
                      1817     	; Check RC pulse against stop value
0506    C3            1818     	CLR	C
0507    E559          1819     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1820     SUBB A , # 1 
050B    4005          1821     	JC	T2H_INT_RCP_STOP
                      1822     
                      1823     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1824     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1825     	AJMP	T2H_INT_RCP_GOV_PWM
                      1826     
                      1827     T2H_INT_RCP_STOP: 	
                      1828     	; RC pulse less than stop value
0512    755D00        1829     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1830     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1831     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1832     	ADD	A, #1
051C    F55C          1833     	MOV	RCP_STOP_CNT, A
051E    5003          1834     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1835     
0520    755CFF        1836     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1837     
                      1838     T2H_INT_RCP_GOV_PWM: 
                      1839     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1968     IF MODE == 2	; Multi
0523    E55F          1969     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1970     	ADD	A, #10
0527    5005          1971     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1972     
0529    755FFF        1973     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1974     	AJMP	T2H_INT_RCP_EXIT
                      1975     
                      1976     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1977     	MOV	PWM_LIMIT_SPOOLUP, A
                      1978     ENDIF
                      1979     
                      1980     T2H_INT_RCP_EXIT: 
0530    D0E0          1981     	POP	ACC			; Restore preserved registers
0532    D0D0          1982     	POP	PSW
0534    C2D3          1983     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1984     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1985     	SETB	ET2			; Enable timer2 interrupts
053B    32            1986     	RETI
                      1987     
                      1988     
                      1989     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1990     ;
                      1991     ; Timer3 interrupt routine
                      1992     ;
                      1993     ; No assumptions
                      1994     ;
                      1995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1996     T3_INT: 	; Used for commutation timing
053C    C2AF          1997     	CLR 	EA			; Disable all interrupts
053E    53917F        1998     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1999     CLR FLAGS0 . 0 
0543    D2AF          2000     	SETB	EA			; Enable all interrupts
0545    32            2001     	RETI
                      2002     
                      2003     
                      2004     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2005     ;
                      2006     ; PCA interrupt routine
                      2007     ;
                      2008     ; No assumptions
                      2009     ;
                      2010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2011     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2012     	CLR	EA
0548    53E6EF        2013     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2014     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2015     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2016     	PUSH	ACC
0551    C0F0          2017     	PUSH	B
0553    D2D3          2018     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2019     	SETB	EA
                      2020     	; Get the PCA counter values
                      2021     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2021+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2021+1   MOV R1 , PCA0CPH0 
                      2022     	; Clear interrupt flag
                      2023     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2023+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2024     	; Check which edge it is
055D    306902        2025     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B3          2026     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2027     
                      2028     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2028+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2028+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2028+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2028+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2028+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2029     SETB FLAGS2 . 1 
                      2030     	; Read RC signal level
                      2031     	READ_RCP_INT			
0573    E580          2031+1   MOV A , P0 
0575    307601        2031+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2031+1   CPL A  ; YES - INVERT
                      2032     	; Test RC signal level
0579    20E502        2033     JB ACC . 5 , ( $+5 ) 
057C    A185          2034     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2035     
                      2036     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2037     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2038     MOV RCP_PREV_EDGE_H , R1 
0582    020824        2039     	LJMP	PCA_INT_EXIT				; Exit
                      2040     
                      2041     PCA_INT_FAIL_MINIMUM: 
                      2042     	; Prepare for next interrupt
                      2043     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2043+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2043+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2043+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2043+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2043+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2044     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2044+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2045     CLR FLAGS2 . 1 
0598    741F          2046     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2047     	ANL	A, FLAGS3					; Check pwm frequency flags
                      2048     	; jnz	($+4)					; If a flag is set (PWM) - proceed
059C    7003          2049     	JNZ	LINE_TEMP01					; If a flag is set (PWM) - proceed, Skypup 2015.05.26
                      2050     
                      2051     	; ajmp	pca_int_set_timeout			; If PPM - ignore trig as noise
059E    02080A        2052     	LJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise, Skypup 2015.05.26
                      2053     LINE_TEMP01: 
                      2054     
05A1    7800          2055     MOV R0 , # 0 
                      2056     	READ_RCP_INT 					; Test RC signal level again
05A3    E580          2056+1   MOV A , P0 
05A5    307601        2056+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A8    F4            2056+1   CPL A  ; YES - INVERT
                      2057     	; jnb	ACC.Rcp_In, ($+5)			; Is it high?
05A9    30E503        2058     JNB ACC . 5 , LINE_TEMP02 
                      2059     	; ajmp	pca_int_set_timeout			; Yes - set new timeout and exit
05AC    02080A        2060     	LJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit, Skypup 2015.05.26
                      2061     LINE_TEMP02: 
                      2062     
                      2063     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2064     ; 
                      2065     ; 对 RCP 信号处理
                      2066     ; 1 小于 1500us 最低油门
                      2067     ; 2 大于 1500us 正常处理
                      2068     ; 
                      2069     ;	clr C
                      2070     ;	mov A, Temp1
                      2071     ;	subb A, #80h
                      2072     ;	jnc skypup_02
                      2073     ;	mov	Temp1, #RCP_MIN
                      2074     ; skypup_02:
                      2075     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2076     
05AF    8859          2077     MOV NEW_RCP , R0 
05B1    E188          2078     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2079     
                      2080     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2081     	; Prepare for next interrupt
                      2082     	RCP_INT_FIRST 					; Set first edge trig
05B3    53DACF        2082+1   ANL PCA0CPM0 , # 0CFH 
05B6    207603        2082+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B9    43DA20        2082+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BC    307603        2082+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BF    43DA10        2082+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C2    C269          2083     CLR FLAGS2 . 1 
                      2084     	; Check if pwm frequency shall be measured
05C4    205902        2085     JB FLAGS0 . 1 , ( $+5 ) 
05C7    C16D          2086     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2087     
                      2088     	; Set second edge trig only during pwm frequency measurement
                      2089     	RCP_INT_SECOND 				; Set second edge trig
05C9    53DACF        2089+1   ANL PCA0CPM0 , # 0CFH 
05CC    207603        2089+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CF    43DA10        2089+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D2    307603        2089+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D5    43DA20        2089+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2090     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D8    C2D8          2090+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05DA    D269          2091     SETB FLAGS2 . 1 
                      2092     	; Store edge data to RAM
05DC    8854          2093     MOV RCP_EDGE_L , R0 
05DE    8955          2094     MOV RCP_EDGE_H , R1 
                      2095     	; Calculate pwm frequency
05E0    C3            2096     	CLR	C
05E1    E8            2097     MOV A , R0 
05E2    9552          2098     	SUBB	A, RCP_PREPREV_EDGE_L	
05E4    F8            2099     MOV R0 , A 
05E5    E9            2100     MOV A , R1 
05E6    9553          2101     	SUBB	A, RCP_PREPREV_EDGE_H
05E8    F9            2102     MOV R1 , A 
05E9    E4            2103     	CLR	A
05EA    FB            2104     MOV R3 , A 
05EB    7AFA          2105     MOV R2 , # 250 
                      2106     	; Check if pwm frequency is 12kHz
05ED    C3            2107     	CLR	C
05EE    E8            2108     MOV A , R0 
05EF    94C8          2109     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05F1    E9            2110     MOV A , R1 
05F2    9400          2111     	SUBB	A, #HIGH(200)
05F4    5008          2112     	JNC	PCA_INT_CHECK_8KHZ
                      2113     
05F6    E4            2114     	CLR	A
05F7    D2E4          2115     SETB ACC . 4 
05F9    FB            2116     MOV R3 , A 
05FA    7A0A          2117     MOV R2 , # 10 
05FC    C140          2118     	AJMP	PCA_INT_RESTORE_EDGE
                      2119     
                      2120     PCA_INT_CHECK_8KHZ: 
                      2121     	; Check if pwm frequency is 8kHz
05FE    C3            2122     	CLR	C
05FF    E8            2123     MOV A , R0 
0600    9468          2124     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0602    E9            2125     MOV A , R1 
0603    9401          2126     	SUBB	A, #HIGH(360)
0605    5008          2127     	JNC	PCA_INT_CHECK_4KHZ
                      2128     
0607    E4            2129     	CLR	A
0608    D2E3          2130     SETB ACC . 3 
060A    FB            2131     MOV R3 , A 
060B    7A0F          2132     MOV R2 , # 15 
060D    C140          2133     	AJMP	PCA_INT_RESTORE_EDGE
                      2134     
                      2135     PCA_INT_CHECK_4KHZ: 
                      2136     	; Check if pwm frequency is 4kHz
060F    C3            2137     	CLR	C
0610    E8            2138     MOV A , R0 
0611    94D0          2139     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0613    E9            2140     MOV A , R1 
0614    9402          2141     	SUBB	A, #HIGH(720)
0616    5008          2142     	JNC	PCA_INT_CHECK_2KHZ
                      2143     
0618    E4            2144     	CLR	A
0619    D2E2          2145     SETB ACC . 2 
061B    FB            2146     MOV R3 , A 
061C    7A1E          2147     MOV R2 , # 30 
061E    C140          2148     	AJMP	PCA_INT_RESTORE_EDGE
                      2149     
                      2150     PCA_INT_CHECK_2KHZ: 
                      2151     	; Check if pwm frequency is 2kHz
0620    C3            2152     	CLR	C
0621    E8            2153     MOV A , R0 
0622    94A0          2154     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0624    E9            2155     MOV A , R1 
0625    9405          2156     	SUBB	A, #HIGH(1440)
0627    5008          2157     	JNC	PCA_INT_CHECK_1KHZ
                      2158     
0629    E4            2159     	CLR	A
062A    D2E1          2160     SETB ACC . 1 
062C    FB            2161     MOV R3 , A 
062D    7A3C          2162     MOV R2 , # 60 
062F    C140          2163     	AJMP	PCA_INT_RESTORE_EDGE
                      2164     
                      2165     PCA_INT_CHECK_1KHZ: 
                      2166     	; Check if pwm frequency is 1kHz
0631    C3            2167     	CLR	C
0632    E8            2168     MOV A , R0 
0633    9498          2169     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0635    E9            2170     MOV A , R1 
0636    9408          2171     	SUBB	A, #HIGH(2200)
0638    5006          2172     	JNC	PCA_INT_RESTORE_EDGE
                      2173     
063A    E4            2174     	CLR	A
063B    D2E0          2175     SETB ACC . 0 
063D    FB            2176     MOV R3 , A 
063E    7A78          2177     MOV R2 , # 120 
                      2178     
                      2179     PCA_INT_RESTORE_EDGE: 
                      2180     	; Calculate difference between this period and previous period
0640    C3            2181     	CLR	C
0641    E8            2182     MOV A , R0 
0642    9556          2183     	SUBB	A, RCP_PREV_PERIOD_L
0644    FC            2184     MOV R4 , A 
0645    E9            2185     MOV A , R1 
0646    9557          2186     	SUBB	A, RCP_PREV_PERIOD_H
0648    FD            2187     MOV R5 , A 
                      2188     	; Make positive
0649    30E708        2189     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064C    EC            2190     MOV A , R4 
064D    F4            2191     	CPL	A
064E    2401          2192     	ADD	A, #1
0650    FC            2193     MOV R4 , A 
0651    ED            2194     MOV A , R5 
0652    F4            2195     	CPL	A
0653    FD            2196     MOV R5 , A 
                      2197     
                      2198     PCA_INT_CHECK_DIFF: 
                      2199     	; Check difference
0654    755800        2200     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0657    7008          2201     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2202     
0659    C3            2203     	CLR	C
065A    EC            2204     MOV A , R4 
065B    9A            2205     SUBB A , R2 
065C    5003          2206     	JNC	PCA_INT_STORE_DATA
                      2207     
065E    755801        2208     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2209     
                      2210     PCA_INT_STORE_DATA: 
                      2211     	; Store previous period
0661    8856          2212     MOV RCP_PREV_PERIOD_L , R0 
0663    8957          2213     MOV RCP_PREV_PERIOD_H , R1 
                      2214     	; Restore edge data from RAM
0665    A854          2215     MOV R0 , RCP_EDGE_L 
0667    A955          2216     MOV R1 , RCP_EDGE_H 
                      2217     	; Store pre previous edge
0669    8852          2218     MOV RCP_PREPREV_EDGE_L , R0 
066B    8953          2219     MOV RCP_PREPREV_EDGE_H , R1 
                      2220     
                      2221     PCA_INT_FALL: 
                      2222     	; RC pulse edge was second, calculate new pulse length
066D    C3            2223     	CLR	C
066E    E8            2224     MOV A , R0 
066F    9526          2225     	SUBB	A, RCP_PREV_EDGE_L	
0671    F8            2226     MOV R0 , A 
0672    E9            2227     MOV A , R1 
0673    9527          2228     	SUBB	A, RCP_PREV_EDGE_H
0675    F9            2229     MOV R1 , A 
0676    307402        2230     JNB FLAGS3 . 4 , ( $+5 ) 
0679    E16C          2231     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
067B    307302        2232     JNB FLAGS3 . 3 , ( $+5 ) 
067E    E16C          2233     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2234     
0680    307202        2235     JNB FLAGS3 . 2 , ( $+5 ) 
0683    E165          2236     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2237     
0685    E9            2238     MOV A , R1 
0686    C3            2239     	CLR	C
0687    13            2240     	RRC	A
0688    F9            2241     MOV R1 , A 
0689    E8            2242     MOV A , R0 
068A    13            2243     	RRC	A
068B    F8            2244     MOV R0 , A 
                      2245     
068C    307102        2246     JNB FLAGS3 . 1 , ( $+5 ) 
068F    E165          2247     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2248     
0691    E9            2249     MOV A , R1 
0692    C3            2250     	CLR	C
0693    13            2251     	RRC	A
0694    F9            2252     MOV R1 , A 
0695    E8            2253     MOV A , R0 
0696    13            2254     	RRC	A
0697    F8            2255     MOV R0 , A 
                      2256     
0698    307002        2257     JNB FLAGS3 . 0 , ( $+5 ) 
069B    E165          2258     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2259     
069D    E9            2260     MOV A , R1 
069E    C3            2261     	CLR	C
069F    13            2262     	RRC	A
06A0    FD            2263     MOV R5 , A 
06A1    E8            2264     MOV A , R0 
06A2    13            2265     	RRC	A
06A3    FC            2266     MOV R4 , A 
                      2267     	; Skip range limitation if pwm frequency measurement
06A4    205918        2268     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2269     
                      2270     	; Check if 2160us or above (in order to ignore false pulses)
06A7    C3            2271     	CLR	C
06A8    EC            2272     MOV A , R4 
06A9    941C          2273     	SUBB	A, #28
06AB    ED            2274     MOV A , R5 
06AC    9402          2275     	SUBB A, #2
06AE    4003          2276     	JC	($+5)						; No - proceed
                      2277     
06B0    02080A        2278     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2279     
                      2280     	; Check if below 800us (in order to ignore false pulses)
06B3    ED            2281     MOV A , R5 
06B4    7009          2282     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2283     
06B6    C3            2284     	CLR	C
06B7    EC            2285     MOV A , R4 
06B8    94C8          2286     	SUBB	A, #200
06BA    5003          2287     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2288     
06BC    02080A        2289     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2290     
                      2291     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2292     	; Calculate "1000us" plus throttle minimum
06BF    7400          2293     	MOV	A, #0						; Set 1000us as default minimum
06C1    20770B        2294     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2295     
                      2296     IF MODE >= 1	; Tail or multi
06C4    7888          2297     MOV R0 , # PGM_DIRECTION 
06C6    E6            2298     MOV A , @ R0 
                      2299     ENDIF
06C7    7896          2300     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2301     IF MODE >= 1	; Tail or multi
06C9    B40302        2302     	CJNE	A, #3, ($+5)
                      2303     
06CC    789E          2304     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2305     ENDIF
06CE    E6            2306     MOV A , @ R0 
                      2307     
                      2308     PCA_INT_PPM_CALCULATE: 
06CF    24FA          2309     	ADD	A, #250						; Add 1000us to minimum
06D1    FE            2310     MOV R6 , A 
06D2    E4            2311     	CLR	A
06D3    3400          2312     	ADDC	A, #0
06D5    FF            2313     MOV R7 , A 
                      2314     
06D6    C3            2315     	CLR	C
06D7    EC            2316     MOV A , R4 
06D8    9E            2317     SUBB A , R6 
06D9    FC            2318     MOV R4 , A 
06DA    ED            2319     MOV A , R5 
06DB    9F            2320     SUBB A , R7 
06DC    FD            2321     MOV R5 , A 
                      2322     IF MODE >= 1	; Tail or multi
06DD    9208          2323     	MOV	BIT_ACCESS_INT.0, C
06DF    7888          2324     MOV R0 , # PGM_DIRECTION 
06E1    E6            2325     MOV A , @ R0 
06E2    B40322        2326     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2327     
06E5    A208          2328     	MOV	C, BIT_ACCESS_INT.0
06E7    5009          2329     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2330     
                      2331     PCA_INT_PPM_BIDIR_REV: 
06E9    20751B        2332     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2333     
06EC    C2AF          2334     	CLR	EA							; Direction change, turn off all fets
06EE    D275          2335     SETB FLAGS3 . 5 
06F0    C1F9          2336     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2337     
                      2338     PCA_INT_PPM_BIDIR_FWD: 
06F2    307512        2339     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2340     
06F5    C2AF          2341     	CLR	EA							; Direction change, turn off all fets
06F7    C275          2342     CLR FLAGS3 . 5 
                      2343     
                      2344     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2345     	ALL_NFETS_OFF
06F9    D297          2345+1   SETB P1 . 7 
06FB    D295          2345+1   SETB P1 . 5 
06FD    D293          2345+1   SETB P1 . 3 
                      2346     	ALL_PFETS_OFF
06FF    C296          2346+1   CLR P1 . 6 
0701    C294          2346+1   CLR P1 . 4 
0703    C292          2346+1   CLR P1 . 2 
0705    D2AF          2347     	SETB	EA
                      2348     
                      2349     PCA_INT_PPM_BIDIR_DIR_SET: 
0707    A208          2350     	MOV	C, BIT_ACCESS_INT.0
                      2351     ENDIF
0709    5017          2352     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2353     
                      2354     IF MODE >= 1	; Tail or multi
070B    E6            2355     MOV A , @ R0 
070C    B4030D        2356     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2357     
070F    EC            2358     MOV A , R4 
0710    F4            2359     	CPL	A
0711    2401          2360     	ADD	A, #1
0713    FC            2361     MOV R4 , A 
0714    ED            2362     MOV A , R5 
0715    F4            2363     	CPL	A
0716    3400          2364     	ADDC	A, #0
0718    FD            2365     MOV R5 , A 
0719    020722        2366     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2367     
                      2368     PCA_INT_PPM_UNIDIR_NEG: 
                      2369     ENDIF
071C    7800          2370     MOV R0 , # 0 
071E    7900          2371     MOV R1 , # 0 
0720    E16C          2372     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2373     
                      2374     PCA_INT_PPM_NEG_CHECKED: 
                      2375     IF MODE >= 1	; Tail or multi
0722    7888          2376     MOV R0 , # PGM_DIRECTION 
0724    E6            2377     MOV A , @ R0 
0725    B40315        2378     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2379     
0728    EC            2380     MOV A , R4 
0729    33            2381     	RLC	A
072A    FC            2382     MOV R4 A 
072B    ED            2383     MOV A , R5 
072C    33            2384     	RLC	A
072D    FD            2385     MOV R5 A 
072E    C3            2386     	CLR	C							; Subtract deadband
072F    EC            2387     MOV A , R4 
0730    9405          2388     	SUBB	A, #5		
0732    FC            2389     MOV R4 , A 
0733    ED            2390     MOV A , R5 
0734    9400          2391     	SUBB	A, #0
0736    FD            2392     MOV R5 , A 
0737    5004          2393     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2394     
0739    7C00          2395     MOV R4 , # 0 
073B    7D00          2396     MOV R5 , # 0 
                      2397     
                      2398     PCA_INT_PPM_BIDIR_DONE: 
                      2399     ENDIF
073D    C3            2400     	CLR	C							; Check that RC pulse is within legal range (max 255)
073E    EC            2401     MOV A , R4 
073F    94FF          2402     SUBB A , # 255 
0741    ED            2403     MOV A , R5 
0742    9400          2404     	SUBB	A, #0
0744    4006          2405     	JC	PCA_INT_PPM_MAX_CHECKED
                      2406     
0746    78FF          2407     MOV R0 , # 255 
0748    7900          2408     MOV R1 , # 0 
074A    E16C          2409     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2410     
                      2411     PCA_INT_PPM_MAX_CHECKED: 
074C    EC            2412     MOV A , R4 
074D    856EF0        2413     	MOV	B, PPM_THROTTLE_GAIN
0750    A4            2414     	MUL	AB
0751    C5F0          2415     	XCH	A, B
0753    A2F7          2416     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0755    33            2417     	RLC	A
0756    F8            2418     MOV R0 , A 
0757    7900          2419     MOV R1 , # 0 
0759    4003          2420     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2421     	
075B    020788        2422     	JMP	PCA_INT_LIMITED			
                      2423     
                      2424     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075E    78FF          2425     MOV R0 , # 255 
0760    7900          2426     MOV R1 , # 0 
0762    020788        2427     	JMP	PCA_INT_LIMITED			
                      2428     
                      2429     PCA_INT_PWM_DIVIDE: 
0765    E9            2430     MOV A , R1 
0766    C3            2431     	CLR	C
0767    13            2432     	RRC	A
0768    F9            2433     MOV R1 , A 
0769    E8            2434     MOV A , R0 
076A    13            2435     	RRC	A
076B    F8            2436     MOV R0 , A 
                      2437     
                      2438     PCA_INT_PWM_DIVIDE_DONE: 
076C    30740E        2439     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076F    E9            2440     MOV A , R1 
0770    6002          2441     	JZ	($+4)
                      2442     
0772    78FF          2443     MOV R0 , # 255 
                      2444     
0774    C3            2445     	CLR	C
0775    E8            2446     MOV A , R0 
0776    13            2447     	RRC	A
0777    38            2448     ADDC A , R0 
0778    F8            2449     MOV R0 , A 
0779    E4            2450     	CLR	A
077A    3400          2451     	ADDC	A, #0
077C    F9            2452     MOV R1 , A 
                      2453     
                      2454     PCA_INT_CHECK_LEGAL_RANGE: 
                      2455     	; Check that RC pulse is within legal range
077D    C3            2456     	CLR	C
077E    E8            2457     MOV A , R0 
077F    94FF          2458     SUBB A , # 255 
0781    E9            2459     MOV A , R1 
0782    9400          2460     	SUBB	A, #0
0784    4002          2461     	JC	PCA_INT_LIMITED
                      2462     
0786    78FF          2463     MOV R0 , # 255 
                      2464     
                      2465     PCA_INT_LIMITED: 
                      2466     
                      2467     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2468     ; 
                      2469     ; GetPWM
                      2470     ; Skypup 2015.05.25
                      2471     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2472     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2473     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2474     ; 
                      2475     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2476     PROCEDURE_GETPWM: 
0788    C3            2477     	CLR	C
0789    E8            2478     MOV A , R0 
078A    94A0          2479     SUBB A , # 160 
078C    5005          2480     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
078E    7800          2481     MOV R0 , # 0 
0790    020795        2482     	JMP	SET_PWM_IN
                      2483     SET_PWM_IN_HIGH: 
0793    7801          2484     MOV R0 , # 1 
                      2485     SET_PWM_IN: 
0795    8875          2486     MOV NPWMIN , R0 
                      2487     END_PROCEDURE_GETPWM: 
                      2488     
                      2489     
                      2490     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2491     ;
                      2492     ; 是否解锁
                      2493     ; Skypup 2015.05.26
                      2494     ;
                      2495     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0797    A873          2496     MOV R0 , FLAG_BEFORE_ARM 
0799    B80107        2497     CJNE R0 , # 1 , ELSE_FLAG_BEFORE_ARM 
                      2498     IF_FLAG_BEFORE_ARM: 
079C    78FF          2499     MOV R0 , # 255 
079E    8859          2500     MOV NEW_RCP , R0 
07A0    0207F7        2501     	JMP SET_PREV_RCP				; 如果未解锁, 不做后续处理, 直接跳转
                      2502     ELSE_FLAG_BEFORE_ARM: 
                      2503     ; endif_Flag_Before_ARM:
                      2504     
                      2505     
                      2506     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2507     ;
                      2508     ; 例程: 判断是否 PWM_IN_HIGH
                      2509     ; Skypup 2015.05.26
                      2510     ;
                      2511     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2512     ;	mov	Temp1, nPWMIn
                      2513     ;	cjne	Temp1, #PWM_IN_HIGH, else_nPWMIn_pwm_in_high
                      2514     ;if_nPWMIn_pwm_in_high:
                      2515     ;	mov	Temp1, Initial_Arm
                      2516     ;	cjne	Temp1, #1, else_Initial_Arm
                      2517     ;  if_Initial_Arm:
                      2518     ;	mov Temp1, #PWM_FULL
                      2519     ;	mov	New_Rcp, Temp1	
                      2520     ;	jmp set_Prev_Rcp		; 如果未解锁, 不做后续处理, 直接跳转
                      2521     ;  else_Initial_Arm:
                      2522     ;	mov	Temp1,  #RCP_MIN
                      2523     ;  endif_INitial_Arm:
                      2524     ;	mov	New_Rcp, Temp1	
                      2525     ;	jmp	endif_nPWMIn_pwm_in_high
                      2526     ;else_nPWMIn_pwm_in_high:
                      2527     ;	; 最低油门
                      2528     ;	mov	Temp1, #RCP_MIN
                      2529     ;	mov	New_Rcp, Temp1	
                      2530     ;	; jmp	endif_nPWMIn_pwm_in_high
                      2531     ;endif_nPWMIn_pwm_in_high:
                      2532     
                      2533     
                      2534     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2535     ;
                      2536     ; 判断 cState 状态
                      2537     ; Skypup 2015.05.
                      2538     ;
                      2539     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2540     ;
07A3    A878          2541     MOV R0 , CSTATE 
07A5    B81029        2542     CJNE R0 , # 16 , ELES_STATE_FULL 
                      2543     IF_STATE_FULL: 
                      2544      	; STATE_FULL
                      2545      	;
                      2546      	; 全油门
07A8    78FF          2547     MOV R0 , # 255 
07AA    8859          2548     MOV NEW_RCP , R0 
                      2549     	; 计数器 ++
07AC    0576          2550     	INC	NHOLD_L						; 低位 ++
07AE    E576          2551     	MOV	A, NHOLD_L
07B0    7002          2552     	JNZ	IF_NHOLD_H_NOT_NEED_INC			; nHold_L 不是 0x00
07B2    0577          2553     	INC	NHOLD_H
                      2554       IF_NHOLD_H_NOT_NEED_INC: 
                      2555     	; 是否超时
07B4    C3            2556     	CLR	C
07B5    E577          2557     	MOV	A, NHOLD_H
07B7    9404          2558     SUBB A , # 4 
07B9    4013          2559     	JC	IF_NHOLD_NOT_TIMEOUT			; 发生借位, 则 nHold_H < #HOLD_FULL_H, 未超时
07BB    C3            2560     	CLR	C
07BC    E576          2561     	MOV	A, NHOLD_L
07BE    9433          2562     SUBB A , # 51 
07C0    400C          2563     	JC	IF_NHOLD_NOT_TIMEOUT			; 发生借位, 则 nHold_L < #HOLD_FULL_L, 未超时
                      2564       IF_NHOLD_TIMEOUT: 
                      2565     	; 状态切换为 STATE_CRUISE
07C2    7820          2566     MOV R0 , # 32 
07C4    8878          2567     MOV CSTATE , R0 
                      2568     	; 计数器清零
07C6    E4            2569     	CLR	A
07C7    F576          2570     	MOV	NHOLD_L, A
07C9    F577          2571     	MOV	NHOLD_H, A
07CB    0207F7        2572     	JMP	ENDIF_STATE_FULL
                      2573       IF_NHOLD_NOT_TIMEOUT: 
                      2574      	; 
07CE    0207F7        2575      	JMP ENDIF_STATE_FULL
                      2576      
                      2577      ELES_STATE_FULL: 
07D1    A878          2578     MOV R0 , CSTATE 
07D3    B82007        2579     CJNE R0 , # 32 , ELSE_STATE_CRUISE 
                      2580      
                      2581     	IF_STATE_CRUISE: 
                      2582     	 	; STATE_CRUISE
                      2583     	 	;
                      2584     	 	; 巡航油门
07D6    787F          2585     MOV R0 , # 127 
07D8    8859          2586     MOV NEW_RCP , R0 
                      2587     	 	; 
07DA    0207F7        2588     	 	JMP ENDIF_STATE_CRUISE
                      2589      
                      2590     	ELSE_STATE_CRUISE: 
                      2591     	 	; STATE_WAIT
07DD    7800          2592     MOV R0 , # 0 
07DF    8859          2593     MOV NEW_RCP , R0 
                      2594     		;
07E1    A830          2595     MOV R0 , INITIAL_ARM 
07E3    B80011        2596     CJNE R0 , # 0 , ELSE_INITIAL_ARM 
                      2597     		IF_INITIAL_ARM: 
                      2598     			; 判断是否 PWM_IN_HIGH
07E6    A875          2599     MOV R0 , NPWMIN 
07E8    B8010C        2600     CJNE R0 , # 1 , ENDIF_STATE_WAIT_PWM_IN_HIGH 
                      2601     			; 状态切换为 STATE_FULL
07EB    7810          2602     MOV R0 , # 16 
07ED    8878          2603     MOV CSTATE , R0 
                      2604     			; 计数器清零
07EF    E4            2605     			CLR	A
07F0    F576          2606     			MOV	NHOLD_L, A
07F2    F577          2607     			MOV	NHOLD_H, A
07F4    0207F7        2608     		 	JMP	ENDIF_INITIAL_ARM
                      2609     			ENDIF_STATE_WAIT_PWM_IN_HIGH: 
                      2610     		ELSE_INITIAL_ARM: 
                      2611     		ENDIF_INITIAL_ARM: 
                      2612     	ENDIF_STATE_CRUISE:  
                      2613     ENDIF_STATE_FULL: 
                      2614     
                      2615     
                      2616     SET_PREV_RCP: 
                      2617     	; 记录 New_Rcp 值
07F7    E559          2618     	MOV A, NEW_RCP
07F9    F574          2619     	MOV PREV_RCP, A
                      2620     
                      2621     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2622     	; RC pulse value accepted
                      2623     	; mov	New_Rcp, Temp1				; Store new pulse length
07FB    D268          2624     SETB FLAGS2 . 0 
07FD    205902        2625     JB FLAGS0 . 1 , ( $+5 ) 
0800    010A          2626     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2627     
0802    741F          2628     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0804    F4            2629     	CPL	A
0805    552E          2630     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0807    4B            2631     ORL A , R3 
0808    F52E          2632     	MOV	FLAGS3, A
                      2633     
                      2634     PCA_INT_SET_TIMEOUT: 
080A    752818        2635     MOV RCP_TIMEOUT_CNT , # 24 
080D    741F          2636     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
080F    552E          2637     	ANL	A, FLAGS3					; Check pwm frequency flags
0811    7003          2638     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2639     
0813    75280A        2640     MOV RCP_TIMEOUT_CNT , # 10 
                      2641     
                      2642     PCA_INT_PPM_TIMEOUT_SET: 
0816    305902        2643     JNB FLAGS0 . 1 , ( $+5 ) 
0819    0124          2644     	AJMP PCA_INT_EXIT				; Yes - exit
                      2645     
081B    741F          2646     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
081D    552E          2647     	ANL	A, FLAGS3					; Check pwm frequency flags
081F    6003          2648     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2649     
                      2650     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
0821    53DAFE        2650+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2651     
                      2652     PCA_INT_EXIT: 	; Exit interrupt routine	
0824    752906        2653     MOV RCP_SKIP_CNT , # 6 
0827    741F          2654     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0829    552E          2655     	ANL	A, FLAGS3					; Check pwm frequency flags
082B    7003          2656     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2657     
082D    75290A        2658     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2659     
0830    D0F0          2660     	POP	B			; Restore preserved registers
0832    D0E0          2661     	POP	ACC			
0834    D0D0          2662     	POP	PSW
0836    C2D3          2663     	CLR	PSW.3		; Select register bank 0 for main program routines	
0838    D2AD          2664     	SETB	ET2			; Enable timer2 interrupts
083A    43E610        2665     	ORL	EIE1, #10H	; Enable PCA0 interrupts
083D    32            2666     	RETI
                      2667     
                      2668     
                      2669     
                      2670     
                      2671     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2672     ;
                      2673     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2674     ;
                      2675     ; No assumptions
                      2676     ;
                      2677     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2678     WAIT1MS: 	
083E    7901          2679     MOV R1 , # 1 
0840    02085C        2680     	JMP	WAITXMS_O
                      2681     
                      2682     WAIT3MS: 	
0843    7903          2683     MOV R1 , # 3 
0845    02085C        2684     	JMP	WAITXMS_O
                      2685     
                      2686     WAIT10MS: 	
0848    790A          2687     MOV R1 , # 10 
084A    02085C        2688     	JMP	WAITXMS_O
                      2689     
                      2690     WAIT30MS: 	
084D    791E          2691     MOV R1 , # 30 
084F    02085C        2692     	JMP	WAITXMS_O
                      2693     
                      2694     WAIT100MS: 	
0852    7964          2695     MOV R1 , # 100 
0854    02085C        2696     	JMP	WAITXMS_O
                      2697     
                      2698     WAIT200MS: 	
0857    79C8          2699     MOV R1 , # 200 
0859    02085C        2700     	JMP	WAITXMS_O
                      2701     
                      2702     WAITXMS_O: 	; Outer loop
085C    7817          2703     MOV R0 , # 23 
                      2704     WAITXMS_M: 	; Middle loop
085E    E4            2705     	CLR	A
085F    D5E0FD        2706      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0862    D8FA          2707     DJNZ R0 , WAITXMS_M 
0864    D9F6          2708     DJNZ R1 , WAITXMS_O 
0866    22            2709     	RET
                      2710     
                      2711     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2712     ;
                      2713     ; Wait 1 second routine
                      2714     ;
                      2715     ; No assumptions
                      2716     ;
                      2717     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2718     WAIT1S: 
0867    7C05          2719     MOV R4 , # 5 
                      2720     WAIT1S_LOOP: 
0869    1157          2721     	CALL WAIT200MS
086B    DCFC          2722     DJNZ R4 , WAIT1S_LOOP 
086D    22            2723     	RET
                      2724     
                      2725     
                      2726     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2727     ;
                      2728     ; Beeper routines (4 different entry points) 
                      2729     ;
                      2730     ; No assumptions
                      2731     ;
                      2732     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2733     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
086E    7A14          2734     MOV R2 , # 20 
0870    7B78          2735     MOV R3 , # 120 
0872    02088A        2736     	JMP	BEEP
                      2737     
                      2738     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0875    7A10          2739     MOV R2 , # 16 
0877    7B8C          2740     MOV R3 , # 140 
0879    02088A        2741     	JMP	BEEP
                      2742     
                      2743     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
087C    7A0D          2744     MOV R2 , # 13 
087E    7BB4          2745     MOV R3 , # 180 
0880    02088A        2746     	JMP	BEEP
                      2747     
                      2748     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0883    7A0B          2749     MOV R2 , # 11 
0885    7BC8          2750     MOV R3 , # 200 
0887    02088A        2751     	JMP	BEEP
                      2752     
                      2753     BEEP: 	; Beep loop start
088A    AC25          2754     MOV R4 , CURRENT_PWM_LIMITED 
088C    752501        2755     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
088F    7902          2756     MOV R1 , # 2 
                      2757     BEEP_ONOFF: 
0891    B275          2758     CPL FLAGS3 . 5 
0893    E4            2759     	CLR	A
                      2760     	BPFET_OFF			; BpFET off
0894    C294          2760+1   CLR P1 . 4 
0896    D5E0FD        2761     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2762     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0899    E525          2762+1   MOV A , CURRENT_PWM_LIMITED 
089B    6002          2762+1   JZ ( $+4 ) 
089D    C295          2762+1   CLR P1 . 5 
089F    D5E0FD        2763     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2764     	BNFET_OFF			; BnFET off again
08A2    D295          2764+1   SETB P1 . 5 
08A4    D5E0FD        2765     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2766     	BPFET_ON			; BpFET on
08A7    D294          2766+1   SETB P1 . 4 
08A9    D5E0FD        2767     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2768     	; Turn on nfet
                      2769     	ANFET_ON			; AnFET on
08AC    E525          2769+1   MOV A , CURRENT_PWM_LIMITED 
08AE    600A          2769+1   JZ ( $+12 ) 
08B0    207502        2769+1   JB FLAGS3 . 5 , ( $+5 ) 
08B3    C297          2769+1   CLR P1 . 7 
08B5    307502        2769+1   JNB FLAGS3 . 5 , ( $+5 ) 
08B8    C293          2769+1   CLR P1 . 3 
08BA    E56F          2770     	MOV	A, BEEP_STRENGTH
08BC    D5E0FD        2771     	DJNZ	ACC, $		
                      2772     	; Turn off nfet
                      2773     	ANFET_OFF			; AnFET off
08BF    207502        2773+1   JB FLAGS3 . 5 , ( $+5 ) 
08C2    D297          2773+1   SETB P1 . 7 
08C4    307502        2773+1   JNB FLAGS3 . 5 , ( $+5 ) 
08C7    D293          2773+1   SETB P1 . 3 
08C9    7496          2774     	MOV	A, #150		; 25s off
08CB    D5E0FD        2775     	DJNZ	ACC, $		
08CE    D9C1          2776     DJNZ R1 , BEEP_ONOFF 
                      2777     	; Copy variable
08D0    EA            2778     MOV A , R2 
08D1    F8            2779     MOV R0 , A 
                      2780     BEEP_OFF: 		; Fets off loop
08D2    D5E0FD        2781     	DJNZ	ACC, $
08D5    D8FB          2782     DJNZ R0 , BEEP_OFF 
08D7    DBB1          2783     DJNZ R3 , BEEP 
                      2784     	BPFET_OFF			; BpFET off
08D9    C294          2784+1   CLR P1 . 4 
08DB    8C25          2785     MOV CURRENT_PWM_LIMITED , R4 
08DD    22            2786     	RET
                      2787     
                      2788     
                      2789     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2790     ;
                      2791     ; Division 16bit unsigned by 16bit unsigned
                      2792     ;
                      2793     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2794     ; Result will be in Temp2/Temp1
                      2795     ;
                      2796     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2797     DIV_U16_BY_U16: 	
08DE    C3            2798     	CLR	C       
08DF    7C00          2799     MOV R4 , # 0 
08E1    7D00          2800     MOV R5 , # 0 
08E3    75F000        2801     	MOV	B, #0
                      2802     DIV_U16_BY_U16_DIV1: 
08E6    05F0          2803     	INC	B      			; Increment counter for each left shift
08E8    EA            2804     MOV A , R2 
08E9    33            2805     	RLC	A      		
08EA    FA            2806     MOV R2 , A 
08EB    EB            2807     MOV A , R3 
08EC    33            2808     	RLC	A      	  	
08ED    FB            2809     MOV R3 , A 
08EE    50F6          2810     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2811     DIV_U16_BY_U16_DIV2:         
08F0    EB            2812     MOV A , R3 
08F1    13            2813     	RRC	A      
08F2    FB            2814     MOV R3 , A 
08F3    EA            2815     MOV A , R2 
08F4    13            2816     	RRC	A      
08F5    FA            2817     MOV R2 , A 
08F6    C3            2818     	CLR	C      
08F7    E9            2819     MOV A , R1 
08F8    FF            2820     MOV R7 , A 
08F9    E8            2821     MOV A , R0 
08FA    FE            2822     MOV R6 , A 
08FB    E8            2823     MOV A , R0 
08FC    9A            2824     SUBB A , R2 
08FD    F8            2825     MOV R0 , A 
08FE    E9            2826     MOV A , R1 
08FF    9B            2827     SUBB A , R3 
0900    F9            2828     MOV R1 , A 
0901    5004          2829     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0903    EF            2830     MOV A , R7 
0904    F9            2831     MOV R1 , A 
0905    EE            2832     MOV A , R6 
0906    F8            2833     MOV R0 , A 
                      2834     DIV_U16_BY_U16_DIV3: 
0907    B3            2835     	CPL	C      			; Invert carry, so it can be directly copied into result
0908    EC            2836     MOV A , R4 
0909    33            2837     	RLC	A      			; Shift carry flag into temporary result
090A    FC            2838     MOV R4 , A 
090B    ED            2839     MOV A , R5 
090C    33            2840     	RLC	A
090D    FD            2841     MOV R5 , A 
090E    D5F0DF        2842     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0911    ED            2843     MOV A , R5 
0912    F9            2844     MOV R1 , A 
0913    EC            2845     MOV A , R4 
0914    F8            2846     MOV R0 , A 
0915    22            2847     	RET
                      2848     
                      2849     
                      2850     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2851     ;
                      2852     ; Multiplication 16bit signed by 8bit unsigned
                      2853     ;
                      2854     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2855     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2856     ;
                      2857     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2858     MULT_S16_BY_U8_DIV_16: 
0916    E8            2859     MOV A , R0 
0917    89F0          2860     MOV B , R1 
0919    8A20          2861     MOV BIT_ACCESS , R2 
091B    D2D4          2862     	SETB	PSW.4		; Select register bank 2 for math routines
091D    F8            2863     MOV R0 , A 
091E    A9F0          2864     MOV R1 , B 
0920    7B00          2865     MOV R3 , # 0 
0922    30F70B        2866     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2867     
0925    7BFF          2868     MOV R3 , # 0FFH 
0927    F4            2869     	CPL	A
0928    2401          2870     	ADD	A, #1
092A    F8            2871     MOV R0 , A 
092B    E9            2872     MOV A , R1 
092C    F4            2873     	CPL	A
092D    3400          2874     	ADDC	A, #0
092F    F9            2875     MOV R1 , A 
                      2876     MULT_S16_BY_U8_POSITIVE: 
0930    E8            2877     MOV A , R0 
0931    8520F0        2878     	MOV	B, BIT_ACCESS
0934    A4            2879     	MUL	AB
0935    ADF0          2880     MOV R5 , B 
0937    F8            2881     MOV R0 , A 
0938    E9            2882     MOV A , R1 
0939    8520F0        2883     	MOV	B, BIT_ACCESS
093C    A4            2884     	MUL	AB
093D    AFF0          2885     MOV R7 , B 
093F    FE            2886     MOV R6 , A 
0940    ED            2887     MOV A , R5 
0941    2E            2888     ADD A , R6 
0942    F9            2889     MOV R1 , A 
0943    7400          2890     	MOV	A, #0
0945    3F            2891     ADDC A , R7 
0946    FA            2892     MOV R2 , A 
0947    7C04          2893     MOV R4 , # 4 
                      2894     MULT_S16_BY_U8_DIV_LOOP: 
0949    C3            2895     	CLR	C			; Rotate right 
094A    EA            2896     MOV A , R2 
094B    13            2897     	RRC	A
094C    FA            2898     MOV R2 , A 
094D    E9            2899     MOV A , R1 
094E    13            2900     	RRC	A
094F    F9            2901     MOV R1 , A 
0950    E8            2902     MOV A , R0 
0951    13            2903     	RRC	A
0952    F8            2904     MOV R0 , A 
0953    DCF4          2905     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2906     
0955    8BF0          2907     MOV B , R3 
0957    30F70A        2908     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2909     
095A    E8            2910     MOV A , R0 
095B    F4            2911     	CPL	A
095C    2401          2912     	ADD	A, #1
095E    F8            2913     MOV R0 , A 
095F    E9            2914     MOV A , R1 
0960    F4            2915     	CPL	A
0961    3400          2916     	ADDC	A, #0
0963    F9            2917     MOV R1 , A 
                      2918     
                      2919     MULT_S16_BY_U8_EXIT: 
0964    E8            2920     MOV A , R0 
0965    89F0          2921     MOV B , R1 
0967    C2D4          2922     	CLR	PSW.4		; Select normal register bank
0969    F8            2923     MOV R0 , A 
096A    A9F0          2924     MOV R1 , B 
096C    22            2925     	RET
                      2926     
                      2927     
                      2928     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2929     ;
                      2930     ; Calculate governor routines
                      2931     ;
                      2932     ; No assumptions
                      2933     ;
                      2934     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2935     ; The governor task is split into several routines in order to distribute processing time
                      2936     ;
                      2937     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2938     ; First governor routine - calculate governor target
                      2939     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3079     IF MODE == 2	; Multi
                      3080     CALC_GOVERNOR_TARGET: 
096D    7882          3081     MOV R0 , # PGM_GOV_MODE 
096F    B60403        3082     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0972    0209C9        3083     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3084     
                      3085     GOVERNOR_TARGET_CALC: 
                      3086     	; Stop governor for stop RC pulse	
0975    C3            3087     	CLR	C
0976    E559          3088     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0978    9401          3089     SUBB A , # 1 
097A    4003          3090     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3091     
097C    020992        3092     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3093     
                      3094     GOVERNOR_DEACTIVATE: 
097F    852224        3095     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0982    E4            3096     	CLR	A
0983    F540          3097     	MOV	GOV_TARGET_L, A			; Set target to zero
0985    F541          3098     	MOV	GOV_TARGET_H, A
0987    F542          3099     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0989    F543          3100     	MOV	GOV_INTEGRAL_H, A
098B    F544          3101     	MOV	GOV_INTEGRAL_X, A
098D    F549          3102     	MOV	GOV_ACTIVE, A
098F    0209C9        3103     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3104     
                      3105     GOVERNOR_ACTIVATE: 
0992    7882          3106     MOV R0 , # PGM_GOV_MODE 
0994    E6            3107     MOV A , @ R0 
0995    FC            3108     MOV R4 , A 
0996    754901        3109     	MOV	GOV_ACTIVE, #1
0999    E522          3110     	MOV	A, REQUESTED_PWM			; Load requested pwm
099B    F523          3111     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3112     	; Calculate comm period target 2*(51000/Requested_Pwm)
099D    7838          3113     MOV R0 , # 38H 
099F    79C7          3114     MOV R1 , # 0C7H 
09A1    AA3C          3115     MOV R2 , COMM_PERIOD4X_L 
09A3    AB3D          3116     MOV R3 , COMM_PERIOD4X_H 
                      3117     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
09A5    C3            3118     	CLR	C
09A6    EB            3119     MOV A , R3 
09A7    13            3120     	RRC	A
09A8    FB            3121     MOV R3 , A 
09A9    EA            3122     MOV A , R2 
09AA    13            3123     	RRC	A
09AB    FA            3124     MOV R2 , A 
                      3125     	; Check range
09AC    EC            3126     MOV A , R4 
09AD    14            3127     	DEC	A
09AE    6013          3128     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3129     GOVERNOR_ACTIVATE_100K: 
09B0    C3            3130     	CLR	C
09B1    EB            3131     MOV A , R3 
09B2    13            3132     	RRC	A
09B3    FB            3133     MOV R3 , A 
09B4    EA            3134     MOV A , R2 
09B5    13            3135     	RRC	A
09B6    FA            3136     MOV R2 , A 
09B7    EC            3137     MOV A , R4 
09B8    14            3138     	DEC	A
09B9    14            3139     	DEC	A
09BA    6007          3140     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3141     GOVERNOR_ACTIVATE_50K: 
09BC    C3            3142     	CLR	C
09BD    EB            3143     MOV A , R3 
09BE    13            3144     	RRC	A
09BF    FB            3145     MOV R3 , A 
09C0    EA            3146     MOV A , R2 
09C1    13            3147     	RRC	A
09C2    FA            3148     MOV R2 , A 
                      3149     GOVERNOR_ACTIVATE_RANGE_SET: 
09C3    11DE          3150     	CALL	DIV_U16_BY_U16
                      3151     	; Store governor target
09C5    8840          3152     MOV GOV_TARGET_L , R0 
09C7    8941          3153     MOV GOV_TARGET_H , R1 
                      3154     CALC_GOVERNOR_TARGET_EXIT: 
09C9    22            3155     	RET						
                      3156     ENDIF
                      3157     
                      3158     
                      3159     ; Second governor routine - calculate governor proportional error
                      3160     CALC_GOVERNOR_PROP_ERROR: 
                      3161     	; Exit if governor is inactive
09CA    E549          3162     	MOV	A, GOV_ACTIVE
09CC    6034          3163     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3164     
                      3165     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3183     IF MODE == 2	; Multi
                      3184     	; Calculate error
09CE    C3            3185     	CLR	C
09CF    E540          3186     	MOV	A, GOV_TARGET_L
09D1    9523          3187     	SUBB	A, GOVERNOR_REQ_PWM
09D3    F8            3188     MOV R0 , A 
09D4    E541          3189     	MOV	A, GOV_TARGET_H
09D6    9400          3190     	SUBB	A, #0
09D8    F9            3191     MOV R1 , A 
                      3192     ENDIF
                      3193     	; Check error and limit
09D9    500C          3194     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3195     
09DB    C3            3196     	CLR	C
09DC    E8            3197     MOV A , R0 
09DD    9480          3198     	SUBB	A, #80H					; Is error too negative?
09DF    E9            3199     MOV A , R1 
09E0    94FF          3200     	SUBB	A, #0FFH
09E2    4016          3201     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
09E4    0209FE        3202     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3203     
                      3204     GOVERNOR_CHECK_PROP_LIMIT_POS: 
09E7    C3            3205     	CLR	C
09E8    E8            3206     MOV A , R0 
09E9    947F          3207     	SUBB	A, #7FH					; Is error too positive?
09EB    E9            3208     MOV A , R1 
09EC    9400          3209     	SUBB	A, #00H
09EE    5003          3210     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
09F0    0209FE        3211     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3212     
                      3213     GOVERNOR_LIMIT_PROP_ERROR_POS: 
09F3    787F          3214     MOV R0 , # 7FH 
09F5    7900          3215     MOV R1 , # 00H 
09F7    0209FE        3216     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3217     
                      3218     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09FA    7880          3219     MOV R0 , # 80H 
09FC    79FF          3220     MOV R1 , # 0FFH 
                      3221     
                      3222     GOVERNOR_STORE_PROP_ERROR: 
                      3223     	; Store proportional
09FE    8845          3224     MOV GOV_PROPORTIONAL_L , R0 
0A00    8946          3225     MOV GOV_PROPORTIONAL_H , R1 
                      3226     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0A02    22            3227     	RET						
                      3228     
                      3229     
                      3230     ; Third governor routine - calculate governor integral error
                      3231     CALC_GOVERNOR_INT_ERROR: 
                      3232     	; Exit if governor is inactive
0A03    E549          3233     	MOV	A, GOV_ACTIVE
0A05    6058          3234     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3235     
                      3236     	; Add proportional to integral
0A07    E545          3237     	MOV	A, GOV_PROPORTIONAL_L
0A09    2542          3238     	ADD	A, GOV_INTEGRAL_L
0A0B    F8            3239     MOV R0 , A 
0A0C    E546          3240     	MOV	A, GOV_PROPORTIONAL_H
0A0E    3543          3241     	ADDC	A, GOV_INTEGRAL_H
0A10    F9            3242     MOV R1 , A 
0A11    854620        3243     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
0A14    E4            3244     	CLR	A
0A15    300701        3245     	JNB	BIT_ACCESS.7, ($+4)			
0A18    F4            3246     	CPL	A
0A19    3544          3247     	ADDC	A, GOV_INTEGRAL_X
0A1B    FA            3248     MOV R2 , A 
                      3249     	; Check integral and limit
0A1C    30E709        3250     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3251     
0A1F    C3            3252     	CLR	C
0A20    EA            3253     MOV A , R2 
0A21    94F0          3254     	SUBB	A, #0F0H					; Is error too negative?
0A23    4015          3255     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0A25    020A40        3256     	JMP	GOVERNOR_CHECK_PWM
                      3257     
                      3258     GOVERNOR_CHECK_INT_LIMIT_POS: 
0A28    C3            3259     	CLR	C
0A29    EA            3260     MOV A , R2 
0A2A    940F          3261     	SUBB	A, #0FH					; Is error too positive?
0A2C    5003          3262     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0A2E    020A40        3263     	JMP	GOVERNOR_CHECK_PWM
                      3264     
                      3265     GOVERNOR_LIMIT_INT_ERROR_POS: 
0A31    78FF          3266     MOV R0 , # 0FFH 
0A33    79FF          3267     MOV R1 , # 0FFH 
0A35    7A0F          3268     MOV R2 , # 0FH 
0A37    020A40        3269     	JMP	GOVERNOR_CHECK_PWM
                      3270     
                      3271     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0A3A    7800          3272     MOV R0 , # 00H 
0A3C    7900          3273     MOV R1 , # 00H 
0A3E    7AF0          3274     MOV R2 , # 0F0H 
                      3275     
                      3276     GOVERNOR_CHECK_PWM: 
                      3277     	; Check current pwm
0A40    C3            3278     	CLR	C
0A41    E524          3279     	MOV	A, CURRENT_PWM
0A43    955E          3280     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0A45    5006          3281     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3282     
0A47    E524          3283     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0A49    6009          3284     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3285     
0A4B    4159          3286     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3287     
                      3288     GOVERNOR_INT_MAX_PWM: 
0A4D    E546          3289     	MOV	A, GOV_PROPORTIONAL_H
0A4F    20E70D        3290     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3291     
0A52    4159          3292     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3293     
                      3294     GOVERNOR_INT_MIN_PWM: 
0A54    E546          3295     	MOV	A, GOV_PROPORTIONAL_H
0A56    30E706        3296     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3297     
                      3298     GOVERNOR_STORE_INT_ERROR: 
                      3299     	; Store integral
0A59    8842          3300     MOV GOV_INTEGRAL_L , R0 
0A5B    8943          3301     MOV GOV_INTEGRAL_H , R1 
0A5D    8A44          3302     MOV GOV_INTEGRAL_X , R2 
                      3303     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A5F    22            3304     	RET						
                      3305     
                      3306     
                      3307     ; Fourth governor routine - calculate governor proportional correction
                      3308     CALC_GOVERNOR_PROP_CORRECTION: 
                      3309     	; Exit if governor is inactive
0A60    E549          3310     	MOV	A, GOV_ACTIVE
0A62    7003          3311     	JNZ	CALC_GOVERNOR_PROP_CORR
0A64    020AC3        3312     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3313     
                      3314     CALC_GOVERNOR_PROP_CORR: 
                      3315     	; Load proportional gain
0A67    789F          3316     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A69    E6            3317     MOV A , @ R0 
0A6A    FA            3318     MOV R2 , A 
                      3319     	; Load proportional
0A6B    C3            3320     	CLR	C
0A6C    E545          3321     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A6E    33            3322     	RLC	A
0A6F    F8            3323     MOV R0 , A 
0A70    E546          3324     	MOV	A, GOV_PROPORTIONAL_H
0A72    33            3325     	RLC	A
0A73    F9            3326     MOV R1 , A 
                      3327     	; Apply gain
0A74    3116          3328     	CALL	MULT_S16_BY_U8_DIV_16
                      3329     	; Check error and limit (to low byte)
0A76    E9            3330     MOV A , R1 
0A77    30E70B        3331     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3332     
0A7A    C3            3333     	CLR	C
0A7B    E8            3334     MOV A , R0 
0A7C    9480          3335     	SUBB	A, #80H					; Is error too negative?
0A7E    E9            3336     MOV A , R1 
0A7F    94FF          3337     	SUBB	A, #0FFH
0A81    4013          3338     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A83    419A          3339     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3340     
                      3341     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A85    C3            3342     	CLR	C
0A86    E8            3343     MOV A , R0 
0A87    947F          3344     	SUBB	A, #7FH					; Is error too positive?
0A89    E9            3345     MOV A , R1 
0A8A    9400          3346     	SUBB	A, #00H
0A8C    5002          3347     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A8E    419A          3348     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3349     
                      3350     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A90    787F          3351     MOV R0 , # 7FH 
0A92    7900          3352     MOV R1 , # 00H 
0A94    419A          3353     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3354     
                      3355     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A96    7880          3356     MOV R0 , # 80H 
0A98    79FF          3357     MOV R1 , # 0FFH 
                      3358     
                      3359     GOVERNOR_APPLY_PROP_CORR: 
                      3360     	; Test proportional sign
0A9A    E8            3361     MOV A , R0 
0A9B    20E715        3362     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3363     
                      3364     	; Subtract positive proportional
0A9E    C3            3365     	CLR	C
0A9F    E523          3366     	MOV	A, GOVERNOR_REQ_PWM
0AA1    98            3367     SUBB A , R0 
0AA2    F8            3368     MOV R0 , A 
                      3369     	; Check result
0AA3    4009          3370     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3371     
0AA5    C3            3372     	CLR	C
0AA6    E8            3373     MOV A , R0 
0AA7    9401          3374     	SUBB	A, #1
0AA9    4003          3375     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0AAB    020AC1        3376     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3377     
                      3378     GOVERNOR_CORR_PROP_MIN_PWM: 
0AAE    7801          3379     MOV R0 , # 1 
0AB0    020AC1        3380     	JMP	GOVERNOR_STORE_PROP_CORR
                      3381     
                      3382     GOVERNOR_CORR_NEG_PROP: 
                      3383     	; Add negative proportional
0AB3    E8            3384     MOV A , R0 
0AB4    F4            3385     	CPL	A
0AB5    2401          3386     	ADD	A, #1
0AB7    2523          3387     	ADD	A, GOVERNOR_REQ_PWM
0AB9    F8            3388     MOV R0 , A 
                      3389     	; Check result
0ABA    4003          3390     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0ABC    020AC1        3391     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3392     
                      3393     GOVERNOR_CORR_PROP_MAX_PWM: 
0ABF    78FF          3394     MOV R0 , # 255 
                      3395     GOVERNOR_STORE_PROP_CORR: 
                      3396     	; Store proportional pwm
0AC1    8847          3397     MOV GOV_PROP_PWM , R0 
                      3398     CALC_GOVERNOR_PROP_CORR_EXIT: 
0AC3    22            3399     	RET
                      3400     
                      3401     
                      3402     ; Fifth governor routine - calculate governor integral correction
                      3403     CALC_GOVERNOR_INT_CORRECTION: 
                      3404     	; Exit if governor is inactive
0AC4    E549          3405     	MOV	A, GOV_ACTIVE
0AC6    7003          3406     	JNZ	CALC_GOVERNOR_INT_CORR
0AC8    020B25        3407     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3408     
                      3409     CALC_GOVERNOR_INT_CORR: 
                      3410     	; Load integral gain
0ACB    78A0          3411     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0ACD    E6            3412     MOV A , @ R0 
0ACE    FA            3413     MOV R2 , A 
                      3414     	; Load integral
0ACF    A843          3415     MOV R0 , GOV_INTEGRAL_H 
0AD1    A944          3416     MOV R1 , GOV_INTEGRAL_X 
                      3417     	; Apply gain
0AD3    3116          3418     	CALL	MULT_S16_BY_U8_DIV_16
                      3419     	; Check integral and limit
0AD5    E9            3420     MOV A , R1 
0AD6    30E70C        3421     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3422     
0AD9    C3            3423     	CLR	C
0ADA    E8            3424     MOV A , R0 
0ADB    9401          3425     	SUBB	A, #01H					; Is integral too negative?
0ADD    E9            3426     MOV A , R1 
0ADE    94FF          3427     	SUBB	A, #0FFH
0AE0    4016          3428     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0AE2    020AFC        3429     	JMP	GOVERNOR_APPLY_INT_CORR
                      3430     
                      3431     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0AE5    C3            3432     	CLR	C
0AE6    E8            3433     MOV A , R0 
0AE7    94FF          3434     	SUBB	A, #0FFH					; Is integral too positive?
0AE9    E9            3435     MOV A , R1 
0AEA    9400          3436     	SUBB	A, #00H
0AEC    5003          3437     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0AEE    020AFC        3438     	JMP	GOVERNOR_APPLY_INT_CORR
                      3439     
                      3440     GOVERNOR_LIMIT_INT_CORR_POS: 
0AF1    78FF          3441     MOV R0 , # 0FFH 
0AF3    7900          3442     MOV R1 , # 00H 
0AF5    020AFC        3443     	JMP	GOVERNOR_APPLY_INT_CORR
                      3444     
                      3445     GOVERNOR_LIMIT_INT_CORR_NEG: 
0AF8    7801          3446     MOV R0 , # 01H 
0AFA    79FF          3447     MOV R1 , # 0FFH 
                      3448     
                      3449     GOVERNOR_APPLY_INT_CORR: 
                      3450     	; Test integral sign
0AFC    E9            3451     MOV A , R1 
0AFD    20E715        3452     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3453     
                      3454     	; Subtract positive integral
0B00    C3            3455     	CLR	C
0B01    E547          3456     	MOV	A, GOV_PROP_PWM
0B03    98            3457     SUBB A , R0 
0B04    F8            3458     MOV R0 , A 
                      3459     	; Check result
0B05    4009          3460     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3461     
0B07    C3            3462     	CLR	C
0B08    E8            3463     MOV A , R0 
0B09    9401          3464     	SUBB	A, #1
0B0B    4003          3465     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0B0D    020B23        3466     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3467     
                      3468     GOVERNOR_CORR_INT_MIN_PWM: 
0B10    7800          3469     MOV R0 , # 0 
0B12    020B23        3470     	JMP	GOVERNOR_STORE_INT_CORR
                      3471     
                      3472     GOVERNOR_CORR_NEG_INT: 
                      3473     	; Add negative integral
0B15    E8            3474     MOV A , R0 
0B16    F4            3475     	CPL	A
0B17    2401          3476     	ADD	A, #1
0B19    2547          3477     	ADD	A, GOV_PROP_PWM
0B1B    F8            3478     MOV R0 , A 
                      3479     	; Check result
0B1C    4003          3480     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0B1E    020B23        3481     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3482     
                      3483     GOVERNOR_CORR_INT_MAX_PWM: 
0B21    78FF          3484     MOV R0 , # 255 
                      3485     GOVERNOR_STORE_INT_CORR: 
                      3486     	; Store current pwm
0B23    8824          3487     MOV CURRENT_PWM , R0 
                      3488     CALC_GOVERNOR_INT_CORR_EXIT: 
0B25    22            3489     	RET
                      3490     
                      3491     
                      3492     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3493     ;
                      3494     ; Measure lipo cells
                      3495     ;
                      3496     ; No assumptions
                      3497     ;
                      3498     ; Measure voltage and calculate lipo cells
                      3499     ;
                      3500     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3501     MEASURE_LIPO_CELLS: 
                      3502     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3506     MEASURE_LIPO_START: 
                      3507     	; Load programmed low voltage limit
0B26    7883          3508     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B28    E6            3509     MOV A , @ R0 
0B29    F520          3510     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3511     	; Set commutation to BpFET on
0B2B    121087        3512     	CALL	COMM5COMM6			
                      3513     	; Start adc
                      3514     	START_ADC 
0B2E    75E890        3514+1   MOV ADC0CN , # 90H  ; ADC START
                      3515     	; Wait for ADC reference to settle, and then start again
0B31    113E          3516     	CALL	WAIT1MS
                      3517     	START_ADC
0B33    75E890        3517+1   MOV ADC0CN , # 90H  ; ADC START
                      3518     	; Wait for ADC conversion to complete
                      3519     MEASURE_LIPO_WAIT_ADC: 
                      3520     	GET_ADC_STATUS 
0B36    E5E8          3520+1   MOV A , ADC0CN 
0B38    20ECFB        3521     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3522     	; Read ADC result
                      3523     	READ_ADC_RESULT
0B3B    A8BD          3523+1   MOV R0 , ADC0L 
0B3D    A9BE          3523+1   MOV R1 , ADC0H 
                      3524     	; Stop ADC
                      3525     	STOP_ADC
                      3526     	; Switch power off
0B3F    12113F        3527     	CALL	SWITCH_POWER_OFF		
                      3528     	; Set limit step
0B42    756A55        3529     MOV LIPO_ADC_LIMIT_L , # 85 
0B45    756B00        3530     MOV LIPO_ADC_LIMIT_H , # 0 
0B48    C3            3531     	CLR	C
0B49    7400          3532     MOV A , # 0 
0B4B    13            3533     	RRC	A
0B4C    FD            3534     MOV R5 , A 
0B4D    7455          3535     MOV A , # 85 
0B4F    13            3536     	RRC	A
0B50    FC            3537     MOV R4 , A 
0B51    7455          3538     MOV A , # 85 
0B53    2C            3539     ADD A , R4 
0B54    FC            3540     MOV R4 , A 
0B55    7400          3541     MOV A , # 0 
0B57    3D            3542     ADDC A , R5 
0B58    FD            3543     MOV R5 , A 
0B59    EC            3544     MOV A , R4 
0B5A    FA            3545     MOV R2 , A 
0B5B    ED            3546     MOV A , R5 
0B5C    FB            3547     MOV R3 , A 
                      3548     MEASURE_LIPO_CELL_LOOP: 
                      3549     	; Check voltage against xS lower limit
0B5D    C3            3550     	CLR	C
0B5E    E8            3551     MOV A , R0 
0B5F    9A            3552     SUBB A , R2 
0B60    E9            3553     MOV A , R1 
0B61    9B            3554     SUBB A , R3 
0B62    4014          3555     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3556     
                      3557     	; Set xS voltage limit
0B64    E56A          3558     	MOV	A, LIPO_ADC_LIMIT_L		
0B66    2455          3559     ADD A , # 85 
0B68    F56A          3560     	MOV	LIPO_ADC_LIMIT_L, A
0B6A    E56B          3561     	MOV	A, LIPO_ADC_LIMIT_H		
0B6C    3400          3562     ADDC A , # 0 
0B6E    F56B          3563     	MOV	LIPO_ADC_LIMIT_H, A
                      3564     	; Set (x+1)S lower limit
0B70    EA            3565     MOV A , R2 
0B71    2C            3566     ADD A , R4 
0B72    FA            3567     MOV R2 , A 
0B73    EB            3568     MOV A , R3 
0B74    3D            3569     ADDC A , R5 
0B75    FB            3570     MOV R3 , A 
0B76    80E5          3571     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3572     
                      3573     MEASURE_LIPO_ADJUST: 
0B78    AE6A          3574     MOV R6 , LIPO_ADC_LIMIT_L 
0B7A    AF6B          3575     MOV R7 , LIPO_ADC_LIMIT_H 
                      3576     	; Calculate 3.125%
0B7C    C3            3577     	CLR	C
0B7D    E56B          3578     	MOV	A, LIPO_ADC_LIMIT_H
0B7F    13            3579     	RRC	A
0B80    F9            3580     MOV R1 , A 
0B81    E56A          3581     	MOV	A, LIPO_ADC_LIMIT_L	
0B83    13            3582     	RRC	A
0B84    F8            3583     MOV R0 , A 
0B85    C3            3584     	CLR	C
0B86    E9            3585     MOV A , R1 
0B87    13            3586     	RRC	A
0B88    F9            3587     MOV R1 , A 
0B89    E8            3588     MOV A , R0 
0B8A    13            3589     	RRC	A
0B8B    F8            3590     MOV R0 , A 
0B8C    E56A          3591     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B8E    28            3592     ADD A , R0 
0B8F    F568          3593     	MOV	LIPO_ADC_REFERENCE_L, A
0B91    E56B          3594     	MOV	A, LIPO_ADC_LIMIT_H
0B93    39            3595     ADDC A , R1 
0B94    F569          3596     	MOV	LIPO_ADC_REFERENCE_H, A
                      3597     	; Divide three times to get to 3.125%
0B96    7A03          3598     MOV R2 , # 3 
                      3599     MEASURE_LIPO_DIVIDE_LOOP: 
0B98    C3            3600     	CLR	C
0B99    E9            3601     MOV A , R1 
0B9A    13            3602     	RRC	A
0B9B    F9            3603     MOV R1 , A 
0B9C    E8            3604     MOV A , R0 
0B9D    13            3605     	RRC	A
0B9E    F8            3606     MOV R0 , A 
0B9F    DAF7          3607     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3608     
                      3609     	; Add the programmed number of 0.1V (or 3.125% increments)
0BA1    AA20          3610     MOV R2 , BIT_ACCESS 
0BA3    1A            3611     DEC R2 
0BA4    7009          3612     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3613     
0BA6    756A00        3614     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0BA9    756B00        3615     	MOV	LIPO_ADC_LIMIT_H, #0
0BAC    020BBF        3616     	JMP	MEASURE_LIPO_EXIT	
                      3617     
                      3618     MEASURE_LIPO_LIMIT_ON: 
0BAF    1A            3619     DEC R2 
0BB0    EA            3620     MOV A , R2 
0BB1    6008          3621     	JZ	MEASURE_LIPO_UPDATE
                      3622     
                      3623     MEASURE_LIPO_ADD_LOOP: 
0BB3    EE            3624     MOV A , R6 
0BB4    28            3625     ADD A , R0 
0BB5    FE            3626     MOV R6 , A 
0BB6    EF            3627     MOV A , R7 
0BB7    39            3628     ADDC A , R1 
0BB8    FF            3629     MOV R7 , A 
0BB9    DAF8          3630     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3631     
                      3632     MEASURE_LIPO_UPDATE: 
                      3633     	; Set ADC limit
0BBB    8E6A          3634     MOV LIPO_ADC_LIMIT_L , R6 
0BBD    8F6B          3635     MOV LIPO_ADC_LIMIT_H , R7 
                      3636     MEASURE_LIPO_EXIT: 
0BBF    22            3637     	RET
                      3638     
                      3639     
                      3640     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3641     ;
                      3642     ; Start ADC conversion
                      3643     ;
                      3644     ; No assumptions
                      3645     ;
                      3646     ; Start conversion used for measuring power supply voltage
                      3647     ;
                      3648     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3649     START_ADC_CONVERSION: 
                      3650     	; Start adc
                      3651     	START_ADC 
0BC0    75E890        3651+1   MOV ADC0CN , # 90H  ; ADC START
0BC3    22            3652     	RET
                      3653     
                      3654     
                      3655     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3656     ;
                      3657     ; Check temperature, power supply voltage and limit power
                      3658     ;
                      3659     ; No assumptions
                      3660     ;
                      3661     ; Used to limit main motor power in order to maintain the required voltage
                      3662     ;
                      3663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3664     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3665     	; Load programmed low voltage limit
0BC4    7883          3666     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0BC6    E6            3667     MOV A , @ R0 
0BC7    FF            3668     MOV R7 , A 
                      3669     	; Wait for ADC conversion to complete
                      3670     	GET_ADC_STATUS 
0BC8    E5E8          3670+1   MOV A , ADC0CN 
0BCA    20ECF7        3671     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3672     	; Read ADC result
                      3673     	READ_ADC_RESULT
0BCD    A8BD          3673+1   MOV R0 , ADC0L 
0BCF    A9BE          3673+1   MOV R1 , ADC0H 
                      3674     	; Stop ADC
                      3675     	STOP_ADC
                      3676     
0BD1    056C          3677     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0BD3    C3            3678     	CLR	C
0BD4    E56C          3679     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0BD6    9408          3680     SUBB A , # 8 
0BD8    404B          3681     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3682     
0BDA    756C00        3683     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0BDD    E9            3684     MOV A , R1 
0BDE    7007          3685     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3686     
0BE0    E56D          3687     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0BE2    601B          3688     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0BE4    020BF3        3689     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3690     
                      3691     TEMP_AVERAGE_INC_DEC: 
0BE7    C3            3692     	CLR	C
0BE8    E8            3693     MOV A , R0 
0BE9    956D          3694     	SUBB	A, CURRENT_AVERAGE_TEMP
0BEB    6010          3695     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3696     
0BED    E56D          3697     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0BEF    5006          3698     	JNC	TEMP_AVERAGE_INC				
                      3699     
0BF1    600C          3700     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3701     TEMP_AVERAGE_DEC: 
0BF3    14            3702     	DEC	A						; Decrement average
0BF4    020BFF        3703     	JMP	TEMP_AVERAGE_UPDATED
                      3704     
                      3705     TEMP_AVERAGE_INC: 
0BF7    04            3706     	INC	A						; Increment average
0BF8    60F9          3707     	JZ	TEMP_AVERAGE_DEC
0BFA    020BFF        3708     	JMP	TEMP_AVERAGE_UPDATED
                      3709     
                      3710     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BFD    E56D          3711     	MOV	A, CURRENT_AVERAGE_TEMP
                      3712     TEMP_AVERAGE_UPDATED: 
0BFF    F56D          3713     	MOV	CURRENT_AVERAGE_TEMP, A
0C01    C3            3714     	CLR	C
0C02    946D          3715     SUBB A , # 109 
0C04    401B          3716     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3717     
0C06    755EC0        3718     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3719     
0C09    C3            3720     	CLR	C
0C0A    9404          3721     SUBB A , # 4 
0C0C    4013          3722     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3723     
0C0E    755E80        3724     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3725     
0C11    C3            3726     	CLR	C
0C12    9404          3727     SUBB A , # 4 
0C14    400B          3728     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3729     
0C16    755E40        3730     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3731     
0C19    C3            3732     	CLR	C
0C1A    9404          3733     SUBB A , # 4 
0C1C    4003          3734     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3735     
0C1E    755E00        3736     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3737     
                      3738     TEMP_CHECK_EXIT: 
                      3739     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0C21    75BB08        3739+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0C24    22            3740     	RET
                      3741     
                      3742     CHECK_VOLTAGE_START: 
                      3743     IF MODE == 0 OR MODE == 2	; Main or multi
                      3744     	; Check if low voltage limiting is enabled
0C25    EF            3745     MOV A , R7 
0C26    C3            3746     	CLR	C
0C27    9401          3747     	SUBB	A, #1					; Is low voltage limit disabled?
0C29    601B          3748     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3749     
                      3750     	; Check if ADC is saturated
0C2B    C3            3751     	CLR	C
0C2C    E8            3752     MOV A , R0 
0C2D    94FF          3753     	SUBB	A, #0FFH
0C2F    E9            3754     MOV A , R1 
0C30    9403          3755     	SUBB	A, #03H
0C32    5012          3756     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3757     
                      3758     	; Check voltage against limit
0C34    C3            3759     	CLR	C
0C35    E8            3760     MOV A , R0 
0C36    956A          3761     	SUBB	A, LIPO_ADC_LIMIT_L
0C38    E9            3762     MOV A , R1 
0C39    956B          3763     	SUBB	A, LIPO_ADC_LIMIT_H
0C3B    5009          3764     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3765     
                      3766     	; Decrease pwm limit
0C3D    E55E          3767     	MOV  A, PWM_LIMIT
0C3F    600C          3768     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3769     
0C41    155E          3770     	DEC	PWM_LIMIT					; Decrement limit
0C43    020C4D        3771     	JMP	CHECK_VOLTAGE_LIM
                      3772     
                      3773     CHECK_VOLTAGE_GOOD: 
                      3774     	; Increase pwm limit
0C46    E55E          3775     	MOV  A, PWM_LIMIT
0C48    F4            3776     	CPL	A			
0C49    6002          3777     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3778     
0C4B    055E          3779     	INC	PWM_LIMIT					; Increment limit
                      3780     
                      3781     CHECK_VOLTAGE_LIM: 
0C4D    A85E          3782     MOV R0 , PWM_LIMIT 
0C4F    C3            3783     	CLR	C
0C50    E524          3784     	MOV	A, CURRENT_PWM
0C52    98            3785     SUBB A , R0 
0C53    5002          3786     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3787     
0C55    A824          3788     MOV R0 , CURRENT_PWM 
                      3789     
                      3790     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3791     	; Slow spoolup
0C57    C3            3792     	CLR	C
0C58    E8            3793     MOV A , R0 
0C59    955F          3794     	SUBB	A, PWM_LIMIT_SPOOLUP
0C5B    400A          3795     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3796     
0C5D    A85F          3797     MOV R0 , PWM_LIMIT_SPOOLUP 
0C5F    E55F          3798     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C61    F4            3799     	CPL	A
0C62    6003          3800     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3801      
0C64    855F5E        3802     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3803     
                      3804     CHECK_VOLTAGE_EXIT: 
0C67    8825          3805     MOV CURRENT_PWM_LIMITED , R0 
                      3806     ENDIF
                      3807     	; Set adc mux for next conversion
0C69    C3            3808     	CLR	C
0C6A    E56C          3809     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C6C    B40703        3810     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3811     
                      3812     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C6F    75BB10        3812+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3813     
                      3814     CHECK_VOLTAGE_RET: 
0C72    22            3815     	RET
                      3816     
                      3817     
                      3818     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3819     ;
                      3820     ; Set startup PWM routine
                      3821     ;
                      3822     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3823     ;
                      3824     ; Used for pwm control during startup
                      3825     ;
                      3826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3827     SET_STARTUP_PWM: 	
                      3828     	; Set pwm values according to startup phase flags
0C73    306102        3829     JNB FLAGS1 . 1 , ( $+5 ) 
0C76    7832          3830     MOV R0 , # 50 
0C78    306202        3831     JNB FLAGS1 . 2 , ( $+5 ) 
0C7B    7878          3832     MOV R0 , # 120 
                      3833     
                      3834     	; Update pwm variables if any startup phase flag is set
0C7D    E52C          3835     	MOV	A, FLAGS1
0C7F    5406          3836     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C81    601F          3837     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3838     
                      3839     	; Adjust startup power
0C83    E8            3840     MOV A , R0 
0C84    79A2          3841     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C86    87F0          3842     MOV B , @ R1 
0C88    A4            3843     	MUL	AB
0C89    C5F0          3844     	XCH	A, B
0C8B    A2F7          3845     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C8D    33            3846     	RLC	A
0C8E    F8            3847     MOV R0 , A 
0C8F    C3            3848     	CLR	C
0C90    E8            3849     MOV A , R0 
0C91    955E          3850     	SUBB	A, PWM_LIMIT	
0C93    4002          3851     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3852     
0C95    A85E          3853     MOV R0 , PWM_LIMIT 
                      3854     
                      3855     STARTUP_PWM_SET_PWM: 
                      3856     	; Set pwm variables
0C97    8822          3857     MOV REQUESTED_PWM , R0 
0C99    8824          3858     MOV CURRENT_PWM , R0 
0C9B    8825          3859     MOV CURRENT_PWM_LIMITED , R0 
0C9D    306102        3860     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3861     
0CA0    8860          3862     MOV PWM_SPOOLUP_BEG , R0 
                      3863     
                      3864     STARTUP_PWM_EXIT: 
0CA2    22            3865     	RET
                      3866     
                      3867     
                      3868     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3869     ;
                      3870     ; Initialize all timings routine
                      3871     ;
                      3872     ; No assumptions
                      3873     ;
                      3874     ; Part of initialization before motor start
                      3875     ;
                      3876     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3877     INITIALIZE_ALL_TIMINGS:  
                      3878     	; Load programmed startup rpm
0CA3    788F          3879     MOV R0 , # PGM_STARTUP_RPM 
0CA5    E6            3880     MOV A , @ R0 
0CA6    FF            3881     MOV R7 , A 
                      3882     	; Check startup rpm setting and set step accordingly
0CA7    C3            3883     	CLR	C
0CA8    EF            3884     MOV A , R7 
0CA9    9405          3885     	SUBB	A, #5
0CAB    5018          3886     	JNC	STEPPER_STEP_HIGH
0CAD    C3            3887     	CLR	C
0CAE    EF            3888     MOV A , R7 
0CAF    9404          3889     	SUBB	A, #4
0CB1    5020          3890     	JNC	STEPPER_STEP_MED_HIGH
0CB3    C3            3891     	CLR	C
0CB4    EF            3892     MOV A , R7 
0CB5    9403          3893     	SUBB	A, #3
0CB7    5028          3894     	JNC	STEPPER_STEP_MED
0CB9    C3            3895     	CLR	C
0CBA    EF            3896     MOV A , R7 
0CBB    9402          3897     	SUBB	A, #2
0CBD    5030          3898     	JNC	STEPPER_STEP_MED_LOW
0CBF    C3            3899     	CLR	C
0CC0    EF            3900     MOV A , R7 
0CC1    9401          3901     	SUBB	A, #1
0CC3    5038          3902     	JNC	STEPPER_STEP_LOW
                      3903     
                      3904     STEPPER_STEP_HIGH: 
0CC5    7533A0        3905     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0CC8    75340F        3906     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0CCB    75353C        3907     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0CCE    753605        3908     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0CD1    A109          3909     	AJMP	STEPPER_STEP_SET
                      3910     STEPPER_STEP_MED_HIGH: 
0CD3    7533C0        3911     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0CD6    753412        3912     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0CD9    753540        3913     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0CDC    753606        3914     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0CDF    A109          3915     	AJMP	STEPPER_STEP_SET
                      3916     STEPPER_STEP_MED: 
0CE1    753370        3917     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0CE4    753417        3918     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0CE7    7535D0        3919     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0CEA    753607        3920     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0CED    A109          3921     	AJMP	STEPPER_STEP_SET
                      3922     STEPPER_STEP_MED_LOW: 
0CEF    75334C        3923     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0CF2    75341D        3924     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0CF5    7535C4        3925     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0CF8    753609        3926     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CFB    A109          3927     	AJMP	STEPPER_STEP_SET
                      3928     STEPPER_STEP_LOW: 
0CFD    753328        3929     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0D00    753423        3930     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0D03    7535B8        3931     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0D06    75360B        3932     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3933     
                      3934     STEPPER_STEP_SET: 
0D09    853350        3935     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0D0C    853451        3936     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0D0F    753C00        3937     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0D12    753D08        3938     	MOV	COMM_PERIOD4X_H, #08H
0D15    22            3939     	RET
                      3940     
                      3941     
                      3942     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3943     ;
                      3944     ; Calculate next commutation timing routine
                      3945     ;
                      3946     ; No assumptions
                      3947     ;
                      3948     ; Called immediately after each commutation
                      3949     ; Also sets up timer 3 to wait advance timing
                      3950     ; Two entry points are used
                      3951     ;
                      3952     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3953     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0D16    A850          3954     MOV R0 , WT_STEPPER_STEP_L 
0D18    A951          3955     MOV R1 , WT_STEPPER_STEP_H 
0D1A    020D21        3956     	JMP	READ_TIMER
                      3957     
                      3958     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0D1D    A84A          3959     MOV R0 , WT_ADVANCE_L 
0D1F    A94B          3960     MOV R1 , WT_ADVANCE_H 
                      3961     READ_TIMER: 
                      3962     	; Set up next wait
0D21    759100        3963     	MOV	TMR3CN, #00H		; Timer3 disabled
0D24    C3            3964     	CLR	C
0D25    E4            3965     	CLR	A
0D26    98            3966     SUBB A , R0 
0D27    F594          3967     	MOV	TMR3L, A
0D29    E4            3968     	CLR	A
0D2A    99            3969     SUBB A , R1 
0D2B    F595          3970     	MOV	TMR3H, A
0D2D    759104        3971     	MOV	TMR3CN, #04H		; Timer3 enabled
0D30    D258          3972     SETB FLAGS0 . 0 
                      3973     	; Read commutation time
0D32    75C820        3974     	MOV	TMR2CN, #20H		; Timer2 disabled
0D35    A8CC          3975     MOV R0 , TMR2L 
0D37    A9CD          3976     MOV R1 , TMR2H 
0D39    75C824        3977     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3978     	; Calculate this commutation time
0D3C    AA3A          3979     MOV R2 , PREV_COMM_L 
0D3E    AB3B          3980     MOV R3 , PREV_COMM_H 
0D40    883A          3981     MOV PREV_COMM_L , R0 
0D42    893B          3982     MOV PREV_COMM_H , R1 
0D44    C3            3983     	CLR	C
0D45    E8            3984     MOV A , R0 
0D46    9A            3985     SUBB A , R2 
0D47    F8            3986     MOV R0 , A 
0D48    E9            3987     MOV A , R1 
0D49    9B            3988     SUBB A , R3 
0D4A    F9            3989     MOV R1 , A 
                      3990     	; Calculate next zero cross scan timeout 
0D4B    AA3C          3991     MOV R2 , COMM_PERIOD4X_L 
0D4D    AB3D          3992     MOV R3 , COMM_PERIOD4X_H 
0D4F    C3            3993     	CLR	C
0D50    EB            3994     MOV A , R3 
0D51    13            3995     	RRC	A					; Divide by 2
0D52    FD            3996     MOV R5 , A 
0D53    EA            3997     MOV A , R2 
0D54    13            3998     	RRC	A
0D55    FC            3999     MOV R4 , A 
0D56    C3            4000     	CLR	C
0D57    ED            4001     MOV A , R5 
0D58    13            4002     	RRC	A					; Divide by 2 again
0D59    FD            4003     MOV R5 , A 
0D5A    EC            4004     MOV A , R4 
0D5B    13            4005     	RRC	A
0D5C    FC            4006     MOV R4 , A 
0D5D    C3            4007     	CLR	C
0D5E    EA            4008     MOV A , R2 
0D5F    9C            4009     SUBB A , R4 
0D60    FA            4010     MOV R2 , A 
0D61    EB            4011     MOV A , R3 
0D62    9D            4012     SUBB A , R5 
0D63    FB            4013     MOV R3 , A 
                      4014     
0D64    EA            4015     MOV A , R2 
0D65    28            4016     ADD A , R0 
0D66    FA            4017     MOV R2 , A 
0D67    EB            4018     MOV A , R3 
0D68    39            4019     ADDC A , R1 
0D69    FB            4020     MOV R3 , A 
0D6A    8A3C          4021     MOV COMM_PERIOD4X_L , R2 
0D6C    8B3D          4022     MOV COMM_PERIOD4X_H , R3 
0D6E    4001          4023     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4024     
0D70    22            4025     	RET
                      4026     
                      4027     CALC_NEXT_COMM_SLOW: 
0D71    753CFF        4028     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D74    753DFF        4029     	MOV	COMM_PERIOD4X_H, #0FFH
0D77    22            4030     	RET
                      4031     
                      4032     
                      4033     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4034     ;
                      4035     ; Setup zero cross scan wait
                      4036     ;
                      4037     ; No assumptions
                      4038     ;
                      4039     ; Sets up timer 3 to wait the zero cross scan wait time
                      4040     ;
                      4041     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4042     SETUP_ZC_SCAN_WAIT: 
0D78    759100        4043     	MOV	TMR3CN, #00H		; Timer3 disabled
0D7B    C3            4044     	CLR	C
0D7C    E4            4045     	CLR	A
0D7D    954C          4046     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D7F    F594          4047     	MOV	TMR3L, A
0D81    E4            4048     	CLR	A
0D82    954D          4049     	SUBB	A, WT_ZC_SCAN_H		
0D84    F595          4050     	MOV	TMR3H, A
0D86    759104        4051     	MOV	TMR3CN, #04H		; Timer3 enabled
0D89    D258          4052     SETB FLAGS0 . 0 
0D8B    22            4053     	RET
                      4054     
                      4055     
                      4056     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4057     ;
                      4058     ; Wait advance timing routine
                      4059     ;
                      4060     ; No assumptions
                      4061     ;
                      4062     ; Waits for the advance timing to elapse, waits one zero cross
                      4063     ; wait and sets up the next zero cross wait
                      4064     ;
                      4065     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4066     WAIT_ADVANCE_TIMING: 	
0D8C    7F01          4067     MOV R7 , # 1 
0D8E    789C          4068     MOV R0 , # PGM_DEMAG_COMP 
0D90    E6            4069     MOV A , @ R0 
0D91    14            4070     	DEC	A
0D92    6002          4071     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4072     
0D94    7F02          4073     MOV R7 , # 2 
                      4074     
                      4075     WAIT_ADVANCE_TIMING_WAIT: 
0D96    305802        4076     JNB FLAGS0 . 0 , ( $+5 ) 
0D99    A196          4077     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4078     
0D9B    B178          4079     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D9D    DFF7          4080     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4081     
0D9F    22            4082     	RET
                      4083     
                      4084     
                      4085     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4086     ;
                      4087     ; Calculate new wait times routine
                      4088     ;
                      4089     ; No assumptions
                      4090     ;
                      4091     ; Calculates new wait times
                      4092     ;
                      4093     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4094     CALC_NEW_WAIT_TIMES: 	
                      4095     	; Load programmed commutation timing
0DA0    7892          4096     MOV R0 , # PGM_COMM_TIMING 
0DA2    E6            4097     MOV A , @ R0 
0DA3    FF            4098     MOV R7 , A 
0DA4    7E14          4099     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4100     IF MODE == 2
0DA6    A83D          4101     MOV R0 , COMM_PERIOD4X_H 
0DA8    C3            4102     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0DA9    E8            4103     MOV A , R0 
0DAA    9404          4104     	SUBB	A, #4
0DAC    4002          4105     	JC	CALC_NEW_WAIT_RED_SET
                      4106     
0DAE    7804          4107     MOV R0 , # 4 
                      4108     
                      4109     CALC_NEW_WAIT_RED_SET: 
0DB0    C3            4110     	CLR	C
0DB1    E8            4111     MOV A , R0 
0DB2    33            4112     	RLC	A
0DB3    F8            4113     MOV R0 , A 
0DB4    C3            4114     	CLR	C
0DB5    EE            4115     MOV A , R6 
0DB6    98            4116     SUBB A , R0 
0DB7    FE            4117     MOV R6 , A 
                      4118     ENDIF
0DB8    306304        4119     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4120     
0DBB    7F03          4121     MOV R7 , # 3 
0DBD    7E00          4122     MOV R6 , # 0 
                      4123     
                      4124     CALC_NEW_WAIT_DIR_START_SET: 
                      4125     	; Load current commutation timing
0DBF    A93D          4126     MOV R1 , COMM_PERIOD4X_H 
0DC1    A83C          4127     MOV R0 , COMM_PERIOD4X_L 
0DC3    7A04          4128     MOV R2 , # 4 
                      4129     DIVIDE_WAIT_TIMES: 
0DC5    C3            4130     	CLR	C
0DC6    E9            4131     MOV A , R1 
0DC7    13            4132     	RRC	A					; Divide by 2
0DC8    F9            4133     MOV R1 , A 
0DC9    E8            4134     MOV A , R0 
0DCA    13            4135     	RRC	A
0DCB    F8            4136     MOV R0 , A 
0DCC    DAF7          4137     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4138     
0DCE    C3            4139     	CLR	C
0DCF    E8            4140     MOV A , R0 
0DD0    9E            4141     SUBB A , R6 
0DD1    F8            4142     MOV R0 , A 
0DD2    E9            4143     MOV A , R1 
0DD3    9400          4144     	SUBB	A, #0
0DD5    F9            4145     MOV R1 , A 
0DD6    4009          4146     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4147     
0DD8    C3            4148     	CLR	C
0DD9    E8            4149     MOV A , R0 
0DDA    9402          4150     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0DDC    E9            4151     MOV A , R1 
0DDD    9400          4152     	SUBB	A, #0
0DDF    5004          4153     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4154     
                      4155     LOAD_MIN_TIME: 
0DE1    7802          4156     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0DE3    E4            4157     	CLR	A
0DE4    F9            4158     MOV R1 , A 
                      4159     
                      4160     ADJUST_TIMING: 
0DE5    E9            4161     MOV A , R1 
0DE6    FB            4162     MOV R3 , A 
0DE7    E8            4163     MOV A , R0 
0DE8    FA            4164     MOV R2 , A 
0DE9    C3            4165     	CLR	C
0DEA    E9            4166     MOV A , R1 
0DEB    13            4167     	RRC	A					; Divide by 2
0DEC    FD            4168     MOV R5 , A 
0DED    E8            4169     MOV A , R0 
0DEE    13            4170     	RRC	A
0DEF    FC            4171     MOV R4 , A 
0DF0    C3            4172     	CLR	C
0DF1    EF            4173     MOV A , R7 
0DF2    9403          4174     	SUBB	A, #3				; Is timing normal?
0DF4    602E          4175     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4176     
0DF6    EF            4177     MOV A , R7 
0DF7    20E00D        4178     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4179     
0DFA    E8            4180     MOV A , R0 
0DFB    2C            4181     ADD A , R4 
0DFC    F8            4182     MOV R0 , A 
0DFD    E9            4183     MOV A , R1 
0DFE    3D            4184     ADDC A , R5 
0DFF    F9            4185     MOV R1 , A 
0E00    EC            4186     MOV A , R4 
0E01    FA            4187     MOV R2 , A 
0E02    ED            4188     MOV A , R5 
0E03    FB            4189     MOV R3 , A 
0E04    020E11        4190     	JMP	STORE_TIMES_UP_OR_DOWN
                      4191     
                      4192     ADJUST_TIMING_TWO_STEPS: 
0E07    E8            4193     MOV A , R0 
0E08    28            4194     ADD A , R0 
0E09    F8            4195     MOV R0 , A 
0E0A    E9            4196     MOV A , R1 
0E0B    39            4197     ADDC A , R1 
0E0C    F9            4198     MOV R1 , A 
0E0D    7A02          4199     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0E0F    E4            4200     	CLR	A
0E10    FB            4201     MOV R3 , A 
                      4202     
                      4203     STORE_TIMES_UP_OR_DOWN: 
0E11    C3            4204     	CLR	C
0E12    EF            4205     MOV A , R7 
0E13    9403          4206     	SUBB	A, #3				; Is timing higher than normal?
0E15    400D          4207     	JC	STORE_TIMES_DECREASE	; No - branch
                      4208     
                      4209     STORE_TIMES_INCREASE: 
0E17    8A4E          4210     MOV WT_COMM_L , R2 
0E19    8B4F          4211     MOV WT_COMM_H , R3 
0E1B    884A          4212     MOV WT_ADVANCE_L , R0 
0E1D    894B          4213     MOV WT_ADVANCE_H , R1 
0E1F    8C4C          4214     MOV WT_ZC_SCAN_L , R4 
0E21    8D4D          4215     MOV WT_ZC_SCAN_H , R5 
0E23    22            4216     	RET
                      4217     
                      4218     STORE_TIMES_DECREASE: 
0E24    884E          4219     MOV WT_COMM_L , R0 
0E26    894F          4220     MOV WT_COMM_H , R1 
0E28    8A4A          4221     MOV WT_ADVANCE_L , R2 
0E2A    8B4B          4222     MOV WT_ADVANCE_H , R3 
0E2C    8C4C          4223     MOV WT_ZC_SCAN_L , R4 
0E2E    8D4D          4224     MOV WT_ZC_SCAN_H , R5 
0E30    22            4225     	RET
                      4226     
                      4227     
                      4228     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4229     ;
                      4230     ; Wait before zero cross scan routine
                      4231     ;
                      4232     ; No assumptions
                      4233     ;
                      4234     ; Waits for the zero cross scan wait time to elapse
                      4235     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4236     ;
                      4237     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4238     WAIT_BEFORE_ZC_SCAN: 	
0E31    305802        4239     JNB FLAGS0 . 0 , ( $+5 ) 
0E34    C131          4240     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4241     
0E36    759100        4242     	MOV	TMR3CN, #00H		; Timer3 disabled
0E39    C3            4243     	CLR	C
0E3A    E4            4244     	CLR	A
0E3B    953C          4245     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0E3D    F594          4246     	MOV	TMR3L, A
0E3F    E4            4247     	CLR	A
0E40    953D          4248     	SUBB	A, COMM_PERIOD4X_H		
0E42    F595          4249     	MOV	TMR3H, A
0E44    759104        4250     	MOV	TMR3CN, #04H		; Timer3 enabled
0E47    D258          4251     SETB FLAGS0 . 0 
0E49    22            4252     	RET
                      4253     
                      4254     
                      4255     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4256     ;
                      4257     ; Wait for comparator to go low/high routines
                      4258     ;
                      4259     ; No assumptions
                      4260     ;
                      4261     ; Waits for the zero cross scan wait time to elapse
                      4262     ; Then scans for comparator going low/high
                      4263     ;
                      4264     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4265     WAIT_FOR_COMP_OUT_LOW: 
0E4A    753F00        4266     	MOV	COMP_WAIT_READS, #0
0E4D    752000        4267     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E50    020E59        4268     	JMP	WAIT_FOR_COMP_OUT_START
                      4269     
                      4270     WAIT_FOR_COMP_OUT_HIGH: 
0E53    753F00        4271     	MOV	COMP_WAIT_READS, #0
0E56    752040        4272     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4273     
                      4274     WAIT_FOR_COMP_OUT_START: 
0E59    D2AF          4275     	SETB	EA						; Enable interrupts
0E5B    053F          4276     	INC	COMP_WAIT_READS
0E5D    205801        4277     JB FLAGS0 . 0 , ( $+4 ) 
0E60    22            4278     	RET							; Yes - return
                      4279     
                      4280     	; Set default comparator response times
0E61    759D00        4281     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4282     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4285     	; Select number of comparator readings based upon current rotation speed
0E64    E53D          4286     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E66    C3            4287     	CLR	C
0E67    13            4288     	RRC	A						; Divide by 4
0E68    C3            4289     	CLR	C
0E69    13            4290     	RRC	A
0E6A    F8            4291     MOV R0 , A 
0E6B    08            4292     INC R0 
0E6C    6030          4293     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4294     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E6E    306A06        4295     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4296     
0E71    C3            4297     	CLR	C
0E72    13            4298     	RRC	A						; Divide by 4 again
0E73    C3            4299     	CLR	C
0E74    13            4300     	RRC	A
0E75    F8            4301     MOV R0 , A 
0E76    08            4302     INC R0 
                      4303     
                      4304     COMP_WAIT_SET_MAX_READINGS: 
0E77    C3            4305     	CLR	C
0E78    E8            4306     MOV A , R0 
0E79    940A          4307     	SUBB	A, #10
0E7B    4002          4308     	JC	($+4)
                      4309     
0E7D    780A          4310     MOV R0 , # 10 
                      4311     
0E7F    306D08        4312     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4313     
0E82    C3            4314     	CLR	C
0E83    E8            4315     MOV A , R0 
0E84    9404          4316     	SUBB	A, #4
0E86    4002          4317     	JC	($+4)
                      4318     
0E88    7804          4319     MOV R0 , # 4 
                      4320     
                      4321     COMP_WAIT_SET_RESPONSE_TIME: 
0E8A    C3            4322     	CLR	C
0E8B    E53D          4323     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E8D    9408          4324     	SUBB	A, #8
0E8F    400D          4325     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4326     
0E91    759D02        4327     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4328     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E94    C3            4331     	CLR	C
0E95    E53D          4332     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E97    9410          4333     	SUBB	A, #16
0E99    4003          4334     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4335     
0E9B    759D03        4336     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4337     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4340     
                      4341     COMP_WAIT_ON_COMP_ABLE: 
0E9E    205803        4342     JB FLAGS0 . 0 , ( $+6 ) 
0EA1    D2AF          4343     	SETB	EA							; Enable interrupts
0EA3    22            4344     	RET								; Yes - return
                      4345     
0EA4    7918          4346     MOV R1 , # 24 
0EA6    206D02        4347     JB FLAGS2 . 5 , ( $+5 ) 
0EA9    7908          4348     MOV R1 , # 8 
0EAB    D2AF          4349     	SETB	EA							; Enable interrupts
0EAD    00            4350     	NOP								; Allocate only just enough time to capture interrupt
0EAE    00            4351     	NOP
0EAF    C2AF          4352     	CLR	EA							; Disable interrupts
0EB1    205A0A        4353     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4354     
0EB4    7914          4355     MOV R1 , # 20 
0EB6    206D02        4356     JB FLAGS2 . 5 , ( $+5 ) 
0EB9    7907          4357     MOV R1 , # 7 
0EBB    3066E0        4358     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4359     
                      4360     PWM_WAIT_STARTUP: 						
0EBE    306302        4361     JNB FLAGS1 . 3 , PWM_WAIT 
                      4362     
0EC1    7978          4363     MOV R1 , # 120 
                      4364     PWM_WAIT: 						
0EC3    C3            4365     	CLR	C
0EC4    E58B          4366     	MOV	A, TL1
0EC6    99            4367     SUBB A , R1 
                      4368     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0EC7    40D5          4373     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4374     ENDIF
                      4375     
                      4376     COMP_READ: 
                      4377     	READ_COMP_OUT 					; Read comparator output
0EC9    E59B          4377+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0ECB    F4            4378     	CPL	A
0ECC    5440          4379     	ANL	A, #40H
0ECE    B52002        4380     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4381     
0ED1    C159          4382     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4383     
0ED3    D8C9          4384     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4385     
0ED5    D2AF          4386     	SETB	EA						; Enable interrupts
0ED7    22            4387     	RET							
                      4388     
                      4389     
                      4390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4391     ;
                      4392     ; Evaluate comparator integrity
                      4393     ;
                      4394     ; No assumptions
                      4395     ;
                      4396     ; Checks comparator signal behaviour versus expected behaviour
                      4397     ;
                      4398     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4399     EVALUATE_COMPARATOR_INTEGRITY: 
0ED8    C25B          4400     CLR FLAGS0 . 3 
                      4401     	; Check if demag compensation is enabled
0EDA    789C          4402     MOV R0 , # PGM_DEMAG_COMP 
0EDC    E6            4403     MOV A , @ R0 
0EDD    14            4404     	DEC	A
0EDE    600A          4405     	JZ	EVAL_COMP_NO_DEMAG
                      4406     
                      4407     	; Check if a demag situation has occurred
0EE0    E53F          4408     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0EE2    14            4409     	DEC	A
0EE3    7005          4410     	JNZ	EVAL_COMP_NO_DEMAG
                      4411     
0EE5    206302        4412     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4413     
0EE8    D25B          4414     SETB FLAGS0 . 3 
                      4415     
                      4416     EVAL_COMP_NO_DEMAG: 
0EEA    30630B        4417     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4418     
0EED    0538          4419     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0EEF    205810        4420     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4421     
0EF2    753800        4422     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0EF5    020F02        4423     	JMP	EVAL_COMP_EXIT
                      4424     
                      4425     EVAL_COMP_CHECK_TIMEOUT: 
0EF8    205807        4426     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EFB    1581          4427     	DEC	SP							; Routine exit without "ret" command
0EFD    1581          4428     	DEC	SP
0EFF    02180B        4429     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4430     
                      4431     EVAL_COMP_EXIT: 
0F02    22            4432     	RET
                      4433     
                      4434     
                      4435     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4436     ;
                      4437     ; Setup commutation timing routine
                      4438     ;
                      4439     ; No assumptions
                      4440     ;
                      4441     ; Sets up and starts wait from commutation to zero cross
                      4442     ;
                      4443     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4444     SETUP_COMM_WAIT:  
0F03    759100        4445     	MOV	TMR3CN, #00H		; Timer3 disabled
0F06    C3            4446     	CLR	C
0F07    E4            4447     	CLR	A
0F08    954E          4448     	SUBB	A, WT_COMM_L		; Set wait commutation value
0F0A    F594          4449     	MOV	TMR3L, A
0F0C    E4            4450     	CLR	A
0F0D    954F          4451     	SUBB	A, WT_COMM_H		
0F0F    F595          4452     	MOV	TMR3H, A
0F11    759104        4453     	MOV	TMR3CN, #04H		; Timer3 enabled
0F14    D258          4454     SETB FLAGS0 . 0 
0F16    22            4455     	RET
                      4456     
                      4457     
                      4458     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4459     ;
                      4460     ; Wait for commutation routine
                      4461     ;
                      4462     ; No assumptions
                      4463     ;
                      4464     ; Waits from zero cross to commutation 
                      4465     ;
                      4466     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4467     WAIT_FOR_COMM:  
                      4468     	; Increment or reset consecutive count
0F17    0539          4469     	INC	DEMAG_CONSECUTIVE_CNT
0F19    205B03        4470     JB FLAGS0 . 3 , ( $+6 ) 
                      4471     
0F1C    753900        4472     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4473     
                      4474     	; Check if a demag situation has occurred
0F1F    305B23        4475     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4476     
                      4477     	; Load programmed demag compensation
0F22    78A3          4478     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0F24    E6            4479     MOV A , @ R0 
0F25    FF            4480     MOV R7 , A 
                      4481     
                      4482     	; Check for power off
0F26    BF0108        4483     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4484     
0F29    D25C          4485     SETB FLAGS0 . 4 
                      4486     	ALL_NFETS_OFF
0F2B    D297          4486+1   SETB P1 . 7 
0F2D    D295          4486+1   SETB P1 . 5 
0F2F    D293          4486+1   SETB P1 . 3 
                      4487     
                      4488     	; Wait a blind wait
                      4489     WAIT_FOR_COMM_BLIND: 
0F31    B178          4490     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4491     WAIT_DEMAG_DEFAULT_ZC: 	
0F33    305802        4492     JNB FLAGS0 . 0 , ( $+5 ) 
0F36    E133          4493     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4494     
                      4495     	; Check for power off
0F38    BF0208        4496     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4497     
0F3B    D25C          4498     SETB FLAGS0 . 4 
                      4499     	ALL_NFETS_OFF
0F3D    D297          4499+1   SETB P1 . 7 
0F3F    D295          4499+1   SETB P1 . 5 
0F41    D293          4499+1   SETB P1 . 3 
                      4500     
                      4501     WAIT_FOR_COMM_SETUP: 
0F43    F103          4502     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4503     WAIT_FOR_COMM_WAIT: 
0F45    305802        4504     JNB FLAGS0 . 0 , ( $+5 ) 
0F48    E145          4505     	AJMP	WAIT_FOR_COMM_WAIT					
                      4506     
0F4A    22            4507     	RET
                      4508     
                      4509     
                      4510     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4511     ;
                      4512     ; Commutation routines
                      4513     ;
                      4514     ; No assumptions
                      4515     ;
                      4516     ; Performs commutation switching 
                      4517     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4518     ;
                      4519     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4520     COMM1COMM2: 	
0F4B    C2AF          4521     	CLR 	EA					; Disable all interrupts
                      4522     	BPFET_OFF					; Bp off
0F4D    C294          4522+1   CLR P1 . 4 
0F4F    206A03        4523     JB FLAGS2 . 2 , COMM12_DAMP 
0F52    020F6A        4524     	JMP	COMM12_NONDAMP
                      4525     COMM12_DAMP: 
                      4526     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4530     IF DAMPED_MODE_ENABLE == 1
0F55    900347        4531     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4532     ENDIF
0F58    30650F        4533     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4534     	CPFET_OFF				
0F5B    207502        4534+1   JB FLAGS3 . 5 , ( $+5 ) 
0F5E    C292          4534+1   CLR P1 . 2 
0F60    307502        4534+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F63    C296          4534+1   CLR P1 . 6 
0F65    7406          4535     MOV A , # 6 
0F67    D5E0FD        4536     	DJNZ ACC,	$
                      4537     COMM12_NONDAMP: 
                      4538     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4539     	ANFET_ON				
0F6A    E525          4539+1   MOV A , CURRENT_PWM_LIMITED 
0F6C    600A          4539+1   JZ ( $+12 ) 
0F6E    207502        4539+1   JB FLAGS3 . 5 , ( $+5 ) 
0F71    C297          4539+1   CLR P1 . 7 
0F73    307502        4539+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F76    C293          4539+1   CLR P1 . 3 
0F78    740F          4540     MOV A , # 15 
0F7A    D5E0FD        4541     	DJNZ ACC,	$
                      4542     	ANFET_OFF				
0F7D    207502        4542+1   JB FLAGS3 . 5 , ( $+5 ) 
0F80    D297          4542+1   SETB P1 . 7 
0F82    307502        4542+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F85    D293          4542+1   SETB P1 . 3 
0F87    7406          4543     MOV A , # 6 
0F89    D5E0FD        4544     	DJNZ ACC,	$
                      4545     ENDIF
                      4546     	APFET_ON					; Ap on
0F8C    207502        4546+1   JB FLAGS3 . 5 , ( $+5 ) 
0F8F    D296          4546+1   SETB P1 . 6 
0F91    307502        4546+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F94    D292          4546+1   SETB P1 . 2 
                      4547     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F96    759F10        4547+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F99    753E02        4548     	MOV	COMM_PHASE, #2
0F9C    02112B        4549     	JMP	COMM_EXIT
                      4550     
                      4551     COMM2COMM3: 	
0F9F    C2AF          4552     	CLR 	EA					; Disable all interrupts
0FA1    206A03        4553     JB FLAGS2 . 2 , COMM23_DAMP 
0FA4    020FC1        4554     	JMP	COMM23_NONDAMP
                      4555     COMM23_DAMP: 
                      4556     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4559     IF DAMPED_MODE_ENABLE == 1
0FA7    9002FE        4560     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4561     ENDIF
0FAA    306517        4562     JNB FLAGS1 . 5 , COMM23_NFET 
                      4563     	BPFET_OFF				
0FAD    C294          4563+1   CLR P1 . 4 
                      4564     	CPFET_OFF				
0FAF    207502        4564+1   JB FLAGS3 . 5 , ( $+5 ) 
0FB2    C292          4564+1   CLR P1 . 2 
0FB4    307502        4564+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FB7    C296          4564+1   CLR P1 . 6 
0FB9    7406          4565     MOV A , # 6 
0FBB    D5E0FD        4566     	DJNZ ACC,	$
0FBE    020FC4        4567     	JMP	COMM23_NFET
                      4568     COMM23_NONDAMP: 
0FC1    9001E1        4569     	MOV	DPTR, #PWM_BFET_ON	
                      4570     COMM23_NFET: 
                      4571     	CNFET_OFF					; Cn off
0FC4    207502        4571+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC7    D293          4571+1   SETB P1 . 3 
0FC9    307502        4571+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FCC    D297          4571+1   SETB P1 . 7 
0FCE    305A06        4572     JNB FLAGS0 . 2 , COMM23_CP 
                      4573     	BNFET_ON					; Yes - Bn on
0FD1    E525          4573+1   MOV A , CURRENT_PWM_LIMITED 
0FD3    6002          4573+1   JZ ( $+4 ) 
0FD5    C295          4573+1   CLR P1 . 5 
                      4574     COMM23_CP: 
                      4575     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FD7    207503        4575+1   JB FLAGS3 . 5 , ( $+6 ) 
0FDA    759F13        4575+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FDD    307503        4575+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FE0    759F11        4575+1   MOV CPT0MX , # 11H 
0FE3    753E03        4576     	MOV	COMM_PHASE, #3
0FE6    02112B        4577     	JMP	COMM_EXIT
                      4578     
                      4579     COMM3COMM4: 	
0FE9    C2AF          4580     	CLR 	EA					; Disable all interrupts
                      4581     	APFET_OFF					; Ap off
0FEB    207502        4581+1   JB FLAGS3 . 5 , ( $+5 ) 
0FEE    C296          4581+1   CLR P1 . 6 
0FF0    307502        4581+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF3    C292          4581+1   CLR P1 . 2 
0FF5    206A03        4582     JB FLAGS2 . 2 , COMM34_DAMP 
0FF8    021008        4583     	JMP	COMM34_NONDAMP
                      4584     COMM34_DAMP: 
                      4585     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4589     IF DAMPED_MODE_ENABLE == 1
0FFB    9002BD        4590     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4591     ENDIF
0FFE    306507        4592     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4593     	BPFET_OFF				
1001    C294          4593+1   CLR P1 . 4 
1003    7406          4594     MOV A , # 6 
1005    D5E0FD        4595     	DJNZ ACC,	$
                      4596     COMM34_NONDAMP: 
                      4597     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4598     	CNFET_ON				
1008    E525          4598+1   MOV A , CURRENT_PWM_LIMITED 
100A    600A          4598+1   JZ ( $+12 ) 
100C    207502        4598+1   JB FLAGS3 . 5 , ( $+5 ) 
100F    C293          4598+1   CLR P1 . 3 
1011    307502        4598+1   JNB FLAGS3 . 5 , ( $+5 ) 
1014    C297          4598+1   CLR P1 . 7 
1016    740F          4599     MOV A , # 15 
1018    D5E0FD        4600     	DJNZ ACC,	$
                      4601     	CNFET_OFF				
101B    207502        4601+1   JB FLAGS3 . 5 , ( $+5 ) 
101E    D293          4601+1   SETB P1 . 3 
1020    307502        4601+1   JNB FLAGS3 . 5 , ( $+5 ) 
1023    D297          4601+1   SETB P1 . 7 
1025    7406          4602     MOV A , # 6 
1027    D5E0FD        4603     	DJNZ ACC,	$
                      4604     ENDIF
                      4605     	CPFET_ON					; Cp on
102A    207502        4605+1   JB FLAGS3 . 5 , ( $+5 ) 
102D    D292          4605+1   SETB P1 . 2 
102F    307502        4605+1   JNB FLAGS3 . 5 , ( $+5 ) 
1032    D296          4605+1   SETB P1 . 6 
                      4606     	SET_COMP_PHASE_A 			; Set comparator to phase A
1034    207503        4606+1   JB FLAGS3 . 5 , ( $+6 ) 
1037    759F11        4606+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
103A    307503        4606+1   JNB FLAGS3 . 5 , ( $+6 ) 
103D    759F13        4606+1   MOV CPT0MX , # 13H 
1040    753E04        4607     	MOV	COMM_PHASE, #4
1043    02112B        4608     	JMP	COMM_EXIT
                      4609     
                      4610     COMM4COMM5: 	
1046    C2AF          4611     	CLR 	EA					; Disable all interrupts
1048    206A03        4612     JB FLAGS2 . 2 , COMM45_DAMP 
104B    021068        4613     	JMP	COMM45_NONDAMP
                      4614     COMM45_DAMP: 
                      4615     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4618     IF DAMPED_MODE_ENABLE == 1
104E    90027C        4619     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4620     ENDIF
1051    306517        4621     JNB FLAGS1 . 5 , COMM45_NFET 
                      4622     	APFET_OFF				
1054    207502        4622+1   JB FLAGS3 . 5 , ( $+5 ) 
1057    C296          4622+1   CLR P1 . 6 
1059    307502        4622+1   JNB FLAGS3 . 5 , ( $+5 ) 
105C    C292          4622+1   CLR P1 . 2 
                      4623     	BPFET_OFF				
105E    C294          4623+1   CLR P1 . 4 
1060    7406          4624     MOV A , # 6 
1062    D5E0FD        4625     	DJNZ ACC,	$
1065    02106B        4626     	JMP	COMM45_NFET
                      4627     COMM45_NONDAMP: 
1068    9001CF        4628     	MOV	DPTR, #PWM_AFET_ON
                      4629     COMM45_NFET: 
                      4630     	BNFET_OFF					; Bn off
106B    D295          4630+1   SETB P1 . 5 
106D    305A0E        4631     JNB FLAGS0 . 2 , COMM45_CP 
                      4632     	ANFET_ON					; Yes - An on
1070    E525          4632+1   MOV A , CURRENT_PWM_LIMITED 
1072    600A          4632+1   JZ ( $+12 ) 
1074    207502        4632+1   JB FLAGS3 . 5 , ( $+5 ) 
1077    C297          4632+1   CLR P1 . 7 
1079    307502        4632+1   JNB FLAGS3 . 5 , ( $+5 ) 
107C    C293          4632+1   CLR P1 . 3 
                      4633     COMM45_CP: 
                      4634     	SET_COMP_PHASE_B 			; Set comparator to phase B
107E    759F10        4634+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
1081    753E05        4635     	MOV	COMM_PHASE, #5
1084    02112B        4636     	JMP	COMM_EXIT
                      4637     
                      4638     COMM5COMM6: 	
1087    C2AF          4639     	CLR 	EA					; Disable all interrupts
                      4640     	CPFET_OFF					; Cp off
1089    207502        4640+1   JB FLAGS3 . 5 , ( $+5 ) 
108C    C292          4640+1   CLR P1 . 2 
108E    307502        4640+1   JNB FLAGS3 . 5 , ( $+5 ) 
1091    C296          4640+1   CLR P1 . 6 
1093    206A03        4641     JB FLAGS2 . 2 , COMM56_DAMP 
1096    0210AE        4642     	JMP	COMM56_NONDAMP
                      4643     COMM56_DAMP: 
                      4644     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4648     IF DAMPED_MODE_ENABLE == 1
1099    900233        4649     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4650     ENDIF
109C    30650F        4651     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4652     	APFET_OFF				
109F    207502        4652+1   JB FLAGS3 . 5 , ( $+5 ) 
10A2    C296          4652+1   CLR P1 . 6 
10A4    307502        4652+1   JNB FLAGS3 . 5 , ( $+5 ) 
10A7    C292          4652+1   CLR P1 . 2 
10A9    7406          4653     MOV A , # 6 
10AB    D5E0FD        4654     	DJNZ ACC,	$
                      4655     COMM56_NONDAMP: 
                      4656     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4657     	BNFET_ON				
10AE    E525          4657+1   MOV A , CURRENT_PWM_LIMITED 
10B0    6002          4657+1   JZ ( $+4 ) 
10B2    C295          4657+1   CLR P1 . 5 
10B4    740F          4658     MOV A , # 15 
10B6    D5E0FD        4659     	DJNZ ACC,	$
                      4660     	BNFET_OFF				
10B9    D295          4660+1   SETB P1 . 5 
10BB    7406          4661     MOV A , # 6 
10BD    D5E0FD        4662     	DJNZ ACC,	$
                      4663     ENDIF
                      4664     	BPFET_ON					; Bp on
10C0    D294          4664+1   SETB P1 . 4 
                      4665     	SET_COMP_PHASE_C 			; Set comparator to phase C
10C2    207503        4665+1   JB FLAGS3 . 5 , ( $+6 ) 
10C5    759F13        4665+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
10C8    307503        4665+1   JNB FLAGS3 . 5 , ( $+6 ) 
10CB    759F11        4665+1   MOV CPT0MX , # 11H 
10CE    753E06        4666     	MOV	COMM_PHASE, #6
10D1    02112B        4667     	JMP	COMM_EXIT
                      4668     
                      4669     COMM6COMM1: 	
10D4    C2AF          4670     	CLR 	EA					; Disable all interrupts
10D6    206A03        4671     JB FLAGS2 . 2 , COMM61_DAMP 
10D9    0210FE        4672     	JMP	COMM61_NONDAMP
                      4673     COMM61_DAMP: 
                      4674     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4677     IF DAMPED_MODE_ENABLE == 1
10DC    9003A0        4678     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4679     ENDIF
10DF    30651F        4680     JNB FLAGS1 . 5 , COMM61_NFET 
                      4681     	APFET_OFF				
10E2    207502        4681+1   JB FLAGS3 . 5 , ( $+5 ) 
10E5    C296          4681+1   CLR P1 . 6 
10E7    307502        4681+1   JNB FLAGS3 . 5 , ( $+5 ) 
10EA    C292          4681+1   CLR P1 . 2 
                      4682     	CPFET_OFF				
10EC    207502        4682+1   JB FLAGS3 . 5 , ( $+5 ) 
10EF    C292          4682+1   CLR P1 . 2 
10F1    307502        4682+1   JNB FLAGS3 . 5 , ( $+5 ) 
10F4    C296          4682+1   CLR P1 . 6 
10F6    7406          4683     MOV A , # 6 
10F8    D5E0FD        4684     	DJNZ ACC,	$
10FB    021101        4685     	JMP	COMM61_NFET
                      4686     COMM61_NONDAMP: 
10FE    9001F3        4687     	MOV	DPTR, #PWM_CFET_ON
                      4688     COMM61_NFET: 
                      4689     	ANFET_OFF					; An off
1101    207502        4689+1   JB FLAGS3 . 5 , ( $+5 ) 
1104    D297          4689+1   SETB P1 . 7 
1106    307502        4689+1   JNB FLAGS3 . 5 , ( $+5 ) 
1109    D293          4689+1   SETB P1 . 3 
110B    305A0E        4690     JNB FLAGS0 . 2 , COMM61_CP 
                      4691     	CNFET_ON					; Yes - Cn on
110E    E525          4691+1   MOV A , CURRENT_PWM_LIMITED 
1110    600A          4691+1   JZ ( $+12 ) 
1112    207502        4691+1   JB FLAGS3 . 5 , ( $+5 ) 
1115    C293          4691+1   CLR P1 . 3 
1117    307502        4691+1   JNB FLAGS3 . 5 , ( $+5 ) 
111A    C297          4691+1   CLR P1 . 7 
                      4692     COMM61_CP: 
                      4693     	SET_COMP_PHASE_A 			; Set comparator to phase A
111C    207503        4693+1   JB FLAGS3 . 5 , ( $+6 ) 
111F    759F11        4693+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1122    307503        4693+1   JNB FLAGS3 . 5 , ( $+6 ) 
1125    759F13        4693+1   MOV CPT0MX , # 13H 
1128    753E01        4694     	MOV	COMM_PHASE, #1
                      4695     
                      4696     COMM_EXIT: 
112B    D2AF          4697     	SETB	EA					; Enable all interrupts
112D    789C          4698     MOV R0 , # PGM_DEMAG_COMP 
112F    E6            4699     MOV A , @ R0 
1130    C3            4700     	CLR	C
1131    9402          4701     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
1133    4007          4702     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4703     
1135    C3            4704     	CLR	C
1136    E539          4705     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1138    9403          4706     	SUBB	A, #3
113A    5002          4707     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4708     
                      4709     COMM_RESTORE_POWER: 
113C    C25C          4710     CLR FLAGS0 . 4 
                      4711     
                      4712     COMM_RETURN: 
113E    22            4713     	RET
                      4714     
                      4715     
                      4716     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4717     ;
                      4718     ; Switch power off routine
                      4719     ;
                      4720     ; No assumptions
                      4721     ;
                      4722     ; Switches all fets off 
                      4723     ;
                      4724     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4725     SWITCH_POWER_OFF: 
113F    9001CD        4726     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4727     	ALL_NFETS_OFF			; Turn off all nfets
1142    D297          4727+1   SETB P1 . 7 
1144    D295          4727+1   SETB P1 . 5 
1146    D293          4727+1   SETB P1 . 3 
                      4728     	ALL_PFETS_OFF			; Turn off all pfets
1148    C296          4728+1   CLR P1 . 6 
114A    C294          4728+1   CLR P1 . 4 
114C    C292          4728+1   CLR P1 . 2 
114E    C25A          4729     CLR FLAGS0 . 2 
1150    22            4730     	RET			
                      4731     
                      4732     
                      4733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4734     ;
                      4735     ; Decrement stepper step routine
                      4736     ;
                      4737     ; No assumptions
                      4738     ;
                      4739     ; Decrements the stepper step 
                      4740     ;
                      4741     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4742     DECREMENT_STEPPER_STEP: 
1151    C3            4743     	CLR	C
1152    E550          4744     	MOV	A, WT_STEPPER_STEP_L
1154    9535          4745     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1156    E551          4746     	MOV	A, WT_STEPPER_STEP_H
1158    9536          4747     	SUBB	A, STEPPER_STEP_END_H	
115A    5001          4748     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
115C    22            4749     	RET
                      4750     
                      4751     DECREMENT_STEP: 
                      4752     	; Load programmed startup acceleration
115D    7890          4753     MOV R0 , # PGM_STARTUP_ACCEL 
115F    E6            4754     MOV A , @ R0 
1160    FF            4755     MOV R7 , A 
                      4756     	; Check acceleration setting and set step size accordingly
1161    C3            4757     	CLR	C
1162    EF            4758     MOV A , R7 
1163    9405          4759     	SUBB	A, #5
1165    5018          4760     	JNC	DEC_STEP_HIGH
1167    C3            4761     	CLR	C
1168    EF            4762     MOV A , R7 
1169    9404          4763     	SUBB	A, #4
116B    501B          4764     	JNC	DEC_STEP_MED_HIGH
116D    C3            4765     	CLR	C
116E    EF            4766     MOV A , R7 
116F    9403          4767     	SUBB	A, #3
1171    501E          4768     	JNC	DEC_STEP_MED
1173    C3            4769     	CLR	C
1174    EF            4770     MOV A , R7 
1175    9402          4771     	SUBB	A, #2
1177    5021          4772     	JNC	DEC_STEP_MED_LOW
1179    C3            4773     	CLR	C
117A    EF            4774     MOV A , R7 
117B    9401          4775     	SUBB	A, #1
117D    5024          4776     	JNC	DEC_STEP_LOW
                      4777     
                      4778     DEC_STEP_HIGH: 
117F    C3            4779     	CLR	C
1180    E550          4780     	MOV	A, WT_STEPPER_STEP_L
1182    943C          4781     	SUBB	A, #LOW(30 SHL 1)		
1184    F8            4782     MOV R0 , A 
1185    0211AC        4783     	JMP	DECREMENT_STEP_EXIT
                      4784     DEC_STEP_MED_HIGH: 
1188    C3            4785     	CLR	C
1189    E550          4786     	MOV	A, WT_STEPPER_STEP_L
118B    9428          4787     	SUBB	A, #LOW(20 SHL 1)		
118D    F8            4788     MOV R0 , A 
118E    0211AC        4789     	JMP	DECREMENT_STEP_EXIT
                      4790     DEC_STEP_MED: 
1191    C3            4791     	CLR	C
1192    E550          4792     	MOV	A, WT_STEPPER_STEP_L
1194    941A          4793     	SUBB	A, #LOW(13 SHL 1)		
1196    F8            4794     MOV R0 , A 
1197    0211AC        4795     	JMP	DECREMENT_STEP_EXIT
                      4796     DEC_STEP_MED_LOW: 
119A    C3            4797     	CLR	C
119B    E550          4798     	MOV	A, WT_STEPPER_STEP_L
119D    9412          4799     	SUBB	A, #LOW(9 SHL 1)		
119F    F8            4800     MOV R0 , A 
11A0    0211AC        4801     	JMP	DECREMENT_STEP_EXIT
                      4802     DEC_STEP_LOW: 
11A3    C3            4803     	CLR	C
11A4    E550          4804     	MOV	A, WT_STEPPER_STEP_L
11A6    940A          4805     	SUBB	A, #LOW(5 SHL 1)		
11A8    F8            4806     MOV R0 , A 
11A9    0211AC        4807     	JMP	DECREMENT_STEP_EXIT
                      4808     
                      4809     DECREMENT_STEP_EXIT: 
11AC    E551          4810     	MOV	A, WT_STEPPER_STEP_H
11AE    9400          4811     	SUBB	A, #0		
11B0    F9            4812     MOV R1 , A 
11B1    8850          4813     MOV WT_STEPPER_STEP_L , R0 
11B3    8951          4814     MOV WT_STEPPER_STEP_H , R1 
11B5    22            4815     	RET
                      4816     
                      4817     
                      4818     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4819     ;
                      4820     ; Stepper timer wait
                      4821     ;
                      4822     ; No assumptions
                      4823     ;
                      4824     ; Waits for the stepper step timer to elapse
                      4825     ;
                      4826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4827     STEPPER_TIMER_WAIT: 
11B6    305802        4828     JNB FLAGS0 . 0 , ( $+5 ) 
11B9    21B6          4829     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
11BB    22            4830     	RET
                      4831     
                      4832     
                      4833     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4834     ;
                      4835     ; Set default parameters
                      4836     ;
                      4837     ; No assumptions
                      4838     ;
                      4839     ; Sets default programming parameters
                      4840     ;
                      4841     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4842     SET_DEFAULT_PARAMETERS: 
                      4843     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4904     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4965     IF MODE == 2	; Multi
11BC    7880          4966     MOV R0 , # PGM_GOV_P_GAIN 
11BE    7609          4967     MOV @ R0 , # 9 
11C0    08            4968     INC R0 
11C1    7609          4969     MOV @ R0 , # 9 
11C3    08            4970     INC R0 
11C4    7604          4971     MOV @ R0 , # 4 
11C6    08            4972     INC R0 
11C7    7601          4973     MOV @ R0 , # 1 
11C9    08            4974     INC R0 
11CA    7603          4975     MOV @ R0 , # 3 
11CC    08            4976     INC R0 
11CD    76FF          4977     MOV @ R0 , # 0XFF 
11CF    08            4978     INC R0 
11D0    7609          4979     MOV @ R0 , # 9 
11D2    08            4980     INC R0 
11D3    7601          4981     MOV @ R0 , # 1 
11D5    08            4982     INC R0 
11D6    7601          4983     MOV @ R0 , # 1 
11D8    08            4984     INC R0 
11D9    7601          4985     MOV @ R0 , # 1 
                      4986     
11DB    788C          4987     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
11DD    7600          4988     MOV @ R0 , # 0 
11DF    08            4989     INC R0 
11E0    76FF          4990     MOV @ R0 , # 0XFF 
11E2    08            4991     INC R0 
11E3    76FF          4992     MOV @ R0 , # 0XFF 
11E5    08            4993     INC R0 
11E6    7601          4994     MOV @ R0 , # 1 
11E8    08            4995     INC R0 
11E9    7605          4996     MOV @ R0 , # 5 
11EB    08            4997     INC R0 
11EC    76FF          4998     MOV @ R0 , # 0XFF 
11EE    08            4999     INC R0 
11EF    7603          5000     MOV @ R0 , # 3 
11F1    08            5001     INC R0 
11F2    7606          5002     MOV @ R0 , # 6 
11F4    08            5003     INC R0 
11F5    76FF          5004     MOV @ R0 , # 0XFF 
11F7    08            5005     INC R0 
11F8    7602          5006     MOV @ R0 , # 2 
11FA    08            5007     INC R0 
11FB    7603          5008     MOV @ R0 , # 3 
11FD    08            5009     INC R0 
11FE    76FA          5010     MOV @ R0 , # 250 
1200    08            5011     INC R0 
1201    7614          5012     MOV @ R0 , # 20 
1203    08            5013     INC R0 
1204    7614          5014     MOV @ R0 , # 20 
1206    08            5015     INC R0 
1207    7605          5016     MOV @ R0 , # 5 
1209    08            5017     INC R0 
120A    7601          5018     MOV @ R0 , # 1 
120C    08            5019     INC R0 
120D    7602          5020     MOV @ R0 , # 2 
120F    08            5021     INC R0 
1210    7600          5022     MOV @ R0 , # 0 
1212    08            5023     INC R0 
1213    767D          5024     MOV @ R0 , # 125 
                      5025     ENDIF
                      5026     
                      5027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5028     ;
                      5029     ; 初始化变量 
                      5030     ; Skypup 2015.05.25
1215    757400        5031     	MOV	PREV_RCP,	#0
1218    757600        5032     	MOV	NHOLD_L,	#0
121B    757700        5033     	MOV	NHOLD_H,	#0
121E    757800        5034     MOV CSTATE , # 0 
                      5035     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1221    22            5036     	RET
                      5037     
                      5038     
                      5039     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5040     ;
                      5041     ; Decode parameters
                      5042     ;
                      5043     ; No assumptions
                      5044     ;
                      5045     ; Decodes programming parameters
                      5046     ;
                      5047     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5048     DECODE_PARAMETERS: 
                      5049     	; Load programmed damping force
1222    7893          5050     MOV R0 , # PGM_DAMPING_FORCE 
1224    E6            5051     MOV A , @ R0 
1225    FF            5052     MOV R7 , A 
                      5053     	; Decode damping
1226    756609        5054     	MOV	DAMPING_PERIOD, #9		; Set default
1229    756701        5055     	MOV	DAMPING_ON, #1
122C    C3            5056     	CLR	C
122D    BF0206        5057     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5058     
1230    756605        5059     	MOV	DAMPING_PERIOD, #5
1233    756701        5060     	MOV	DAMPING_ON, #1
                      5061     
                      5062     DECODE_DAMPING_3: 
1236    C3            5063     	CLR	C
1237    BF0306        5064     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5065     
123A    756605        5066     	MOV	DAMPING_PERIOD, #5
123D    756702        5067     	MOV	DAMPING_ON, #2
                      5068     
                      5069     DECODE_DAMPING_4: 
1240    C3            5070     	CLR	C
1241    BF0406        5071     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5072     
1244    756605        5073     	MOV	DAMPING_PERIOD, #5
1247    756703        5074     	MOV	DAMPING_ON, #3
                      5075     
                      5076     DECODE_DAMPING_5: 
124A    C3            5077     	CLR	C
124B    BF0506        5078     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5079     
124E    756609        5080     	MOV	DAMPING_PERIOD, #9
1251    756707        5081     	MOV	DAMPING_ON, #7
                      5082     
                      5083     DECODE_DAMPING_6: 
1254    C3            5084     	CLR	C
1255    BF0606        5085     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5086     
1258    756600        5087     	MOV	DAMPING_PERIOD, #0
125B    756700        5088     	MOV	DAMPING_ON, #0
                      5089     
                      5090     DECODE_DAMPING_DONE: 
                      5091     	; Load programmed pwm frequency
125E    7887          5092     MOV R0 , # PGM_PWM_FREQ 
1260    E6            5093     MOV A , @ R0 
1261    FF            5094     MOV R7 , A 
                      5095     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5102     IF MODE >= 1	; Tail or multi
1262    C26C          5103     CLR FLAGS2 . 4 
1264    C3            5104     	CLR	C
1265    BF0302        5105     CJNE R7 , # 3 , ( $+5 ) 
1268    D26C          5106     SETB FLAGS2 . 4 
126A    C26B          5107     CLR FLAGS2 . 3 
126C    C3            5108     	CLR	C
126D    BF0402        5109     CJNE R7 , # 4 , ( $+5 ) 
1270    D26B          5110     SETB FLAGS2 . 3 
                      5111     ENDIF
1272    C26A          5112     CLR FLAGS2 . 2 
1274    7418          5113     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
1276    552D          5114     	ANL	A, FLAGS2					; Check if any damped mode is set
1278    6002          5115     	JZ	($+4)
127A    D26A          5116     SETB FLAGS2 . 2 
127C    C265          5117     CLR FLAGS1 . 5 
127E    6002          5118     	JZ	($+4)
1280    D265          5119     SETB FLAGS1 . 5 
1282    D266          5120     SETB FLAGS1 . 6 
1284    6002          5121     	JZ	($+4)
1286    C266          5122     CLR FLAGS1 . 6 
                      5123     	; Load programmed direction
1288    7888          5124     MOV R0 , # PGM_DIRECTION 
                      5125     IF MODE >= 1	; Tail or multi
128A    E6            5126     MOV A , @ R0 
128B    C3            5127     	CLR	C
128C    9403          5128     	SUBB	A, #3
128E    6008          5129     	JZ	DECODE_PARAMS_DIR_SET
                      5130     ENDIF
                      5131     
1290    C275          5132     CLR FLAGS3 . 5 
1292    E6            5133     MOV A , @ R0 
1293    30E102        5134     	JNB	ACC.1, ($+5)
1296    D275          5135     SETB FLAGS3 . 5 
                      5136     DECODE_PARAMS_DIR_SET: 
1298    C276          5137     CLR FLAGS3 . 6 
129A    7889          5138     MOV R0 , # PGM_INPUT_POL 
129C    E6            5139     MOV A , @ R0 
129D    30E102        5140     	JNB	ACC.1, ($+5)
12A0    D276          5141     SETB FLAGS3 . 6 
12A2    C3            5142     	CLR	C
12A3    EF            5143     MOV A , R7 
12A4    9402          5144     	SUBB	A, #2
12A6    6008          5145     	JZ	DECODE_PWM_FREQ_LOW
                      5146     
12A8    758E01        5147     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
12AB    D26D          5148     SETB FLAGS2 . 5 
12AD    0212B5        5149     	JMP	DECODE_PWM_FREQ_END
                      5150     
                      5151     DECODE_PWM_FREQ_LOW: 
12B0    758E00        5152     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
12B3    C26D          5153     CLR FLAGS2 . 5 
                      5154     
                      5155     DECODE_PWM_FREQ_END: 
12B5    22            5156     	RET
                      5157     
                      5158     
                      5159     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5160     ;
                      5161     ; Decode governor gain
                      5162     ;
                      5163     ; No assumptions
                      5164     ;
                      5165     ; Decodes governor gains
                      5166     ;
                      5167     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5168     DECODE_GOVERNOR_GAINS: 
                      5169     	; Decode governor gains
12B6    7880          5170     MOV R0 , # PGM_GOV_P_GAIN 
12B8    E6            5171     MOV A , @ R0 
12B9    14            5172     	DEC	A	
12BA    900080        5173     	MOV	DPTR, #GOV_GAIN_TABLE
12BD    93            5174     	MOVC A, @A+DPTR	
12BE    789F          5175     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
12C0    F6            5176     MOV @ R0 , A 
12C1    7881          5177     MOV R0 , # PGM_GOV_I_GAIN 
12C3    E6            5178     MOV A , @ R0 
12C4    14            5179     	DEC	A	
12C5    900080        5180     	MOV	DPTR, #GOV_GAIN_TABLE
12C8    93            5181     	MOVC A, @A+DPTR	
12C9    78A0          5182     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
12CB    F6            5183     MOV @ R0 , A 
12CC    313F          5184     	CALL	SWITCH_POWER_OFF		; Reset DPTR
12CE    22            5185     	RET
                      5186     
                      5187     
                      5188     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5189     ;
                      5190     ; Decode throttle rate
                      5191     ;
                      5192     ; No assumptions
                      5193     ;
                      5194     ; Decodes throttle rate
                      5195     ;
                      5196     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5197     DECODE_THROTTLE_RATE: 
                      5198     	; Decode throttle rate
12CF    789B          5199     MOV R0 , # PGM_THROTTLE_RATE 
12D1    E6            5200     MOV A , @ R0 
12D2    14            5201     	DEC	A	
12D3    90008D        5202     	MOV	DPTR, #THROTTLE_RATE_TABLE
12D6    93            5203     	MOVC A, @A+DPTR	
12D7    78A1          5204     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
12D9    F6            5205     MOV @ R0 , A 
12DA    313F          5206     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12DC    22            5207     	RET
                      5208     
                      5209     
                      5210     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5211     ;
                      5212     ; Decode startup power
                      5213     ;
                      5214     ; No assumptions
                      5215     ;
                      5216     ; Decodes startup power
                      5217     ;
                      5218     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5219     DECODE_STARTUP_POWER: 
                      5220     	; Decode startup power
12DD    7886          5221     MOV R0 , # PGM_STARTUP_PWR 
12DF    E6            5222     MOV A , @ R0 
12E0    14            5223     	DEC	A	
12E1    90009A        5224     	MOV	DPTR, #STARTUP_POWER_TABLE
12E4    93            5225     	MOVC A, @A+DPTR	
12E5    78A2          5226     MOV R0 , # PGM_STARTUP_PWR_DECODED 
12E7    F6            5227     MOV @ R0 , A 
12E8    313F          5228     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12EA    22            5229     	RET
                      5230     
                      5231     
                      5232     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5233     ;
                      5234     ; Decode demag compensation
                      5235     ;
                      5236     ; No assumptions
                      5237     ;
                      5238     ; Decodes throttle rate
                      5239     ;
                      5240     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5241     DECODE_DEMAG_COMP: 
                      5242     	; Decode demag compensation
12EB    789C          5243     MOV R0 , # PGM_DEMAG_COMP 
12ED    E6            5244     MOV A , @ R0 
12EE    14            5245     	DEC	A	
12EF    9000A7        5246     	MOV	DPTR, #DEMAG_POWER_TABLE
12F2    93            5247     	MOVC A, @A+DPTR	
12F3    78A3          5248     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
12F5    F6            5249     MOV @ R0 , A 
12F6    313F          5250     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12F8    22            5251     	RET
                      5252     
                      5253     
                      5254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5255     ;
                      5256     ; Set BEC voltage
                      5257     ;
                      5258     ; No assumptions
                      5259     ;
                      5260     ; Sets the BEC output voltage low or high
                      5261     ;
                      5262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5263     SET_BEC_VOLTAGE: 
                      5264     	; Set bec voltage
                      5265     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
12F9    22            5275     	RET
                      5276     
                      5277     
                      5278     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5279     ;
                      5280     ; Find throttle gain
                      5281     ;
                      5282     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5283     ;
                      5284     ; Finds throttle gain from throttle calibration values
                      5285     ;
                      5286     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5287     FIND_THROTTLE_GAIN: 
                      5288     	; Load programmed minimum and maximum throttle
12FA    7896          5289     MOV R0 , # PGM_PPM_MIN_THROTTLE 
12FC    E6            5290     MOV A , @ R0 
12FD    FA            5291     MOV R2 , A 
12FE    7897          5292     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1300    E6            5293     MOV A , @ R0 
1301    FB            5294     MOV R3 , A 
                      5295     	; Check if full range is chosen
1302    307704        5296     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5297     
1305    7A00          5298     MOV R2 , # 0 
1307    7BFF          5299     MOV R3 , # 255 
                      5300     
                      5301     FIND_THROTTLE_GAIN_CALCULATE: 
                      5302     	; Calculate difference
1309    C3            5303     	CLR	C
130A    EB            5304     MOV A , R3 
130B    9A            5305     SUBB A , R2 
130C    FC            5306     MOV R4 , A 
                      5307     	; Check that difference is minimum 130
130D    C3            5308     	CLR	C
130E    9482          5309     	SUBB	A, #130
1310    5002          5310     	JNC	($+4)
                      5311     
1312    7C82          5312     MOV R4 , # 130 
                      5313     
                      5314     	; Find gain
1314    756E00        5315     	MOV	PPM_THROTTLE_GAIN, #0
                      5316     TEST_THROTTLE_GAIN: 
1317    056E          5317     	INC	PPM_THROTTLE_GAIN
1319    EC            5318     MOV A , R4 
131A    856EF0        5319     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
131D    A4            5320     	MUL	AB
131E    C3            5321     	CLR	C
131F    E5F0          5322     	MOV	A, B
1321    9480          5323     	SUBB	A, #128
1323    40F2          5324     	JC	TEST_THROTTLE_GAIN
1325    22            5325     	RET
                      5326     
                      5327     
                      5328     
                      5329     
                      5330     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5331     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5332     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5333     ;
                      5334     ; Main program start
                      5335     ;
                      5336     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5337     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5338     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5339     
                      5340     RESET: 
                      5341     	; Check flash lock byte
1326    E5EF          5342     	MOV	A, RSTSRC			
1328    20E603        5343     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5344     
132B    752000        5345     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5346     
132E    0520          5347     	INC	BIT_ACCESS
1330    903FFF        5348     MOV DPTR , # 16383 
1333    E520          5349     	MOV	A, BIT_ACCESS
1335    14            5350     	DEC	A
1336    6006          5351     	JZ	LOCK_BYTE_TEST
                      5352     
1338    901DFF        5353     MOV DPTR , # 7679 
133B    14            5354     	DEC	A
133C    6000          5355     	JZ	LOCK_BYTE_TEST
                      5356     
                      5357     LOCK_BYTE_TEST: 
133E    93            5358     	MOVC A, @A+DPTR		; Read lock byte
133F    04            5359     	INC	A				
1340    6003          5360     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5361     
                      5362     IF ONE_S_CAPABLE == 0		
1342    75EF12        5363     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5364     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5367     
                      5368     LOCK_BYTE_OK: 
                      5369     	; Select register bank 0 for main program routines
1345    C2D3          5370     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5371     	; Disable the WDT.
1347    53D9BF        5372     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5373     	; Initialize stack
134A    7581C0        5374     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5375     	; Initialize VDD monitor
134D    43FF80        5376     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1350    12083E        5377     	CALL	WAIT1MS			; Wait at least 100us
                      5378     IF ONE_S_CAPABLE == 0		
1353    75EF02        5379     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5380     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5383     	; Set clock frequency
1356    43B203        5384     	ORL	OSCICN, #03H		; Set clock divider to 1
1359    E5B3          5385     	MOV	A, OSCICL				
135B    2404          5386     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
135D    4002          5387     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5388     
135F    F5B3          5389     	MOV	OSCICL, A
                      5390     
                      5391     RESET_CAL_DONE: 
                      5392     	; Switch power off
1361    313F          5393     	CALL	SWITCH_POWER_OFF
                      5394     	; Ports initialization
1363    7580FF        5395     MOV P0 , # 255 
1366    75A400        5396     MOV P0MDOUT , # 0 
1369    75F1B2        5397     MOV P0MDIN , # -78 
136C    75D4DF        5398     MOV P0SKIP , # 223 
136F    7590A9        5399     MOV P1 , # 169 
1372    75A5FC        5400     MOV P1MDOUT , # 252 
1375    75F2FC        5401     MOV P1MDIN , # 252 
1378    75D501        5402     MOV P1SKIP , # 1 
                      5403     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
137B    75A601        5406     MOV P2MDOUT , # 1 
                      5407     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5414     	; Initialize the XBAR and related functionality
                      5415     	INITIALIZE_XBAR		
137E    75E241        5415+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5416     	; Clear RAM
1381    E4            5417     	CLR	A				; Clear accumulator
1382    F8            5418     MOV R0 , A 
                      5419     CLEAR_RAM: 	
1383    F6            5420     MOV @ R0 , A 
1384    D8FD          5421     DJNZ R0 , CLEAR_RAM 
                      5422     	; Set default programmed parameters
1386    31BC          5423     	CALL	SET_DEFAULT_PARAMETERS
                      5424     	; Decode parameters
1388    5122          5425     	CALL	DECODE_PARAMETERS
                      5426     	; Decode governor gains
138A    51B6          5427     	CALL	DECODE_GOVERNOR_GAINS
                      5428     	; Decode throttle rate
138C    51CF          5429     	CALL	DECODE_THROTTLE_RATE
                      5430     	; Decode startup power
138E    51DD          5431     	CALL	DECODE_STARTUP_POWER
                      5432     	; Decode demag compensation
1390    51EB          5433     	CALL	DECODE_DEMAG_COMP
                      5434     	; Set BEC voltage
1392    51F9          5435     	CALL	SET_BEC_VOLTAGE
                      5436     	; Find throttle gain from stored min and max settings
1394    51FA          5437     	CALL	FIND_THROTTLE_GAIN
                      5438     	; Set beep strength
1396    7898          5439     MOV R0 , # PGM_BEEP_STRENGTH 
1398    866F          5440     MOV BEEP_STRENGTH , @ R0 
                      5441     	; Switch power off
139A    313F          5442     	CALL	SWITCH_POWER_OFF
                      5443     	; Timer control
139C    758850        5444     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5445     	; Timer mode
139F    758902        5446     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5447     	; Timer2: clk/12 for 128us and 32ms interrupts
13A2    75C824        5448     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5449     	; Timer3: clk/12 for commutation timing
13A5    759104        5450     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5451     	; PCA
13A8    75D840        5452     	MOV	PCA0CN, #40H		; PCA enabled
                      5453     	; Initializing beep
13AB    C2AF          5454     	CLR	EA				; Disable interrupts explicitly
13AD    120857        5455     	CALL WAIT200MS	
13B0    12086E        5456     	CALL BEEP_F1
13B3    120848        5457     	CALL WAIT10MS
13B6    120875        5458     	CALL BEEP_F2
13B9    120848        5459     	CALL WAIT10MS
13BC    12087C        5460     	CALL BEEP_F3
13BF    120848        5461     	CALL WAIT10MS
13C2    120883        5462     	CALL BEEP_F4
13C5    120848        5463     	CALL WAIT10MS
                      5464     
                      5465     	; Wait for receiver to initialize
13C8    120867        5466     	CALL	WAIT1S
13CB    120857        5467     	CALL	WAIT200MS
13CE    120857        5468     	CALL	WAIT200MS
13D1    120852        5469     	CALL	WAIT100MS
                      5470     
                      5471     
                      5472     	; Enable interrupts
13D4    75A822        5473     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
13D7    75B802        5474     	MOV	IP, #02H			; High priority to timer0 interrupts
13DA    75E690        5475     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5476     	; Initialize comparator
13DD    759B80        5477     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
13E0    759D03        5478     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5479     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5483     	; Initialize ADC
                      5484     	INITIALIZE_ADC			; Initialize ADC operation
13E3    75D10E        5484+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
13E6    75BC58        5484+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
13E9    75BB08        5484+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
13EC    75BA11        5484+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
13EF    75E880        5484+1   MOV ADC0CN , # 80H  ; ADC ENABLED
13F2    12083E        5485     	CALL	WAIT1MS
13F5    D2AF          5486     	SETB	EA				; Enable all interrupts
                      5487     
                      5488     	; Measure number of lipo cells
13F7    120B26        5489     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5490     	; Initialize rc pulse
                      5491     	RCP_INT_ENABLE		 			; Enable interrupt
13FA    43DA01        5491+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5492     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
13FD    C2D8          5492+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
13FF    C269          5493     CLR FLAGS2 . 1 
1401    120857        5494     	CALL WAIT200MS
                      5495     	; Set initial arm variable
1404    753001        5496     	MOV	INITIAL_ARM, #1
1407    757301        5497     	MOV	FLAG_BEFORE_ARM, #1
                      5498     
                      5499     	; Measure PWM frequency
                      5500     MEASURE_PWM_FREQ_INIT: 	
140A    D259          5501     SETB FLAGS0 . 1 
                      5502     MEASURE_PWM_FREQ_START: 	
140C    7A05          5503     MOV R2 , # 5 
                      5504     MEASURE_PWM_FREQ_LOOP: 	
                      5505     	; Check if period diff was accepted
140E    E558          5506     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1410    7002          5507     	JNZ	($+4)
                      5508     
1412    7A05          5509     MOV R2 , # 5 
                      5510     
1414    120843        5511     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1417    E559          5512     	MOV	A, NEW_RCP					; Load value
1419    C3            5513     	CLR	C
141A    9402          5514     SUBB A , # 2 
141C    40EE          5515     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5516     
141E    E52E          5517     	MOV	A, FLAGS3						; Check pwm frequency flags
1420    541F          5518     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1422    855B5A        5519     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1425    F55B          5520     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1427    B55AE2        5521     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5522     
142A    DAE2          5523     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5524     
                      5525     	; Clear measure pwm frequency flag
142C    C259          5526     CLR FLAGS0 . 1 
                      5527     	; Set up RC pulse interrupts after pwm frequency measurement
                      5528     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
142E    53DACF        5528+1   ANL PCA0CPM0 , # 0CFH 
1431    207603        5528+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1434    43DA20        5528+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1437    307603        5528+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
143A    43DA10        5528+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5529     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
143D    C2D8          5529+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
143F    C269          5530     CLR FLAGS2 . 1 
1441    120852        5531     	CALL WAIT100MS						; Wait for new RC pulse
                      5532     
                      5533     	; Validate RC pulse
                      5534     VALIDATE_RCP_START: 	
1444    120843        5535     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1447    7802          5536     MOV R0 , # 2 
1449    741F          5537     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
144B    552E          5538     	ANL	A, FLAGS3						; Check pwm frequency flags
144D    7002          5539     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5540     
144F    7800          5541     MOV R0 , # 0 
                      5542     
1451    C3            5543     	CLR	C
1452    E559          5544     	MOV	A, NEW_RCP					; Load value
1454    98            5545     SUBB A , R0 
1455    40ED          5546     	JC	VALIDATE_RCP_START				; No - start over
                      5547     
                      5548     	; Beep arm sequence start signal
1457    C2AF          5549     	CLR 	EA							; Disable all interrupts
1459    12086E        5550     	CALL BEEP_F1
145C    120848        5551     	CALL WAIT10MS
145F    12086E        5552     	CALL BEEP_F1
1462    120848        5553     	CALL WAIT10MS
1465    120875        5554     	CALL BEEP_F2
1468    120848        5555     	CALL WAIT10MS
146B    120875        5556     	CALL BEEP_F2
146E    120848        5557     	CALL WAIT10MS
1471    D2AF          5558     	SETB	EA							; Enable all interrupts
1473    120857        5559     	CALL WAIT200MS	
                      5560     
1476    757300        5561     	MOV	FLAG_BEFORE_ARM, #0		; 为了让定制的程序输出最低油门. Skypup 2015.05.26
                      5562     
                      5563     	; Arming sequence start
1479    754800        5564     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5565     ARMING_START: 
147C    C3            5566     	CLR	C
147D    E559          5567     	MOV	A, NEW_RCP			; Load new RC pulse value
147F    9548          5568     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1481    4003          5569     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5570     
1483    855948        5571     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5572     
                      5573     ARM_TARGET_UPDATED: 
1486    120852        5574     	CALL WAIT100MS				; Wait for new throttle value
1489    C3            5575     	CLR	C
148A    E559          5576     	MOV	A, NEW_RCP			; Load new RC pulse value
148C    9401          5577     SUBB A , # 1 
148E    4002          5578     	JC	ARM_END_BEEP			; Yes - proceed
                      5579     
1490    80EA          5580     	JMP	ARMING_START			; No - start over
                      5581     
                      5582     ARM_END_BEEP: 
                      5583     	; Beep arm sequence end signal
1492    C2AF          5584     	CLR 	EA					; Disable all interrupts
1494    120883        5585     	CALL BEEP_F4
1497    120848        5586     	CALL WAIT10MS
149A    120883        5587     	CALL BEEP_F4
149D    120848        5588     	CALL WAIT10MS
14A0    12087C        5589     	CALL BEEP_F3
14A3    120848        5590     	CALL WAIT10MS
14A6    12087C        5591     	CALL BEEP_F3
14A9    120848        5592     	CALL WAIT10MS
14AC    D2AF          5593     	SETB	EA					; Enable all interrupts
14AE    120857        5594     	CALL WAIT200MS
                      5595     
                      5596     	; Clear initial arm variable
14B1    753000        5597     	MOV	INITIAL_ARM, #0
                      5598     
                      5599     	; Armed and waiting for power on
                      5600     WAIT_FOR_POWER_ON: 
14B4    E4            5601     	CLR	A
14B5    F531          5602     	MOV	POWER_ON_WAIT_CNT_L, A	; 清零
14B7    F532          5603     	MOV	POWER_ON_WAIT_CNT_H, A	; 清零
                      5604     WAIT_FOR_POWER_ON_LOOP: 
14B9    0531          5605     	INC	POWER_ON_WAIT_CNT_L		; 低位 ++
14BB    E531          5606     	MOV	A, POWER_ON_WAIT_CNT_L
14BD    F4            5607     	CPL	A					; 取反
14BE    7039          5608     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Power_On_Wait_Cnt_L 不是 0xFF 则跳转, 进入下一个循环, Counter wrapping (about 1 sec)?
                      5609     
14C0    0532          5610     	INC	POWER_ON_WAIT_CNT_H		; Power_On_Wait_Cnt_L == 0xFF, 高位 ++
14C2    789A          5611     MOV R0 , # PGM_BEACON_DELAY 
14C4    E6            5612     MOV A , @ R0 
14C5    7819          5613     MOV R0 , # 25 
14C7    14            5614     	DEC	A
14C8    6012          5615     	JZ	BEEP_DELAY_SET
                      5616     
14CA    7832          5617     MOV R0 , # 50 
14CC    14            5618     	DEC	A
14CD    600D          5619     	JZ	BEEP_DELAY_SET
                      5620     
14CF    787D          5621     MOV R0 , # 125 
14D1    14            5622     	DEC	A
14D2    6008          5623     	JZ	BEEP_DELAY_SET
                      5624     
14D4    78FA          5625     MOV R0 , # 250 
14D6    14            5626     	DEC	A
14D7    6003          5627     	JZ	BEEP_DELAY_SET
                      5628     
14D9    753200        5629     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5630     
                      5631     BEEP_DELAY_SET: 
14DC    C3            5632     	CLR	C
14DD    E532          5633     	MOV	A, POWER_ON_WAIT_CNT_H
14DF    98            5634     SUBB A , R0 
14E0    4017          5635     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5636     
14E2    1532          5637     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14E4    7531B4        5638     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14E7    7899          5639     MOV R0 , # PGM_BEACON_STRENGTH 
14E9    866F          5640     MOV BEEP_STRENGTH , @ R0 
14EB    C2AF          5641     	CLR 	EA					; Disable all interrupts
14ED    120883        5642     	CALL BEEP_F4				; Signal that there is no signal
14F0    D2AF          5643     	SETB	EA					; Enable all interrupts
14F2    7898          5644     MOV R0 , # PGM_BEEP_STRENGTH 
14F4    866F          5645     MOV BEEP_STRENGTH , @ R0 
14F6    120852        5646     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5647     
                      5648     WAIT_FOR_POWER_ON_NO_BEEP: 
14F9    120848        5649     	CALL WAIT10MS
14FC    E528          5650     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14FE    7008          5651     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5652     
1500    741F          5653     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1502    552E          5654     	ANL	A, FLAGS3						; Check pwm frequency flags
1504    7002          5655     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5656     
1506    810A          5657     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5658     
                      5659     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1508    C3            5660     	CLR	C
1509    E559          5661     	MOV	A, NEW_RCP			; Load new RC pulse value
150B    9406          5662     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
150D    40AA          5663     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5664     
                      5665     IF MODE >= 1	; Tail or multi
150F    7888          5666     MOV R0 , # PGM_DIRECTION 
1511    E6            5667     MOV A , @ R0 
1512    C3            5668     	CLR	C
1513    9403          5669     	SUBB	A, #3
1515    6003          5670     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5671     ENDIF
                      5672     
1517    120852        5673     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5674     
151A    E528          5675     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
151C    7003          5676     	JNZ	($+5)				; If it is not zero - proceed
                      5677     
151E    02140A        5678     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5679     
                      5680     
                      5681     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5682     ;
                      5683     ; Start entry point
                      5684     ;
                      5685     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5686     INIT_START: 
1521    C2AF          5687     	CLR	EA
1523    313F          5688     	CALL SWITCH_POWER_OFF
1525    E4            5689     	CLR	A
1526    F522          5690     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1528    F523          5691     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
152A    F524          5692     	MOV	CURRENT_PWM, A			; Set current pwm to zero
152C    F525          5693     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
152E    D2AF          5694     	SETB	EA
1530    7885          5695     MOV R0 , # PGM_MOTOR_IDLE 
1532    8661          5696     MOV PWM_MOTOR_IDLE , @ R0 
1534    F540          5697     	MOV	GOV_TARGET_L, A		; Set target to zero
1536    F541          5698     	MOV	GOV_TARGET_H, A
1538    F542          5699     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
153A    F543          5700     	MOV	GOV_INTEGRAL_H, A
153C    F544          5701     	MOV	GOV_INTEGRAL_X, A
153E    F56C          5702     	MOV	ADC_CONVERSION_CNT, A
1540    F549          5703     	MOV	GOV_ACTIVE, A
1542    F52B          5704     	MOV	FLAGS0, A				; Clear flags0
1544    F52C          5705     	MOV	FLAGS1, A				; Clear flags1
1546    F539          5706     	MOV	DEMAG_CONSECUTIVE_CNT, A
1548    120CA3        5707     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5708     	;**** **** **** **** ****
                      5709     	; Motor start beginning
                      5710     	;**** **** **** **** **** 
154B    756C08        5711     MOV ADC_CONVERSION_CNT , # 8 
                      5712     	SET_ADC_IP_TEMP
154E    75BB10        5712+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1551    12083E        5713     	CALL WAIT1MS
1554    120BC0        5714     	CALL START_ADC_CONVERSION
                      5715     READ_INITIAL_TEMP: 
                      5716     	GET_ADC_STATUS 
1557    E5E8          5716+1   MOV A , ADC0CN 
1559    20ECFB        5717     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5718     	READ_ADC_RESULT						; Read initial temperature
155C    A8BD          5718+1   MOV R0 , ADC0L 
155E    A9BE          5718+1   MOV R1 , ADC0H 
1560    E9            5719     MOV A , R1 
1561    7001          5720     	JNZ	($+3)							; Is reading below 256?
                      5721     
1563    F8            5722     MOV R0 , A 
                      5723     
1564    886D          5724     MOV CURRENT_AVERAGE_TEMP , R0 
1566    120BC4        5725     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1569    756C08        5726     MOV ADC_CONVERSION_CNT , # 8 
                      5727     	SET_ADC_IP_TEMP
156C    75BB10        5727+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5728     
                      5729     	; Go to the desired startup mode
156F    7895          5730     MOV R0 , # PGM_STARTUP_METHOD 
1571    E6            5731     MOV A , @ R0 
1572    30E003        5732     	JNB	ACC.0, DIRECT_METHOD_START
                      5733     
1575    0215B8        5734     	JMP	STEPPER_METHOD_START
                      5735     
                      5736     DIRECT_METHOD_START: 
                      5737     	; Set up start operating conditions
1578    7887          5738     MOV R0 , # PGM_PWM_FREQ 
157A    E6            5739     MOV A , @ R0 
157B    FE            5740     MOV R6 , A 
157C    7602          5741     MOV @ R0 , # 2 
157E    5122          5742     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1580    7887          5743     MOV R0 , # PGM_PWM_FREQ 
1582    EE            5744     MOV A , R6 
1583    F6            5745     MOV @ R0 , A 
                      5746     	; Set max allowed power
1584    D261          5747     SETB FLAGS1 . 1 
1586    C2AF          5748     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1588    755EFF        5749     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
158B    120C73        5750     	CALL SET_STARTUP_PWM
158E    85225E        5751     	MOV	PWM_LIMIT, REQUESTED_PWM
1591    85225F        5752     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1594    D2AF          5753     	SETB	EA
1596    C261          5754     CLR FLAGS1 . 1 
1598    752501        5755     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
159B    855D64        5756     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
159E    756501        5757     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5758     	; Begin startup sequence
15A1    D260          5759     SETB FLAGS1 . 0 
15A3    D263          5760     SETB FLAGS1 . 3 
15A5    753800        5761     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15A8    1187          5762     	CALL COMM5COMM6				; Initialize commutation
15AA    11D4          5763     	CALL COMM6COMM1				
15AC    120D1D        5764     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
15AF    120CA3        5765     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
15B2    120DA0        5766     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15B5    0216DB        5767     	JMP	RUN1
                      5768     
                      5769     
                      5770     STEPPER_METHOD_START: 
                      5771     	; Set up start operating conditions
15B8    7887          5772     MOV R0 , # PGM_PWM_FREQ 
15BA    E6            5773     MOV A , @ R0 
15BB    FE            5774     MOV R6 , A 
15BC    7603          5775     MOV @ R0 , # 3 
15BE    7893          5776     MOV R0 , # PGM_DAMPING_FORCE 
15C0    E6            5777     MOV A , @ R0 
15C1    FD            5778     MOV R5 , A 
15C2    7605          5779     MOV @ R0 , # 5 
15C4    5122          5780     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15C6    7887          5781     MOV R0 , # PGM_PWM_FREQ 
15C8    EE            5782     MOV A , R6 
15C9    F6            5783     MOV @ R0 , A 
15CA    7893          5784     MOV R0 , # PGM_DAMPING_FORCE 
15CC    ED            5785     MOV A , R5 
15CD    F6            5786     MOV @ R0 , A 
                      5787     	; Begin startup sequence
15CE    D260          5788     SETB FLAGS1 . 0 
15D0    D261          5789     SETB FLAGS1 . 1 
15D2    D265          5790     SETB FLAGS1 . 5 
15D4    1187          5791     	CALL COMM5COMM6			; Initialize commutation
15D6    11D4          5792     	CALL COMM6COMM1			
15D8    755EFF        5793     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15DB    120C73        5794     	CALL SET_STARTUP_PWM
15DE    12083E        5795     	CALL WAIT1MS
15E1    120F4B        5796     	CALL COMM1COMM2
15E4    12083E        5797     	CALL WAIT1MS
15E7    12083E        5798     	CALL WAIT1MS
15EA    120F9F        5799     	CALL COMM2COMM3
15ED    120843        5800     	CALL WAIT3MS			
15F0    120FE9        5801     	CALL COMM3COMM4
15F3    120843        5802     	CALL WAIT3MS			
15F6    120843        5803     	CALL WAIT3MS			
15F9    1146          5804     	CALL COMM4COMM5
15FB    120848        5805     	CALL WAIT10MS				; Settle rotor
15FE    1187          5806     	CALL COMM5COMM6
1600    120843        5807     	CALL WAIT3MS				
1603    12083E        5808     	CALL WAIT1MS			
1606    C261          5809     CLR FLAGS1 . 1 
1608    D262          5810     SETB FLAGS1 . 2 
                      5811     
                      5812     	;**** **** **** **** ****
                      5813     	; Stepper phase beginning
                      5814     	;**** **** **** **** **** 
                      5815     STEPPER_ROT_BEG: 
160A    120BC0        5816     	CALL START_ADC_CONVERSION
160D    120BC4        5817     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1610    120C73        5818     	CALL SET_STARTUP_PWM
1613    756C08        5819     MOV ADC_CONVERSION_CNT , # 8 
                      5820     	SET_ADC_IP_TEMP
1616    75BB10        5820+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5821     
1619    11D4          5822     	CALL COMM6COMM1				; Commutate
161B    120D16        5823     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
161E    120DA0        5824     	CALL CALC_NEW_WAIT_TIMES
1621    3151          5825     	CALL DECREMENT_STEPPER_STEP
1623    31B6          5826     	CALL STEPPER_TIMER_WAIT
                      5827     
1625    120F4B        5828     	CALL COMM1COMM2			
1628    120D16        5829     	CALL CALC_NEXT_COMM_TIMING_START	
162B    120DA0        5830     	CALL CALC_NEW_WAIT_TIMES
162E    3151          5831     	CALL DECREMENT_STEPPER_STEP
1630    31B6          5832     	CALL STEPPER_TIMER_WAIT
                      5833     
1632    120F9F        5834     	CALL COMM2COMM3			
1635    120D16        5835     	CALL CALC_NEXT_COMM_TIMING_START	
1638    120DA0        5836     	CALL CALC_NEW_WAIT_TIMES
163B    3151          5837     	CALL DECREMENT_STEPPER_STEP
163D    31B6          5838     	CALL STEPPER_TIMER_WAIT
                      5839     
163F    120FE9        5840     	CALL COMM3COMM4			
1642    120D16        5841     	CALL CALC_NEXT_COMM_TIMING_START	
1645    120DA0        5842     	CALL CALC_NEW_WAIT_TIMES
1648    3151          5843     	CALL DECREMENT_STEPPER_STEP
164A    31B6          5844     	CALL STEPPER_TIMER_WAIT
                      5845     
164C    1146          5846     	CALL COMM4COMM5			
164E    120D16        5847     	CALL CALC_NEXT_COMM_TIMING_START	
1651    120DA0        5848     	CALL CALC_NEW_WAIT_TIMES
1654    3151          5849     	CALL DECREMENT_STEPPER_STEP
1656    31B6          5850     	CALL STEPPER_TIMER_WAIT
                      5851     
1658    1187          5852     	CALL COMM5COMM6			
165A    120D16        5853     	CALL CALC_NEXT_COMM_TIMING_START	
165D    120DA0        5854     	CALL CALC_NEW_WAIT_TIMES
1660    3151          5855     	CALL DECREMENT_STEPPER_STEP	
                      5856     	; Check stepper step versus end criteria
1662    C3            5857     	CLR	C
1663    E550          5858     	MOV	A, WT_STEPPER_STEP_L
1665    9535          5859     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1667    E551          5860     	MOV	A, WT_STEPPER_STEP_H
1669    9536          5861     	SUBB	A, STEPPER_STEP_END_H
166B    400C          5862     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5863     
                      5864     	; Wait for step
166D    31B6          5865     	CALL STEPPER_TIMER_WAIT
166F    C3            5866     	CLR	C
1670    E559          5867     	MOV	A, NEW_RCP				; Load new pulse value
1672    9401          5868     SUBB A , # 1 
1674    5094          5869     	JNC	STEPPER_ROT_BEG
                      5870     
1676    02180B        5871     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5872     
                      5873     STEPPER_ROT_EXIT: 
                      5874     	; Wait for step
1679    31B6          5875     	CALL STEPPER_TIMER_WAIT
                      5876     	; Clear stepper phase
167B    C262          5877     CLR FLAGS1 . 2 
                      5878     	; Set dondamped low pwm frequency
167D    7887          5879     MOV R0 , # PGM_PWM_FREQ 
167F    E6            5880     MOV A , @ R0 
1680    FE            5881     MOV R6 , A 
1681    7602          5882     MOV @ R0 , # 2 
1683    5122          5883     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1685    7887          5884     MOV R0 , # PGM_PWM_FREQ 
1687    EE            5885     MOV A , R6 
1688    F6            5886     MOV @ R0 , A 
                      5887     	; Set spoolup power variables (power is now controlled from RCP)
1689    85225E        5888     	MOV	PWM_LIMIT, REQUESTED_PWM
168C    85605F        5889     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
168F    856025        5890     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
1692    855D64        5891     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1695    756501        5892     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5893     	; Set direct startup phase to acquire sync quickly
1698    D263          5894     SETB FLAGS1 . 3 
169A    753800        5895     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
169D    C2AF          5896     	CLR	EA						; Disable interrupts
                      5897     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
169F    207502        5897+1   JB FLAGS3 . 5 , ( $+5 ) 
16A2    C296          5897+1   CLR P1 . 6 
16A4    307502        5897+1   JNB FLAGS3 . 5 , ( $+5 ) 
16A7    C292          5897+1   CLR P1 . 2 
                      5898     	CPFET_OFF						; Cp off
16A9    207502        5898+1   JB FLAGS3 . 5 , ( $+5 ) 
16AC    C292          5898+1   CLR P1 . 2 
16AE    307502        5898+1   JNB FLAGS3 . 5 , ( $+5 ) 
16B1    C296          5898+1   CLR P1 . 6 
16B3    742D          5899     	MOV	A, #45					; 8us delay for pfets to go off
16B5    D5E0FD        5900     	DJNZ	ACC, $
16B8    D2AF          5901     	SETB	EA						; Enable interrupts
16BA    11D4          5902     	CALL COMM6COMM1				
16BC    120D1D        5903     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16BF    120D8C        5904     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16C2    120DA0        5905     	CALL CALC_NEW_WAIT_TIMES
16C5    120E31        5906     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16C8    756C00        5907     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5908     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16CB    75BB08        5908+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16CE    0216DB        5909     	JMP	RUN1
                      5910     
                      5911     
                      5912     
                      5913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5914     ;
                      5915     ; Run entry point
                      5916     ;
                      5917     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5918     DAMPED_TRANSITION: 
                      5919     	; Transition from nondamped to damped if applicable
16D1    5122          5920     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16D3    11D4          5921     	CALL	COMM6COMM1
16D5    756C00        5922     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5923     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16D8    75BB08        5923+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5924     
                      5925     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5926     ; Out_cA changes from low to high
                      5927     RUN1: 
16DB    120E53        5928     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16DE    120ED8        5929     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16E1    120F03        5930     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16E4    12096D        5931     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16E7    120F17        5932     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16EA    120F4B        5933     	CALL COMM1COMM2			; Commutate
16ED    120D1D        5934     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
16F0    120D8C        5935     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
16F3    120DA0        5936     	CALL CALC_NEW_WAIT_TIMES
16F6    120E31        5937     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5938     
                      5939     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5940     ; Out_cB changes from high to low
                      5941     RUN2: 
16F9    120E4A        5942     	CALL WAIT_FOR_COMP_OUT_LOW
16FC    120ED8        5943     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16FF    120F03        5944     	CALL SETUP_COMM_WAIT	
1702    1209CA        5945     	CALL CALC_GOVERNOR_PROP_ERROR
1705    120F17        5946     	CALL WAIT_FOR_COMM
1708    120F9F        5947     	CALL COMM2COMM3
170B    120D1D        5948     	CALL CALC_NEXT_COMM_TIMING
170E    120D8C        5949     	CALL WAIT_ADVANCE_TIMING
1711    120DA0        5950     	CALL CALC_NEW_WAIT_TIMES
1714    120E31        5951     	CALL WAIT_BEFORE_ZC_SCAN	
                      5952     
                      5953     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5954     ; Out_cC changes from low to high
                      5955     RUN3: 
1717    120E53        5956     	CALL WAIT_FOR_COMP_OUT_HIGH
171A    120ED8        5957     	CALL	EVALUATE_COMPARATOR_INTEGRITY
171D    120F03        5958     	CALL SETUP_COMM_WAIT	
1720    120A03        5959     	CALL CALC_GOVERNOR_INT_ERROR
1723    120F17        5960     	CALL WAIT_FOR_COMM
1726    120FE9        5961     	CALL COMM3COMM4
1729    120D1D        5962     	CALL CALC_NEXT_COMM_TIMING
172C    120D8C        5963     	CALL WAIT_ADVANCE_TIMING
172F    120DA0        5964     	CALL CALC_NEW_WAIT_TIMES
1732    120E31        5965     	CALL WAIT_BEFORE_ZC_SCAN	
                      5966     
                      5967     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5968     ; Out_cA changes from high to low
                      5969     RUN4: 
1735    120E4A        5970     	CALL WAIT_FOR_COMP_OUT_LOW
1738    120ED8        5971     	CALL	EVALUATE_COMPARATOR_INTEGRITY
173B    120F03        5972     	CALL SETUP_COMM_WAIT	
173E    120A60        5973     	CALL CALC_GOVERNOR_PROP_CORRECTION
1741    120F17        5974     	CALL WAIT_FOR_COMM
1744    1146          5975     	CALL COMM4COMM5
1746    120D1D        5976     	CALL CALC_NEXT_COMM_TIMING
1749    120D8C        5977     	CALL WAIT_ADVANCE_TIMING
174C    120DA0        5978     	CALL CALC_NEW_WAIT_TIMES
174F    120E31        5979     	CALL WAIT_BEFORE_ZC_SCAN	
                      5980     
                      5981     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5982     ; Out_cB changes from low to high
                      5983     RUN5: 
1752    120E53        5984     	CALL WAIT_FOR_COMP_OUT_HIGH
1755    120ED8        5985     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1758    120F03        5986     	CALL SETUP_COMM_WAIT	
175B    120AC4        5987     	CALL CALC_GOVERNOR_INT_CORRECTION
175E    120F17        5988     	CALL WAIT_FOR_COMM
1761    1187          5989     	CALL COMM5COMM6
1763    120D1D        5990     	CALL CALC_NEXT_COMM_TIMING
1766    120D8C        5991     	CALL WAIT_ADVANCE_TIMING
1769    120DA0        5992     	CALL CALC_NEW_WAIT_TIMES
176C    120E31        5993     	CALL WAIT_BEFORE_ZC_SCAN	
                      5994     
                      5995     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5996     ; Out_cC changes from high to low
                      5997     RUN6: 
176F    120E4A        5998     	CALL WAIT_FOR_COMP_OUT_LOW
1772    120BC0        5999     	CALL START_ADC_CONVERSION
1775    120ED8        6000     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1778    120F03        6001     	CALL SETUP_COMM_WAIT	
177B    120BC4        6002     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
177E    120F17        6003     	CALL WAIT_FOR_COMM
1781    11D4          6004     	CALL COMM6COMM1
1783    120D1D        6005     	CALL CALC_NEXT_COMM_TIMING
1786    120D8C        6006     	CALL WAIT_ADVANCE_TIMING
1789    120DA0        6007     	CALL CALC_NEW_WAIT_TIMES
178C    120E31        6008     	CALL WAIT_BEFORE_ZC_SCAN	
                      6009     
                      6010     	; Check if it is direct startup
178F    306342        6011     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6012     
                      6013     	; Set spoolup power variables
1792    85605E        6014     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1795    85605F        6015     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1798    855D64        6016     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
179B    756501        6017     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6018     	; Check startup ok counter
179E    7964          6019     MOV R1 , # 100 
17A0    7A14          6020     MOV R2 , # 20 
                      6021     IF MODE >= 1	; Tail or multi
17A2    7888          6022     MOV R0 , # PGM_DIRECTION 
17A4    E6            6023     MOV A , @ R0 
17A5    B40304        6024     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6025     
17A8    791E          6026     MOV R1 , # 30 
17AA    7A05          6027     MOV R2 , # 5 
                      6028     
                      6029     DIRECT_START_PARAMS_SET: 
                      6030     ENDIF
17AC    C3            6031     	CLR	C
17AD    E538          6032     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
17AF    99            6033     SUBB A , R1 
17B0    4015          6034     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6035     
17B2    C263          6036     CLR FLAGS1 . 3 
17B4    D264          6037     SETB FLAGS1 . 4 
17B6    8A37          6038     MOV STARTUP_ROT_CNT , R2 
                      6039     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6043     IF MODE == 2	; Multi
17B8    7888          6044     MOV R0 , # PGM_DIRECTION 
17BA    E6            6045     MOV A , @ R0 
17BB    B40306        6046     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6047     
17BE    755EFF        6048     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17C1    755FFF        6049     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6050     
                      6051     DIRECT_START_PWM_LIM_SET: 
                      6052     ENDIF
17C4    0217D4        6053     	JMP	NORMAL_RUN_CHECKS
                      6054     
                      6055     DIRECT_START_CHECK_RCP: 
17C7    C3            6056     	CLR	C
17C8    E559          6057     	MOV	A, NEW_RCP				; Load new pulse value
17CA    9401          6058     SUBB A , # 1 
17CC    4003          6059     	JC	($+5)
                      6060     
17CE    0216DB        6061     	LJMP	RUN1						; Continue to run 
                      6062     
17D1    02180B        6063     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6064     
                      6065     
                      6066     NORMAL_RUN_CHECKS: 
                      6067     	; Check if it is initial run phase
17D4    306419        6068     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6069     
                      6070     	; Decrement startup rotaton count
17D7    E537          6071     	MOV	A, STARTUP_ROT_CNT
17D9    14            6072     	DEC	A
                      6073     	; Check number of nondamped rotations
17DA    7005          6074     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6075     
17DC    C264          6076     CLR FLAGS1 . 4 
17DE    0216D1        6077     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6078     
                      6079     NORMAL_RUN_CHECK_STARTUP_ROT: 
17E1    F537          6080     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6081     
17E3    C3            6082     	CLR	C
17E4    E559          6083     	MOV	A, NEW_RCP				; Load new pulse value
17E6    9401          6084     SUBB A , # 1 
17E8    4003          6085     	JC	($+5)
                      6086     
17EA    0216DB        6087     	LJMP	RUN1						; Continue to run 
                      6088     
17ED    02180B        6089     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6090     
                      6091     
                      6092     INITIAL_RUN_PHASE_DONE: 
                      6093     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6106     	; Exit run loop after a given time
17F0    C3            6107     	CLR	C
17F1    E55C          6108     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
17F3    94FA          6109     SUBB A , # 250 
17F5    5014          6110     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6111     
                      6112     RUN6_CHECK_RCP_TIMEOUT: 
17F7    741F          6113     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
17F9    552E          6114     	ANL	A, FLAGS3					; Check pwm frequency flags
17FB    7004          6115     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6116     
17FD    E528          6117     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17FF    600A          6118     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6119     
                      6120     RUN6_CHECK_SPEED: 
1801    C3            6121     	CLR	C
1802    E53D          6122     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1804    94F0          6123     	SUBB	A, #0F0H
1806    5003          6124     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
1808    0216DB        6125     	JMP	RUN1						; Go back to run 1
                      6126     
                      6127     
                      6128     RUN_TO_WAIT_FOR_POWER_ON: 	
180B    C2AF          6129     	CLR	EA
180D    12113F        6130     	CALL SWITCH_POWER_OFF
1810    7887          6131     MOV R0 , # PGM_PWM_FREQ 
1812    E6            6132     MOV A , @ R0 
1813    FE            6133     MOV R6 , A 
1814    7602          6134     MOV @ R0 , # 2 
1816    121222        6135     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1819    7887          6136     MOV R0 , # PGM_PWM_FREQ 
181B    EE            6137     MOV A , R6 
181C    F6            6138     MOV @ R0 , A 
181D    E4            6139     	CLR	A
181E    F522          6140     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1820    F523          6141     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1822    F524          6142     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1824    F525          6143     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1826    F561          6144     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1828    C260          6145     CLR FLAGS1 . 0 
182A    D2AF          6146     	SETB	EA
182C    12083E        6147     	CALL	WAIT1MS					; Wait for pwm to be stopped
182F    12113F        6148     	CALL SWITCH_POWER_OFF
                      6149     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6180     IF MODE >= 1	; Tail or multi
1832    741F          6181     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1834    552E          6182     	ANL	A, FLAGS3					; Check pwm frequency flags
1836    7007          6183     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6184     
1838    E528          6185     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
183A    7003          6186     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6187     
183C    02140A        6188     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6189     
                      6190     JMP_WAIT_FOR_POWER_ON: 
183F    0214B4        6191     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6192     ENDIF
                      6193     
                      6194     
                      6195     END
MACRO ASSEMBLER BLHELI                                      05/26/15 14:36:45 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17E1H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E9EH   A 
CALC_NEXT_COMM_SL~  C ADDR   0D71H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0BC4H   A 
MEASURE_LIPO_WAIT~  C ADDR   0B36H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AF1H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AB3H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0076H   A 
HOLD_FULL_H. . . .  N NUMB   0004h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0000h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
INIT_START . . . .  C ADDR   1521H   A 
FIND_THROTTLE_GAI~  C ADDR   1309H   A 
COMM45_NFET. . . .  C ADDR   106BH   A 
COMM45_NONDAMP . .  C ADDR   1068H   A 
COMM4COMM5 . . . .  C ADDR   1046H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D96H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C57H   A 
IF_STATE_FULL. . .  C ADDR   07A8H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0074H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   12DDH   A 
GOVERNOR_CHECK_PWM  C ADDR   0A40H   A 
GOVERNOR_ACTIVATE.  C ADDR   0992H   A 
ENDIF_STATE_WAIT_~  C ADDR   07F7H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
WAIT_FOR_POWER_ON.  C ADDR   14B4H   A 
SET_DEFAULT_PARAM~  C ADDR   11BCH   A 
COMM56_NONDAMP . .  C ADDR   10AEH   A 
COMM23_CP. . . . .  C ADDR   0FD7H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D1DH   A 
COMM5COMM6 . . . .  C ADDR   1087H   A 
CALC_GOVERNOR_INT~  C ADDR   0ACBH   A 
CALC_GOVERNOR_TAR~  C ADDR   09C9H   A 
PCA_INT_STORE_DATA  C ADDR   0661H   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   1326H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1DFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   160AH   A 
DECODE_THROTTLE_R~  C ADDR   12CFH   A 
STEPPER_STEP_MED_~  C ADDR   0CEFH   A 
INITIALIZE_ALL_TI~  C ADDR   0CA3H   A 
STARTUP_PWM_SET_P~  C ADDR   0C97H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0078H   A 
HOLD_FULL_L. . . .  N NUMB   0033h            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   140AH   A 
COMM61_CP. . . . .  C ADDR   111CH   A 
COMM_EXIT. . . . .  C ADDR   112BH   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D78H   A 
CALC_GOVERNOR_INT~  C ADDR   0AC4H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BFH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0765H   A 
PCA_INT_LIMITED. .  C ADDR   0788H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   16DBH   A 
CLEAR_RAM. . . . .  C ADDR   1383H   A 
SET_BEC_VOLTAGE. .  C ADDR   12F9H   A 
DECODE_GOVERNOR_G~  C ADDR   12B6H   A 
DEC_STEP_HIGH. . .  C ADDR   117FH   A 
WAIT_FOR_COMM. . .  C ADDR   0F17H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0DBFH   A 
MEASURE_LIPO_ADD_~  C ADDR   0BB3H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A02H   A 
DIV_U16_BY_U16_DI~  C ADDR   08E6H   A 
WAIT100MS. . . . .  C ADDR   0852H   A 
WAIT1MS. . . . . .  C ADDR   083EH   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   17C4H   A 
RUN2 . . . . . . .  C ADDR   16F9H   A 
COMM45_CP. . . . .  C ADDR   107EH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0E31H   A 
MEASURE_LIPO_UPDA~  C ADDR   0BBBH   A 
GOVERNOR_CORR_INT~  C ADDR   0B10H   A 
GOVERNOR_STORE_PR~  C ADDR   09FEH   A 
DIV_U16_BY_U16_DI~  C ADDR   08F0H   A 
WAIT200MS. . . . .  C ADDR   0857H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   1717H   A 
DIRECT_METHOD_STA~  C ADDR   1578H   A 
DECODE_DAMPING_DO~  C ADDR   125EH   A 
PWM_WAIT . . . . .  C ADDR   0EC3H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C67H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AF8H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A28H   A 
DIV_U16_BY_U16_DI~  C ADDR   0907H   A 
WAIT3MS. . . . . .  C ADDR   0843H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   183FH   A 
DIRECT_START_CHEC~  C ADDR   17C7H   A 
RUN4 . . . . . . .  C ADDR   1735H   A 
STORE_TIMES_UP_OR~  C ADDR   0E11H   A 
STORE_TIMES_DECRE~  C ADDR   0E24H   A 
STEPPER_STEP_SET .  C ADDR   0D09H   A 
TEMP_AVERAGE_INC .  C ADDR   0BF7H   A 
GOVERNOR_CORR_INT~  C ADDR   0B21H   A 
MULT_S16_BY_U8_DI~  C ADDR   0916H   A 
IF_NHOLD_TIMEOUT .  C ADDR   07C2H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0722H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   0014h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   1752H   A 
COMP_READ. . . . .  C ADDR   0EC9H   A 
COMP_WAIT_SET_RES~  C ADDR   0E8AH   A 
DIVIDE_WAIT_TIMES.  C ADDR   0DC5H   A 
GOVERNOR_CORR_NEG~  C ADDR   0B15H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09F3H   A 
GOVERNOR_TARGET_C~  C ADDR   0975H   A 
CALC_GOVERNOR_TAR~  C ADDR   096DH   A 
PCA_INT_PWM_DIVID~  C ADDR   076CH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   176FH   A 
ARMING_START . . .  C ADDR   147CH   A 
MEASURE_PWM_FREQ_~  C ADDR   140EH   A 
DECREMENT_STEP_EX~  C ADDR   11ACH   A 
COMM_RETURN. . . .  C ADDR   113EH   A 
GOVERNOR_DEACTIVA~  C ADDR   097FH   A 
PCA_INT_CHECK_LEG~  C ADDR   077DH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
FLAG_BEFORE_ARM. .  D ADDR   0073H   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
COMP_PWM_HIGH_ON_~  N NUMB   0018h            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   1486H   A 
EVALUATE_COMPARAT~  C ADDR   0ED8H   A 
TEMP_CHECK_EXIT. .  C ADDR   0C21H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A9AH   A 
SET_PREV_RCP . . .  C ADDR   07F7H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
NORMAL_RUN_CHECKS.  C ADDR   17D4H   A 
DEC_STEP_MED_LOW .  C ADDR   119AH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E59H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D8CH   A 
CALC_GOVERNOR_PRO~  C ADDR   09CAH   A 
PCA_INT_PPM_UNIDI~  C ADDR   071CH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0F31H   A 
ENDIF_INITIAL_ARM.  C ADDR   07F7H   A 
IF_NHOLD_H_NOT_NE~  C ADDR   07B4H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0007h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   12EBH   A 
EVAL_COMP_EXIT . .  C ADDR   0F02H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0EEAH   A 
STEPPER_STEP_LOW .  C ADDR   0CFDH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B78H   A 
PCA_INT_SET_TIMEO~  C ADDR   080AH   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
STEPPER_ROT_EXIT .  C ADDR   1679H   A 
STEPPER_METHOD_ST~  C ADDR   15B8H   A 
DECODE_PARAMS_DIR~  C ADDR   1298H   A 
COMM12_DAMP. . . .  C ADDR   0F55H   A 
SETUP_COMM_WAIT. .  C ADDR   0F03H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D16H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0C4DH   A 
CALC_GOVERNOR_INT~  C ADDR   0A5FH   A 
ENDIF_STATE_CRUISE  C ADDR   07F7H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   1492H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E4AH   A 
LOAD_MIN_TIME. . .  C ADDR   0DE1H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0DA0H   A 
SET_STARTUP_PWM. .  C ADDR   0C73H   A 
GOVERNOR_STORE_IN~  C ADDR   0A59H   A 
GOVERNOR_ACTIVATE~  C ADDR   09BCH   A 
ELSE_INITIAL_ARM .  C ADDR   07F7H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   000Fh            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   17F7H   A 
DECREMENT_STEP . .  C ADDR   115DH   A 
COMM23_DAMP. . . .  C ADDR   0FA7H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0F33H   A 
ADJUST_TIMING. . .  C ADDR   0DE5H   A 
STEPPER_STEP_MED_~  C ADDR   0CD3H   A 
MEASURE_LIPO_DIVI~  C ADDR   0B98H   A 
MEASURE_LIPO_START  C ADDR   0B26H   A 
CALC_GOVERNOR_PRO~  C ADDR   0AC3H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A54H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09FAH   A 
BEEP_F1. . . . . .  C ADDR   086EH   A 
WAIT1S_LOOP. . . .  C ADDR   0869H   A 
END_PROCEDURE_GET~  C ADDR   0797H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
INITIAL_RUN_PHASE~  C ADDR   17F0H   A 
TEST_THROTTLE_GAIN  C ADDR   1317H   A 
STEPPER_STEP_MED .  C ADDR   0CE1H   A 
GOVERNOR_STORE_PR~  C ADDR   0AC1H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A85H   A 
MULT_S16_BY_U8_PO~  C ADDR   0930H   A 
DIV_U16_BY_U16 . .  C ADDR   08DEH   A 
BEEP_ONOFF . . . .  C ADDR   0891H   A 
BEEP_F2. . . . . .  C ADDR   0875H   A 
ELSE_STATE_CRUISE.  C ADDR   07DDH   A 
ELSE_FLAG_BEFORE_~  C ADDR   07A3H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F2H   A 
PCA_INT_CHECK_DIFF  C ADDR   0654H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   12FAH   A 
DECREMENT_STEPPER~  C ADDR   1151H   A 
COMM61_DAMP. . . .  C ADDR   10DCH   A 
COMM34_DAMP. . . .  C ADDR   0FFBH   A 
TEMP_AVERAGE_INC_~  C ADDR   0BE7H   A 
GOVERNOR_INT_MAX_~  C ADDR   0A4DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A31H   A 
BEEP_F3. . . . . .  C ADDR   087CH   A 
SET_PWM_IN_HIGH. .  C ADDR   0793H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   00A9h            
TEMP_LIMIT . . . .  N NUMB   006Dh            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
DAMPED_TRANSITION.  C ADDR   16D1H   A 
BEEP_DELAY_SET . .  C ADDR   14DCH   A 
LOCK_BYTE_OK . . .  C ADDR   1345H   A 
DECODE_PWM_FREQ_L~  C ADDR   12B0H   A 
DECODE_DAMPING_3 .  C ADDR   1236H   A 
CALC_NEW_WAIT_RED~  C ADDR   0DB0H   A 
BEEP_F4. . . . . .  C ADDR   0883H   A 
SET_PWM_IN . . . .  C ADDR   0795H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074CH   A 
PCA_INT_RESTORE_E~  C ADDR   0640H   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
DIRECT_START_PARA~  C ADDR   17ACH   A 
DECODE_DAMPING_4 .  C ADDR   1240H   A 
COMM45_DAMP. . . .  C ADDR   104EH   A 
WAIT_FOR_COMM_SET~  C ADDR   0F43H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BFFH   A 
GOVERNOR_APPLY_IN~  C ADDR   0AFCH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A90H   A 
BEEP_OFF . . . . .  C ADDR   08D2H   A 
WAIT10MS . . . . .  C ADDR   0848H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F9H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   00DFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
RESET_CAL_DONE . .  C ADDR   1361H   A 
DECODE_DAMPING_5 .  C ADDR   124AH   A 
DECODE_PARAMETERS.  C ADDR   1222H   A 
STEPPER_TIMER_WAIT  C ADDR   11B6H   A 
STORE_TIMES_INCRE~  C ADDR   0E17H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0C46H   A 
MEASURE_LIPO_CELLS  C ADDR   0B26H   A 
CALC_GOVERNOR_INT~  C ADDR   0A03H   A 
IF_INITIAL_ARM . .  C ADDR   07E6H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CFH   A 
PCA_INT_EXIT . . .  C ADDR   0824H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
RUN6_CHECK_SPEED .  C ADDR   1801H   A 
WAIT_FOR_POWER_ON~  C ADDR   1508H   A 
DECODE_DAMPING_6 .  C ADDR   1254H   A 
DEC_STEP_LOW . . .  C ADDR   11A3H   A 
COMM56_DAMP. . . .  C ADDR   1099H   A 
SWITCH_POWER_OFF .  C ADDR   113FH   A 
WAIT30MS . . . . .  C ADDR   084DH   A 
ENDIF_STATE_FULL .  C ADDR   07F7H   A 
PCA_INT_PPM_BIDIR~  C ADDR   073DH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0631H   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0075h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   180BH   A 
EVAL_COMP_CHECK_T~  C ADDR   0EF8H   A 
ADJUST_TIMING_TWO~  C ADDR   0E07H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C72H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A67H   A 
GOVERNOR_ACTIVATE~  C ADDR   09C3H   A 
WAIT1S . . . . . .  C ADDR   0867H   A 
WAITXMS_M. . . . .  C ADDR   085EH   A 
IF_STATE_CRUISE. .  C ADDR   07D6H   A 
IF_NHOLD_NOT_TIME~  C ADDR   07CEH   A 
IF_FLAG_BEFORE_ARM  C ADDR   079CH   A 
PCA_INT_CHECK_2KHZ  C ADDR   0620H   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0075H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   1557H   A 
WAIT_FOR_POWER_ON~  C ADDR   14F9H   A 
DECODE_PWM_FREQ_E~  C ADDR   12B5H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0F45H   A 
PWM_WAIT_STARTUP .  C ADDR   0EBEH   A 
START_ADC_CONVERS~  C ADDR   0BC0H   A 
MULT_S16_BY_U8_EX~  C ADDR   0964H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075EH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
MUX_A. . . . . . .  N NUMB   0002h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   1444H   A 
LOCK_BYTE_TEST . .  C ADDR   133EH   A 
DEC_STEP_MED_HIGH.  C ADDR   1188H   A 
COMM_RESTORE_POWER  C ADDR   113CH   A 
COMM12_NONDAMP . .  C ADDR   0F6AH   A 
COMM1COMM2 . . . .  C ADDR   0F4BH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BFDH   A 
TEMP_AVERAGE_DEC .  C ADDR   0BF3H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A60H   A 
WAITXMS_O. . . . .  C ADDR   085CH   A 
PCA_INT_PPM_TIMEO~  C ADDR   0816H   A 
ELES_STATE_FULL. .  C ADDR   07D1H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060FH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
MUX_B. . . . . . .  N NUMB   0000h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0007h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
WAIT_FOR_POWER_ON~  C ADDR   14B9H   A 
DEC_STEP_MED . . .  C ADDR   1191H   A 
READ_TIMER . . . .  C ADDR   0D21H   A 
CHECK_VOLTAGE_STA~  C ADDR   0C25H   A 
CALC_GOVERNOR_INT~  C ADDR   0B25H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A3AH   A 
MULT_S16_BY_U8_DI~  C ADDR   0949H   A 
BEEP . . . . . . .  C ADDR   088AH   A 
PROCEDURE_GETPWM .  C ADDR   0788H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0707H   A 
PCA_INT_FALL . . .  C ADDR   066DH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0077H   A 
HOLD_CRUISE_L. . .  N NUMB   0030h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
COMM23_NFET. . . .  C ADDR   0FC4H   A 
COMM23_NONDAMP . .  C ADDR   0FC1H   A 
COMM2COMM3 . . . .  C ADDR   0F9FH   A 
STEPPER_STEP_HIGH.  C ADDR   0CC5H   A 
MEASURE_LIPO_CELL~  C ADDR   0B5DH   A 
GOVERNOR_STORE_IN~  C ADDR   0B23H   A 
GOVERNOR_CHECK_IN~  C ADDR   0AE5H   A 
GOVERNOR_CORR_PRO~  C ADDR   0AAEH   A 
GOVERNOR_ACTIVATE~  C ADDR   09B0H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
COMP_PWM_LOW_ON_D~  N NUMB   0008h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0BBFH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A96H   A 
GOVERNOR_CHECK_PR~  C ADDR   09E7H   A 
LINE_TEMP01. . . .  C ADDR   05A1H   A 
PCA_INT_SECOND_ME~  C ADDR   05B3H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   00FCh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   140CH   A 
COMM61_NFET. . . .  C ADDR   1101H   A 
COMM61_NONDAMP . .  C ADDR   10FEH   A 
COMM6COMM1 . . . .  C ADDR   10D4H   A 
COMM34_NONDAMP . .  C ADDR   1008H   A 
COMM3COMM4 . . . .  C ADDR   0FE9H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E77H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E53H   A 
STARTUP_PWM_EXIT .  C ADDR   0CA2H   A 
MEASURE_LIPO_LIMI~  C ADDR   0BAFH   A 
GOVERNOR_CORR_PRO~  C ADDR   0ABFH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E9H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FEH   A 
LINE_TEMP02. . . .  C ADDR   05AFH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6180    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     88    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
