MACRO ASSEMBLER BLHELI                                      05/25/15 20:01:22 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       145     
                       146     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       150     
                       151     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       155     
                       156     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                 157     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       158     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       768     ENDIF
                       769     
                       770     
                       771     ;**** **** **** **** ****
                       772     ; TX programming defaults
                       773     ;
                       774     ; Parameter dependencies:
                       775     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       776     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       777     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       778     ; - Damping force is only used if DampedLight or Damped is selected
                       779     ;
                       780     ; Main
  0007                 781     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 782     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 783     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 784     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 785     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 786     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 787     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 788     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 789     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 790     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 791     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 792     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 793     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 794     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 795     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 796     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 797     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 798     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 799     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       800     ; Tail
  0003                 801     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 802     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 803     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 804     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 805     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 806     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 807     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       808     IF DAMPED_MODE_ENABLE == 1
  0004                 809     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       810     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 813     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 814     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 815     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 816     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 817     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 818     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       819     ; Multi
  0009                 820     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 821     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 822     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 823     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 824     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 825     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 826     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 827     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 828     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 829     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       830     IF DAMPED_MODE_ENABLE == 1
  0001                 831     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       832     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 835     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 836     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 837     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0050                 838     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 80	; Beep strength
  0050                 839     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0005                 840     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       841     ; Common
  0000                 842     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 843     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 844     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 845     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 846     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       847     
                       848     ;**** **** **** **** ****
                       849     ; Constant definitions for main
                       850     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       872     ; Constant definitions for tail
                       873     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       894     ; Constant definitions for multi
                       895     IF MODE == 2
                       896     
  0001                 897     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       898     
  000A                 899     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 900     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 901     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 902     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 903     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 904     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 905     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 906     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       907     
  0032                 908     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 909     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       910     
  000A                 911     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 912     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       913     
  0008                 914     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       915     
                       916     ENDIF
                       917     
                       918     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       919     ;
                       920     ; Skypup 2015.05.25
                       921     ;
                       922     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       923     ;
  0002                 924     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 925     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       926     ;
                       927     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       928     
                       929     ;**** **** **** **** ****
                       930     ; Temporary register definitions
  REG                  931     TEMP1		EQU	R0
  REG                  932     TEMP2		EQU	R1
  REG                  933     TEMP3		EQU	R2
  REG                  934     TEMP4		EQU	R3
  REG                  935     TEMP5		EQU	R4
  REG                  936     TEMP6		EQU	R5
  REG                  937     TEMP7		EQU	R6
  REG                  938     TEMP8		EQU	R7
                       939     
                       940     ;**** **** **** **** ****
                       941     ; Register definitions
------                 942     DSEG AT 20H					; Variables segment 
                       943     
0020                   944     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   945     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       946     
0022                   947     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   948     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   949     CURRENT_PWM: 				DS	1		; Current pwm
0025                   950     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   951     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   952     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   953     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   954     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   955     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       956     
002B                   957     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 958     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 959     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 960     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 961     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 962     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       963     ;						EQU 	5
                       964     ;						EQU 	6
                       965     ;						EQU 	7
                       966     
002C                   967     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 968     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 969     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 970     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 971     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 972     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 973     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 974     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       975     ;						EQU 	7
                       976     
002D                   977     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 978     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 979     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 980     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 981     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 982     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 983     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       984     ;						EQU 	6	
                       985     ;						EQU 	7	
                       986     
002E                   987     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 988     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 989     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 990     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 991     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 992     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 993     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 994     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 995     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       996     
                       997     ;**** **** **** **** ****
                       998     ; RAM definitions
------                 999     DSEG AT 30H						; Ram data segment, direct addressing
                      1000     
0030                  1001     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      1002     
0031                  1003     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  1004     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      1005     
0033                  1006     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                  1007     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                  1008     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                  1009     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                  1010     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                  1011     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                  1012     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                      1013     
003A                  1014     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                  1015     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                  1016     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                  1017     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                  1018     COMM_PHASE: 				DS	1		; Current commutation phase
003F                  1019     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                      1020     
0040                  1021     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                  1022     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                  1023     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                  1024     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                  1025     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                  1026     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                  1027     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                  1028     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                  1029     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                  1030     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                      1031     
004A                  1032     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                  1033     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                  1034     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                  1035     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                  1036     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                  1037     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                  1038     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                  1039     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                      1040     
0052                  1041     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                  1042     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                  1043     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                  1044     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                  1045     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                  1046     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                  1047     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                  1048     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                  1049     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  1050     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  1051     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                  1052     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      1053     
005E                  1054     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                  1055     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                  1056     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                  1057     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                  1058     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                  1059     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      1060     
0064                  1061     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                  1062     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                      1063     
0066                  1064     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                  1065     DAMPING_ON: 				DS	1		; Damping on part of damping period
                      1066     
0068                  1067     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                  1068     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                  1069     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                  1070     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                  1071     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      1072     
006D                  1073     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      1074     
006E                  1075     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                  1076     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      1077     
0070                  1078     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                  1079     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                  1080     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      1081     
                      1082     ; Skypup 2015.05.25
0073                  1083     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
0074                  1084     RUN_COUNT_L: 				DS	1		; 运行循环计数低位
0075                  1085     RUN_COUNT_H: 				DS	1		; 运行循环计数高位
0076                  1086     TEMP_SKYPUP: 				DS	1		; 临时变量
                      1087     
                      1088     ; Indirect addressing data segment. The variables below must be in this sequence
------                1089     ISEG AT 080H					
0080                  1090     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1091     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1092     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1093     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1094     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1095     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1096     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1097     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1098     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1099     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1100     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1101     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1102     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1103     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1104     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1105     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1106     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1107     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1108     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1109     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1110     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1111     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1112     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1113     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1114     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1115     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1116     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1117     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1118     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1119     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1120     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1121     
                      1122     ; The sequence of the variables below is no longer of importance
009F                  1123     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1124     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1125     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1126     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1127     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1128     
                      1129     
                      1130     ; Indirect addressing data segment
------                1131     ISEG AT 0D0H					
00D0                  1132     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1133     
                      1134     
                      1135     ;**** **** **** **** ****
------                1136     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1137     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1138     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1139     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1140     
1A00    0B            1141     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1142     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1143     EEP_LAYOUT_REVISION:  DB 17 
                      1144     
                      1145     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1178     
                      1179     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1212     
                      1213     IF MODE == 2
1A03    09            1214     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1215     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1216     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1217     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1218     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1219     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1220     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1221     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1222     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1223     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1224     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1225     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1226     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1227     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1228     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1229     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1230     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1231     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1232     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1233     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1234     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1235     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1236     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1237     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    50            1238     EEP_PGM_BEEP_STRENGTH:  DB 80 
1A1C    50            1239     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    05            1240     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    0D            1241     EEP_PGM_THROTTLE_RATE:  DB 13 
1A1F    02            1242     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1243     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1244     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1245     ENDIF
                      1246     
                      1247     
1A22    FF            1248     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1249     
------                1250     CSEG AT 1A60H
1A60    6F72672E      1251     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1252     
                      1253     ;**** **** **** **** ****
                      1254             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1254+1   CSEG AT 0  ; CODE SEGMENT START
0000    021272        1254+1   JMP RESET 
------                1254+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1254+1   JMP T0_INT 
------                1254+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1254+1   JMP T2_INT 
------                1254+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1254+1   JMP PCA_INT 
------                1254+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1254+1   JMP T3_INT 
------                1255     CSEG AT 80H			; Code segment after interrupt vectors 
                      1256     
                      1257     ;**** **** **** **** ****
                      1258     
                      1259     ; Table definitions
0080    02030406      1260     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1261     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1262     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1263     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1264     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1267     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1275     IF MODE == 2
                      1276       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1277     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1278       ENDIF
                      1279       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1282     ENDIF
                      1283     
                      1284     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1285     ;
                      1286     ; Timer0 interrupt routine
                      1287     ;
                      1288     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1289     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1290     ;
                      1291     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1292     T0_INT: 	; Used for pwm control
00BA    C2AF          1293     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1294     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1295     	PUSH	ACC		
                      1296     	; Check if pwm is on
00C0    205A10        1297     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1298     
                      1299     	; Do not execute pwm when stopped
00C3    30600A        1300     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1301     	; Do not execute pwm on during demag recovery
00C6    205C07        1302     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1303     	; Pwm on cycle. 
00C9    302F02        1304     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1305     
                      1306     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1307     	CLR	A					
00CD    73            1308     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1309     
                      1310     T0_INT_PWM_ON_LOW_PWM: 
                      1311     
                      1312     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1313     	JMP	T0_INT_PWM_ON_EXECUTE
                      1314     ENDIF
                      1315     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1332     
                      1333     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1334     	JMP	T0_INT_PWM_ON_EXIT
                      1335     
                      1336     
                      1337     T0_INT_PWM_OFF: 
00D3    306306        1338     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1339     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1339+1   CLR P1 . 2 
00D8    C296          1339+1   CLR P1 . 6 
00DA    C295          1339+1   CLR P1 . 5 
                      1340     T0_INT_PWM_OFF_START_CHECKED: 
                      1341     	; Pwm off cycle
00DC    85258A        1342     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1343     	; Clear pwm on flag
00DF    C25A          1344     CLR FLAGS0 . 2 
                      1345     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1346     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1347     	CPL	A						; Full pwm?
00E4    7002          1348     	JNZ	($+4)					; No - branch
00E6    21C6          1349     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1350     
00E8    0563          1351     	INC	PWM_OFF_CNT				; Increment event counter
                      1352     	; Do not execute pwm when stopped
00EA    306013        1353     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1354     
                      1355     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1356     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1357     
                      1358     	; Separate exit commands here for minimum delay
00F0    758B00        1359     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1360     	POP	ACC			; Restore preserved registers
00F5    D0D0          1361     	POP	PSW
                      1362     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1362+1   CLR P1 . 2 
00F9    C296          1362+1   CLR P1 . 6 
00FB    C295          1362+1   CLR P1 . 5 
00FD    D2AF          1363     	SETB	EA			; Enable all interrupts
00FF    32            1364     	RETI
                      1365     
                      1366     T0_INT_PWM_OFF_STOPPED: 
                      1367     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1367+1   CLR P1 . 2 
0102    C296          1367+1   CLR P1 . 6 
0104    C295          1367+1   CLR P1 . 5 
0106    0201B6        1368     	JMP	T0_INT_PWM_OFF_EXIT
                      1369     
                      1370     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1371     SETB FLAGS1 . 5 
010B    C266          1372     CLR FLAGS1 . 6 
010D    E567          1373     	MOV	A, DAMPING_ON
010F    601C          1374     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1375     
0111    C3            1376     	CLR	C
0112    E563          1377     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1378     	DEC	A
0115    9567          1379     	SUBB	A, DAMPING_ON
0117    4014          1380     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1381     
0119    C265          1382     CLR FLAGS1 . 5 
011B    D266          1383     SETB FLAGS1 . 6 
011D    C3            1384     	CLR	C
011E    E563          1385     	MOV	A, PWM_OFF_CNT					
0120    9566          1386     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1387     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1388     
0124    0201B6        1389     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1390     
                      1391     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1392     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1393     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1394     
                      1395     T0_INT_PWM_OFF_DO_DAMPED: 
                      1396     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1397     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1398     
                      1399     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1399+1   CLR P1 . 2 
0132    C296          1399+1   CLR P1 . 6 
0134    C295          1399+1   CLR P1 . 5 
0136    7406          1400     MOV A , # 6 
0138    D5E0FD        1401     	DJNZ	ACC, $	
                      1402     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1402+1   SETB P1 . 3 
013D    D297          1402+1   SETB P1 . 7 
013F    D294          1402+1   SETB P1 . 4 
0141    0201B6        1403     	JMP	T0_INT_PWM_OFF_EXIT
                      1404     
                      1405     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1406     IF DAMPED_MODE_ENABLE == 1
0144    D266          1407     SETB FLAGS1 . 6 
                      1408     ENDIF
                      1409     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1409+1   CLR P1 . 2 
0148    C296          1409+1   CLR P1 . 6 
014A    C295          1409+1   CLR P1 . 5 
014C    E53E          1410     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1411     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1412     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1413     
                      1414     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1417     MOV A , # 6 
0156    D5E0FD        1418     	DJNZ	ACC, $	
                      1419     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1419+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1419+1   SETB P1 . 7 
015E    307502        1419+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1419+1   SETB P1 . 3 
                      1420     ENDIF
0163    0201B6        1421     	JMP	T0_INT_PWM_OFF_EXIT
                      1422     
                      1423     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1424     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1425     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1428     MOV A , # 6 
016B    D5E0FD        1429     	DJNZ	ACC, $	
                      1430     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1430+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1430+1   SETB P1 . 7 
0173    307502        1430+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1430+1   SETB P1 . 3 
                      1431     ENDIF
0178    0201B6        1432     	JMP	T0_INT_PWM_OFF_EXIT
                      1433     
                      1434     T0_INT_PWM_OFF_COMM_3: 
                      1435     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1438     MOV A , # 6 
017D    D5E0FD        1439     	DJNZ	ACC, $	
                      1440     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1440+1   SETB P1 . 4 
                      1441     ENDIF
0182    0201B6        1442     	JMP	T0_INT_PWM_OFF_EXIT
                      1443     
                      1444     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1445     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1446     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1447     
                      1448     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1451     MOV A , # 6 
018D    D5E0FD        1452     	DJNZ	ACC, $	
                      1453     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1453+1   SETB P1 . 4 
                      1454     ENDIF
0192    0201B6        1455     	JMP	T0_INT_PWM_OFF_EXIT
                      1456     
                      1457     T0_INT_PWM_OFF_COMM_5: 
                      1458     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1461     MOV A , # 6 
0197    D5E0FD        1462     	DJNZ	ACC, $	
                      1463     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1463+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1463+1   SETB P1 . 3 
019F    307502        1463+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1463+1   SETB P1 . 7 
                      1464     ENDIF
01A4    0201B6        1465     	JMP	T0_INT_PWM_OFF_EXIT
                      1466     
                      1467     T0_INT_PWM_OFF_COMM_6: 
                      1468     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1471     MOV A , # 6 
01A9    D5E0FD        1472     	DJNZ	ACC, $	
                      1473     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1473+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1473+1   SETB P1 . 3 
01B1    307502        1473+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1473+1   SETB P1 . 7 
                      1474     ENDIF
                      1475     
                      1476     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1477     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1478     	POP	ACC			; Restore preserved registers
01BB    D0D0          1479     	POP	PSW
                      1480     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1480+1   CLR P1 . 2 
01BF    C296          1480+1   CLR P1 . 6 
01C1    C295          1480+1   CLR P1 . 5 
01C3    D2AF          1481     	SETB	EA			; Enable all interrupts
01C5    32            1482     	RETI
                      1483     
                      1484     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1485     	POP	ACC			; Restore preserved registers
01C8    D0D0          1486     	POP	PSW
01CA    D2AF          1487     	SETB	EA			; Enable all interrupts
01CC    32            1488     	RETI
                      1489     
                      1490     
                      1491     
                      1492     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1493     	AJMP	T0_INT_PWM_ON_EXIT
                      1494     
                      1495     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1496     	ANFET_ON	
01CF    E525          1496+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1496+1   JZ ( $+12 ) 
01D3    207502        1496+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1496+1   SETB P1 . 2 
01D8    307502        1496+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1496+1   SETB P1 . 6 
                      1497     	BNFET_OFF
01DD    C295          1497+1   CLR P1 . 5 
01DF    61D3          1498     	AJMP	T0_INT_PWM_ON_EXIT
                      1499     
                      1500     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1501     	BNFET_ON
01E1    E525          1501+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1501+1   JZ ( $+4 ) 
01E5    D295          1501+1   SETB P1 . 5 
                      1502     	CNFET_OFF
01E7    207502        1502+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1502+1   CLR P1 . 6 
01EC    307502        1502+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1502+1   CLR P1 . 2 
01F1    61D3          1503     	AJMP	T0_INT_PWM_ON_EXIT
                      1504     
                      1505     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1506     	CNFET_ON
01F3    E525          1506+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1506+1   JZ ( $+12 ) 
01F7    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1506+1   SETB P1 . 6 
01FC    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1506+1   SETB P1 . 2 
                      1507     	ANFET_OFF
0201    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1507+1   CLR P1 . 2 
0206    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1507+1   CLR P1 . 6 
020B    61D3          1508     	AJMP	T0_INT_PWM_ON_EXIT
                      1509     
                      1510     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1511     	APFET_OFF
020D    207502        1511+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1511+1   CLR P1 . 3 
0212    307502        1511+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1511+1   CLR P1 . 7 
                      1512     	ANFET_ON								; Switch nFETs
0217    E525          1512+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1512+1   JZ ( $+12 ) 
021B    207502        1512+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1512+1   SETB P1 . 2 
0220    307502        1512+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1512+1   SETB P1 . 6 
                      1513     	CPFET_OFF
0225    207502        1513+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1513+1   CLR P1 . 7 
022A    307502        1513+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1513+1   CLR P1 . 3 
                      1514     	BNFET_OFF 							
022F    C295          1514+1   CLR P1 . 5 
0231    61D3          1515     	AJMP	T0_INT_PWM_ON_EXIT
                      1516     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1517     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1518     	APFET_OFF
0233    207502        1518+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1518+1   CLR P1 . 3 
0238    307502        1518+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1518+1   CLR P1 . 7 
                      1519     	CPFET_OFF
023D    207502        1519+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1519+1   CLR P1 . 7 
0242    307502        1519+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1519+1   CLR P1 . 3 
0247    7406          1520     MOV A , # 6 
0249    D5E0FD        1521     	DJNZ ACC,	$
                      1522     	ANFET_ON								; Switch nFETs
024C    E525          1522+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1522+1   JZ ( $+12 ) 
0250    207502        1522+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1522+1   SETB P1 . 2 
0255    307502        1522+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1522+1   SETB P1 . 6 
                      1523     	BNFET_OFF 							
025A    C295          1523+1   CLR P1 . 5 
025C    61D3          1524     	AJMP	T0_INT_PWM_ON_EXIT
                      1525     
                      1526     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1527     	APFET_OFF
025E    207502        1527+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1527+1   CLR P1 . 3 
0263    307502        1527+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1527+1   CLR P1 . 7 
                      1528     	ANFET_ON								; Switch nFETs
0268    E525          1528+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1528+1   JZ ( $+12 ) 
026C    207502        1528+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1528+1   SETB P1 . 2 
0271    307502        1528+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1528+1   SETB P1 . 6 
                      1529     	BPFET_OFF
0276    C294          1529+1   CLR P1 . 4 
                      1530     	BNFET_OFF								
0278    C295          1530+1   CLR P1 . 5 
027A    61D3          1531     	AJMP	T0_INT_PWM_ON_EXIT
                      1532     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1533     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1534     	APFET_OFF
027C    207502        1534+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1534+1   CLR P1 . 3 
0281    307502        1534+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1534+1   CLR P1 . 7 
                      1535     	BPFET_OFF
0286    C294          1535+1   CLR P1 . 4 
0288    7406          1536     MOV A , # 6 
028A    D5E0FD        1537     	DJNZ ACC,	$
                      1538     	ANFET_ON								; Switch nFETs
028D    E525          1538+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1538+1   JZ ( $+12 ) 
0291    207502        1538+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1538+1   SETB P1 . 2 
0296    307502        1538+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1538+1   SETB P1 . 6 
                      1539     	BNFET_OFF								
029B    C295          1539+1   CLR P1 . 5 
029D    61D3          1540     	AJMP	T0_INT_PWM_ON_EXIT
                      1541     
                      1542     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1543     	BPFET_OFF
029F    C294          1543+1   CLR P1 . 4 
                      1544     	BNFET_ON								; Switch nFETs
02A1    E525          1544+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1544+1   JZ ( $+4 ) 
02A5    D295          1544+1   SETB P1 . 5 
                      1545     	APFET_OFF
02A7    207502        1545+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1545+1   CLR P1 . 3 
02AC    307502        1545+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1545+1   CLR P1 . 7 
                      1546     	CNFET_OFF								
02B1    207502        1546+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1546+1   CLR P1 . 6 
02B6    307502        1546+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1546+1   CLR P1 . 2 
02BB    61D3          1547     	AJMP	T0_INT_PWM_ON_EXIT
                      1548     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1549     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1550     	BPFET_OFF
02BD    C294          1550+1   CLR P1 . 4 
                      1551     	APFET_OFF
02BF    207502        1551+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1551+1   CLR P1 . 3 
02C4    307502        1551+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1551+1   CLR P1 . 7 
02C9    7406          1552     MOV A , # 6 
02CB    D5E0FD        1553     	DJNZ ACC,	$
                      1554     	BNFET_ON								; Switch nFETs
02CE    E525          1554+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1554+1   JZ ( $+4 ) 
02D2    D295          1554+1   SETB P1 . 5 
                      1555     	CNFET_OFF								
02D4    207502        1555+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1555+1   CLR P1 . 6 
02D9    307502        1555+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1555+1   CLR P1 . 2 
02DE    61D3          1556     	AJMP	T0_INT_PWM_ON_EXIT
                      1557     
                      1558     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1559     	BPFET_OFF
02E0    C294          1559+1   CLR P1 . 4 
                      1560     	BNFET_ON								; Switch nFETs
02E2    E525          1560+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1560+1   JZ ( $+4 ) 
02E6    D295          1560+1   SETB P1 . 5 
                      1561     	CPFET_OFF
02E8    207502        1561+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1561+1   CLR P1 . 7 
02ED    307502        1561+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1561+1   CLR P1 . 3 
                      1562     	CNFET_OFF								
02F2    207502        1562+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1562+1   CLR P1 . 6 
02F7    307502        1562+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1562+1   CLR P1 . 2 
02FC    61D3          1563     	AJMP	T0_INT_PWM_ON_EXIT
                      1564     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1565     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1566     	BPFET_OFF
02FE    C294          1566+1   CLR P1 . 4 
                      1567     	CPFET_OFF
0300    207502        1567+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1567+1   CLR P1 . 7 
0305    307502        1567+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1567+1   CLR P1 . 3 
030A    7406          1568     MOV A , # 6 
030C    D5E0FD        1569     	DJNZ ACC,	$
                      1570     	BNFET_ON								; Switch nFETs
030F    E525          1570+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1570+1   JZ ( $+4 ) 
0313    D295          1570+1   SETB P1 . 5 
                      1571     	CNFET_OFF								
0315    207502        1571+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1571+1   CLR P1 . 6 
031A    307502        1571+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1571+1   CLR P1 . 2 
031F    61D3          1572     	AJMP	T0_INT_PWM_ON_EXIT
                      1573     
                      1574     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1575     	CPFET_OFF
0321    207502        1575+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1575+1   CLR P1 . 7 
0326    307502        1575+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1575+1   CLR P1 . 3 
                      1576     	CNFET_ON								; Switch nFETs
032B    E525          1576+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1576+1   JZ ( $+12 ) 
032F    207502        1576+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1576+1   SETB P1 . 6 
0334    307502        1576+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1576+1   SETB P1 . 2 
                      1577     	BPFET_OFF
0339    C294          1577+1   CLR P1 . 4 
                      1578     	ANFET_OFF								
033B    207502        1578+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1578+1   CLR P1 . 2 
0340    307502        1578+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1578+1   CLR P1 . 6 
0345    61D3          1579     	AJMP	T0_INT_PWM_ON_EXIT
                      1580     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1581     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1582     	CPFET_OFF
0347    207502        1582+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1582+1   CLR P1 . 7 
034C    307502        1582+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1582+1   CLR P1 . 3 
                      1583     	BPFET_OFF
0351    C294          1583+1   CLR P1 . 4 
0353    7406          1584     MOV A , # 6 
0355    D5E0FD        1585     	DJNZ ACC,	$
                      1586     	CNFET_ON								; Switch nFETs
0358    E525          1586+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1586+1   JZ ( $+12 ) 
035C    207502        1586+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1586+1   SETB P1 . 6 
0361    307502        1586+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1586+1   SETB P1 . 2 
                      1587     	ANFET_OFF								
0366    207502        1587+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1587+1   CLR P1 . 2 
036B    307502        1587+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1587+1   CLR P1 . 6 
0370    61D3          1588     	AJMP	T0_INT_PWM_ON_EXIT
                      1589     
                      1590     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1591     	CPFET_OFF
0372    207502        1591+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1591+1   CLR P1 . 7 
0377    307502        1591+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1591+1   CLR P1 . 3 
                      1592     	CNFET_ON								; Switch nFETs
037C    E525          1592+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1592+1   JZ ( $+12 ) 
0380    207502        1592+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1592+1   SETB P1 . 6 
0385    307502        1592+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1592+1   SETB P1 . 2 
                      1593     	APFET_OFF
038A    207502        1593+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1593+1   CLR P1 . 3 
038F    307502        1593+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1593+1   CLR P1 . 7 
                      1594     	ANFET_OFF								
0394    207502        1594+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1594+1   CLR P1 . 2 
0399    307502        1594+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1594+1   CLR P1 . 6 
039E    61D3          1595     	AJMP	T0_INT_PWM_ON_EXIT
                      1596     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1597     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1598     	CPFET_OFF
03A0    207502        1598+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1598+1   CLR P1 . 7 
03A5    307502        1598+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1598+1   CLR P1 . 3 
                      1599     	APFET_OFF
03AA    207502        1599+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1599+1   CLR P1 . 3 
03AF    307502        1599+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1599+1   CLR P1 . 7 
03B4    7406          1600     MOV A , # 6 
03B6    D5E0FD        1601     	DJNZ ACC,	$
                      1602     	CNFET_ON								; Switch nFETs
03B9    E525          1602+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1602+1   JZ ( $+12 ) 
03BD    207502        1602+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1602+1   SETB P1 . 6 
03C2    307502        1602+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1602+1   SETB P1 . 2 
                      1603     	ANFET_OFF								
03C7    207502        1603+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1603+1   CLR P1 . 2 
03CC    307502        1603+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1603+1   CLR P1 . 6 
03D1    61D3          1604     	AJMP	T0_INT_PWM_ON_EXIT
                      1605     
                      1606     T0_INT_PWM_ON_EXIT: 
                      1607     	; Set timer for coming on cycle length
03D3    E525          1608     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1609     	CPL	A						; cpl is 255-x
03D6    F58A          1610     	MOV	TL0, A					; Write start point for timer
                      1611     	; Set other variables
03D8    758B00        1612     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1613     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1614     SETB FLAGS0 . 2 
                      1615     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1616     	; Exit interrupt
03E0    D0E0          1617     	POP	ACC			; Restore preserved registers
03E2    D0D0          1618     	POP	PSW
03E4    D2AF          1619     	SETB	EA			; Enable all interrupts
03E6    32            1620     	RETI
                      1621     
                      1622     
                      1623     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1624     ;
                      1625     ; Timer2 interrupt routine
                      1626     ;
                      1627     ; No assumptions
                      1628     ;
                      1629     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1630     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1631     	CLR	EA
03E9    C2AD          1632     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1633     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1634     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1635     	PUSH	ACC
03F2    D2D3          1636     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1637     	SETB	EA
                      1638     	; Clear low byte interrupt flag
03F6    C2CE          1639     	CLR	TF2L						; Clear interrupt flag
                      1640     	; Check RC pulse timeout counter
03F8    E528          1641     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1642     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1643     
                      1644     	; Decrement timeout counter (if PWM)
03FC    741F          1645     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1646     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1647     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1648     
0402    1528          1649     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1650     	AJMP	T2_INT_SKIP_START
                      1651     
                      1652     T2_INT_PULSES_ABSENT: 
                      1653     	; Timeout counter has reached zero, pulses are absent
0406    7800          1654     MOV R0 , # 0 
0408    7900          1655     MOV R1 , # 0 
                      1656     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1656+1   MOV A , P0 
040C    307601        1656+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1656+1   CPL A  ; YES - INVERT
0410    30E502        1657     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1658     MOV R0 , # 255 
                      1659     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1659+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1659+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1659+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1659+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1659+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1660     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1660+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1661     CLR FLAGS2 . 1 
                      1662     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1662+1   MOV A , P0 
042A    307601        1662+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1662+1   CPL A  ; YES - INVERT
042E    30E502        1663     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1664     MOV R1 , # 255 
0433    C3            1665     	CLR	C
0434    E8            1666     MOV A , R0 
0435    99            1667     SUBB A , R1 
0436    70CE          1668     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1669     
0438    305903        1670     JNB FLAGS0 . 1 , ( $+6 ) 
                      1671     
043B    752818        1672     MOV RCP_TIMEOUT_CNT , # 24 
                      1673     
043E    741F          1674     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1675     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1676     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1677     
0444    752818        1678     MOV RCP_TIMEOUT_CNT , # 24 
                      1679     
                      1680     
                      1681     T2_INT_PPM_TIMEOUT_SET: 
                      1682     
                      1683     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1684     ; 
                      1685     ; 对 RCP 信号处理
                      1686     ; 1 小于 1500us 最低油门
                      1687     ; 2 大于 1500us 正常处理
                      1688     ; 
                      1689     ;	clr C
                      1690     ;	mov A, Temp1
                      1691     ;	subb A, #80h
                      1692     ;	jnc skypup_01
                      1693     ;	mov	Temp1, #RCP_MIN
                      1694     ; skypup_01:
                      1695     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1696     MOV NEW_RCP , R0 
0449    D268          1697     SETB FLAGS2 . 0 
                      1698     
                      1699     T2_INT_SKIP_START: 
                      1700     	; Check RC pulse skip counter
044B    E529          1701     	MOV	A, RCP_SKIP_CNT			
044D    6004          1702     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1703     	
                      1704     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1705     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1706     	AJMP	T2_INT_RCP_UPDATE_START
                      1707     
                      1708     T2_INT_SKIP_END: 
0453    741F          1709     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1710     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1711     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1712     
                      1713     	; Skip counter has reached zero, start looking for RC pulses again
                      1714     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1714+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1715     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1715+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1716     	
                      1717     T2_INT_RCP_UPDATE_START: 
                      1718     	; Process updated RC pulse
045E    206802        1719     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1720     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1721     
0463    E559          1722     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1723     MOV R0 , A 
0466    C268          1724     CLR FLAGS2 . 0 
                      1725     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1726     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1727     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1728     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1729     
                      1730     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1733     
                      1734     IF MODE == 2	; Multi
046E    7982          1735     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1736     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1737     ENDIF
                      1738     
                      1739     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1740     	CLR	C
0474    E8            1741     MOV A , R0 
0475    94F0          1742     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1743     	JC	T2_INT_RCP_UPDATE_MULT
                      1744     
0479    74F0          1745     	MOV	A, #240			; Set requested pwm to max
047B    F8            1746     MOV R0 , A 
                      1747     
                      1748     T2_INT_RCP_UPDATE_MULT: 	
                      1749     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1750     MOV A , R0 
047D    C4            1751     	SWAP	A			; After this "0.0625"
047E    540F          1752     	ANL	A, #0FH
0480    28            1753     ADD A , R0 
0481    F8            1754     MOV R0 , A 
                      1755     	; Adjust tail gain
0482    7984          1756     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1757     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1758     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1759     
0489    C3            1760     	CLR	C
048A    13            1761     	RRC	A			; After this "0.5"
048B    C3            1762     	CLR	C
048C    13            1763     	RRC	A			; After this "0.25"
048D    8721          1764     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1765     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1766     
0492    C3            1767     	CLR	C
0493    13            1768     	RRC	A			; After this "0.125"
                      1769     
                      1770     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1771     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1772     
0497    C3            1773     	CLR	C
0498    C8            1774     XCH A , R0 
0499    98            1775     SUBB A , R0 
049A    F8            1776     MOV R0 , A 
049B    81A4          1777     	AJMP	T2_INT_PWM_MIN_RUN
                      1778     
                      1779     T2_INT_RCP_GAIN_POS: 
049D    28            1780     ADD A , R0 
049E    F8            1781     MOV R0 , A 
049F    5003          1782     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1783     
04A1    74FF          1784     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1785     MOV R0 , A 
                      1786     
                      1787     T2_INT_PWM_MIN_RUN:  
                      1788     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1798     
                      1799     T2_INT_PWM_UPDATE:  
                      1800     	; Check if any startup phase flags are set
04A4    E52C          1801     	MOV	A, FLAGS1
04A6    5406          1802     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1803     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1804     
                      1805     	; Update requested_pwm
04AA    8822          1806     MOV REQUESTED_PWM , R0 
                      1807     	; Limit pwm during direct start
04AC    30630A        1808     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1809     
04AF    C3            1810     	CLR	C
04B0    E522          1811     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1812     	SUBB	A, PWM_LIMIT
04B4    4003          1813     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1814     
04B6    855E22        1815     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1816     
                      1817     T2_INT_CURRENT_PWM_UPDATE:  
                      1818     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1819     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1820     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1821     ENDIF
                      1822     
                      1823     	; Update current pwm, with limited throttle change rate
04BE    C3            1824     	CLR	C
04BF    E522          1825     	MOV	A, REQUESTED_PWM	 
04C1    9524          1826     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1827     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1828     
                      1829     	; 缓启动
04C5    78A1          1830     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1831     	;mov	Temp1, #1
04C7    96            1832     SUBB A , @ R0 
                      1833     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1834     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1835     
04CA    E524          1836     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1837     ADD A , @ R0 
                      1838     	; add	A, Temp1
04CD    F524          1839     	MOV	CURRENT_PWM, A
04CF    5009          1840     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1841     
04D1    7524FF        1842     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1843     	JMP	T2_INT_CURRENT_PWM_DONE
                      1844     
                      1845     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1846     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1847     T2_INT_CURRENT_PWM_DONE: 
                      1848     IF MODE >= 1	; Tail or multi
                      1849     	; Set current_pwm_limited
04DA    A824          1850     MOV R0 , CURRENT_PWM 
04DC    C3            1851     	CLR	C
04DD    E524          1852     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1853     	SUBB	A, PWM_LIMIT
04E1    4002          1854     	JC	($+4)					; If current pwm below limit - branch
                      1855     
04E3    A85E          1856     MOV R0 , PWM_LIMIT 
                      1857     
04E5    8825          1858     MOV CURRENT_PWM_LIMITED , R0 
                      1859     ENDIF
                      1860     T2_INT_PWM_EXIT: 	
                      1861     	; Check if high byte flag is set
04E7    20CF0C        1862     	JB	TF2H, T2H_INT		
04EA    D0E0          1863     	POP	ACC			; Restore preserved registers
04EC    D0D0          1864     	POP	PSW
04EE    C2D3          1865     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1866     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1867     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1868     	RETI
                      1869     
                      1870     T2H_INT: 
                      1871     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1872     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1873     MOV R0 , # 1 
                      1874     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1875     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1876     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1877     
                      1878     	; Decrement timeout counter (if PPM)
04FE    741F          1879     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1880     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1881     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1882     
0504    1528          1883     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1884     
                      1885     T2H_INT_RCP_STOP_CHECK: 
                      1886     	; Check RC pulse against stop value
0506    C3            1887     	CLR	C
0507    E559          1888     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1889     SUBB A , # 1 
050B    4005          1890     	JC	T2H_INT_RCP_STOP
                      1891     
                      1892     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1893     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1894     	AJMP	T2H_INT_RCP_GOV_PWM
                      1895     
                      1896     T2H_INT_RCP_STOP: 	
                      1897     	; RC pulse less than stop value
0512    755D00        1898     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1899     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1900     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1901     	ADD	A, #1
051C    F55C          1902     	MOV	RCP_STOP_CNT, A
051E    5003          1903     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1904     
0520    755CFF        1905     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1906     
                      1907     T2H_INT_RCP_GOV_PWM: 
                      1908     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      2037     IF MODE == 2	; Multi
0523    E55F          2038     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          2039     	ADD	A, #10
0527    5005          2040     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      2041     
0529    755FFF        2042     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          2043     	AJMP	T2H_INT_RCP_EXIT
                      2044     
                      2045     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          2046     	MOV	PWM_LIMIT_SPOOLUP, A
                      2047     ENDIF
                      2048     
                      2049     T2H_INT_RCP_EXIT: 
0530    D0E0          2050     	POP	ACC			; Restore preserved registers
0532    D0D0          2051     	POP	PSW
0534    C2D3          2052     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        2053     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          2054     	SETB	ET2			; Enable timer2 interrupts
053B    32            2055     	RETI
                      2056     
                      2057     
                      2058     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2059     ;
                      2060     ; Timer3 interrupt routine
                      2061     ;
                      2062     ; No assumptions
                      2063     ;
                      2064     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2065     T3_INT: 	; Used for commutation timing
053C    C2AF          2066     	CLR 	EA			; Disable all interrupts
053E    53917F        2067     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          2068     CLR FLAGS0 . 0 
0543    D2AF          2069     	SETB	EA			; Enable all interrupts
0545    32            2070     	RETI
                      2071     
                      2072     
                      2073     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2074     ;
                      2075     ; PCA interrupt routine
                      2076     ;
                      2077     ; No assumptions
                      2078     ;
                      2079     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2080     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2081     	CLR	EA
0548    53E6EF        2082     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2083     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2084     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2085     	PUSH	ACC
0551    C0F0          2086     	PUSH	B
0553    D2D3          2087     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2088     	SETB	EA
                      2089     	; Get the PCA counter values
                      2090     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2090+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2090+1   MOV R1 , PCA0CPH0 
                      2091     	; Clear interrupt flag
                      2092     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2092+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2093     	; Check which edge it is
055D    306902        2094     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          2095     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2096     
                      2097     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2097+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2097+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2097+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2097+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2097+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2098     SETB FLAGS2 . 1 
                      2099     	; Read RC signal level
                      2100     	READ_RCP_INT			
0573    E580          2100+1   MOV A , P0 
0575    307601        2100+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2100+1   CPL A  ; YES - INVERT
                      2101     	; Test RC signal level
0579    20E502        2102     JB ACC . 5 , ( $+5 ) 
057C    A185          2103     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2104     
                      2105     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2106     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2107     MOV RCP_PREV_EDGE_H , R1 
0582    0207D1        2108     	LJMP	PCA_INT_EXIT				; Exit
                      2109     
                      2110     PCA_INT_FAIL_MINIMUM: 
                      2111     	; Prepare for next interrupt
                      2112     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2112+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2112+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2112+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2112+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2112+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2113     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2113+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2114     CLR FLAGS2 . 1 
0598    741F          2115     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2116     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          2117     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      2118     
059E    E1B7          2119     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      2120     
05A0    7800          2121     MOV R0 , # 0 
                      2122     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          2122+1   MOV A , P0 
05A4    307601        2122+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            2122+1   CPL A  ; YES - INVERT
05A8    30E502        2123     JNB ACC . 5 , ( $+5 ) 
05AB    E1B7          2124     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      2125     
                      2126     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2127     ; 
                      2128     ; 对 RCP 信号处理
                      2129     ; 1 小于 1500us 最低油门
                      2130     ; 2 大于 1500us 正常处理
                      2131     ; 
                      2132     ;	clr C
                      2133     ;	mov A, Temp1
                      2134     ;	subb A, #80h
                      2135     ;	jnc skypup_02
                      2136     ;	mov	Temp1, #RCP_MIN
                      2137     ; skypup_02:
                      2138     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2139     
05AD    8859          2140     MOV NEW_RCP , R0 
05AF    E186          2141     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2142     
                      2143     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2144     	; Prepare for next interrupt
                      2145     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        2145+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        2145+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        2145+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        2145+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        2145+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          2146     CLR FLAGS2 . 1 
                      2147     	; Check if pwm frequency shall be measured
05C2    205902        2148     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          2149     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2150     
                      2151     	; Set second edge trig only during pwm frequency measurement
                      2152     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        2152+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        2152+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        2152+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        2152+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        2152+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2153     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          2153+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          2154     SETB FLAGS2 . 1 
                      2155     	; Store edge data to RAM
05DA    8854          2156     MOV RCP_EDGE_L , R0 
05DC    8955          2157     MOV RCP_EDGE_H , R1 
                      2158     	; Calculate pwm frequency
05DE    C3            2159     	CLR	C
05DF    E8            2160     MOV A , R0 
05E0    9552          2161     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            2162     MOV R0 , A 
05E3    E9            2163     MOV A , R1 
05E4    9553          2164     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            2165     MOV R1 , A 
05E7    E4            2166     	CLR	A
05E8    FB            2167     MOV R3 , A 
05E9    7AFA          2168     MOV R2 , # 250 
                      2169     	; Check if pwm frequency is 12kHz
05EB    C3            2170     	CLR	C
05EC    E8            2171     MOV A , R0 
05ED    94C8          2172     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            2173     MOV A , R1 
05F0    9400          2174     	SUBB	A, #HIGH(200)
05F2    5008          2175     	JNC	PCA_INT_CHECK_8KHZ
                      2176     
05F4    E4            2177     	CLR	A
05F5    D2E4          2178     SETB ACC . 4 
05F7    FB            2179     MOV R3 , A 
05F8    7A0A          2180     MOV R2 , # 10 
05FA    C13E          2181     	AJMP	PCA_INT_RESTORE_EDGE
                      2182     
                      2183     PCA_INT_CHECK_8KHZ: 
                      2184     	; Check if pwm frequency is 8kHz
05FC    C3            2185     	CLR	C
05FD    E8            2186     MOV A , R0 
05FE    9468          2187     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            2188     MOV A , R1 
0601    9401          2189     	SUBB	A, #HIGH(360)
0603    5008          2190     	JNC	PCA_INT_CHECK_4KHZ
                      2191     
0605    E4            2192     	CLR	A
0606    D2E3          2193     SETB ACC . 3 
0608    FB            2194     MOV R3 , A 
0609    7A0F          2195     MOV R2 , # 15 
060B    C13E          2196     	AJMP	PCA_INT_RESTORE_EDGE
                      2197     
                      2198     PCA_INT_CHECK_4KHZ: 
                      2199     	; Check if pwm frequency is 4kHz
060D    C3            2200     	CLR	C
060E    E8            2201     MOV A , R0 
060F    94D0          2202     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2203     MOV A , R1 
0612    9402          2204     	SUBB	A, #HIGH(720)
0614    5008          2205     	JNC	PCA_INT_CHECK_2KHZ
                      2206     
0616    E4            2207     	CLR	A
0617    D2E2          2208     SETB ACC . 2 
0619    FB            2209     MOV R3 , A 
061A    7A1E          2210     MOV R2 , # 30 
061C    C13E          2211     	AJMP	PCA_INT_RESTORE_EDGE
                      2212     
                      2213     PCA_INT_CHECK_2KHZ: 
                      2214     	; Check if pwm frequency is 2kHz
061E    C3            2215     	CLR	C
061F    E8            2216     MOV A , R0 
0620    94A0          2217     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2218     MOV A , R1 
0623    9405          2219     	SUBB	A, #HIGH(1440)
0625    5008          2220     	JNC	PCA_INT_CHECK_1KHZ
                      2221     
0627    E4            2222     	CLR	A
0628    D2E1          2223     SETB ACC . 1 
062A    FB            2224     MOV R3 , A 
062B    7A3C          2225     MOV R2 , # 60 
062D    C13E          2226     	AJMP	PCA_INT_RESTORE_EDGE
                      2227     
                      2228     PCA_INT_CHECK_1KHZ: 
                      2229     	; Check if pwm frequency is 1kHz
062F    C3            2230     	CLR	C
0630    E8            2231     MOV A , R0 
0631    9498          2232     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2233     MOV A , R1 
0634    9408          2234     	SUBB	A, #HIGH(2200)
0636    5006          2235     	JNC	PCA_INT_RESTORE_EDGE
                      2236     
0638    E4            2237     	CLR	A
0639    D2E0          2238     SETB ACC . 0 
063B    FB            2239     MOV R3 , A 
063C    7A78          2240     MOV R2 , # 120 
                      2241     
                      2242     PCA_INT_RESTORE_EDGE: 
                      2243     	; Calculate difference between this period and previous period
063E    C3            2244     	CLR	C
063F    E8            2245     MOV A , R0 
0640    9556          2246     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2247     MOV R4 , A 
0643    E9            2248     MOV A , R1 
0644    9557          2249     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2250     MOV R5 , A 
                      2251     	; Make positive
0647    30E708        2252     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2253     MOV A , R4 
064B    F4            2254     	CPL	A
064C    2401          2255     	ADD	A, #1
064E    FC            2256     MOV R4 , A 
064F    ED            2257     MOV A , R5 
0650    F4            2258     	CPL	A
0651    FD            2259     MOV R5 , A 
                      2260     
                      2261     PCA_INT_CHECK_DIFF: 
                      2262     	; Check difference
0652    755800        2263     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2264     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2265     
0657    C3            2266     	CLR	C
0658    EC            2267     MOV A , R4 
0659    9A            2268     SUBB A , R2 
065A    5003          2269     	JNC	PCA_INT_STORE_DATA
                      2270     
065C    755801        2271     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2272     
                      2273     PCA_INT_STORE_DATA: 
                      2274     	; Store previous period
065F    8856          2275     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2276     MOV RCP_PREV_PERIOD_H , R1 
                      2277     	; Restore edge data from RAM
0663    A854          2278     MOV R0 , RCP_EDGE_L 
0665    A955          2279     MOV R1 , RCP_EDGE_H 
                      2280     	; Store pre previous edge
0667    8852          2281     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2282     MOV RCP_PREPREV_EDGE_H , R1 
                      2283     
                      2284     PCA_INT_FALL: 
                      2285     	; RC pulse edge was second, calculate new pulse length
066B    C3            2286     	CLR	C
066C    E8            2287     MOV A , R0 
066D    9526          2288     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2289     MOV R0 , A 
0670    E9            2290     MOV A , R1 
0671    9527          2291     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2292     MOV R1 , A 
0674    307402        2293     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2294     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2295     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2296     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2297     
067E    307202        2298     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2299     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2300     
0683    E9            2301     MOV A , R1 
0684    C3            2302     	CLR	C
0685    13            2303     	RRC	A
0686    F9            2304     MOV R1 , A 
0687    E8            2305     MOV A , R0 
0688    13            2306     	RRC	A
0689    F8            2307     MOV R0 , A 
                      2308     
068A    307102        2309     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2310     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2311     
068F    E9            2312     MOV A , R1 
0690    C3            2313     	CLR	C
0691    13            2314     	RRC	A
0692    F9            2315     MOV R1 , A 
0693    E8            2316     MOV A , R0 
0694    13            2317     	RRC	A
0695    F8            2318     MOV R0 , A 
                      2319     
0696    307002        2320     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2321     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2322     
069B    E9            2323     MOV A , R1 
069C    C3            2324     	CLR	C
069D    13            2325     	RRC	A
069E    FD            2326     MOV R5 , A 
069F    E8            2327     MOV A , R0 
06A0    13            2328     	RRC	A
06A1    FC            2329     MOV R4 , A 
                      2330     	; Skip range limitation if pwm frequency measurement
06A2    205918        2331     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2332     
                      2333     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2334     	CLR	C
06A6    EC            2335     MOV A , R4 
06A7    941C          2336     	SUBB	A, #28
06A9    ED            2337     MOV A , R5 
06AA    9402          2338     	SUBB A, #2
06AC    4003          2339     	JC	($+5)						; No - proceed
                      2340     
06AE    0207B7        2341     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2342     
                      2343     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2344     MOV A , R5 
06B2    7009          2345     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2346     
06B4    C3            2347     	CLR	C
06B5    EC            2348     MOV A , R4 
06B6    94C8          2349     	SUBB	A, #200
06B8    5003          2350     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2351     
06BA    0207B7        2352     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2353     
                      2354     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2355     	; Calculate "1000us" plus throttle minimum
06BD    7400          2356     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2357     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2358     
                      2359     IF MODE >= 1	; Tail or multi
06C2    7888          2360     MOV R0 , # PGM_DIRECTION 
06C4    E6            2361     MOV A , @ R0 
                      2362     ENDIF
06C5    7896          2363     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2364     IF MODE >= 1	; Tail or multi
06C7    B40302        2365     	CJNE	A, #3, ($+5)
                      2366     
06CA    789E          2367     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2368     ENDIF
06CC    E6            2369     MOV A , @ R0 
                      2370     
                      2371     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2372     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2373     MOV R6 , A 
06D0    E4            2374     	CLR	A
06D1    3400          2375     	ADDC	A, #0
06D3    FF            2376     MOV R7 , A 
                      2377     
06D4    C3            2378     	CLR	C
06D5    EC            2379     MOV A , R4 
06D6    9E            2380     SUBB A , R6 
06D7    FC            2381     MOV R4 , A 
06D8    ED            2382     MOV A , R5 
06D9    9F            2383     SUBB A , R7 
06DA    FD            2384     MOV R5 , A 
                      2385     IF MODE >= 1	; Tail or multi
06DB    9208          2386     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2387     MOV R0 , # PGM_DIRECTION 
06DF    E6            2388     MOV A , @ R0 
06E0    B40322        2389     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2390     
06E3    A208          2391     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2392     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2393     
                      2394     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2395     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2396     
06EA    C2AF          2397     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2398     SETB FLAGS3 . 5 
06EE    C1F7          2399     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2400     
                      2401     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2402     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2403     
06F3    C2AF          2404     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2405     CLR FLAGS3 . 5 
                      2406     
                      2407     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2408     	ALL_NFETS_OFF
06F7    C292          2408+1   CLR P1 . 2 
06F9    C296          2408+1   CLR P1 . 6 
06FB    C295          2408+1   CLR P1 . 5 
                      2409     	ALL_PFETS_OFF
06FD    C293          2409+1   CLR P1 . 3 
06FF    C297          2409+1   CLR P1 . 7 
0701    C294          2409+1   CLR P1 . 4 
0703    D2AF          2410     	SETB	EA
                      2411     
                      2412     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2413     	MOV	C, BIT_ACCESS_INT.0
                      2414     ENDIF
0707    5017          2415     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2416     
                      2417     IF MODE >= 1	; Tail or multi
0709    E6            2418     MOV A , @ R0 
070A    B4030D        2419     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2420     
070D    EC            2421     MOV A , R4 
070E    F4            2422     	CPL	A
070F    2401          2423     	ADD	A, #1
0711    FC            2424     MOV R4 , A 
0712    ED            2425     MOV A , R5 
0713    F4            2426     	CPL	A
0714    3400          2427     	ADDC	A, #0
0716    FD            2428     MOV R5 , A 
0717    020720        2429     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2430     
                      2431     PCA_INT_PPM_UNIDIR_NEG: 
                      2432     ENDIF
071A    7800          2433     MOV R0 , # 0 
071C    7900          2434     MOV R1 , # 0 
071E    E16A          2435     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2436     
                      2437     PCA_INT_PPM_NEG_CHECKED: 
                      2438     IF MODE >= 1	; Tail or multi
0720    7888          2439     MOV R0 , # PGM_DIRECTION 
0722    E6            2440     MOV A , @ R0 
0723    B40315        2441     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2442     
0726    EC            2443     MOV A , R4 
0727    33            2444     	RLC	A
0728    FC            2445     MOV R4 A 
0729    ED            2446     MOV A , R5 
072A    33            2447     	RLC	A
072B    FD            2448     MOV R5 A 
072C    C3            2449     	CLR	C							; Subtract deadband
072D    EC            2450     MOV A , R4 
072E    9405          2451     	SUBB	A, #5		
0730    FC            2452     MOV R4 , A 
0731    ED            2453     MOV A , R5 
0732    9400          2454     	SUBB	A, #0
0734    FD            2455     MOV R5 , A 
0735    5004          2456     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2457     
0737    7C00          2458     MOV R4 , # 0 
0739    7D00          2459     MOV R5 , # 0 
                      2460     
                      2461     PCA_INT_PPM_BIDIR_DONE: 
                      2462     ENDIF
073B    C3            2463     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2464     MOV A , R4 
073D    94FF          2465     SUBB A , # 255 
073F    ED            2466     MOV A , R5 
0740    9400          2467     	SUBB	A, #0
0742    4006          2468     	JC	PCA_INT_PPM_MAX_CHECKED
                      2469     
0744    78FF          2470     MOV R0 , # 255 
0746    7900          2471     MOV R1 , # 0 
0748    E16A          2472     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2473     
                      2474     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2475     MOV A , R4 
074B    856EF0        2476     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2477     	MUL	AB
074F    C5F0          2478     	XCH	A, B
0751    A2F7          2479     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2480     	RLC	A
0754    F8            2481     MOV R0 , A 
0755    7900          2482     MOV R1 , # 0 
0757    4003          2483     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2484     	
0759    020786        2485     	JMP	PCA_INT_LIMITED			
                      2486     
                      2487     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2488     MOV R0 , # 255 
075E    7900          2489     MOV R1 , # 0 
0760    020786        2490     	JMP	PCA_INT_LIMITED			
                      2491     
                      2492     PCA_INT_PWM_DIVIDE: 
0763    E9            2493     MOV A , R1 
0764    C3            2494     	CLR	C
0765    13            2495     	RRC	A
0766    F9            2496     MOV R1 , A 
0767    E8            2497     MOV A , R0 
0768    13            2498     	RRC	A
0769    F8            2499     MOV R0 , A 
                      2500     
                      2501     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2502     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2503     MOV A , R1 
076E    6002          2504     	JZ	($+4)
                      2505     
0770    78FF          2506     MOV R0 , # 255 
                      2507     
0772    C3            2508     	CLR	C
0773    E8            2509     MOV A , R0 
0774    13            2510     	RRC	A
0775    38            2511     ADDC A , R0 
0776    F8            2512     MOV R0 , A 
0777    E4            2513     	CLR	A
0778    3400          2514     	ADDC	A, #0
077A    F9            2515     MOV R1 , A 
                      2516     
                      2517     PCA_INT_CHECK_LEGAL_RANGE: 
                      2518     	; Check that RC pulse is within legal range
077B    C3            2519     	CLR	C
077C    E8            2520     MOV A , R0 
077D    94FF          2521     SUBB A , # 255 
077F    E9            2522     MOV A , R1 
0780    9400          2523     	SUBB	A, #0
0782    4002          2524     	JC	PCA_INT_LIMITED
                      2525     
0784    78FF          2526     MOV R0 , # 255 
                      2527     
                      2528     PCA_INT_LIMITED: 
                      2529     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2530     ; 
                      2531     ; 对 RCP 信号处理
                      2532     ; 1 小于 1500us 最低油门
                      2533     ; 2 大于 1500us 正常处理
                      2534     ; 
0786    C3            2535     	CLR C
0787    E8            2536     MOV A , R0 
0788    94A0          2537     SUBB A , # 160 
078A    5002          2538     	JNC SKYPUP_03					; No 跳转
078C    7800          2539     MOV R0 , # 0 
                      2540     SKYPUP_03: 
                      2541     
078E    C3            2542     	CLR C
078F    E8            2543     MOV A , R0 
0790    9573          2544     	SUBB A, PREV_RCP				; 上一个 Rcp > 当前 Rcp ?
0792    400E          2545     	JC SKYPUP_04					; No
                      2546     
0794    9402          2547     SUBB A , # 2 
0796    400A          2548     	JC SKYPUP_04					; No
                      2549     
0798    C3            2550     	CLR C						; 这一句能否去掉? Skypup 2015.05.25
0799    E573          2551     	MOV A, PREV_RCP
079B    2402          2552     ADD A , # 2 
079D    F8            2553     MOV R0 , A 
079E    5002          2554     	JNC SKYPUP_04					; 没有发生进位溢出
                      2555     
07A0    78FF          2556     MOV R0 , # 0FFH 
                      2557     	
                      2558     SKYPUP_04: 
07A2    E559          2559     	MOV A, NEW_RCP
07A4    F573          2560     	MOV PREV_RCP, A
                      2561     
                      2562     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2563     	; RC pulse value accepted
07A6    8859          2564     MOV NEW_RCP , R0 
07A8    D268          2565     SETB FLAGS2 . 0 
07AA    205902        2566     JB FLAGS0 . 1 , ( $+5 ) 
07AD    E1B7          2567     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2568     
07AF    741F          2569     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B1    F4            2570     	CPL	A
07B2    552E          2571     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07B4    4B            2572     ORL A , R3 
07B5    F52E          2573     	MOV	FLAGS3, A
                      2574     
                      2575     PCA_INT_SET_TIMEOUT: 
07B7    752818        2576     MOV RCP_TIMEOUT_CNT , # 24 
07BA    741F          2577     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07BC    552E          2578     	ANL	A, FLAGS3					; Check pwm frequency flags
07BE    7003          2579     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2580     
07C0    75280A        2581     MOV RCP_TIMEOUT_CNT , # 10 
                      2582     
                      2583     PCA_INT_PPM_TIMEOUT_SET: 
07C3    305902        2584     JNB FLAGS0 . 1 , ( $+5 ) 
07C6    E1D1          2585     	AJMP PCA_INT_EXIT				; Yes - exit
                      2586     
07C8    741F          2587     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07CA    552E          2588     	ANL	A, FLAGS3					; Check pwm frequency flags
07CC    6003          2589     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2590     
                      2591     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07CE    53DAFE        2591+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2592     
                      2593     PCA_INT_EXIT: 	; Exit interrupt routine	
07D1    752906        2594     MOV RCP_SKIP_CNT , # 6 
07D4    741F          2595     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07D6    552E          2596     	ANL	A, FLAGS3					; Check pwm frequency flags
07D8    7003          2597     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2598     
07DA    75290A        2599     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2600     
07DD    D0F0          2601     	POP	B			; Restore preserved registers
07DF    D0E0          2602     	POP	ACC			
07E1    D0D0          2603     	POP	PSW
07E3    C2D3          2604     	CLR	PSW.3		; Select register bank 0 for main program routines	
07E5    D2AD          2605     	SETB	ET2			; Enable timer2 interrupts
07E7    43E610        2606     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07EA    32            2607     	RETI
                      2608     
                      2609     
                      2610     
                      2611     
                      2612     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2613     ;
                      2614     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2615     ;
                      2616     ; No assumptions
                      2617     ;
                      2618     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2619     WAIT1MS: 	
07EB    7901          2620     MOV R1 , # 1 
07ED    020809        2621     	JMP	WAITXMS_O
                      2622     
                      2623     WAIT3MS: 	
07F0    7903          2624     MOV R1 , # 3 
07F2    020809        2625     	JMP	WAITXMS_O
                      2626     
                      2627     WAIT10MS: 	
07F5    790A          2628     MOV R1 , # 10 
07F7    020809        2629     	JMP	WAITXMS_O
                      2630     
                      2631     WAIT30MS: 	
07FA    791E          2632     MOV R1 , # 30 
07FC    020809        2633     	JMP	WAITXMS_O
                      2634     
                      2635     WAIT100MS: 	
07FF    7964          2636     MOV R1 , # 100 
0801    020809        2637     	JMP	WAITXMS_O
                      2638     
                      2639     WAIT200MS: 	
0804    79C8          2640     MOV R1 , # 200 
0806    020809        2641     	JMP	WAITXMS_O
                      2642     
                      2643     WAITXMS_O: 	; Outer loop
0809    7817          2644     MOV R0 , # 23 
                      2645     WAITXMS_M: 	; Middle loop
080B    E4            2646     	CLR	A
080C    D5E0FD        2647      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
080F    D8FA          2648     DJNZ R0 , WAITXMS_M 
0811    D9F6          2649     DJNZ R1 , WAITXMS_O 
0813    22            2650     	RET
                      2651     
                      2652     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2653     ;
                      2654     ; Wait 1 second routine
                      2655     ;
                      2656     ; No assumptions
                      2657     ;
                      2658     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2659     WAIT1S: 
0814    7C05          2660     MOV R4 , # 5 
                      2661     WAIT1S_LOOP: 
0816    1104          2662     	CALL WAIT200MS
0818    DCFC          2663     DJNZ R4 , WAIT1S_LOOP 
081A    22            2664     	RET
                      2665     
                      2666     
                      2667     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2668     ;
                      2669     ; Beeper routines (4 different entry points) 
                      2670     ;
                      2671     ; No assumptions
                      2672     ;
                      2673     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2674     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
081B    7A14          2675     MOV R2 , # 20 
081D    7B78          2676     MOV R3 , # 120 
081F    020837        2677     	JMP	BEEP
                      2678     
                      2679     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0822    7A10          2680     MOV R2 , # 16 
0824    7B8C          2681     MOV R3 , # 140 
0826    020837        2682     	JMP	BEEP
                      2683     
                      2684     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0829    7A0D          2685     MOV R2 , # 13 
082B    7BB4          2686     MOV R3 , # 180 
082D    020837        2687     	JMP	BEEP
                      2688     
                      2689     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0830    7A0B          2690     MOV R2 , # 11 
0832    7BC8          2691     MOV R3 , # 200 
0834    020837        2692     	JMP	BEEP
                      2693     
                      2694     BEEP: 	; Beep loop start
0837    AC25          2695     MOV R4 , CURRENT_PWM_LIMITED 
0839    752501        2696     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
083C    7902          2697     MOV R1 , # 2 
                      2698     BEEP_ONOFF: 
083E    B275          2699     CPL FLAGS3 . 5 
0840    E4            2700     	CLR	A
                      2701     	BPFET_OFF			; BpFET off
0841    C294          2701+1   CLR P1 . 4 
0843    D5E0FD        2702     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2703     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0846    E525          2703+1   MOV A , CURRENT_PWM_LIMITED 
0848    6002          2703+1   JZ ( $+4 ) 
084A    D295          2703+1   SETB P1 . 5 
084C    D5E0FD        2704     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2705     	BNFET_OFF			; BnFET off again
084F    C295          2705+1   CLR P1 . 5 
0851    D5E0FD        2706     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2707     	BPFET_ON			; BpFET on
0854    D294          2707+1   SETB P1 . 4 
0856    D5E0FD        2708     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2709     	; Turn on nfet
                      2710     	ANFET_ON			; AnFET on
0859    E525          2710+1   MOV A , CURRENT_PWM_LIMITED 
085B    600A          2710+1   JZ ( $+12 ) 
085D    207502        2710+1   JB FLAGS3 . 5 , ( $+5 ) 
0860    D292          2710+1   SETB P1 . 2 
0862    307502        2710+1   JNB FLAGS3 . 5 , ( $+5 ) 
0865    D296          2710+1   SETB P1 . 6 
0867    E56F          2711     	MOV	A, BEEP_STRENGTH
0869    D5E0FD        2712     	DJNZ	ACC, $		
                      2713     	; Turn off nfet
                      2714     	ANFET_OFF			; AnFET off
086C    207502        2714+1   JB FLAGS3 . 5 , ( $+5 ) 
086F    C292          2714+1   CLR P1 . 2 
0871    307502        2714+1   JNB FLAGS3 . 5 , ( $+5 ) 
0874    C296          2714+1   CLR P1 . 6 
0876    7496          2715     	MOV	A, #150		; 25s off
0878    D5E0FD        2716     	DJNZ	ACC, $		
087B    D9C1          2717     DJNZ R1 , BEEP_ONOFF 
                      2718     	; Copy variable
087D    EA            2719     MOV A , R2 
087E    F8            2720     MOV R0 , A 
                      2721     BEEP_OFF: 		; Fets off loop
087F    D5E0FD        2722     	DJNZ	ACC, $
0882    D8FB          2723     DJNZ R0 , BEEP_OFF 
0884    DBB1          2724     DJNZ R3 , BEEP 
                      2725     	BPFET_OFF			; BpFET off
0886    C294          2725+1   CLR P1 . 4 
0888    8C25          2726     MOV CURRENT_PWM_LIMITED , R4 
088A    22            2727     	RET
                      2728     
                      2729     
                      2730     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2731     ;
                      2732     ; Division 16bit unsigned by 16bit unsigned
                      2733     ;
                      2734     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2735     ; Result will be in Temp2/Temp1
                      2736     ;
                      2737     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2738     DIV_U16_BY_U16: 	
088B    C3            2739     	CLR	C       
088C    7C00          2740     MOV R4 , # 0 
088E    7D00          2741     MOV R5 , # 0 
0890    75F000        2742     	MOV	B, #0
                      2743     DIV_U16_BY_U16_DIV1: 
0893    05F0          2744     	INC	B      			; Increment counter for each left shift
0895    EA            2745     MOV A , R2 
0896    33            2746     	RLC	A      		
0897    FA            2747     MOV R2 , A 
0898    EB            2748     MOV A , R3 
0899    33            2749     	RLC	A      	  	
089A    FB            2750     MOV R3 , A 
089B    50F6          2751     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2752     DIV_U16_BY_U16_DIV2:         
089D    EB            2753     MOV A , R3 
089E    13            2754     	RRC	A      
089F    FB            2755     MOV R3 , A 
08A0    EA            2756     MOV A , R2 
08A1    13            2757     	RRC	A      
08A2    FA            2758     MOV R2 , A 
08A3    C3            2759     	CLR	C      
08A4    E9            2760     MOV A , R1 
08A5    FF            2761     MOV R7 , A 
08A6    E8            2762     MOV A , R0 
08A7    FE            2763     MOV R6 , A 
08A8    E8            2764     MOV A , R0 
08A9    9A            2765     SUBB A , R2 
08AA    F8            2766     MOV R0 , A 
08AB    E9            2767     MOV A , R1 
08AC    9B            2768     SUBB A , R3 
08AD    F9            2769     MOV R1 , A 
08AE    5004          2770     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08B0    EF            2771     MOV A , R7 
08B1    F9            2772     MOV R1 , A 
08B2    EE            2773     MOV A , R6 
08B3    F8            2774     MOV R0 , A 
                      2775     DIV_U16_BY_U16_DIV3: 
08B4    B3            2776     	CPL	C      			; Invert carry, so it can be directly copied into result
08B5    EC            2777     MOV A , R4 
08B6    33            2778     	RLC	A      			; Shift carry flag into temporary result
08B7    FC            2779     MOV R4 , A 
08B8    ED            2780     MOV A , R5 
08B9    33            2781     	RLC	A
08BA    FD            2782     MOV R5 , A 
08BB    D5F0DF        2783     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08BE    ED            2784     MOV A , R5 
08BF    F9            2785     MOV R1 , A 
08C0    EC            2786     MOV A , R4 
08C1    F8            2787     MOV R0 , A 
08C2    22            2788     	RET
                      2789     
                      2790     
                      2791     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2792     ;
                      2793     ; Multiplication 16bit signed by 8bit unsigned
                      2794     ;
                      2795     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2796     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2797     ;
                      2798     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2799     MULT_S16_BY_U8_DIV_16: 
08C3    E8            2800     MOV A , R0 
08C4    89F0          2801     MOV B , R1 
08C6    8A20          2802     MOV BIT_ACCESS , R2 
08C8    D2D4          2803     	SETB	PSW.4		; Select register bank 2 for math routines
08CA    F8            2804     MOV R0 , A 
08CB    A9F0          2805     MOV R1 , B 
08CD    7B00          2806     MOV R3 , # 0 
08CF    30F70B        2807     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2808     
08D2    7BFF          2809     MOV R3 , # 0FFH 
08D4    F4            2810     	CPL	A
08D5    2401          2811     	ADD	A, #1
08D7    F8            2812     MOV R0 , A 
08D8    E9            2813     MOV A , R1 
08D9    F4            2814     	CPL	A
08DA    3400          2815     	ADDC	A, #0
08DC    F9            2816     MOV R1 , A 
                      2817     MULT_S16_BY_U8_POSITIVE: 
08DD    E8            2818     MOV A , R0 
08DE    8520F0        2819     	MOV	B, BIT_ACCESS
08E1    A4            2820     	MUL	AB
08E2    ADF0          2821     MOV R5 , B 
08E4    F8            2822     MOV R0 , A 
08E5    E9            2823     MOV A , R1 
08E6    8520F0        2824     	MOV	B, BIT_ACCESS
08E9    A4            2825     	MUL	AB
08EA    AFF0          2826     MOV R7 , B 
08EC    FE            2827     MOV R6 , A 
08ED    ED            2828     MOV A , R5 
08EE    2E            2829     ADD A , R6 
08EF    F9            2830     MOV R1 , A 
08F0    7400          2831     	MOV	A, #0
08F2    3F            2832     ADDC A , R7 
08F3    FA            2833     MOV R2 , A 
08F4    7C04          2834     MOV R4 , # 4 
                      2835     MULT_S16_BY_U8_DIV_LOOP: 
08F6    C3            2836     	CLR	C			; Rotate right 
08F7    EA            2837     MOV A , R2 
08F8    13            2838     	RRC	A
08F9    FA            2839     MOV R2 , A 
08FA    E9            2840     MOV A , R1 
08FB    13            2841     	RRC	A
08FC    F9            2842     MOV R1 , A 
08FD    E8            2843     MOV A , R0 
08FE    13            2844     	RRC	A
08FF    F8            2845     MOV R0 , A 
0900    DCF4          2846     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2847     
0902    8BF0          2848     MOV B , R3 
0904    30F70A        2849     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2850     
0907    E8            2851     MOV A , R0 
0908    F4            2852     	CPL	A
0909    2401          2853     	ADD	A, #1
090B    F8            2854     MOV R0 , A 
090C    E9            2855     MOV A , R1 
090D    F4            2856     	CPL	A
090E    3400          2857     	ADDC	A, #0
0910    F9            2858     MOV R1 , A 
                      2859     
                      2860     MULT_S16_BY_U8_EXIT: 
0911    E8            2861     MOV A , R0 
0912    89F0          2862     MOV B , R1 
0914    C2D4          2863     	CLR	PSW.4		; Select normal register bank
0916    F8            2864     MOV R0 , A 
0917    A9F0          2865     MOV R1 , B 
0919    22            2866     	RET
                      2867     
                      2868     
                      2869     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2870     ;
                      2871     ; Calculate governor routines
                      2872     ;
                      2873     ; No assumptions
                      2874     ;
                      2875     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2876     ; The governor task is split into several routines in order to distribute processing time
                      2877     ;
                      2878     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2879     ; First governor routine - calculate governor target
                      2880     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3020     IF MODE == 2	; Multi
                      3021     CALC_GOVERNOR_TARGET: 
091A    7882          3022     MOV R0 , # PGM_GOV_MODE 
091C    B60403        3023     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
091F    020976        3024     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3025     
                      3026     GOVERNOR_TARGET_CALC: 
                      3027     	; Stop governor for stop RC pulse	
0922    C3            3028     	CLR	C
0923    E559          3029     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0925    9401          3030     SUBB A , # 1 
0927    4003          3031     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3032     
0929    02093F        3033     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3034     
                      3035     GOVERNOR_DEACTIVATE: 
092C    852224        3036     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
092F    E4            3037     	CLR	A
0930    F540          3038     	MOV	GOV_TARGET_L, A			; Set target to zero
0932    F541          3039     	MOV	GOV_TARGET_H, A
0934    F542          3040     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0936    F543          3041     	MOV	GOV_INTEGRAL_H, A
0938    F544          3042     	MOV	GOV_INTEGRAL_X, A
093A    F549          3043     	MOV	GOV_ACTIVE, A
093C    020976        3044     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3045     
                      3046     GOVERNOR_ACTIVATE: 
093F    7882          3047     MOV R0 , # PGM_GOV_MODE 
0941    E6            3048     MOV A , @ R0 
0942    FC            3049     MOV R4 , A 
0943    754901        3050     	MOV	GOV_ACTIVE, #1
0946    E522          3051     	MOV	A, REQUESTED_PWM			; Load requested pwm
0948    F523          3052     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3053     	; Calculate comm period target 2*(51000/Requested_Pwm)
094A    7838          3054     MOV R0 , # 38H 
094C    79C7          3055     MOV R1 , # 0C7H 
094E    AA3C          3056     MOV R2 , COMM_PERIOD4X_L 
0950    AB3D          3057     MOV R3 , COMM_PERIOD4X_H 
                      3058     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
0952    C3            3059     	CLR	C
0953    EB            3060     MOV A , R3 
0954    13            3061     	RRC	A
0955    FB            3062     MOV R3 , A 
0956    EA            3063     MOV A , R2 
0957    13            3064     	RRC	A
0958    FA            3065     MOV R2 , A 
                      3066     	; Check range
0959    EC            3067     MOV A , R4 
095A    14            3068     	DEC	A
095B    6013          3069     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3070     GOVERNOR_ACTIVATE_100K: 
095D    C3            3071     	CLR	C
095E    EB            3072     MOV A , R3 
095F    13            3073     	RRC	A
0960    FB            3074     MOV R3 , A 
0961    EA            3075     MOV A , R2 
0962    13            3076     	RRC	A
0963    FA            3077     MOV R2 , A 
0964    EC            3078     MOV A , R4 
0965    14            3079     	DEC	A
0966    14            3080     	DEC	A
0967    6007          3081     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3082     GOVERNOR_ACTIVATE_50K: 
0969    C3            3083     	CLR	C
096A    EB            3084     MOV A , R3 
096B    13            3085     	RRC	A
096C    FB            3086     MOV R3 , A 
096D    EA            3087     MOV A , R2 
096E    13            3088     	RRC	A
096F    FA            3089     MOV R2 , A 
                      3090     GOVERNOR_ACTIVATE_RANGE_SET: 
0970    118B          3091     	CALL	DIV_U16_BY_U16
                      3092     	; Store governor target
0972    8840          3093     MOV GOV_TARGET_L , R0 
0974    8941          3094     MOV GOV_TARGET_H , R1 
                      3095     CALC_GOVERNOR_TARGET_EXIT: 
0976    22            3096     	RET						
                      3097     ENDIF
                      3098     
                      3099     
                      3100     ; Second governor routine - calculate governor proportional error
                      3101     CALC_GOVERNOR_PROP_ERROR: 
                      3102     	; Exit if governor is inactive
0977    E549          3103     	MOV	A, GOV_ACTIVE
0979    6034          3104     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3105     
                      3106     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3124     IF MODE == 2	; Multi
                      3125     	; Calculate error
097B    C3            3126     	CLR	C
097C    E540          3127     	MOV	A, GOV_TARGET_L
097E    9523          3128     	SUBB	A, GOVERNOR_REQ_PWM
0980    F8            3129     MOV R0 , A 
0981    E541          3130     	MOV	A, GOV_TARGET_H
0983    9400          3131     	SUBB	A, #0
0985    F9            3132     MOV R1 , A 
                      3133     ENDIF
                      3134     	; Check error and limit
0986    500C          3135     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3136     
0988    C3            3137     	CLR	C
0989    E8            3138     MOV A , R0 
098A    9480          3139     	SUBB	A, #80H					; Is error too negative?
098C    E9            3140     MOV A , R1 
098D    94FF          3141     	SUBB	A, #0FFH
098F    4016          3142     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0991    0209AB        3143     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3144     
                      3145     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0994    C3            3146     	CLR	C
0995    E8            3147     MOV A , R0 
0996    947F          3148     	SUBB	A, #7FH					; Is error too positive?
0998    E9            3149     MOV A , R1 
0999    9400          3150     	SUBB	A, #00H
099B    5003          3151     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
099D    0209AB        3152     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3153     
                      3154     GOVERNOR_LIMIT_PROP_ERROR_POS: 
09A0    787F          3155     MOV R0 , # 7FH 
09A2    7900          3156     MOV R1 , # 00H 
09A4    0209AB        3157     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3158     
                      3159     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09A7    7880          3160     MOV R0 , # 80H 
09A9    79FF          3161     MOV R1 , # 0FFH 
                      3162     
                      3163     GOVERNOR_STORE_PROP_ERROR: 
                      3164     	; Store proportional
09AB    8845          3165     MOV GOV_PROPORTIONAL_L , R0 
09AD    8946          3166     MOV GOV_PROPORTIONAL_H , R1 
                      3167     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09AF    22            3168     	RET						
                      3169     
                      3170     
                      3171     ; Third governor routine - calculate governor integral error
                      3172     CALC_GOVERNOR_INT_ERROR: 
                      3173     	; Exit if governor is inactive
09B0    E549          3174     	MOV	A, GOV_ACTIVE
09B2    6058          3175     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3176     
                      3177     	; Add proportional to integral
09B4    E545          3178     	MOV	A, GOV_PROPORTIONAL_L
09B6    2542          3179     	ADD	A, GOV_INTEGRAL_L
09B8    F8            3180     MOV R0 , A 
09B9    E546          3181     	MOV	A, GOV_PROPORTIONAL_H
09BB    3543          3182     	ADDC	A, GOV_INTEGRAL_H
09BD    F9            3183     MOV R1 , A 
09BE    854620        3184     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09C1    E4            3185     	CLR	A
09C2    300701        3186     	JNB	BIT_ACCESS.7, ($+4)			
09C5    F4            3187     	CPL	A
09C6    3544          3188     	ADDC	A, GOV_INTEGRAL_X
09C8    FA            3189     MOV R2 , A 
                      3190     	; Check integral and limit
09C9    30E709        3191     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3192     
09CC    C3            3193     	CLR	C
09CD    EA            3194     MOV A , R2 
09CE    94F0          3195     	SUBB	A, #0F0H					; Is error too negative?
09D0    4015          3196     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09D2    0209ED        3197     	JMP	GOVERNOR_CHECK_PWM
                      3198     
                      3199     GOVERNOR_CHECK_INT_LIMIT_POS: 
09D5    C3            3200     	CLR	C
09D6    EA            3201     MOV A , R2 
09D7    940F          3202     	SUBB	A, #0FH					; Is error too positive?
09D9    5003          3203     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09DB    0209ED        3204     	JMP	GOVERNOR_CHECK_PWM
                      3205     
                      3206     GOVERNOR_LIMIT_INT_ERROR_POS: 
09DE    78FF          3207     MOV R0 , # 0FFH 
09E0    79FF          3208     MOV R1 , # 0FFH 
09E2    7A0F          3209     MOV R2 , # 0FH 
09E4    0209ED        3210     	JMP	GOVERNOR_CHECK_PWM
                      3211     
                      3212     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09E7    7800          3213     MOV R0 , # 00H 
09E9    7900          3214     MOV R1 , # 00H 
09EB    7AF0          3215     MOV R2 , # 0F0H 
                      3216     
                      3217     GOVERNOR_CHECK_PWM: 
                      3218     	; Check current pwm
09ED    C3            3219     	CLR	C
09EE    E524          3220     	MOV	A, CURRENT_PWM
09F0    955E          3221     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09F2    5006          3222     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3223     
09F4    E524          3224     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09F6    6009          3225     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3226     
09F8    4106          3227     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3228     
                      3229     GOVERNOR_INT_MAX_PWM: 
09FA    E546          3230     	MOV	A, GOV_PROPORTIONAL_H
09FC    20E70D        3231     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3232     
09FF    4106          3233     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3234     
                      3235     GOVERNOR_INT_MIN_PWM: 
0A01    E546          3236     	MOV	A, GOV_PROPORTIONAL_H
0A03    30E706        3237     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3238     
                      3239     GOVERNOR_STORE_INT_ERROR: 
                      3240     	; Store integral
0A06    8842          3241     MOV GOV_INTEGRAL_L , R0 
0A08    8943          3242     MOV GOV_INTEGRAL_H , R1 
0A0A    8A44          3243     MOV GOV_INTEGRAL_X , R2 
                      3244     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A0C    22            3245     	RET						
                      3246     
                      3247     
                      3248     ; Fourth governor routine - calculate governor proportional correction
                      3249     CALC_GOVERNOR_PROP_CORRECTION: 
                      3250     	; Exit if governor is inactive
0A0D    E549          3251     	MOV	A, GOV_ACTIVE
0A0F    7003          3252     	JNZ	CALC_GOVERNOR_PROP_CORR
0A11    020A70        3253     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3254     
                      3255     CALC_GOVERNOR_PROP_CORR: 
                      3256     	; Load proportional gain
0A14    789F          3257     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A16    E6            3258     MOV A , @ R0 
0A17    FA            3259     MOV R2 , A 
                      3260     	; Load proportional
0A18    C3            3261     	CLR	C
0A19    E545          3262     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A1B    33            3263     	RLC	A
0A1C    F8            3264     MOV R0 , A 
0A1D    E546          3265     	MOV	A, GOV_PROPORTIONAL_H
0A1F    33            3266     	RLC	A
0A20    F9            3267     MOV R1 , A 
                      3268     	; Apply gain
0A21    11C3          3269     	CALL	MULT_S16_BY_U8_DIV_16
                      3270     	; Check error and limit (to low byte)
0A23    E9            3271     MOV A , R1 
0A24    30E70B        3272     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3273     
0A27    C3            3274     	CLR	C
0A28    E8            3275     MOV A , R0 
0A29    9480          3276     	SUBB	A, #80H					; Is error too negative?
0A2B    E9            3277     MOV A , R1 
0A2C    94FF          3278     	SUBB	A, #0FFH
0A2E    4013          3279     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A30    4147          3280     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3281     
                      3282     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A32    C3            3283     	CLR	C
0A33    E8            3284     MOV A , R0 
0A34    947F          3285     	SUBB	A, #7FH					; Is error too positive?
0A36    E9            3286     MOV A , R1 
0A37    9400          3287     	SUBB	A, #00H
0A39    5002          3288     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A3B    4147          3289     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3290     
                      3291     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A3D    787F          3292     MOV R0 , # 7FH 
0A3F    7900          3293     MOV R1 , # 00H 
0A41    4147          3294     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3295     
                      3296     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A43    7880          3297     MOV R0 , # 80H 
0A45    79FF          3298     MOV R1 , # 0FFH 
                      3299     
                      3300     GOVERNOR_APPLY_PROP_CORR: 
                      3301     	; Test proportional sign
0A47    E8            3302     MOV A , R0 
0A48    20E715        3303     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3304     
                      3305     	; Subtract positive proportional
0A4B    C3            3306     	CLR	C
0A4C    E523          3307     	MOV	A, GOVERNOR_REQ_PWM
0A4E    98            3308     SUBB A , R0 
0A4F    F8            3309     MOV R0 , A 
                      3310     	; Check result
0A50    4009          3311     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3312     
0A52    C3            3313     	CLR	C
0A53    E8            3314     MOV A , R0 
0A54    9401          3315     	SUBB	A, #1
0A56    4003          3316     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A58    020A6E        3317     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3318     
                      3319     GOVERNOR_CORR_PROP_MIN_PWM: 
0A5B    7801          3320     MOV R0 , # 1 
0A5D    020A6E        3321     	JMP	GOVERNOR_STORE_PROP_CORR
                      3322     
                      3323     GOVERNOR_CORR_NEG_PROP: 
                      3324     	; Add negative proportional
0A60    E8            3325     MOV A , R0 
0A61    F4            3326     	CPL	A
0A62    2401          3327     	ADD	A, #1
0A64    2523          3328     	ADD	A, GOVERNOR_REQ_PWM
0A66    F8            3329     MOV R0 , A 
                      3330     	; Check result
0A67    4003          3331     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A69    020A6E        3332     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3333     
                      3334     GOVERNOR_CORR_PROP_MAX_PWM: 
0A6C    78FF          3335     MOV R0 , # 255 
                      3336     GOVERNOR_STORE_PROP_CORR: 
                      3337     	; Store proportional pwm
0A6E    8847          3338     MOV GOV_PROP_PWM , R0 
                      3339     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A70    22            3340     	RET
                      3341     
                      3342     
                      3343     ; Fifth governor routine - calculate governor integral correction
                      3344     CALC_GOVERNOR_INT_CORRECTION: 
                      3345     	; Exit if governor is inactive
0A71    E549          3346     	MOV	A, GOV_ACTIVE
0A73    7003          3347     	JNZ	CALC_GOVERNOR_INT_CORR
0A75    020AD2        3348     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3349     
                      3350     CALC_GOVERNOR_INT_CORR: 
                      3351     	; Load integral gain
0A78    78A0          3352     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A7A    E6            3353     MOV A , @ R0 
0A7B    FA            3354     MOV R2 , A 
                      3355     	; Load integral
0A7C    A843          3356     MOV R0 , GOV_INTEGRAL_H 
0A7E    A944          3357     MOV R1 , GOV_INTEGRAL_X 
                      3358     	; Apply gain
0A80    11C3          3359     	CALL	MULT_S16_BY_U8_DIV_16
                      3360     	; Check integral and limit
0A82    E9            3361     MOV A , R1 
0A83    30E70C        3362     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3363     
0A86    C3            3364     	CLR	C
0A87    E8            3365     MOV A , R0 
0A88    9401          3366     	SUBB	A, #01H					; Is integral too negative?
0A8A    E9            3367     MOV A , R1 
0A8B    94FF          3368     	SUBB	A, #0FFH
0A8D    4016          3369     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A8F    020AA9        3370     	JMP	GOVERNOR_APPLY_INT_CORR
                      3371     
                      3372     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A92    C3            3373     	CLR	C
0A93    E8            3374     MOV A , R0 
0A94    94FF          3375     	SUBB	A, #0FFH					; Is integral too positive?
0A96    E9            3376     MOV A , R1 
0A97    9400          3377     	SUBB	A, #00H
0A99    5003          3378     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A9B    020AA9        3379     	JMP	GOVERNOR_APPLY_INT_CORR
                      3380     
                      3381     GOVERNOR_LIMIT_INT_CORR_POS: 
0A9E    78FF          3382     MOV R0 , # 0FFH 
0AA0    7900          3383     MOV R1 , # 00H 
0AA2    020AA9        3384     	JMP	GOVERNOR_APPLY_INT_CORR
                      3385     
                      3386     GOVERNOR_LIMIT_INT_CORR_NEG: 
0AA5    7801          3387     MOV R0 , # 01H 
0AA7    79FF          3388     MOV R1 , # 0FFH 
                      3389     
                      3390     GOVERNOR_APPLY_INT_CORR: 
                      3391     	; Test integral sign
0AA9    E9            3392     MOV A , R1 
0AAA    20E715        3393     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3394     
                      3395     	; Subtract positive integral
0AAD    C3            3396     	CLR	C
0AAE    E547          3397     	MOV	A, GOV_PROP_PWM
0AB0    98            3398     SUBB A , R0 
0AB1    F8            3399     MOV R0 , A 
                      3400     	; Check result
0AB2    4009          3401     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3402     
0AB4    C3            3403     	CLR	C
0AB5    E8            3404     MOV A , R0 
0AB6    9401          3405     	SUBB	A, #1
0AB8    4003          3406     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0ABA    020AD0        3407     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3408     
                      3409     GOVERNOR_CORR_INT_MIN_PWM: 
0ABD    7800          3410     MOV R0 , # 0 
0ABF    020AD0        3411     	JMP	GOVERNOR_STORE_INT_CORR
                      3412     
                      3413     GOVERNOR_CORR_NEG_INT: 
                      3414     	; Add negative integral
0AC2    E8            3415     MOV A , R0 
0AC3    F4            3416     	CPL	A
0AC4    2401          3417     	ADD	A, #1
0AC6    2547          3418     	ADD	A, GOV_PROP_PWM
0AC8    F8            3419     MOV R0 , A 
                      3420     	; Check result
0AC9    4003          3421     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0ACB    020AD0        3422     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3423     
                      3424     GOVERNOR_CORR_INT_MAX_PWM: 
0ACE    78FF          3425     MOV R0 , # 255 
                      3426     GOVERNOR_STORE_INT_CORR: 
                      3427     	; Store current pwm
0AD0    8824          3428     MOV CURRENT_PWM , R0 
                      3429     CALC_GOVERNOR_INT_CORR_EXIT: 
0AD2    22            3430     	RET
                      3431     
                      3432     
                      3433     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3434     ;
                      3435     ; Measure lipo cells
                      3436     ;
                      3437     ; No assumptions
                      3438     ;
                      3439     ; Measure voltage and calculate lipo cells
                      3440     ;
                      3441     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3442     MEASURE_LIPO_CELLS: 
                      3443     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3447     MEASURE_LIPO_START: 
                      3448     	; Load programmed low voltage limit
0AD3    7883          3449     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AD5    E6            3450     MOV A , @ R0 
0AD6    F520          3451     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3452     	; Set commutation to BpFET on
0AD8    120FF1        3453     	CALL	COMM5COMM6			
                      3454     	; Start adc
                      3455     	START_ADC 
0ADB    75E890        3455+1   MOV ADC0CN , # 90H  ; ADC START
                      3456     	; Wait for ADC reference to settle, and then start again
0ADE    1207EB        3457     	CALL	WAIT1MS
                      3458     	START_ADC
0AE1    75E890        3458+1   MOV ADC0CN , # 90H  ; ADC START
                      3459     	; Wait for ADC conversion to complete
                      3460     MEASURE_LIPO_WAIT_ADC: 
                      3461     	GET_ADC_STATUS 
0AE4    E5E8          3461+1   MOV A , ADC0CN 
0AE6    20ECFB        3462     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3463     	; Read ADC result
                      3464     	READ_ADC_RESULT
0AE9    A8BD          3464+1   MOV R0 , ADC0L 
0AEB    A9BE          3464+1   MOV R1 , ADC0H 
                      3465     	; Stop ADC
                      3466     	STOP_ADC
                      3467     	; Switch power off
0AED    121097        3468     	CALL	SWITCH_POWER_OFF		
                      3469     	; Set limit step
0AF0    756A55        3470     MOV LIPO_ADC_LIMIT_L , # 85 
0AF3    756B00        3471     MOV LIPO_ADC_LIMIT_H , # 0 
0AF6    C3            3472     	CLR	C
0AF7    7400          3473     MOV A , # 0 
0AF9    13            3474     	RRC	A
0AFA    FD            3475     MOV R5 , A 
0AFB    7455          3476     MOV A , # 85 
0AFD    13            3477     	RRC	A
0AFE    FC            3478     MOV R4 , A 
0AFF    7455          3479     MOV A , # 85 
0B01    2C            3480     ADD A , R4 
0B02    FC            3481     MOV R4 , A 
0B03    7400          3482     MOV A , # 0 
0B05    3D            3483     ADDC A , R5 
0B06    FD            3484     MOV R5 , A 
0B07    EC            3485     MOV A , R4 
0B08    FA            3486     MOV R2 , A 
0B09    ED            3487     MOV A , R5 
0B0A    FB            3488     MOV R3 , A 
                      3489     MEASURE_LIPO_CELL_LOOP: 
                      3490     	; Check voltage against xS lower limit
0B0B    C3            3491     	CLR	C
0B0C    E8            3492     MOV A , R0 
0B0D    9A            3493     SUBB A , R2 
0B0E    E9            3494     MOV A , R1 
0B0F    9B            3495     SUBB A , R3 
0B10    4014          3496     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3497     
                      3498     	; Set xS voltage limit
0B12    E56A          3499     	MOV	A, LIPO_ADC_LIMIT_L		
0B14    2455          3500     ADD A , # 85 
0B16    F56A          3501     	MOV	LIPO_ADC_LIMIT_L, A
0B18    E56B          3502     	MOV	A, LIPO_ADC_LIMIT_H		
0B1A    3400          3503     ADDC A , # 0 
0B1C    F56B          3504     	MOV	LIPO_ADC_LIMIT_H, A
                      3505     	; Set (x+1)S lower limit
0B1E    EA            3506     MOV A , R2 
0B1F    2C            3507     ADD A , R4 
0B20    FA            3508     MOV R2 , A 
0B21    EB            3509     MOV A , R3 
0B22    3D            3510     ADDC A , R5 
0B23    FB            3511     MOV R3 , A 
0B24    80E5          3512     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3513     
                      3514     MEASURE_LIPO_ADJUST: 
0B26    AE6A          3515     MOV R6 , LIPO_ADC_LIMIT_L 
0B28    AF6B          3516     MOV R7 , LIPO_ADC_LIMIT_H 
                      3517     	; Calculate 3.125%
0B2A    C3            3518     	CLR	C
0B2B    E56B          3519     	MOV	A, LIPO_ADC_LIMIT_H
0B2D    13            3520     	RRC	A
0B2E    F9            3521     MOV R1 , A 
0B2F    E56A          3522     	MOV	A, LIPO_ADC_LIMIT_L	
0B31    13            3523     	RRC	A
0B32    F8            3524     MOV R0 , A 
0B33    C3            3525     	CLR	C
0B34    E9            3526     MOV A , R1 
0B35    13            3527     	RRC	A
0B36    F9            3528     MOV R1 , A 
0B37    E8            3529     MOV A , R0 
0B38    13            3530     	RRC	A
0B39    F8            3531     MOV R0 , A 
0B3A    E56A          3532     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B3C    28            3533     ADD A , R0 
0B3D    F568          3534     	MOV	LIPO_ADC_REFERENCE_L, A
0B3F    E56B          3535     	MOV	A, LIPO_ADC_LIMIT_H
0B41    39            3536     ADDC A , R1 
0B42    F569          3537     	MOV	LIPO_ADC_REFERENCE_H, A
                      3538     	; Divide three times to get to 3.125%
0B44    7A03          3539     MOV R2 , # 3 
                      3540     MEASURE_LIPO_DIVIDE_LOOP: 
0B46    C3            3541     	CLR	C
0B47    E9            3542     MOV A , R1 
0B48    13            3543     	RRC	A
0B49    F9            3544     MOV R1 , A 
0B4A    E8            3545     MOV A , R0 
0B4B    13            3546     	RRC	A
0B4C    F8            3547     MOV R0 , A 
0B4D    DAF7          3548     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3549     
                      3550     	; Add the programmed number of 0.1V (or 3.125% increments)
0B4F    AA20          3551     MOV R2 , BIT_ACCESS 
0B51    1A            3552     DEC R2 
0B52    7009          3553     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3554     
0B54    756A00        3555     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B57    756B00        3556     	MOV	LIPO_ADC_LIMIT_H, #0
0B5A    020B6D        3557     	JMP	MEASURE_LIPO_EXIT	
                      3558     
                      3559     MEASURE_LIPO_LIMIT_ON: 
0B5D    1A            3560     DEC R2 
0B5E    EA            3561     MOV A , R2 
0B5F    6008          3562     	JZ	MEASURE_LIPO_UPDATE
                      3563     
                      3564     MEASURE_LIPO_ADD_LOOP: 
0B61    EE            3565     MOV A , R6 
0B62    28            3566     ADD A , R0 
0B63    FE            3567     MOV R6 , A 
0B64    EF            3568     MOV A , R7 
0B65    39            3569     ADDC A , R1 
0B66    FF            3570     MOV R7 , A 
0B67    DAF8          3571     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3572     
                      3573     MEASURE_LIPO_UPDATE: 
                      3574     	; Set ADC limit
0B69    8E6A          3575     MOV LIPO_ADC_LIMIT_L , R6 
0B6B    8F6B          3576     MOV LIPO_ADC_LIMIT_H , R7 
                      3577     MEASURE_LIPO_EXIT: 
0B6D    22            3578     	RET
                      3579     
                      3580     
                      3581     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3582     ;
                      3583     ; Start ADC conversion
                      3584     ;
                      3585     ; No assumptions
                      3586     ;
                      3587     ; Start conversion used for measuring power supply voltage
                      3588     ;
                      3589     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3590     START_ADC_CONVERSION: 
                      3591     	; Start adc
                      3592     	START_ADC 
0B6E    75E890        3592+1   MOV ADC0CN , # 90H  ; ADC START
0B71    22            3593     	RET
                      3594     
                      3595     
                      3596     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3597     ;
                      3598     ; Check temperature, power supply voltage and limit power
                      3599     ;
                      3600     ; No assumptions
                      3601     ;
                      3602     ; Used to limit main motor power in order to maintain the required voltage
                      3603     ;
                      3604     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3605     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3606     	; Load programmed low voltage limit
0B72    7883          3607     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B74    E6            3608     MOV A , @ R0 
0B75    FF            3609     MOV R7 , A 
                      3610     	; Wait for ADC conversion to complete
                      3611     	GET_ADC_STATUS 
0B76    E5E8          3611+1   MOV A , ADC0CN 
0B78    20ECF7        3612     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3613     	; Read ADC result
                      3614     	READ_ADC_RESULT
0B7B    A8BD          3614+1   MOV R0 , ADC0L 
0B7D    A9BE          3614+1   MOV R1 , ADC0H 
                      3615     	; Stop ADC
                      3616     	STOP_ADC
                      3617     
0B7F    056C          3618     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B81    C3            3619     	CLR	C
0B82    E56C          3620     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B84    9408          3621     SUBB A , # 8 
0B86    404B          3622     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3623     
0B88    756C00        3624     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B8B    E9            3625     MOV A , R1 
0B8C    7007          3626     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3627     
0B8E    E56D          3628     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B90    601B          3629     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B92    020BA1        3630     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3631     
                      3632     TEMP_AVERAGE_INC_DEC: 
0B95    C3            3633     	CLR	C
0B96    E8            3634     MOV A , R0 
0B97    956D          3635     	SUBB	A, CURRENT_AVERAGE_TEMP
0B99    6010          3636     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3637     
0B9B    E56D          3638     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0B9D    5006          3639     	JNC	TEMP_AVERAGE_INC				
                      3640     
0B9F    600C          3641     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3642     TEMP_AVERAGE_DEC: 
0BA1    14            3643     	DEC	A						; Decrement average
0BA2    020BAD        3644     	JMP	TEMP_AVERAGE_UPDATED
                      3645     
                      3646     TEMP_AVERAGE_INC: 
0BA5    04            3647     	INC	A						; Increment average
0BA6    60F9          3648     	JZ	TEMP_AVERAGE_DEC
0BA8    020BAD        3649     	JMP	TEMP_AVERAGE_UPDATED
                      3650     
                      3651     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BAB    E56D          3652     	MOV	A, CURRENT_AVERAGE_TEMP
                      3653     TEMP_AVERAGE_UPDATED: 
0BAD    F56D          3654     	MOV	CURRENT_AVERAGE_TEMP, A
0BAF    C3            3655     	CLR	C
0BB0    9472          3656     SUBB A , # 114 
0BB2    401B          3657     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3658     
0BB4    755EC0        3659     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3660     
0BB7    C3            3661     	CLR	C
0BB8    9404          3662     SUBB A , # 4 
0BBA    4013          3663     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3664     
0BBC    755E80        3665     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3666     
0BBF    C3            3667     	CLR	C
0BC0    9404          3668     SUBB A , # 4 
0BC2    400B          3669     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3670     
0BC4    755E40        3671     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3672     
0BC7    C3            3673     	CLR	C
0BC8    9404          3674     SUBB A , # 4 
0BCA    4003          3675     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3676     
0BCC    755E00        3677     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3678     
                      3679     TEMP_CHECK_EXIT: 
                      3680     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BCF    75BB09        3680+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BD2    22            3681     	RET
                      3682     
                      3683     CHECK_VOLTAGE_START: 
                      3684     IF MODE == 0 OR MODE == 2	; Main or multi
                      3685     	; Check if low voltage limiting is enabled
0BD3    EF            3686     MOV A , R7 
0BD4    C3            3687     	CLR	C
0BD5    9401          3688     	SUBB	A, #1					; Is low voltage limit disabled?
0BD7    601B          3689     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3690     
                      3691     	; Check if ADC is saturated
0BD9    C3            3692     	CLR	C
0BDA    E8            3693     MOV A , R0 
0BDB    94FF          3694     	SUBB	A, #0FFH
0BDD    E9            3695     MOV A , R1 
0BDE    9403          3696     	SUBB	A, #03H
0BE0    5012          3697     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3698     
                      3699     	; Check voltage against limit
0BE2    C3            3700     	CLR	C
0BE3    E8            3701     MOV A , R0 
0BE4    956A          3702     	SUBB	A, LIPO_ADC_LIMIT_L
0BE6    E9            3703     MOV A , R1 
0BE7    956B          3704     	SUBB	A, LIPO_ADC_LIMIT_H
0BE9    5009          3705     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3706     
                      3707     	; Decrease pwm limit
0BEB    E55E          3708     	MOV  A, PWM_LIMIT
0BED    600C          3709     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3710     
0BEF    155E          3711     	DEC	PWM_LIMIT					; Decrement limit
0BF1    020BFB        3712     	JMP	CHECK_VOLTAGE_LIM
                      3713     
                      3714     CHECK_VOLTAGE_GOOD: 
                      3715     	; Increase pwm limit
0BF4    E55E          3716     	MOV  A, PWM_LIMIT
0BF6    F4            3717     	CPL	A			
0BF7    6002          3718     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3719     
0BF9    055E          3720     	INC	PWM_LIMIT					; Increment limit
                      3721     
                      3722     CHECK_VOLTAGE_LIM: 
0BFB    A85E          3723     MOV R0 , PWM_LIMIT 
0BFD    C3            3724     	CLR	C
0BFE    E524          3725     	MOV	A, CURRENT_PWM
0C00    98            3726     SUBB A , R0 
0C01    5002          3727     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3728     
0C03    A824          3729     MOV R0 , CURRENT_PWM 
                      3730     
                      3731     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3732     	; Slow spoolup
0C05    C3            3733     	CLR	C
0C06    E8            3734     MOV A , R0 
0C07    955F          3735     	SUBB	A, PWM_LIMIT_SPOOLUP
0C09    400A          3736     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3737     
0C0B    A85F          3738     MOV R0 , PWM_LIMIT_SPOOLUP 
0C0D    E55F          3739     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C0F    F4            3740     	CPL	A
0C10    6003          3741     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3742      
0C12    855F5E        3743     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3744     
                      3745     CHECK_VOLTAGE_EXIT: 
0C15    8825          3746     MOV CURRENT_PWM_LIMITED , R0 
                      3747     ENDIF
                      3748     	; Set adc mux for next conversion
0C17    C3            3749     	CLR	C
0C18    E56C          3750     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C1A    B40703        3751     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3752     
                      3753     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C1D    75BB10        3753+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3754     
                      3755     CHECK_VOLTAGE_RET: 
0C20    22            3756     	RET
                      3757     
                      3758     
                      3759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3760     ;
                      3761     ; Set startup PWM routine
                      3762     ;
                      3763     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3764     ;
                      3765     ; Used for pwm control during startup
                      3766     ;
                      3767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3768     SET_STARTUP_PWM: 	
                      3769     	; Set pwm values according to startup phase flags
0C21    306102        3770     JNB FLAGS1 . 1 , ( $+5 ) 
0C24    7832          3771     MOV R0 , # 50 
0C26    306202        3772     JNB FLAGS1 . 2 , ( $+5 ) 
0C29    7878          3773     MOV R0 , # 120 
                      3774     
                      3775     	; Update pwm variables if any startup phase flag is set
0C2B    E52C          3776     	MOV	A, FLAGS1
0C2D    5406          3777     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C2F    601F          3778     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3779     
                      3780     	; Adjust startup power
0C31    E8            3781     MOV A , R0 
0C32    79A2          3782     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C34    87F0          3783     MOV B , @ R1 
0C36    A4            3784     	MUL	AB
0C37    C5F0          3785     	XCH	A, B
0C39    A2F7          3786     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C3B    33            3787     	RLC	A
0C3C    F8            3788     MOV R0 , A 
0C3D    C3            3789     	CLR	C
0C3E    E8            3790     MOV A , R0 
0C3F    955E          3791     	SUBB	A, PWM_LIMIT	
0C41    4002          3792     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3793     
0C43    A85E          3794     MOV R0 , PWM_LIMIT 
                      3795     
                      3796     STARTUP_PWM_SET_PWM: 
                      3797     	; Set pwm variables
0C45    8822          3798     MOV REQUESTED_PWM , R0 
0C47    8824          3799     MOV CURRENT_PWM , R0 
0C49    8825          3800     MOV CURRENT_PWM_LIMITED , R0 
0C4B    306102        3801     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3802     
0C4E    8860          3803     MOV PWM_SPOOLUP_BEG , R0 
                      3804     
                      3805     STARTUP_PWM_EXIT: 
0C50    22            3806     	RET
                      3807     
                      3808     
                      3809     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3810     ;
                      3811     ; Initialize all timings routine
                      3812     ;
                      3813     ; No assumptions
                      3814     ;
                      3815     ; Part of initialization before motor start
                      3816     ;
                      3817     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3818     INITIALIZE_ALL_TIMINGS:  
                      3819     	; Load programmed startup rpm
0C51    788F          3820     MOV R0 , # PGM_STARTUP_RPM 
0C53    E6            3821     MOV A , @ R0 
0C54    FF            3822     MOV R7 , A 
                      3823     	; Check startup rpm setting and set step accordingly
0C55    C3            3824     	CLR	C
0C56    EF            3825     MOV A , R7 
0C57    9405          3826     	SUBB	A, #5
0C59    5018          3827     	JNC	STEPPER_STEP_HIGH
0C5B    C3            3828     	CLR	C
0C5C    EF            3829     MOV A , R7 
0C5D    9404          3830     	SUBB	A, #4
0C5F    5020          3831     	JNC	STEPPER_STEP_MED_HIGH
0C61    C3            3832     	CLR	C
0C62    EF            3833     MOV A , R7 
0C63    9403          3834     	SUBB	A, #3
0C65    5028          3835     	JNC	STEPPER_STEP_MED
0C67    C3            3836     	CLR	C
0C68    EF            3837     MOV A , R7 
0C69    9402          3838     	SUBB	A, #2
0C6B    5030          3839     	JNC	STEPPER_STEP_MED_LOW
0C6D    C3            3840     	CLR	C
0C6E    EF            3841     MOV A , R7 
0C6F    9401          3842     	SUBB	A, #1
0C71    5038          3843     	JNC	STEPPER_STEP_LOW
                      3844     
                      3845     STEPPER_STEP_HIGH: 
0C73    7533A0        3846     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C76    75340F        3847     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C79    75353C        3848     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C7C    753605        3849     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C7F    81B7          3850     	AJMP	STEPPER_STEP_SET
                      3851     STEPPER_STEP_MED_HIGH: 
0C81    7533C0        3852     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C84    753412        3853     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C87    753540        3854     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C8A    753606        3855     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C8D    81B7          3856     	AJMP	STEPPER_STEP_SET
                      3857     STEPPER_STEP_MED: 
0C8F    753370        3858     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C92    753417        3859     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C95    7535D0        3860     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C98    753607        3861     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C9B    81B7          3862     	AJMP	STEPPER_STEP_SET
                      3863     STEPPER_STEP_MED_LOW: 
0C9D    75334C        3864     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0CA0    75341D        3865     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0CA3    7535C4        3866     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0CA6    753609        3867     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CA9    81B7          3868     	AJMP	STEPPER_STEP_SET
                      3869     STEPPER_STEP_LOW: 
0CAB    753328        3870     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CAE    753423        3871     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CB1    7535B8        3872     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CB4    75360B        3873     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3874     
                      3875     STEPPER_STEP_SET: 
0CB7    853350        3876     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CBA    853451        3877     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CBD    753C00        3878     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CC0    753D08        3879     	MOV	COMM_PERIOD4X_H, #08H
0CC3    22            3880     	RET
                      3881     
                      3882     
                      3883     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3884     ;
                      3885     ; Calculate next commutation timing routine
                      3886     ;
                      3887     ; No assumptions
                      3888     ;
                      3889     ; Called immediately after each commutation
                      3890     ; Also sets up timer 3 to wait advance timing
                      3891     ; Two entry points are used
                      3892     ;
                      3893     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3894     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CC4    A850          3895     MOV R0 , WT_STEPPER_STEP_L 
0CC6    A951          3896     MOV R1 , WT_STEPPER_STEP_H 
0CC8    020CCF        3897     	JMP	READ_TIMER
                      3898     
                      3899     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CCB    A84A          3900     MOV R0 , WT_ADVANCE_L 
0CCD    A94B          3901     MOV R1 , WT_ADVANCE_H 
                      3902     READ_TIMER: 
                      3903     	; Set up next wait
0CCF    759100        3904     	MOV	TMR3CN, #00H		; Timer3 disabled
0CD2    C3            3905     	CLR	C
0CD3    E4            3906     	CLR	A
0CD4    98            3907     SUBB A , R0 
0CD5    F594          3908     	MOV	TMR3L, A
0CD7    E4            3909     	CLR	A
0CD8    99            3910     SUBB A , R1 
0CD9    F595          3911     	MOV	TMR3H, A
0CDB    759104        3912     	MOV	TMR3CN, #04H		; Timer3 enabled
0CDE    D258          3913     SETB FLAGS0 . 0 
                      3914     	; Read commutation time
0CE0    75C820        3915     	MOV	TMR2CN, #20H		; Timer2 disabled
0CE3    A8CC          3916     MOV R0 , TMR2L 
0CE5    A9CD          3917     MOV R1 , TMR2H 
0CE7    75C824        3918     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3919     	; Calculate this commutation time
0CEA    AA3A          3920     MOV R2 , PREV_COMM_L 
0CEC    AB3B          3921     MOV R3 , PREV_COMM_H 
0CEE    883A          3922     MOV PREV_COMM_L , R0 
0CF0    893B          3923     MOV PREV_COMM_H , R1 
0CF2    C3            3924     	CLR	C
0CF3    E8            3925     MOV A , R0 
0CF4    9A            3926     SUBB A , R2 
0CF5    F8            3927     MOV R0 , A 
0CF6    E9            3928     MOV A , R1 
0CF7    9B            3929     SUBB A , R3 
0CF8    F9            3930     MOV R1 , A 
                      3931     	; Calculate next zero cross scan timeout 
0CF9    AA3C          3932     MOV R2 , COMM_PERIOD4X_L 
0CFB    AB3D          3933     MOV R3 , COMM_PERIOD4X_H 
0CFD    C3            3934     	CLR	C
0CFE    EB            3935     MOV A , R3 
0CFF    13            3936     	RRC	A					; Divide by 2
0D00    FD            3937     MOV R5 , A 
0D01    EA            3938     MOV A , R2 
0D02    13            3939     	RRC	A
0D03    FC            3940     MOV R4 , A 
0D04    C3            3941     	CLR	C
0D05    ED            3942     MOV A , R5 
0D06    13            3943     	RRC	A					; Divide by 2 again
0D07    FD            3944     MOV R5 , A 
0D08    EC            3945     MOV A , R4 
0D09    13            3946     	RRC	A
0D0A    FC            3947     MOV R4 , A 
0D0B    C3            3948     	CLR	C
0D0C    EA            3949     MOV A , R2 
0D0D    9C            3950     SUBB A , R4 
0D0E    FA            3951     MOV R2 , A 
0D0F    EB            3952     MOV A , R3 
0D10    9D            3953     SUBB A , R5 
0D11    FB            3954     MOV R3 , A 
                      3955     
0D12    EA            3956     MOV A , R2 
0D13    28            3957     ADD A , R0 
0D14    FA            3958     MOV R2 , A 
0D15    EB            3959     MOV A , R3 
0D16    39            3960     ADDC A , R1 
0D17    FB            3961     MOV R3 , A 
0D18    8A3C          3962     MOV COMM_PERIOD4X_L , R2 
0D1A    8B3D          3963     MOV COMM_PERIOD4X_H , R3 
0D1C    4001          3964     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3965     
0D1E    22            3966     	RET
                      3967     
                      3968     CALC_NEXT_COMM_SLOW: 
0D1F    753CFF        3969     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D22    753DFF        3970     	MOV	COMM_PERIOD4X_H, #0FFH
0D25    22            3971     	RET
                      3972     
                      3973     
                      3974     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3975     ;
                      3976     ; Setup zero cross scan wait
                      3977     ;
                      3978     ; No assumptions
                      3979     ;
                      3980     ; Sets up timer 3 to wait the zero cross scan wait time
                      3981     ;
                      3982     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3983     SETUP_ZC_SCAN_WAIT: 
0D26    759100        3984     	MOV	TMR3CN, #00H		; Timer3 disabled
0D29    C3            3985     	CLR	C
0D2A    E4            3986     	CLR	A
0D2B    954C          3987     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D2D    F594          3988     	MOV	TMR3L, A
0D2F    E4            3989     	CLR	A
0D30    954D          3990     	SUBB	A, WT_ZC_SCAN_H		
0D32    F595          3991     	MOV	TMR3H, A
0D34    759104        3992     	MOV	TMR3CN, #04H		; Timer3 enabled
0D37    D258          3993     SETB FLAGS0 . 0 
0D39    22            3994     	RET
                      3995     
                      3996     
                      3997     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3998     ;
                      3999     ; Wait advance timing routine
                      4000     ;
                      4001     ; No assumptions
                      4002     ;
                      4003     ; Waits for the advance timing to elapse, waits one zero cross
                      4004     ; wait and sets up the next zero cross wait
                      4005     ;
                      4006     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4007     WAIT_ADVANCE_TIMING: 	
0D3A    7F01          4008     MOV R7 , # 1 
0D3C    789C          4009     MOV R0 , # PGM_DEMAG_COMP 
0D3E    E6            4010     MOV A , @ R0 
0D3F    14            4011     	DEC	A
0D40    6002          4012     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4013     
0D42    7F02          4014     MOV R7 , # 2 
                      4015     
                      4016     WAIT_ADVANCE_TIMING_WAIT: 
0D44    305802        4017     JNB FLAGS0 . 0 , ( $+5 ) 
0D47    A144          4018     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4019     
0D49    B126          4020     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D4B    DFF7          4021     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4022     
0D4D    22            4023     	RET
                      4024     
                      4025     
                      4026     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4027     ;
                      4028     ; Calculate new wait times routine
                      4029     ;
                      4030     ; No assumptions
                      4031     ;
                      4032     ; Calculates new wait times
                      4033     ;
                      4034     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4035     CALC_NEW_WAIT_TIMES: 	
                      4036     	; Load programmed commutation timing
0D4E    7892          4037     MOV R0 , # PGM_COMM_TIMING 
0D50    E6            4038     MOV A , @ R0 
0D51    FF            4039     MOV R7 , A 
0D52    7E14          4040     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4041     IF MODE == 2
0D54    A83D          4042     MOV R0 , COMM_PERIOD4X_H 
0D56    C3            4043     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D57    E8            4044     MOV A , R0 
0D58    9404          4045     	SUBB	A, #4
0D5A    4002          4046     	JC	CALC_NEW_WAIT_RED_SET
                      4047     
0D5C    7804          4048     MOV R0 , # 4 
                      4049     
                      4050     CALC_NEW_WAIT_RED_SET: 
0D5E    C3            4051     	CLR	C
0D5F    E8            4052     MOV A , R0 
0D60    33            4053     	RLC	A
0D61    F8            4054     MOV R0 , A 
0D62    C3            4055     	CLR	C
0D63    EE            4056     MOV A , R6 
0D64    98            4057     SUBB A , R0 
0D65    FE            4058     MOV R6 , A 
                      4059     ENDIF
0D66    306304        4060     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4061     
0D69    7F03          4062     MOV R7 , # 3 
0D6B    7E00          4063     MOV R6 , # 0 
                      4064     
                      4065     CALC_NEW_WAIT_DIR_START_SET: 
                      4066     	; Load current commutation timing
0D6D    A93D          4067     MOV R1 , COMM_PERIOD4X_H 
0D6F    A83C          4068     MOV R0 , COMM_PERIOD4X_L 
0D71    7A04          4069     MOV R2 , # 4 
                      4070     DIVIDE_WAIT_TIMES: 
0D73    C3            4071     	CLR	C
0D74    E9            4072     MOV A , R1 
0D75    13            4073     	RRC	A					; Divide by 2
0D76    F9            4074     MOV R1 , A 
0D77    E8            4075     MOV A , R0 
0D78    13            4076     	RRC	A
0D79    F8            4077     MOV R0 , A 
0D7A    DAF7          4078     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4079     
0D7C    C3            4080     	CLR	C
0D7D    E8            4081     MOV A , R0 
0D7E    9E            4082     SUBB A , R6 
0D7F    F8            4083     MOV R0 , A 
0D80    E9            4084     MOV A , R1 
0D81    9400          4085     	SUBB	A, #0
0D83    F9            4086     MOV R1 , A 
0D84    4009          4087     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4088     
0D86    C3            4089     	CLR	C
0D87    E8            4090     MOV A , R0 
0D88    9402          4091     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D8A    E9            4092     MOV A , R1 
0D8B    9400          4093     	SUBB	A, #0
0D8D    5004          4094     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4095     
                      4096     LOAD_MIN_TIME: 
0D8F    7802          4097     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D91    E4            4098     	CLR	A
0D92    F9            4099     MOV R1 , A 
                      4100     
                      4101     ADJUST_TIMING: 
0D93    E9            4102     MOV A , R1 
0D94    FB            4103     MOV R3 , A 
0D95    E8            4104     MOV A , R0 
0D96    FA            4105     MOV R2 , A 
0D97    C3            4106     	CLR	C
0D98    E9            4107     MOV A , R1 
0D99    13            4108     	RRC	A					; Divide by 2
0D9A    FD            4109     MOV R5 , A 
0D9B    E8            4110     MOV A , R0 
0D9C    13            4111     	RRC	A
0D9D    FC            4112     MOV R4 , A 
0D9E    C3            4113     	CLR	C
0D9F    EF            4114     MOV A , R7 
0DA0    9403          4115     	SUBB	A, #3				; Is timing normal?
0DA2    602E          4116     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4117     
0DA4    EF            4118     MOV A , R7 
0DA5    20E00D        4119     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4120     
0DA8    E8            4121     MOV A , R0 
0DA9    2C            4122     ADD A , R4 
0DAA    F8            4123     MOV R0 , A 
0DAB    E9            4124     MOV A , R1 
0DAC    3D            4125     ADDC A , R5 
0DAD    F9            4126     MOV R1 , A 
0DAE    EC            4127     MOV A , R4 
0DAF    FA            4128     MOV R2 , A 
0DB0    ED            4129     MOV A , R5 
0DB1    FB            4130     MOV R3 , A 
0DB2    020DBF        4131     	JMP	STORE_TIMES_UP_OR_DOWN
                      4132     
                      4133     ADJUST_TIMING_TWO_STEPS: 
0DB5    E8            4134     MOV A , R0 
0DB6    28            4135     ADD A , R0 
0DB7    F8            4136     MOV R0 , A 
0DB8    E9            4137     MOV A , R1 
0DB9    39            4138     ADDC A , R1 
0DBA    F9            4139     MOV R1 , A 
0DBB    7A02          4140     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DBD    E4            4141     	CLR	A
0DBE    FB            4142     MOV R3 , A 
                      4143     
                      4144     STORE_TIMES_UP_OR_DOWN: 
0DBF    C3            4145     	CLR	C
0DC0    EF            4146     MOV A , R7 
0DC1    9403          4147     	SUBB	A, #3				; Is timing higher than normal?
0DC3    400D          4148     	JC	STORE_TIMES_DECREASE	; No - branch
                      4149     
                      4150     STORE_TIMES_INCREASE: 
0DC5    8A4E          4151     MOV WT_COMM_L , R2 
0DC7    8B4F          4152     MOV WT_COMM_H , R3 
0DC9    884A          4153     MOV WT_ADVANCE_L , R0 
0DCB    894B          4154     MOV WT_ADVANCE_H , R1 
0DCD    8C4C          4155     MOV WT_ZC_SCAN_L , R4 
0DCF    8D4D          4156     MOV WT_ZC_SCAN_H , R5 
0DD1    22            4157     	RET
                      4158     
                      4159     STORE_TIMES_DECREASE: 
0DD2    884E          4160     MOV WT_COMM_L , R0 
0DD4    894F          4161     MOV WT_COMM_H , R1 
0DD6    8A4A          4162     MOV WT_ADVANCE_L , R2 
0DD8    8B4B          4163     MOV WT_ADVANCE_H , R3 
0DDA    8C4C          4164     MOV WT_ZC_SCAN_L , R4 
0DDC    8D4D          4165     MOV WT_ZC_SCAN_H , R5 
0DDE    22            4166     	RET
                      4167     
                      4168     
                      4169     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4170     ;
                      4171     ; Wait before zero cross scan routine
                      4172     ;
                      4173     ; No assumptions
                      4174     ;
                      4175     ; Waits for the zero cross scan wait time to elapse
                      4176     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4177     ;
                      4178     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4179     WAIT_BEFORE_ZC_SCAN: 	
0DDF    305802        4180     JNB FLAGS0 . 0 , ( $+5 ) 
0DE2    A1DF          4181     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4182     
0DE4    759100        4183     	MOV	TMR3CN, #00H		; Timer3 disabled
0DE7    C3            4184     	CLR	C
0DE8    E4            4185     	CLR	A
0DE9    953C          4186     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DEB    F594          4187     	MOV	TMR3L, A
0DED    E4            4188     	CLR	A
0DEE    953D          4189     	SUBB	A, COMM_PERIOD4X_H		
0DF0    F595          4190     	MOV	TMR3H, A
0DF2    759104        4191     	MOV	TMR3CN, #04H		; Timer3 enabled
0DF5    D258          4192     SETB FLAGS0 . 0 
0DF7    22            4193     	RET
                      4194     
                      4195     
                      4196     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4197     ;
                      4198     ; Wait for comparator to go low/high routines
                      4199     ;
                      4200     ; No assumptions
                      4201     ;
                      4202     ; Waits for the zero cross scan wait time to elapse
                      4203     ; Then scans for comparator going low/high
                      4204     ;
                      4205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4206     WAIT_FOR_COMP_OUT_LOW: 
0DF8    753F00        4207     	MOV	COMP_WAIT_READS, #0
0DFB    752000        4208     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0DFE    020E07        4209     	JMP	WAIT_FOR_COMP_OUT_START
                      4210     
                      4211     WAIT_FOR_COMP_OUT_HIGH: 
0E01    753F00        4212     	MOV	COMP_WAIT_READS, #0
0E04    752040        4213     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4214     
                      4215     WAIT_FOR_COMP_OUT_START: 
0E07    D2AF          4216     	SETB	EA						; Enable interrupts
0E09    053F          4217     	INC	COMP_WAIT_READS
0E0B    205801        4218     JB FLAGS0 . 0 , ( $+4 ) 
0E0E    22            4219     	RET							; Yes - return
                      4220     
                      4221     	; Set default comparator response times
0E0F    759D00        4222     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4223     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4226     	; Select number of comparator readings based upon current rotation speed
0E12    E53D          4227     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E14    C3            4228     	CLR	C
0E15    13            4229     	RRC	A						; Divide by 4
0E16    C3            4230     	CLR	C
0E17    13            4231     	RRC	A
0E18    F8            4232     MOV R0 , A 
0E19    08            4233     INC R0 
0E1A    6030          4234     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4235     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E1C    306A06        4236     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4237     
0E1F    C3            4238     	CLR	C
0E20    13            4239     	RRC	A						; Divide by 4 again
0E21    C3            4240     	CLR	C
0E22    13            4241     	RRC	A
0E23    F8            4242     MOV R0 , A 
0E24    08            4243     INC R0 
                      4244     
                      4245     COMP_WAIT_SET_MAX_READINGS: 
0E25    C3            4246     	CLR	C
0E26    E8            4247     MOV A , R0 
0E27    940A          4248     	SUBB	A, #10
0E29    4002          4249     	JC	($+4)
                      4250     
0E2B    780A          4251     MOV R0 , # 10 
                      4252     
0E2D    306D08        4253     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4254     
0E30    C3            4255     	CLR	C
0E31    E8            4256     MOV A , R0 
0E32    9404          4257     	SUBB	A, #4
0E34    4002          4258     	JC	($+4)
                      4259     
0E36    7804          4260     MOV R0 , # 4 
                      4261     
                      4262     COMP_WAIT_SET_RESPONSE_TIME: 
0E38    C3            4263     	CLR	C
0E39    E53D          4264     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E3B    9408          4265     	SUBB	A, #8
0E3D    400D          4266     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4267     
0E3F    759D02        4268     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4269     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E42    C3            4272     	CLR	C
0E43    E53D          4273     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E45    9410          4274     	SUBB	A, #16
0E47    4003          4275     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4276     
0E49    759D03        4277     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4278     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4281     
                      4282     COMP_WAIT_ON_COMP_ABLE: 
0E4C    205803        4283     JB FLAGS0 . 0 , ( $+6 ) 
0E4F    D2AF          4284     	SETB	EA							; Enable interrupts
0E51    22            4285     	RET								; Yes - return
                      4286     
0E52    791E          4287     MOV R1 , # 30 
0E54    206D02        4288     JB FLAGS2 . 5 , ( $+5 ) 
0E57    790A          4289     MOV R1 , # 10 
0E59    D2AF          4290     	SETB	EA							; Enable interrupts
0E5B    00            4291     	NOP								; Allocate only just enough time to capture interrupt
0E5C    00            4292     	NOP
0E5D    C2AF          4293     	CLR	EA							; Disable interrupts
0E5F    205A0A        4294     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4295     
0E62    793C          4296     MOV R1 , # 60 
0E64    206D02        4297     JB FLAGS2 . 5 , ( $+5 ) 
0E67    7914          4298     MOV R1 , # 20 
0E69    3066E0        4299     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4300     
                      4301     PWM_WAIT_STARTUP: 						
0E6C    306302        4302     JNB FLAGS1 . 3 , PWM_WAIT 
                      4303     
0E6F    7978          4304     MOV R1 , # 120 
                      4305     PWM_WAIT: 						
0E71    C3            4306     	CLR	C
0E72    E58B          4307     	MOV	A, TL1
0E74    99            4308     SUBB A , R1 
                      4309     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E75    40D5          4314     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4315     ENDIF
                      4316     
                      4317     COMP_READ: 
                      4318     	READ_COMP_OUT 					; Read comparator output
0E77    E59B          4318+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E79    F4            4319     	CPL	A
0E7A    5440          4320     	ANL	A, #40H
0E7C    B52002        4321     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4322     
0E7F    C107          4323     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4324     
0E81    D8C9          4325     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4326     
0E83    D2AF          4327     	SETB	EA						; Enable interrupts
0E85    22            4328     	RET							
                      4329     
                      4330     
                      4331     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4332     ;
                      4333     ; Evaluate comparator integrity
                      4334     ;
                      4335     ; No assumptions
                      4336     ;
                      4337     ; Checks comparator signal behaviour versus expected behaviour
                      4338     ;
                      4339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4340     EVALUATE_COMPARATOR_INTEGRITY: 
0E86    C25B          4341     CLR FLAGS0 . 3 
                      4342     	; Check if demag compensation is enabled
0E88    789C          4343     MOV R0 , # PGM_DEMAG_COMP 
0E8A    E6            4344     MOV A , @ R0 
0E8B    14            4345     	DEC	A
0E8C    600A          4346     	JZ	EVAL_COMP_NO_DEMAG
                      4347     
                      4348     	; Check if a demag situation has occurred
0E8E    E53F          4349     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E90    14            4350     	DEC	A
0E91    7005          4351     	JNZ	EVAL_COMP_NO_DEMAG
                      4352     
0E93    206302        4353     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4354     
0E96    D25B          4355     SETB FLAGS0 . 3 
                      4356     
                      4357     EVAL_COMP_NO_DEMAG: 
0E98    30630B        4358     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4359     
0E9B    0538          4360     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0E9D    205810        4361     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4362     
0EA0    753800        4363     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0EA3    020EB0        4364     	JMP	EVAL_COMP_EXIT
                      4365     
                      4366     EVAL_COMP_CHECK_TIMEOUT: 
0EA6    205807        4367     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EA9    1581          4368     	DEC	SP							; Routine exit without "ret" command
0EAB    1581          4369     	DEC	SP
0EAD    021822        4370     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4371     
                      4372     EVAL_COMP_EXIT: 
0EB0    22            4373     	RET
                      4374     
                      4375     
                      4376     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4377     ;
                      4378     ; Setup commutation timing routine
                      4379     ;
                      4380     ; No assumptions
                      4381     ;
                      4382     ; Sets up and starts wait from commutation to zero cross
                      4383     ;
                      4384     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4385     SETUP_COMM_WAIT:  
0EB1    759100        4386     	MOV	TMR3CN, #00H		; Timer3 disabled
0EB4    C3            4387     	CLR	C
0EB5    E4            4388     	CLR	A
0EB6    954E          4389     	SUBB	A, WT_COMM_L		; Set wait commutation value
0EB8    F594          4390     	MOV	TMR3L, A
0EBA    E4            4391     	CLR	A
0EBB    954F          4392     	SUBB	A, WT_COMM_H		
0EBD    F595          4393     	MOV	TMR3H, A
0EBF    759104        4394     	MOV	TMR3CN, #04H		; Timer3 enabled
0EC2    D258          4395     SETB FLAGS0 . 0 
0EC4    22            4396     	RET
                      4397     
                      4398     
                      4399     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4400     ;
                      4401     ; Wait for commutation routine
                      4402     ;
                      4403     ; No assumptions
                      4404     ;
                      4405     ; Waits from zero cross to commutation 
                      4406     ;
                      4407     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4408     WAIT_FOR_COMM:  
                      4409     	; Increment or reset consecutive count
0EC5    0539          4410     	INC	DEMAG_CONSECUTIVE_CNT
0EC7    205B03        4411     JB FLAGS0 . 3 , ( $+6 ) 
                      4412     
0ECA    753900        4413     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4414     
                      4415     	; Check if a demag situation has occurred
0ECD    305B23        4416     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4417     
                      4418     	; Load programmed demag compensation
0ED0    78A3          4419     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0ED2    E6            4420     MOV A , @ R0 
0ED3    FF            4421     MOV R7 , A 
                      4422     
                      4423     	; Check for power off
0ED4    BF0108        4424     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4425     
0ED7    D25C          4426     SETB FLAGS0 . 4 
                      4427     	ALL_NFETS_OFF
0ED9    C292          4427+1   CLR P1 . 2 
0EDB    C296          4427+1   CLR P1 . 6 
0EDD    C295          4427+1   CLR P1 . 5 
                      4428     
                      4429     	; Wait a blind wait
                      4430     WAIT_FOR_COMM_BLIND: 
0EDF    B126          4431     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4432     WAIT_DEMAG_DEFAULT_ZC: 	
0EE1    305802        4433     JNB FLAGS0 . 0 , ( $+5 ) 
0EE4    C1E1          4434     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4435     
                      4436     	; Check for power off
0EE6    BF0208        4437     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4438     
0EE9    D25C          4439     SETB FLAGS0 . 4 
                      4440     	ALL_NFETS_OFF
0EEB    C292          4440+1   CLR P1 . 2 
0EED    C296          4440+1   CLR P1 . 6 
0EEF    C295          4440+1   CLR P1 . 5 
                      4441     
                      4442     WAIT_FOR_COMM_SETUP: 
0EF1    D1B1          4443     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4444     WAIT_FOR_COMM_WAIT: 
0EF3    305802        4445     JNB FLAGS0 . 0 , ( $+5 ) 
0EF6    C1F3          4446     	AJMP	WAIT_FOR_COMM_WAIT					
                      4447     
0EF8    22            4448     	RET
                      4449     
                      4450     
                      4451     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4452     ;
                      4453     ; Commutation routines
                      4454     ;
                      4455     ; No assumptions
                      4456     ;
                      4457     ; Performs commutation switching 
                      4458     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4459     ;
                      4460     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4461     COMM1COMM2: 	
0EF9    C2AF          4462     	CLR 	EA					; Disable all interrupts
                      4463     	BPFET_OFF					; Bp off
0EFB    C294          4463+1   CLR P1 . 4 
0EFD    206A03        4464     JB FLAGS2 . 2 , COMM12_DAMP 
0F00    020F18        4465     	JMP	COMM12_NONDAMP
                      4466     COMM12_DAMP: 
                      4467     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4471     IF DAMPED_MODE_ENABLE == 1
0F03    900347        4472     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4473     ENDIF
0F06    30650F        4474     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4475     	CPFET_OFF				
0F09    207502        4475+1   JB FLAGS3 . 5 , ( $+5 ) 
0F0C    C297          4475+1   CLR P1 . 7 
0F0E    307502        4475+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F11    C293          4475+1   CLR P1 . 3 
0F13    7406          4476     MOV A , # 6 
0F15    D5E0FD        4477     	DJNZ ACC,	$
                      4478     COMM12_NONDAMP: 
                      4479     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4487     	APFET_ON					; Ap on
0F18    207502        4487+1   JB FLAGS3 . 5 , ( $+5 ) 
0F1B    D293          4487+1   SETB P1 . 3 
0F1D    307502        4487+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F20    D297          4487+1   SETB P1 . 7 
                      4488     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F22    759F80        4488+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F25    753E02        4489     	MOV	COMM_PHASE, #2
0F28    021083        4490     	JMP	COMM_EXIT
                      4491     
                      4492     COMM2COMM3: 	
0F2B    C2AF          4493     	CLR 	EA					; Disable all interrupts
0F2D    206A03        4494     JB FLAGS2 . 2 , COMM23_DAMP 
0F30    020F4D        4495     	JMP	COMM23_NONDAMP
                      4496     COMM23_DAMP: 
                      4497     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4500     IF DAMPED_MODE_ENABLE == 1
0F33    9002FE        4501     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4502     ENDIF
0F36    306517        4503     JNB FLAGS1 . 5 , COMM23_NFET 
                      4504     	BPFET_OFF				
0F39    C294          4504+1   CLR P1 . 4 
                      4505     	CPFET_OFF				
0F3B    207502        4505+1   JB FLAGS3 . 5 , ( $+5 ) 
0F3E    C297          4505+1   CLR P1 . 7 
0F40    307502        4505+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F43    C293          4505+1   CLR P1 . 3 
0F45    7406          4506     MOV A , # 6 
0F47    D5E0FD        4507     	DJNZ ACC,	$
0F4A    020F50        4508     	JMP	COMM23_NFET
                      4509     COMM23_NONDAMP: 
0F4D    9001E1        4510     	MOV	DPTR, #PWM_BFET_ON	
                      4511     COMM23_NFET: 
                      4512     	CNFET_OFF					; Cn off
0F50    207502        4512+1   JB FLAGS3 . 5 , ( $+5 ) 
0F53    C296          4512+1   CLR P1 . 6 
0F55    307502        4512+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F58    C292          4512+1   CLR P1 . 2 
0F5A    305A06        4513     JNB FLAGS0 . 2 , COMM23_CP 
                      4514     	BNFET_ON					; Yes - Bn on
0F5D    E525          4514+1   MOV A , CURRENT_PWM_LIMITED 
0F5F    6002          4514+1   JZ ( $+4 ) 
0F61    D295          4514+1   SETB P1 . 5 
                      4515     COMM23_CP: 
                      4516     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F63    207503        4516+1   JB FLAGS3 . 5 , ( $+6 ) 
0F66    759F89        4516+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F69    307503        4516+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F6C    759F81        4516+1   MOV CPT0MX , # 81H 
0F6F    753E03        4517     	MOV	COMM_PHASE, #3
0F72    021083        4518     	JMP	COMM_EXIT
                      4519     
                      4520     COMM3COMM4: 	
0F75    C2AF          4521     	CLR 	EA					; Disable all interrupts
                      4522     	APFET_OFF					; Ap off
0F77    207502        4522+1   JB FLAGS3 . 5 , ( $+5 ) 
0F7A    C293          4522+1   CLR P1 . 3 
0F7C    307502        4522+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F7F    C297          4522+1   CLR P1 . 7 
0F81    206A03        4523     JB FLAGS2 . 2 , COMM34_DAMP 
0F84    020F94        4524     	JMP	COMM34_NONDAMP
                      4525     COMM34_DAMP: 
                      4526     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4530     IF DAMPED_MODE_ENABLE == 1
0F87    9002BD        4531     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4532     ENDIF
0F8A    306507        4533     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4534     	BPFET_OFF				
0F8D    C294          4534+1   CLR P1 . 4 
0F8F    7406          4535     MOV A , # 6 
0F91    D5E0FD        4536     	DJNZ ACC,	$
                      4537     COMM34_NONDAMP: 
                      4538     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4546     	CPFET_ON					; Cp on
0F94    207502        4546+1   JB FLAGS3 . 5 , ( $+5 ) 
0F97    D297          4546+1   SETB P1 . 7 
0F99    307502        4546+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F9C    D293          4546+1   SETB P1 . 3 
                      4547     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F9E    207503        4547+1   JB FLAGS3 . 5 , ( $+6 ) 
0FA1    759F81        4547+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FA4    307503        4547+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FA7    759F89        4547+1   MOV CPT0MX , # 89H 
0FAA    753E04        4548     	MOV	COMM_PHASE, #4
0FAD    021083        4549     	JMP	COMM_EXIT
                      4550     
                      4551     COMM4COMM5: 	
0FB0    C2AF          4552     	CLR 	EA					; Disable all interrupts
0FB2    206A03        4553     JB FLAGS2 . 2 , COMM45_DAMP 
0FB5    020FD2        4554     	JMP	COMM45_NONDAMP
                      4555     COMM45_DAMP: 
                      4556     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4559     IF DAMPED_MODE_ENABLE == 1
0FB8    90027C        4560     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4561     ENDIF
0FBB    306517        4562     JNB FLAGS1 . 5 , COMM45_NFET 
                      4563     	APFET_OFF				
0FBE    207502        4563+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC1    C293          4563+1   CLR P1 . 3 
0FC3    307502        4563+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FC6    C297          4563+1   CLR P1 . 7 
                      4564     	BPFET_OFF				
0FC8    C294          4564+1   CLR P1 . 4 
0FCA    7406          4565     MOV A , # 6 
0FCC    D5E0FD        4566     	DJNZ ACC,	$
0FCF    020FD5        4567     	JMP	COMM45_NFET
                      4568     COMM45_NONDAMP: 
0FD2    9001CF        4569     	MOV	DPTR, #PWM_AFET_ON
                      4570     COMM45_NFET: 
                      4571     	BNFET_OFF					; Bn off
0FD5    C295          4571+1   CLR P1 . 5 
0FD7    305A0E        4572     JNB FLAGS0 . 2 , COMM45_CP 
                      4573     	ANFET_ON					; Yes - An on
0FDA    E525          4573+1   MOV A , CURRENT_PWM_LIMITED 
0FDC    600A          4573+1   JZ ( $+12 ) 
0FDE    207502        4573+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE1    D292          4573+1   SETB P1 . 2 
0FE3    307502        4573+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FE6    D296          4573+1   SETB P1 . 6 
                      4574     COMM45_CP: 
                      4575     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FE8    759F80        4575+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FEB    753E05        4576     	MOV	COMM_PHASE, #5
0FEE    021083        4577     	JMP	COMM_EXIT
                      4578     
                      4579     COMM5COMM6: 	
0FF1    C2AF          4580     	CLR 	EA					; Disable all interrupts
                      4581     	CPFET_OFF					; Cp off
0FF3    207502        4581+1   JB FLAGS3 . 5 , ( $+5 ) 
0FF6    C297          4581+1   CLR P1 . 7 
0FF8    307502        4581+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FFB    C293          4581+1   CLR P1 . 3 
0FFD    206A03        4582     JB FLAGS2 . 2 , COMM56_DAMP 
1000    021018        4583     	JMP	COMM56_NONDAMP
                      4584     COMM56_DAMP: 
                      4585     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4589     IF DAMPED_MODE_ENABLE == 1
1003    900233        4590     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4591     ENDIF
1006    30650F        4592     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4593     	APFET_OFF				
1009    207502        4593+1   JB FLAGS3 . 5 , ( $+5 ) 
100C    C293          4593+1   CLR P1 . 3 
100E    307502        4593+1   JNB FLAGS3 . 5 , ( $+5 ) 
1011    C297          4593+1   CLR P1 . 7 
1013    7406          4594     MOV A , # 6 
1015    D5E0FD        4595     	DJNZ ACC,	$
                      4596     COMM56_NONDAMP: 
                      4597     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4605     	BPFET_ON					; Bp on
1018    D294          4605+1   SETB P1 . 4 
                      4606     	SET_COMP_PHASE_C 			; Set comparator to phase C
101A    207503        4606+1   JB FLAGS3 . 5 , ( $+6 ) 
101D    759F89        4606+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1020    307503        4606+1   JNB FLAGS3 . 5 , ( $+6 ) 
1023    759F81        4606+1   MOV CPT0MX , # 81H 
1026    753E06        4607     	MOV	COMM_PHASE, #6
1029    021083        4608     	JMP	COMM_EXIT
                      4609     
                      4610     COMM6COMM1: 	
102C    C2AF          4611     	CLR 	EA					; Disable all interrupts
102E    206A03        4612     JB FLAGS2 . 2 , COMM61_DAMP 
1031    021056        4613     	JMP	COMM61_NONDAMP
                      4614     COMM61_DAMP: 
                      4615     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4618     IF DAMPED_MODE_ENABLE == 1
1034    9003A0        4619     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4620     ENDIF
1037    30651F        4621     JNB FLAGS1 . 5 , COMM61_NFET 
                      4622     	APFET_OFF				
103A    207502        4622+1   JB FLAGS3 . 5 , ( $+5 ) 
103D    C293          4622+1   CLR P1 . 3 
103F    307502        4622+1   JNB FLAGS3 . 5 , ( $+5 ) 
1042    C297          4622+1   CLR P1 . 7 
                      4623     	CPFET_OFF				
1044    207502        4623+1   JB FLAGS3 . 5 , ( $+5 ) 
1047    C297          4623+1   CLR P1 . 7 
1049    307502        4623+1   JNB FLAGS3 . 5 , ( $+5 ) 
104C    C293          4623+1   CLR P1 . 3 
104E    7406          4624     MOV A , # 6 
1050    D5E0FD        4625     	DJNZ ACC,	$
1053    021059        4626     	JMP	COMM61_NFET
                      4627     COMM61_NONDAMP: 
1056    9001F3        4628     	MOV	DPTR, #PWM_CFET_ON
                      4629     COMM61_NFET: 
                      4630     	ANFET_OFF					; An off
1059    207502        4630+1   JB FLAGS3 . 5 , ( $+5 ) 
105C    C292          4630+1   CLR P1 . 2 
105E    307502        4630+1   JNB FLAGS3 . 5 , ( $+5 ) 
1061    C296          4630+1   CLR P1 . 6 
1063    305A0E        4631     JNB FLAGS0 . 2 , COMM61_CP 
                      4632     	CNFET_ON					; Yes - Cn on
1066    E525          4632+1   MOV A , CURRENT_PWM_LIMITED 
1068    600A          4632+1   JZ ( $+12 ) 
106A    207502        4632+1   JB FLAGS3 . 5 , ( $+5 ) 
106D    D296          4632+1   SETB P1 . 6 
106F    307502        4632+1   JNB FLAGS3 . 5 , ( $+5 ) 
1072    D292          4632+1   SETB P1 . 2 
                      4633     COMM61_CP: 
                      4634     	SET_COMP_PHASE_A 			; Set comparator to phase A
1074    207503        4634+1   JB FLAGS3 . 5 , ( $+6 ) 
1077    759F81        4634+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
107A    307503        4634+1   JNB FLAGS3 . 5 , ( $+6 ) 
107D    759F89        4634+1   MOV CPT0MX , # 89H 
1080    753E01        4635     	MOV	COMM_PHASE, #1
                      4636     
                      4637     COMM_EXIT: 
1083    D2AF          4638     	SETB	EA					; Enable all interrupts
1085    789C          4639     MOV R0 , # PGM_DEMAG_COMP 
1087    E6            4640     MOV A , @ R0 
1088    C3            4641     	CLR	C
1089    9402          4642     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
108B    4007          4643     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4644     
108D    C3            4645     	CLR	C
108E    E539          4646     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1090    9403          4647     	SUBB	A, #3
1092    5002          4648     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4649     
                      4650     COMM_RESTORE_POWER: 
1094    C25C          4651     CLR FLAGS0 . 4 
                      4652     
                      4653     COMM_RETURN: 
1096    22            4654     	RET
                      4655     
                      4656     
                      4657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4658     ;
                      4659     ; Switch power off routine
                      4660     ;
                      4661     ; No assumptions
                      4662     ;
                      4663     ; Switches all fets off 
                      4664     ;
                      4665     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4666     SWITCH_POWER_OFF: 
1097    9001CD        4667     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4668     	ALL_NFETS_OFF			; Turn off all nfets
109A    C292          4668+1   CLR P1 . 2 
109C    C296          4668+1   CLR P1 . 6 
109E    C295          4668+1   CLR P1 . 5 
                      4669     	ALL_PFETS_OFF			; Turn off all pfets
10A0    C293          4669+1   CLR P1 . 3 
10A2    C297          4669+1   CLR P1 . 7 
10A4    C294          4669+1   CLR P1 . 4 
10A6    C25A          4670     CLR FLAGS0 . 2 
10A8    22            4671     	RET			
                      4672     
                      4673     
                      4674     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4675     ;
                      4676     ; Decrement stepper step routine
                      4677     ;
                      4678     ; No assumptions
                      4679     ;
                      4680     ; Decrements the stepper step 
                      4681     ;
                      4682     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4683     DECREMENT_STEPPER_STEP: 
10A9    C3            4684     	CLR	C
10AA    E550          4685     	MOV	A, WT_STEPPER_STEP_L
10AC    9535          4686     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
10AE    E551          4687     	MOV	A, WT_STEPPER_STEP_H
10B0    9536          4688     	SUBB	A, STEPPER_STEP_END_H	
10B2    5001          4689     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
10B4    22            4690     	RET
                      4691     
                      4692     DECREMENT_STEP: 
                      4693     	; Load programmed startup acceleration
10B5    7890          4694     MOV R0 , # PGM_STARTUP_ACCEL 
10B7    E6            4695     MOV A , @ R0 
10B8    FF            4696     MOV R7 , A 
                      4697     	; Check acceleration setting and set step size accordingly
10B9    C3            4698     	CLR	C
10BA    EF            4699     MOV A , R7 
10BB    9405          4700     	SUBB	A, #5
10BD    5018          4701     	JNC	DEC_STEP_HIGH
10BF    C3            4702     	CLR	C
10C0    EF            4703     MOV A , R7 
10C1    9404          4704     	SUBB	A, #4
10C3    501B          4705     	JNC	DEC_STEP_MED_HIGH
10C5    C3            4706     	CLR	C
10C6    EF            4707     MOV A , R7 
10C7    9403          4708     	SUBB	A, #3
10C9    501E          4709     	JNC	DEC_STEP_MED
10CB    C3            4710     	CLR	C
10CC    EF            4711     MOV A , R7 
10CD    9402          4712     	SUBB	A, #2
10CF    5021          4713     	JNC	DEC_STEP_MED_LOW
10D1    C3            4714     	CLR	C
10D2    EF            4715     MOV A , R7 
10D3    9401          4716     	SUBB	A, #1
10D5    5024          4717     	JNC	DEC_STEP_LOW
                      4718     
                      4719     DEC_STEP_HIGH: 
10D7    C3            4720     	CLR	C
10D8    E550          4721     	MOV	A, WT_STEPPER_STEP_L
10DA    943C          4722     	SUBB	A, #LOW(30 SHL 1)		
10DC    F8            4723     MOV R0 , A 
10DD    021104        4724     	JMP	DECREMENT_STEP_EXIT
                      4725     DEC_STEP_MED_HIGH: 
10E0    C3            4726     	CLR	C
10E1    E550          4727     	MOV	A, WT_STEPPER_STEP_L
10E3    9428          4728     	SUBB	A, #LOW(20 SHL 1)		
10E5    F8            4729     MOV R0 , A 
10E6    021104        4730     	JMP	DECREMENT_STEP_EXIT
                      4731     DEC_STEP_MED: 
10E9    C3            4732     	CLR	C
10EA    E550          4733     	MOV	A, WT_STEPPER_STEP_L
10EC    941A          4734     	SUBB	A, #LOW(13 SHL 1)		
10EE    F8            4735     MOV R0 , A 
10EF    021104        4736     	JMP	DECREMENT_STEP_EXIT
                      4737     DEC_STEP_MED_LOW: 
10F2    C3            4738     	CLR	C
10F3    E550          4739     	MOV	A, WT_STEPPER_STEP_L
10F5    9412          4740     	SUBB	A, #LOW(9 SHL 1)		
10F7    F8            4741     MOV R0 , A 
10F8    021104        4742     	JMP	DECREMENT_STEP_EXIT
                      4743     DEC_STEP_LOW: 
10FB    C3            4744     	CLR	C
10FC    E550          4745     	MOV	A, WT_STEPPER_STEP_L
10FE    940A          4746     	SUBB	A, #LOW(5 SHL 1)		
1100    F8            4747     MOV R0 , A 
1101    021104        4748     	JMP	DECREMENT_STEP_EXIT
                      4749     
                      4750     DECREMENT_STEP_EXIT: 
1104    E551          4751     	MOV	A, WT_STEPPER_STEP_H
1106    9400          4752     	SUBB	A, #0		
1108    F9            4753     MOV R1 , A 
1109    8850          4754     MOV WT_STEPPER_STEP_L , R0 
110B    8951          4755     MOV WT_STEPPER_STEP_H , R1 
110D    22            4756     	RET
                      4757     
                      4758     
                      4759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4760     ;
                      4761     ; Stepper timer wait
                      4762     ;
                      4763     ; No assumptions
                      4764     ;
                      4765     ; Waits for the stepper step timer to elapse
                      4766     ;
                      4767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4768     STEPPER_TIMER_WAIT: 
110E    305802        4769     JNB FLAGS0 . 0 , ( $+5 ) 
1111    210E          4770     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
1113    22            4771     	RET
                      4772     
                      4773     
                      4774     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4775     ;
                      4776     ; Set default parameters
                      4777     ;
                      4778     ; No assumptions
                      4779     ;
                      4780     ; Sets default programming parameters
                      4781     ;
                      4782     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4783     SET_DEFAULT_PARAMETERS: 
                      4784     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4845     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4906     IF MODE == 2	; Multi
1114    7880          4907     MOV R0 , # PGM_GOV_P_GAIN 
1116    7609          4908     MOV @ R0 , # 9 
1118    08            4909     INC R0 
1119    7609          4910     MOV @ R0 , # 9 
111B    08            4911     INC R0 
111C    7604          4912     MOV @ R0 , # 4 
111E    08            4913     INC R0 
111F    7601          4914     MOV @ R0 , # 1 
1121    08            4915     INC R0 
1122    7603          4916     MOV @ R0 , # 3 
1124    08            4917     INC R0 
1125    76FF          4918     MOV @ R0 , # 0XFF 
1127    08            4919     INC R0 
1128    7609          4920     MOV @ R0 , # 9 
112A    08            4921     INC R0 
112B    7601          4922     MOV @ R0 , # 1 
112D    08            4923     INC R0 
112E    7601          4924     MOV @ R0 , # 1 
1130    08            4925     INC R0 
1131    7601          4926     MOV @ R0 , # 1 
                      4927     
1133    788C          4928     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1135    7600          4929     MOV @ R0 , # 0 
1137    08            4930     INC R0 
1138    76FF          4931     MOV @ R0 , # 0XFF 
113A    08            4932     INC R0 
113B    76FF          4933     MOV @ R0 , # 0XFF 
113D    08            4934     INC R0 
113E    7601          4935     MOV @ R0 , # 1 
1140    08            4936     INC R0 
1141    7605          4937     MOV @ R0 , # 5 
1143    08            4938     INC R0 
1144    76FF          4939     MOV @ R0 , # 0XFF 
1146    08            4940     INC R0 
1147    7603          4941     MOV @ R0 , # 3 
1149    08            4942     INC R0 
114A    7606          4943     MOV @ R0 , # 6 
114C    08            4944     INC R0 
114D    76FF          4945     MOV @ R0 , # 0XFF 
114F    08            4946     INC R0 
1150    7602          4947     MOV @ R0 , # 2 
1152    08            4948     INC R0 
1153    7603          4949     MOV @ R0 , # 3 
1155    08            4950     INC R0 
1156    76FA          4951     MOV @ R0 , # 250 
1158    08            4952     INC R0 
1159    7650          4953     MOV @ R0 , # 80 
115B    08            4954     INC R0 
115C    7650          4955     MOV @ R0 , # 80 
115E    08            4956     INC R0 
115F    7605          4957     MOV @ R0 , # 5 
1161    08            4958     INC R0 
1162    760D          4959     MOV @ R0 , # 13 
1164    08            4960     INC R0 
1165    7602          4961     MOV @ R0 , # 2 
1167    08            4962     INC R0 
1168    7600          4963     MOV @ R0 , # 0 
116A    08            4964     INC R0 
116B    767D          4965     MOV @ R0 , # 125 
                      4966     ENDIF
116D    22            4967     	RET
                      4968     
                      4969     
                      4970     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4971     ;
                      4972     ; Decode parameters
                      4973     ;
                      4974     ; No assumptions
                      4975     ;
                      4976     ; Decodes programming parameters
                      4977     ;
                      4978     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4979     DECODE_PARAMETERS: 
                      4980     	; Load programmed damping force
116E    7893          4981     MOV R0 , # PGM_DAMPING_FORCE 
1170    E6            4982     MOV A , @ R0 
1171    FF            4983     MOV R7 , A 
                      4984     	; Decode damping
1172    756609        4985     	MOV	DAMPING_PERIOD, #9		; Set default
1175    756701        4986     	MOV	DAMPING_ON, #1
1178    C3            4987     	CLR	C
1179    BF0206        4988     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      4989     
117C    756605        4990     	MOV	DAMPING_PERIOD, #5
117F    756701        4991     	MOV	DAMPING_ON, #1
                      4992     
                      4993     DECODE_DAMPING_3: 
1182    C3            4994     	CLR	C
1183    BF0306        4995     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      4996     
1186    756605        4997     	MOV	DAMPING_PERIOD, #5
1189    756702        4998     	MOV	DAMPING_ON, #2
                      4999     
                      5000     DECODE_DAMPING_4: 
118C    C3            5001     	CLR	C
118D    BF0406        5002     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5003     
1190    756605        5004     	MOV	DAMPING_PERIOD, #5
1193    756703        5005     	MOV	DAMPING_ON, #3
                      5006     
                      5007     DECODE_DAMPING_5: 
1196    C3            5008     	CLR	C
1197    BF0506        5009     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5010     
119A    756609        5011     	MOV	DAMPING_PERIOD, #9
119D    756707        5012     	MOV	DAMPING_ON, #7
                      5013     
                      5014     DECODE_DAMPING_6: 
11A0    C3            5015     	CLR	C
11A1    BF0606        5016     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5017     
11A4    756600        5018     	MOV	DAMPING_PERIOD, #0
11A7    756700        5019     	MOV	DAMPING_ON, #0
                      5020     
                      5021     DECODE_DAMPING_DONE: 
                      5022     	; Load programmed pwm frequency
11AA    7887          5023     MOV R0 , # PGM_PWM_FREQ 
11AC    E6            5024     MOV A , @ R0 
11AD    FF            5025     MOV R7 , A 
                      5026     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5033     IF MODE >= 1	; Tail or multi
11AE    C26C          5034     CLR FLAGS2 . 4 
11B0    C3            5035     	CLR	C
11B1    BF0302        5036     CJNE R7 , # 3 , ( $+5 ) 
11B4    D26C          5037     SETB FLAGS2 . 4 
11B6    C26B          5038     CLR FLAGS2 . 3 
11B8    C3            5039     	CLR	C
11B9    BF0402        5040     CJNE R7 , # 4 , ( $+5 ) 
11BC    D26B          5041     SETB FLAGS2 . 3 
                      5042     ENDIF
11BE    C26A          5043     CLR FLAGS2 . 2 
11C0    7418          5044     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11C2    552D          5045     	ANL	A, FLAGS2					; Check if any damped mode is set
11C4    6002          5046     	JZ	($+4)
11C6    D26A          5047     SETB FLAGS2 . 2 
11C8    C265          5048     CLR FLAGS1 . 5 
11CA    6002          5049     	JZ	($+4)
11CC    D265          5050     SETB FLAGS1 . 5 
11CE    D266          5051     SETB FLAGS1 . 6 
11D0    6002          5052     	JZ	($+4)
11D2    C266          5053     CLR FLAGS1 . 6 
                      5054     	; Load programmed direction
11D4    7888          5055     MOV R0 , # PGM_DIRECTION 
                      5056     IF MODE >= 1	; Tail or multi
11D6    E6            5057     MOV A , @ R0 
11D7    C3            5058     	CLR	C
11D8    9403          5059     	SUBB	A, #3
11DA    6008          5060     	JZ	DECODE_PARAMS_DIR_SET
                      5061     ENDIF
                      5062     
11DC    C275          5063     CLR FLAGS3 . 5 
11DE    E6            5064     MOV A , @ R0 
11DF    30E102        5065     	JNB	ACC.1, ($+5)
11E2    D275          5066     SETB FLAGS3 . 5 
                      5067     DECODE_PARAMS_DIR_SET: 
11E4    C276          5068     CLR FLAGS3 . 6 
11E6    7889          5069     MOV R0 , # PGM_INPUT_POL 
11E8    E6            5070     MOV A , @ R0 
11E9    30E102        5071     	JNB	ACC.1, ($+5)
11EC    D276          5072     SETB FLAGS3 . 6 
11EE    C3            5073     	CLR	C
11EF    EF            5074     MOV A , R7 
11F0    9402          5075     	SUBB	A, #2
11F2    6008          5076     	JZ	DECODE_PWM_FREQ_LOW
                      5077     
11F4    758E01        5078     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
11F7    D26D          5079     SETB FLAGS2 . 5 
11F9    021201        5080     	JMP	DECODE_PWM_FREQ_END
                      5081     
                      5082     DECODE_PWM_FREQ_LOW: 
11FC    758E00        5083     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
11FF    C26D          5084     CLR FLAGS2 . 5 
                      5085     
                      5086     DECODE_PWM_FREQ_END: 
1201    22            5087     	RET
                      5088     
                      5089     
                      5090     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5091     ;
                      5092     ; Decode governor gain
                      5093     ;
                      5094     ; No assumptions
                      5095     ;
                      5096     ; Decodes governor gains
                      5097     ;
                      5098     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5099     DECODE_GOVERNOR_GAINS: 
                      5100     	; Decode governor gains
1202    7880          5101     MOV R0 , # PGM_GOV_P_GAIN 
1204    E6            5102     MOV A , @ R0 
1205    14            5103     	DEC	A	
1206    900080        5104     	MOV	DPTR, #GOV_GAIN_TABLE
1209    93            5105     	MOVC A, @A+DPTR	
120A    789F          5106     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
120C    F6            5107     MOV @ R0 , A 
120D    7881          5108     MOV R0 , # PGM_GOV_I_GAIN 
120F    E6            5109     MOV A , @ R0 
1210    14            5110     	DEC	A	
1211    900080        5111     	MOV	DPTR, #GOV_GAIN_TABLE
1214    93            5112     	MOVC A, @A+DPTR	
1215    78A0          5113     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1217    F6            5114     MOV @ R0 , A 
1218    1197          5115     	CALL	SWITCH_POWER_OFF		; Reset DPTR
121A    22            5116     	RET
                      5117     
                      5118     
                      5119     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5120     ;
                      5121     ; Decode throttle rate
                      5122     ;
                      5123     ; No assumptions
                      5124     ;
                      5125     ; Decodes throttle rate
                      5126     ;
                      5127     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5128     DECODE_THROTTLE_RATE: 
                      5129     	; Decode throttle rate
121B    789B          5130     MOV R0 , # PGM_THROTTLE_RATE 
121D    E6            5131     MOV A , @ R0 
121E    14            5132     	DEC	A	
121F    90008D        5133     	MOV	DPTR, #THROTTLE_RATE_TABLE
1222    93            5134     	MOVC A, @A+DPTR	
1223    78A1          5135     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
1225    F6            5136     MOV @ R0 , A 
1226    1197          5137     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1228    22            5138     	RET
                      5139     
                      5140     
                      5141     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5142     ;
                      5143     ; Decode startup power
                      5144     ;
                      5145     ; No assumptions
                      5146     ;
                      5147     ; Decodes startup power
                      5148     ;
                      5149     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5150     DECODE_STARTUP_POWER: 
                      5151     	; Decode startup power
1229    7886          5152     MOV R0 , # PGM_STARTUP_PWR 
122B    E6            5153     MOV A , @ R0 
122C    14            5154     	DEC	A	
122D    90009A        5155     	MOV	DPTR, #STARTUP_POWER_TABLE
1230    93            5156     	MOVC A, @A+DPTR	
1231    78A2          5157     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1233    F6            5158     MOV @ R0 , A 
1234    1197          5159     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1236    22            5160     	RET
                      5161     
                      5162     
                      5163     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5164     ;
                      5165     ; Decode demag compensation
                      5166     ;
                      5167     ; No assumptions
                      5168     ;
                      5169     ; Decodes throttle rate
                      5170     ;
                      5171     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5172     DECODE_DEMAG_COMP: 
                      5173     	; Decode demag compensation
1237    789C          5174     MOV R0 , # PGM_DEMAG_COMP 
1239    E6            5175     MOV A , @ R0 
123A    14            5176     	DEC	A	
123B    9000A7        5177     	MOV	DPTR, #DEMAG_POWER_TABLE
123E    93            5178     	MOVC A, @A+DPTR	
123F    78A3          5179     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
1241    F6            5180     MOV @ R0 , A 
1242    1197          5181     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1244    22            5182     	RET
                      5183     
                      5184     
                      5185     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5186     ;
                      5187     ; Set BEC voltage
                      5188     ;
                      5189     ; No assumptions
                      5190     ;
                      5191     ; Sets the BEC output voltage low or high
                      5192     ;
                      5193     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5194     SET_BEC_VOLTAGE: 
                      5195     	; Set bec voltage
                      5196     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1245    22            5206     	RET
                      5207     
                      5208     
                      5209     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5210     ;
                      5211     ; Find throttle gain
                      5212     ;
                      5213     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5214     ;
                      5215     ; Finds throttle gain from throttle calibration values
                      5216     ;
                      5217     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5218     FIND_THROTTLE_GAIN: 
                      5219     	; Load programmed minimum and maximum throttle
1246    7896          5220     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1248    E6            5221     MOV A , @ R0 
1249    FA            5222     MOV R2 , A 
124A    7897          5223     MOV R0 , # PGM_PPM_MAX_THROTTLE 
124C    E6            5224     MOV A , @ R0 
124D    FB            5225     MOV R3 , A 
                      5226     	; Check if full range is chosen
124E    307704        5227     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5228     
1251    7A00          5229     MOV R2 , # 0 
1253    7BFF          5230     MOV R3 , # 255 
                      5231     
                      5232     FIND_THROTTLE_GAIN_CALCULATE: 
                      5233     	; Calculate difference
1255    C3            5234     	CLR	C
1256    EB            5235     MOV A , R3 
1257    9A            5236     SUBB A , R2 
1258    FC            5237     MOV R4 , A 
                      5238     	; Check that difference is minimum 130
1259    C3            5239     	CLR	C
125A    9482          5240     	SUBB	A, #130
125C    5002          5241     	JNC	($+4)
                      5242     
125E    7C82          5243     MOV R4 , # 130 
                      5244     
                      5245     	; Find gain
1260    756E00        5246     	MOV	PPM_THROTTLE_GAIN, #0
                      5247     TEST_THROTTLE_GAIN: 
1263    056E          5248     	INC	PPM_THROTTLE_GAIN
1265    EC            5249     MOV A , R4 
1266    856EF0        5250     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1269    A4            5251     	MUL	AB
126A    C3            5252     	CLR	C
126B    E5F0          5253     	MOV	A, B
126D    9480          5254     	SUBB	A, #128
126F    40F2          5255     	JC	TEST_THROTTLE_GAIN
1271    22            5256     	RET
                      5257     
                      5258     
                      5259     
                      5260     
                      5261     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5263     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5264     ;
                      5265     ; Main program start
                      5266     ;
                      5267     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5268     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5269     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5270     
                      5271     RESET: 
                      5272     	; Check flash lock byte
1272    E5EF          5273     	MOV	A, RSTSRC			
1274    20E603        5274     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5275     
1277    752000        5276     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5277     
127A    0520          5278     	INC	BIT_ACCESS
127C    903FFF        5279     MOV DPTR , # 16383 
127F    E520          5280     	MOV	A, BIT_ACCESS
1281    14            5281     	DEC	A
1282    6006          5282     	JZ	LOCK_BYTE_TEST
                      5283     
1284    901FFF        5284     MOV DPTR , # 8191 
1287    14            5285     	DEC	A
1288    6000          5286     	JZ	LOCK_BYTE_TEST
                      5287     
                      5288     LOCK_BYTE_TEST: 
128A    93            5289     	MOVC A, @A+DPTR		; Read lock byte
128B    04            5290     	INC	A				
128C    6003          5291     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5292     
                      5293     IF ONE_S_CAPABLE == 0		
128E    75EF12        5294     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5295     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5298     
                      5299     LOCK_BYTE_OK: 
                      5300     	; Select register bank 0 for main program routines
1291    C2D3          5301     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5302     	; Disable the WDT.
1293    53D9BF        5303     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5304     	; Initialize stack
1296    7581C0        5305     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5306     	; Initialize VDD monitor
1299    43FF80        5307     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
129C    1207EB        5308     	CALL	WAIT1MS			; Wait at least 100us
                      5309     IF ONE_S_CAPABLE == 0		
129F    75EF02        5310     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5311     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5314     	; Set clock frequency
12A2    43B203        5315     	ORL	OSCICN, #03H		; Set clock divider to 1
12A5    E5B3          5316     	MOV	A, OSCICL				
12A7    2404          5317     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
12A9    4002          5318     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5319     
12AB    F5B3          5320     	MOV	OSCICL, A
                      5321     
                      5322     RESET_CAL_DONE: 
                      5323     	; Switch power off
12AD    1197          5324     	CALL	SWITCH_POWER_OFF
                      5325     	; Ports initialization
12AF    7580FF        5326     MOV P0 , # 255 
12B2    75A400        5327     MOV P0MDOUT , # 0 
12B5    75F1F0        5328     MOV P0MDIN , # -16 
12B8    75D4DF        5329     MOV P0SKIP , # -33 
12BB    759002        5330     MOV P1 , # 2 
12BE    75A5FC        5331     MOV P1MDOUT , # 252 
12C1    75F2FD        5332     MOV P1MDIN , # -3 
12C4    75D502        5333     MOV P1SKIP , # 2 
                      5334     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12C7    75A610        5337     MOV P2MDOUT , # 16 
                      5338     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5345     	; Initialize the XBAR and related functionality
                      5346     	INITIALIZE_XBAR		
12CA    75A0FF        5346+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12CD    75F3F1        5346+1   MOV P2MDIN , # -15 
12D0    75E241        5346+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5347     	; Clear RAM
12D3    E4            5348     	CLR	A				; Clear accumulator
12D4    F8            5349     MOV R0 , A 
                      5350     CLEAR_RAM: 	
12D5    F6            5351     MOV @ R0 , A 
12D6    D8FD          5352     DJNZ R0 , CLEAR_RAM 
                      5353     	; Set default programmed parameters
12D8    3114          5354     	CALL	SET_DEFAULT_PARAMETERS
                      5355     	; Decode parameters
12DA    316E          5356     	CALL	DECODE_PARAMETERS
                      5357     	; Decode governor gains
12DC    5102          5358     	CALL	DECODE_GOVERNOR_GAINS
                      5359     	; Decode throttle rate
12DE    511B          5360     	CALL	DECODE_THROTTLE_RATE
                      5361     	; Decode startup power
12E0    5129          5362     	CALL	DECODE_STARTUP_POWER
                      5363     	; Decode demag compensation
12E2    5137          5364     	CALL	DECODE_DEMAG_COMP
                      5365     	; Set BEC voltage
12E4    5145          5366     	CALL	SET_BEC_VOLTAGE
                      5367     	; Find throttle gain from stored min and max settings
12E6    5146          5368     	CALL	FIND_THROTTLE_GAIN
                      5369     	; Set beep strength
12E8    7898          5370     MOV R0 , # PGM_BEEP_STRENGTH 
12EA    866F          5371     MOV BEEP_STRENGTH , @ R0 
                      5372     	; Switch power off
12EC    1197          5373     	CALL	SWITCH_POWER_OFF
                      5374     	; Timer control
12EE    758850        5375     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5376     	; Timer mode
12F1    758902        5377     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5378     	; Timer2: clk/12 for 128us and 32ms interrupts
12F4    75C824        5379     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5380     	; Timer3: clk/12 for commutation timing
12F7    759104        5381     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5382     	; PCA
12FA    75D840        5383     	MOV	PCA0CN, #40H		; PCA enabled
                      5384     	; Initializing beep
12FD    C2AF          5385     	CLR	EA				; Disable interrupts explicitly
12FF    120804        5386     	CALL WAIT200MS	
1302    12081B        5387     	CALL BEEP_F1
1305    1207FA        5388     	CALL WAIT30MS
1308    120822        5389     	CALL BEEP_F2
130B    1207FA        5390     	CALL WAIT30MS
130E    120829        5391     	CALL BEEP_F3
1311    1207FA        5392     	CALL WAIT30MS
                      5393     
                      5394     	; Wait for receiver to initialize
1314    120814        5395     	CALL	WAIT1S
1317    120804        5396     	CALL	WAIT200MS
131A    120804        5397     	CALL	WAIT200MS
131D    1207FF        5398     	CALL	WAIT100MS
                      5399     
                      5400     	; Enable interrupts
1320    75A822        5401     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1323    75B802        5402     	MOV	IP, #02H			; High priority to timer0 interrupts
1326    75E690        5403     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5404     	; Initialize comparator
1329    759B80        5405     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
132C    759D03        5406     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5407     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5411     	; Initialize ADC
                      5412     	INITIALIZE_ADC			; Initialize ADC operation
132F    75D10E        5412+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1332    75BC58        5412+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1335    75BB09        5412+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1338    75BA11        5412+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
133B    75E880        5412+1   MOV ADC0CN , # 80H  ; ADC ENABLED
133E    1207EB        5413     	CALL	WAIT1MS
1341    D2AF          5414     	SETB	EA				; Enable all interrupts
                      5415     	; Measure number of lipo cells
1343    120AD3        5416     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5417     	; Initialize rc pulse
                      5418     	RCP_INT_ENABLE		 			; Enable interrupt
1346    43DA01        5418+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5419     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1349    C2D8          5419+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
134B    C269          5420     CLR FLAGS2 . 1 
134D    120804        5421     	CALL WAIT200MS
                      5422     	; Set initial arm variable
1350    753001        5423     	MOV	INITIAL_ARM, #1
                      5424     
                      5425     	; Measure PWM frequency
                      5426     MEASURE_PWM_FREQ_INIT: 	
1353    D259          5427     SETB FLAGS0 . 1 
                      5428     MEASURE_PWM_FREQ_START: 	
1355    7A05          5429     MOV R2 , # 5 
                      5430     MEASURE_PWM_FREQ_LOOP: 	
                      5431     	; Check if period diff was accepted
1357    E558          5432     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1359    7002          5433     	JNZ	($+4)
                      5434     
135B    7A05          5435     MOV R2 , # 5 
                      5436     
135D    1207F0        5437     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1360    E559          5438     	MOV	A, NEW_RCP					; Load value
1362    C3            5439     	CLR	C
1363    9402          5440     SUBB A , # 2 
1365    40EE          5441     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5442     
1367    E52E          5443     	MOV	A, FLAGS3						; Check pwm frequency flags
1369    541F          5444     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
136B    855B5A        5445     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
136E    F55B          5446     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1370    B55AE2        5447     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5448     
1373    DAE2          5449     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5450     
                      5451     	; Clear measure pwm frequency flag
1375    C259          5452     CLR FLAGS0 . 1 
                      5453     	; Set up RC pulse interrupts after pwm frequency measurement
                      5454     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1377    53DACF        5454+1   ANL PCA0CPM0 , # 0CFH 
137A    207603        5454+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
137D    43DA20        5454+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1380    307603        5454+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1383    43DA10        5454+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5455     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1386    C2D8          5455+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1388    C269          5456     CLR FLAGS2 . 1 
138A    1207FF        5457     	CALL WAIT100MS						; Wait for new RC pulse
                      5458     
                      5459     	; Validate RC pulse
                      5460     VALIDATE_RCP_START: 	
138D    1207F0        5461     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1390    7802          5462     MOV R0 , # 2 
1392    741F          5463     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1394    552E          5464     	ANL	A, FLAGS3						; Check pwm frequency flags
1396    7002          5465     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5466     
1398    7800          5467     MOV R0 , # 0 
                      5468     
139A    C3            5469     	CLR	C
139B    E559          5470     	MOV	A, NEW_RCP					; Load value
139D    98            5471     SUBB A , R0 
139E    40ED          5472     	JC	VALIDATE_RCP_START				; No - start over
                      5473     
                      5474     	; Beep arm sequence start signal
13A0    C2AF          5475     	CLR 	EA							; Disable all interrupts
13A2    12081B        5476     	CALL BEEP_F1
13A5    1207FA        5477     	CALL WAIT30MS
13A8    12081B        5478     	CALL BEEP_F1
13AB    1207FA        5479     	CALL WAIT30MS
13AE    120822        5480     	CALL BEEP_F2
13B1    1207FA        5481     	CALL WAIT30MS
13B4    120822        5482     	CALL BEEP_F2
13B7    1207FA        5483     	CALL WAIT30MS
13BA    D2AF          5484     	SETB	EA							; Enable all interrupts
13BC    120804        5485     	CALL WAIT200MS	
                      5486     
                      5487     	; Arming sequence start
13BF    754800        5488     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5489     ARMING_START: 
                      5490     IF MODE >= 1	; Tail or multi
13C2    7888          5491     MOV R0 , # PGM_DIRECTION 
13C4    E6            5492     MOV A , @ R0 
13C5    B40302        5493     	CJNE	A, #3, ($+5)
                      5494     
13C8    818B          5495     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      5496     ENDIF
                      5497     
13CA    1207F0        5498     	CALL WAIT3MS
13CD    788C          5499     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
13CF    E6            5500     MOV A , @ R0 
13D0    C3            5501     	CLR	C
13D1    9401          5502     	SUBB	A, #1				; Is TX programming enabled?
13D3    5003          5503     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5504     
13D5    02148B        5505     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5506     
                      5507     ARMING_INITIAL_ARM_CHECK: 
13D8    E530          5508     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
13DA    C3            5509     	CLR	C
13DB    9401          5510     	SUBB	A, #1				; Is it the initial arm sequence?
13DD    5003          5511     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5512     
13DF    02148B        5513     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5514     
                      5515     ARMING_PPM_CHECK: 
13E2    741F          5516     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13E4    552E          5517     	ANL	A, FLAGS3				; Check pwm frequency flags
13E6    6032          5518     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5519     
                      5520     	; PWM tx program entry
13E8    C3            5521     	CLR	C
13E9    E559          5522     	MOV	A, NEW_RCP			; Load new RC pulse value
13EB    94FF          5523     SUBB A , # 255 
13ED    5003          5524     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5525     
13EF    02148B        5526     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5527     
                      5528     PROGRAM_BY_TX_ENTRY_PWM: 	
13F2    C2AF          5529     	CLR	EA					; Disable all interrupts
13F4    120830        5530     	CALL BEEP_F4
13F7    D2AF          5531     	SETB	EA					; Enable all interrupts
13F9    1207FF        5532     	CALL WAIT100MS
13FC    C3            5533     	CLR	C
13FD    E559          5534     	MOV	A, NEW_RCP			; Load new RC pulse value
13FF    9401          5535     SUBB A , # 1 
1401    50EF          5536     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5537     
                      5538     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
1403    C2AF          5539     	CLR	EA					; Disable all interrupts
1405    12081B        5540     	CALL BEEP_F1
1408    1207F5        5541     	CALL WAIT10MS
140B    12081B        5542     	CALL BEEP_F1
140E    D2AF          5543     	SETB	EA					; Enable all interrupts
1410    1207FF        5544     	CALL WAIT100MS
1413    C3            5545     	CLR	C
1414    E559          5546     	MOV	A, NEW_RCP			; Load new RC pulse value
1416    94FF          5547     SUBB A , # 255 
1418    40E9          5548     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5549     
                      5550     	; jmp	program_by_tx			; Yes - enter programming mode
                      5551     
                      5552     	; PPM throttle calibration and tx program entry
                      5553     THROTTLE_HIGH_CAL_START: 
141A    7F05          5554     MOV R7 , # 5 
                      5555     THROTTLE_HIGH_CAL: 			
141C    D277          5556     SETB FLAGS3 . 7 
141E    5146          5557     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1420    1207FF        5558     	CALL WAIT100MS				; Wait for new throttle value
1423    C2AF          5559     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1425    C277          5560     CLR FLAGS3 . 7 
1427    5146          5561     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1429    AE59          5562     MOV R6 , NEW_RCP 
142B    C3            5563     	CLR	C
142C    E559          5564     	MOV	A, NEW_RCP			; Load new RC pulse value
142E    947F          5565     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1430    D2AF          5566     	SETB	EA					; Enable interrupts
1432    4061          5567     	JC	ARM_TARGET_UPDATED		; No - branch
                      5568     
1434    1207EB        5569     	CALL WAIT1MS		
1437    C2AF          5570     	CLR	EA					; Disable all interrupts
1439    120830        5571     	CALL BEEP_F4
143C    D2AF          5572     	SETB	EA					; Enable all interrupts
143E    DFDC          5573     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5574     
1440    C3            5575     	CLR	C
1441    EE            5576     MOV A , R6 
1442    9405          5577     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1444    7897          5578     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1446    F6            5579     MOV @ R0 , A 
1447    120804        5580     	CALL WAIT200MS				
                      5581     	; call erase_and_store_all_in_eeprom	
                      5582     	; call	success_beep
                      5583     
                      5584     THROTTLE_LOW_CAL_START: 
144A    7F0A          5585     MOV R7 , # 10 
                      5586     THROTTLE_LOW_CAL: 			
144C    D277          5587     SETB FLAGS3 . 7 
144E    5146          5588     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1450    1207FF        5589     	CALL WAIT100MS
1453    C2AF          5590     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1455    C277          5591     CLR FLAGS3 . 7 
1457    5146          5592     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1459    AE59          5593     MOV R6 , NEW_RCP 
145B    C3            5594     	CLR	C
145C    E559          5595     	MOV	A, NEW_RCP			; Load new RC pulse value
145E    947F          5596     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1460    D2AF          5597     	SETB	EA					; Enable interrupts
1462    50E6          5598     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5599     
1464    1207EB        5600     	CALL WAIT1MS		
1467    C2AF          5601     	CLR	EA					; Disable all interrupts
1469    12081B        5602     	CALL BEEP_F1
146C    1207F5        5603     	CALL WAIT10MS
146F    12081B        5604     	CALL BEEP_F1
1472    D2AF          5605     	SETB	EA					; Enable all interrupts
1474    DFD6          5606     DJNZ R7 , THROTTLE_LOW_CAL 
                      5607     
1476    EE            5608     MOV A , R6 
1477    2405          5609     	ADD	A, #5				; Add about 2%
1479    7896          5610     MOV R0 , # PGM_PPM_MIN_THROTTLE 
147B    F6            5611     MOV @ R0 , A 
147C    120804        5612     	CALL WAIT200MS				
                      5613     	; call erase_and_store_all_in_eeprom	
                      5614     	; call	success_beep_inverted
                      5615     
                      5616     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
147F    1207FF        5617     	CALL WAIT100MS
1482    5146          5618     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1484    C3            5619     	CLR	C
1485    E559          5620     	MOV	A, NEW_RCP			; Load new RC pulse value
1487    94FF          5621     SUBB A , # 255 
1489    40F4          5622     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5623     
                      5624     	; jmp	program_by_tx			; Yes - enter programming mode
                      5625     
                      5626     PROGRAM_BY_TX_CHECKED: 
148B    C3            5627     	CLR	C
148C    E559          5628     	MOV	A, NEW_RCP			; Load new RC pulse value
148E    9548          5629     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1490    4003          5630     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5631     
1492    855948        5632     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5633     
                      5634     ARM_TARGET_UPDATED: 
1495    1207FF        5635     	CALL WAIT100MS				; Wait for new throttle value
1498    C3            5636     	CLR	C
1499    E559          5637     	MOV	A, NEW_RCP			; Load new RC pulse value
149B    9401          5638     SUBB A , # 1 
149D    4002          5639     	JC	ARM_END_BEEP			; Yes - proceed
                      5640     
149F    61C2          5641     	JMP	ARMING_START			; No - start over
                      5642     
                      5643     ARM_END_BEEP: 
                      5644     	; Beep arm sequence end signal
14A1    C2AF          5645     	CLR 	EA					; Disable all interrupts
14A3    120830        5646     	CALL BEEP_F4
14A6    1207FA        5647     	CALL WAIT30MS
14A9    120830        5648     	CALL BEEP_F4
14AC    1207FA        5649     	CALL WAIT30MS
14AF    120829        5650     	CALL BEEP_F3
14B2    1207FA        5651     	CALL WAIT30MS
14B5    120829        5652     	CALL BEEP_F3
14B8    1207FA        5653     	CALL WAIT30MS
14BB    D2AF          5654     	SETB	EA					; Enable all interrupts
14BD    120804        5655     	CALL WAIT200MS
                      5656     
                      5657     	; Clear initial arm variable
14C0    753000        5658     	MOV	INITIAL_ARM, #0
                      5659     
                      5660     	; Armed and waiting for power on
                      5661     WAIT_FOR_POWER_ON: 
14C3    E4            5662     	CLR	A
14C4    F531          5663     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
14C6    F532          5664     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5665     WAIT_FOR_POWER_ON_LOOP: 
14C8    0531          5666     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
14CA    E531          5667     	MOV	A, POWER_ON_WAIT_CNT_L
14CC    F4            5668     	CPL	A
14CD    7039          5669     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5670     
14CF    0532          5671     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
14D1    789A          5672     MOV R0 , # PGM_BEACON_DELAY 
14D3    E6            5673     MOV A , @ R0 
14D4    7819          5674     MOV R0 , # 25 
14D6    14            5675     	DEC	A
14D7    6012          5676     	JZ	BEEP_DELAY_SET
                      5677     
14D9    7832          5678     MOV R0 , # 50 
14DB    14            5679     	DEC	A
14DC    600D          5680     	JZ	BEEP_DELAY_SET
                      5681     
14DE    787D          5682     MOV R0 , # 125 
14E0    14            5683     	DEC	A
14E1    6008          5684     	JZ	BEEP_DELAY_SET
                      5685     
14E3    78FA          5686     MOV R0 , # 250 
14E5    14            5687     	DEC	A
14E6    6003          5688     	JZ	BEEP_DELAY_SET
                      5689     
14E8    753200        5690     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5691     
                      5692     BEEP_DELAY_SET: 
14EB    C3            5693     	CLR	C
14EC    E532          5694     	MOV	A, POWER_ON_WAIT_CNT_H
14EE    98            5695     SUBB A , R0 
14EF    4017          5696     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5697     
14F1    1532          5698     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14F3    7531B4        5699     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14F6    7899          5700     MOV R0 , # PGM_BEACON_STRENGTH 
14F8    866F          5701     MOV BEEP_STRENGTH , @ R0 
14FA    C2AF          5702     	CLR 	EA					; Disable all interrupts
14FC    120830        5703     	CALL BEEP_F4				; Signal that there is no signal
14FF    D2AF          5704     	SETB	EA					; Enable all interrupts
1501    7898          5705     MOV R0 , # PGM_BEEP_STRENGTH 
1503    866F          5706     MOV BEEP_STRENGTH , @ R0 
1505    1207FF        5707     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5708     
                      5709     WAIT_FOR_POWER_ON_NO_BEEP: 
1508    1207F5        5710     	CALL WAIT10MS
150B    E528          5711     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
150D    7008          5712     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5713     
150F    741F          5714     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1511    552E          5715     	ANL	A, FLAGS3						; Check pwm frequency flags
1513    7002          5716     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5717     
1515    6153          5718     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5719     
                      5720     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1517    C3            5721     	CLR	C
1518    E559          5722     	MOV	A, NEW_RCP			; Load new RC pulse value
151A    9406          5723     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
151C    40AA          5724     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5725     
                      5726     IF MODE >= 1	; Tail or multi
151E    7888          5727     MOV R0 , # PGM_DIRECTION 
1520    E6            5728     MOV A , @ R0 
1521    C3            5729     	CLR	C
1522    9403          5730     	SUBB	A, #3
1524    6003          5731     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5732     ENDIF
                      5733     
1526    1207FF        5734     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5735     
1529    E528          5736     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
152B    7003          5737     	JNZ	($+5)				; If it is not zero - proceed
                      5738     
152D    021353        5739     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5740     
                      5741     
                      5742     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5743     ;
                      5744     ; Start entry point
                      5745     ;
                      5746     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5747     INIT_START: 
1530    C2AF          5748     	CLR	EA
1532    1197          5749     	CALL SWITCH_POWER_OFF
1534    E4            5750     	CLR	A
1535    F522          5751     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1537    F523          5752     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1539    F524          5753     	MOV	CURRENT_PWM, A			; Set current pwm to zero
153B    F525          5754     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
153D    D2AF          5755     	SETB	EA
153F    7885          5756     MOV R0 , # PGM_MOTOR_IDLE 
1541    8661          5757     MOV PWM_MOTOR_IDLE , @ R0 
1543    F540          5758     	MOV	GOV_TARGET_L, A		; Set target to zero
1545    F541          5759     	MOV	GOV_TARGET_H, A
1547    F542          5760     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1549    F543          5761     	MOV	GOV_INTEGRAL_H, A
154B    F544          5762     	MOV	GOV_INTEGRAL_X, A
154D    F56C          5763     	MOV	ADC_CONVERSION_CNT, A
154F    F549          5764     	MOV	GOV_ACTIVE, A
1551    F52B          5765     	MOV	FLAGS0, A				; Clear flags0
1553    F52C          5766     	MOV	FLAGS1, A				; Clear flags1
1555    F539          5767     	MOV	DEMAG_CONSECUTIVE_CNT, A
1557    120C51        5768     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5769     	;**** **** **** **** ****
                      5770     	; Motor start beginning
                      5771     	;**** **** **** **** **** 
155A    756C08        5772     MOV ADC_CONVERSION_CNT , # 8 
                      5773     	SET_ADC_IP_TEMP
155D    75BB10        5773+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1560    1207EB        5774     	CALL WAIT1MS
1563    120B6E        5775     	CALL START_ADC_CONVERSION
                      5776     READ_INITIAL_TEMP: 
                      5777     	GET_ADC_STATUS 
1566    E5E8          5777+1   MOV A , ADC0CN 
1568    20ECFB        5778     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5779     	READ_ADC_RESULT						; Read initial temperature
156B    A8BD          5779+1   MOV R0 , ADC0L 
156D    A9BE          5779+1   MOV R1 , ADC0H 
156F    E9            5780     MOV A , R1 
1570    7001          5781     	JNZ	($+3)							; Is reading below 256?
                      5782     
1572    F8            5783     MOV R0 , A 
                      5784     
1573    886D          5785     MOV CURRENT_AVERAGE_TEMP , R0 
1575    120B72        5786     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1578    756C08        5787     MOV ADC_CONVERSION_CNT , # 8 
                      5788     	SET_ADC_IP_TEMP
157B    75BB10        5788+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5789     
                      5790     	; Go to the desired startup mode
157E    7895          5791     MOV R0 , # PGM_STARTUP_METHOD 
1580    E6            5792     MOV A , @ R0 
1581    30E003        5793     	JNB	ACC.0, DIRECT_METHOD_START
                      5794     
1584    0215C8        5795     	JMP	STEPPER_METHOD_START
                      5796     
                      5797     DIRECT_METHOD_START: 
                      5798     	; Set up start operating conditions
1587    7887          5799     MOV R0 , # PGM_PWM_FREQ 
1589    E6            5800     MOV A , @ R0 
158A    FE            5801     MOV R6 , A 
158B    7602          5802     MOV @ R0 , # 2 
158D    316E          5803     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
158F    7887          5804     MOV R0 , # PGM_PWM_FREQ 
1591    EE            5805     MOV A , R6 
1592    F6            5806     MOV @ R0 , A 
                      5807     	; Set max allowed power
1593    D261          5808     SETB FLAGS1 . 1 
1595    C2AF          5809     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1597    755EFF        5810     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
159A    120C21        5811     	CALL SET_STARTUP_PWM
159D    85225E        5812     	MOV	PWM_LIMIT, REQUESTED_PWM
15A0    85225F        5813     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
15A3    D2AF          5814     	SETB	EA
15A5    C261          5815     CLR FLAGS1 . 1 
15A7    752501        5816     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
15AA    855D64        5817     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15AD    756501        5818     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5819     	; Begin startup sequence
15B0    D260          5820     SETB FLAGS1 . 0 
15B2    D263          5821     SETB FLAGS1 . 3 
15B4    753800        5822     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15B7    120FF1        5823     	CALL COMM5COMM6				; Initialize commutation
15BA    112C          5824     	CALL COMM6COMM1				
15BC    120CCB        5825     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
15BF    120C51        5826     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
15C2    120D4E        5827     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15C5    0216F0        5828     	JMP	RUN1
                      5829     
                      5830     
                      5831     STEPPER_METHOD_START: 
                      5832     	; Set up start operating conditions
15C8    7887          5833     MOV R0 , # PGM_PWM_FREQ 
15CA    E6            5834     MOV A , @ R0 
15CB    FE            5835     MOV R6 , A 
15CC    7603          5836     MOV @ R0 , # 3 
15CE    7893          5837     MOV R0 , # PGM_DAMPING_FORCE 
15D0    E6            5838     MOV A , @ R0 
15D1    FD            5839     MOV R5 , A 
15D2    7605          5840     MOV @ R0 , # 5 
15D4    316E          5841     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15D6    7887          5842     MOV R0 , # PGM_PWM_FREQ 
15D8    EE            5843     MOV A , R6 
15D9    F6            5844     MOV @ R0 , A 
15DA    7893          5845     MOV R0 , # PGM_DAMPING_FORCE 
15DC    ED            5846     MOV A , R5 
15DD    F6            5847     MOV @ R0 , A 
                      5848     	; Begin startup sequence
15DE    D260          5849     SETB FLAGS1 . 0 
15E0    D261          5850     SETB FLAGS1 . 1 
15E2    D265          5851     SETB FLAGS1 . 5 
15E4    120FF1        5852     	CALL COMM5COMM6			; Initialize commutation
15E7    112C          5853     	CALL COMM6COMM1			
15E9    755EFF        5854     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15EC    120C21        5855     	CALL SET_STARTUP_PWM
15EF    1207EB        5856     	CALL WAIT1MS
15F2    120EF9        5857     	CALL COMM1COMM2
15F5    1207EB        5858     	CALL WAIT1MS
15F8    1207EB        5859     	CALL WAIT1MS
15FB    120F2B        5860     	CALL COMM2COMM3
15FE    1207F0        5861     	CALL WAIT3MS			
1601    120F75        5862     	CALL COMM3COMM4
1604    1207F0        5863     	CALL WAIT3MS			
1607    1207F0        5864     	CALL WAIT3MS			
160A    120FB0        5865     	CALL COMM4COMM5
160D    1207F5        5866     	CALL WAIT10MS				; Settle rotor
1610    120FF1        5867     	CALL COMM5COMM6
1613    1207F0        5868     	CALL WAIT3MS				
1616    1207EB        5869     	CALL WAIT1MS			
1619    C261          5870     CLR FLAGS1 . 1 
161B    D262          5871     SETB FLAGS1 . 2 
                      5872     
                      5873     	;**** **** **** **** ****
                      5874     	; Stepper phase beginning
                      5875     	;**** **** **** **** **** 
                      5876     STEPPER_ROT_BEG: 
161D    120B6E        5877     	CALL START_ADC_CONVERSION
1620    120B72        5878     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1623    120C21        5879     	CALL SET_STARTUP_PWM
1626    756C08        5880     MOV ADC_CONVERSION_CNT , # 8 
                      5881     	SET_ADC_IP_TEMP
1629    75BB10        5881+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5882     
162C    112C          5883     	CALL COMM6COMM1				; Commutate
162E    120CC4        5884     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
1631    120D4E        5885     	CALL CALC_NEW_WAIT_TIMES
1634    11A9          5886     	CALL DECREMENT_STEPPER_STEP
1636    310E          5887     	CALL STEPPER_TIMER_WAIT
                      5888     
1638    120EF9        5889     	CALL COMM1COMM2			
163B    120CC4        5890     	CALL CALC_NEXT_COMM_TIMING_START	
163E    120D4E        5891     	CALL CALC_NEW_WAIT_TIMES
1641    11A9          5892     	CALL DECREMENT_STEPPER_STEP
1643    310E          5893     	CALL STEPPER_TIMER_WAIT
                      5894     
1645    120F2B        5895     	CALL COMM2COMM3			
1648    120CC4        5896     	CALL CALC_NEXT_COMM_TIMING_START	
164B    120D4E        5897     	CALL CALC_NEW_WAIT_TIMES
164E    11A9          5898     	CALL DECREMENT_STEPPER_STEP
1650    310E          5899     	CALL STEPPER_TIMER_WAIT
                      5900     
1652    120F75        5901     	CALL COMM3COMM4			
1655    120CC4        5902     	CALL CALC_NEXT_COMM_TIMING_START	
1658    120D4E        5903     	CALL CALC_NEW_WAIT_TIMES
165B    11A9          5904     	CALL DECREMENT_STEPPER_STEP
165D    310E          5905     	CALL STEPPER_TIMER_WAIT
                      5906     
165F    120FB0        5907     	CALL COMM4COMM5			
1662    120CC4        5908     	CALL CALC_NEXT_COMM_TIMING_START	
1665    120D4E        5909     	CALL CALC_NEW_WAIT_TIMES
1668    11A9          5910     	CALL DECREMENT_STEPPER_STEP
166A    310E          5911     	CALL STEPPER_TIMER_WAIT
                      5912     
166C    120FF1        5913     	CALL COMM5COMM6			
166F    120CC4        5914     	CALL CALC_NEXT_COMM_TIMING_START	
1672    120D4E        5915     	CALL CALC_NEW_WAIT_TIMES
1675    11A9          5916     	CALL DECREMENT_STEPPER_STEP	
                      5917     	; Check stepper step versus end criteria
1677    C3            5918     	CLR	C
1678    E550          5919     	MOV	A, WT_STEPPER_STEP_L
167A    9535          5920     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
167C    E551          5921     	MOV	A, WT_STEPPER_STEP_H
167E    9536          5922     	SUBB	A, STEPPER_STEP_END_H
1680    400C          5923     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5924     
                      5925     	; Wait for step
1682    310E          5926     	CALL STEPPER_TIMER_WAIT
1684    C3            5927     	CLR	C
1685    E559          5928     	MOV	A, NEW_RCP				; Load new pulse value
1687    9401          5929     SUBB A , # 1 
1689    5092          5930     	JNC	STEPPER_ROT_BEG
                      5931     
168B    021822        5932     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5933     
                      5934     STEPPER_ROT_EXIT: 
                      5935     	; Wait for step
168E    310E          5936     	CALL STEPPER_TIMER_WAIT
                      5937     	; Clear stepper phase
1690    C262          5938     CLR FLAGS1 . 2 
                      5939     	; Set dondamped low pwm frequency
1692    7887          5940     MOV R0 , # PGM_PWM_FREQ 
1694    E6            5941     MOV A , @ R0 
1695    FE            5942     MOV R6 , A 
1696    7602          5943     MOV @ R0 , # 2 
1698    316E          5944     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
169A    7887          5945     MOV R0 , # PGM_PWM_FREQ 
169C    EE            5946     MOV A , R6 
169D    F6            5947     MOV @ R0 , A 
                      5948     	; Set spoolup power variables (power is now controlled from RCP)
169E    85225E        5949     	MOV	PWM_LIMIT, REQUESTED_PWM
16A1    85605F        5950     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
16A4    856025        5951     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
16A7    855D64        5952     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
16AA    756501        5953     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5954     	; Set direct startup phase to acquire sync quickly
16AD    D263          5955     SETB FLAGS1 . 3 
16AF    753800        5956     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
16B2    C2AF          5957     	CLR	EA						; Disable interrupts
                      5958     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
16B4    207502        5958+1   JB FLAGS3 . 5 , ( $+5 ) 
16B7    C293          5958+1   CLR P1 . 3 
16B9    307502        5958+1   JNB FLAGS3 . 5 , ( $+5 ) 
16BC    C297          5958+1   CLR P1 . 7 
                      5959     	CPFET_OFF						; Cp off
16BE    207502        5959+1   JB FLAGS3 . 5 , ( $+5 ) 
16C1    C297          5959+1   CLR P1 . 7 
16C3    307502        5959+1   JNB FLAGS3 . 5 , ( $+5 ) 
16C6    C293          5959+1   CLR P1 . 3 
16C8    742D          5960     	MOV	A, #45					; 8us delay for pfets to go off
16CA    D5E0FD        5961     	DJNZ	ACC, $
16CD    D2AF          5962     	SETB	EA						; Enable interrupts
16CF    112C          5963     	CALL COMM6COMM1				
16D1    120CCB        5964     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16D4    120D3A        5965     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16D7    120D4E        5966     	CALL CALC_NEW_WAIT_TIMES
16DA    120DDF        5967     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16DD    756C00        5968     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5969     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16E0    75BB09        5969+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16E3    0216F0        5970     	JMP	RUN1
                      5971     
                      5972     
                      5973     
                      5974     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5975     ;
                      5976     ; Run entry point
                      5977     ;
                      5978     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5979     DAMPED_TRANSITION: 
                      5980     	; Transition from nondamped to damped if applicable
16E6    316E          5981     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16E8    112C          5982     	CALL	COMM6COMM1
16EA    756C00        5983     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5984     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16ED    75BB09        5984+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5985     
                      5986     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5987     ; Out_cA changes from low to high
                      5988     RUN1: 
16F0    120E01        5989     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16F3    120E86        5990     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16F6    120EB1        5991     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16F9    12091A        5992     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16FC    120EC5        5993     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16FF    120EF9        5994     	CALL COMM1COMM2			; Commutate
1702    120CCB        5995     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1705    120D3A        5996     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1708    120D4E        5997     	CALL CALC_NEW_WAIT_TIMES
170B    120DDF        5998     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5999     
                      6000     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      6001     ; Out_cB changes from high to low
                      6002     RUN2: 
170E    120DF8        6003     	CALL WAIT_FOR_COMP_OUT_LOW
1711    120E86        6004     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1714    120EB1        6005     	CALL SETUP_COMM_WAIT	
1717    120977        6006     	CALL CALC_GOVERNOR_PROP_ERROR
171A    120EC5        6007     	CALL WAIT_FOR_COMM
171D    120F2B        6008     	CALL COMM2COMM3
1720    120CCB        6009     	CALL CALC_NEXT_COMM_TIMING
1723    120D3A        6010     	CALL WAIT_ADVANCE_TIMING
1726    120D4E        6011     	CALL CALC_NEW_WAIT_TIMES
1729    120DDF        6012     	CALL WAIT_BEFORE_ZC_SCAN	
                      6013     
                      6014     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6015     ; Out_cC changes from low to high
                      6016     RUN3: 
172C    120E01        6017     	CALL WAIT_FOR_COMP_OUT_HIGH
172F    120E86        6018     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1732    120EB1        6019     	CALL SETUP_COMM_WAIT	
1735    1209B0        6020     	CALL CALC_GOVERNOR_INT_ERROR
1738    120EC5        6021     	CALL WAIT_FOR_COMM
173B    120F75        6022     	CALL COMM3COMM4
173E    120CCB        6023     	CALL CALC_NEXT_COMM_TIMING
1741    120D3A        6024     	CALL WAIT_ADVANCE_TIMING
1744    120D4E        6025     	CALL CALC_NEW_WAIT_TIMES
1747    120DDF        6026     	CALL WAIT_BEFORE_ZC_SCAN	
                      6027     
                      6028     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6029     ; Out_cA changes from high to low
                      6030     RUN4: 
174A    120DF8        6031     	CALL WAIT_FOR_COMP_OUT_LOW
174D    120E86        6032     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1750    120EB1        6033     	CALL SETUP_COMM_WAIT	
1753    120A0D        6034     	CALL CALC_GOVERNOR_PROP_CORRECTION
1756    120EC5        6035     	CALL WAIT_FOR_COMM
1759    120FB0        6036     	CALL COMM4COMM5
175C    120CCB        6037     	CALL CALC_NEXT_COMM_TIMING
175F    120D3A        6038     	CALL WAIT_ADVANCE_TIMING
1762    120D4E        6039     	CALL CALC_NEW_WAIT_TIMES
1765    120DDF        6040     	CALL WAIT_BEFORE_ZC_SCAN	
                      6041     
                      6042     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6043     ; Out_cB changes from low to high
                      6044     RUN5: 
1768    120E01        6045     	CALL WAIT_FOR_COMP_OUT_HIGH
176B    120E86        6046     	CALL	EVALUATE_COMPARATOR_INTEGRITY
176E    120EB1        6047     	CALL SETUP_COMM_WAIT	
1771    120A71        6048     	CALL CALC_GOVERNOR_INT_CORRECTION
1774    120EC5        6049     	CALL WAIT_FOR_COMM
1777    120FF1        6050     	CALL COMM5COMM6
177A    120CCB        6051     	CALL CALC_NEXT_COMM_TIMING
177D    120D3A        6052     	CALL WAIT_ADVANCE_TIMING
1780    120D4E        6053     	CALL CALC_NEW_WAIT_TIMES
1783    120DDF        6054     	CALL WAIT_BEFORE_ZC_SCAN	
                      6055     
                      6056     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6057     ; Out_cC changes from high to low
                      6058     RUN6: 
1786    120DF8        6059     	CALL WAIT_FOR_COMP_OUT_LOW
1789    120B6E        6060     	CALL START_ADC_CONVERSION
178C    120E86        6061     	CALL	EVALUATE_COMPARATOR_INTEGRITY
178F    120EB1        6062     	CALL SETUP_COMM_WAIT	
1792    120B72        6063     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1795    120EC5        6064     	CALL WAIT_FOR_COMM
1798    112C          6065     	CALL COMM6COMM1
179A    120CCB        6066     	CALL CALC_NEXT_COMM_TIMING
179D    120D3A        6067     	CALL WAIT_ADVANCE_TIMING
17A0    120D4E        6068     	CALL CALC_NEW_WAIT_TIMES
17A3    120DDF        6069     	CALL WAIT_BEFORE_ZC_SCAN	
                      6070     
                      6071     	; Check if it is direct startup
17A6    306342        6072     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6073     
                      6074     	; Set spoolup power variables
17A9    85605E        6075     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
17AC    85605F        6076     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
17AF    855D64        6077     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
17B2    756501        6078     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6079     	; Check startup ok counter
17B5    7964          6080     MOV R1 , # 100 
17B7    7A14          6081     MOV R2 , # 20 
                      6082     IF MODE >= 1	; Tail or multi
17B9    7888          6083     MOV R0 , # PGM_DIRECTION 
17BB    E6            6084     MOV A , @ R0 
17BC    B40304        6085     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6086     
17BF    791E          6087     MOV R1 , # 30 
17C1    7A05          6088     MOV R2 , # 5 
                      6089     
                      6090     DIRECT_START_PARAMS_SET: 
                      6091     ENDIF
17C3    C3            6092     	CLR	C
17C4    E538          6093     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
17C6    99            6094     SUBB A , R1 
17C7    4015          6095     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6096     
17C9    C263          6097     CLR FLAGS1 . 3 
17CB    D264          6098     SETB FLAGS1 . 4 
17CD    8A37          6099     MOV STARTUP_ROT_CNT , R2 
                      6100     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6104     IF MODE == 2	; Multi
17CF    7888          6105     MOV R0 , # PGM_DIRECTION 
17D1    E6            6106     MOV A , @ R0 
17D2    B40306        6107     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6108     
17D5    755EFF        6109     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17D8    755FFF        6110     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6111     
                      6112     DIRECT_START_PWM_LIM_SET: 
                      6113     ENDIF
17DB    0217EB        6114     	JMP	NORMAL_RUN_CHECKS
                      6115     
                      6116     DIRECT_START_CHECK_RCP: 
17DE    C3            6117     	CLR	C
17DF    E559          6118     	MOV	A, NEW_RCP				; Load new pulse value
17E1    9401          6119     SUBB A , # 1 
17E3    4003          6120     	JC	($+5)
                      6121     
17E5    0216F0        6122     	LJMP	RUN1						; Continue to run 
                      6123     
17E8    021822        6124     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6125     
                      6126     
                      6127     NORMAL_RUN_CHECKS: 
                      6128     	; Check if it is initial run phase
17EB    306419        6129     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6130     
                      6131     	; Decrement startup rotaton count
17EE    E537          6132     	MOV	A, STARTUP_ROT_CNT
17F0    14            6133     	DEC	A
                      6134     	; Check number of nondamped rotations
17F1    7005          6135     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6136     
17F3    C264          6137     CLR FLAGS1 . 4 
17F5    0216E6        6138     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6139     
                      6140     NORMAL_RUN_CHECK_STARTUP_ROT: 
17F8    F537          6141     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6142     
17FA    C3            6143     	CLR	C
17FB    E559          6144     	MOV	A, NEW_RCP				; Load new pulse value
17FD    9401          6145     SUBB A , # 1 
17FF    4003          6146     	JC	($+5)
                      6147     
1801    0216F0        6148     	LJMP	RUN1						; Continue to run 
                      6149     
1804    021822        6150     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6151     
                      6152     
                      6153     INITIAL_RUN_PHASE_DONE: 
                      6154     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6167     	; Exit run loop after a given time
1807    C3            6168     	CLR	C
1808    E55C          6169     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
180A    94FA          6170     SUBB A , # 250 
180C    5014          6171     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6172     
                      6173     RUN6_CHECK_RCP_TIMEOUT: 
180E    741F          6174     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1810    552E          6175     	ANL	A, FLAGS3					; Check pwm frequency flags
1812    7004          6176     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6177     
1814    E528          6178     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1816    600A          6179     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6180     
                      6181     RUN6_CHECK_SPEED: 
1818    C3            6182     	CLR	C
1819    E53D          6183     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
181B    94F0          6184     	SUBB	A, #0F0H
181D    5003          6185     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
181F    0216F0        6186     	JMP	RUN1						; Go back to run 1
                      6187     
                      6188     
                      6189     RUN_TO_WAIT_FOR_POWER_ON: 	
1822    C2AF          6190     	CLR	EA
1824    121097        6191     	CALL SWITCH_POWER_OFF
1827    7887          6192     MOV R0 , # PGM_PWM_FREQ 
1829    E6            6193     MOV A , @ R0 
182A    FE            6194     MOV R6 , A 
182B    7602          6195     MOV @ R0 , # 2 
182D    12116E        6196     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1830    7887          6197     MOV R0 , # PGM_PWM_FREQ 
1832    EE            6198     MOV A , R6 
1833    F6            6199     MOV @ R0 , A 
1834    E4            6200     	CLR	A
1835    F522          6201     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1837    F523          6202     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1839    F524          6203     	MOV	CURRENT_PWM, A				; Set current pwm to zero
183B    F525          6204     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
183D    F561          6205     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
183F    C260          6206     CLR FLAGS1 . 0 
1841    D2AF          6207     	SETB	EA
1843    1207EB        6208     	CALL	WAIT1MS					; Wait for pwm to be stopped
1846    121097        6209     	CALL SWITCH_POWER_OFF
                      6210     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6241     IF MODE >= 1	; Tail or multi
1849    741F          6242     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
184B    552E          6243     	ANL	A, FLAGS3					; Check pwm frequency flags
184D    7007          6244     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6245     
184F    E528          6246     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1851    7003          6247     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6248     
1853    021353        6249     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6250     
                      6251     JMP_WAIT_FOR_POWER_ON: 
1856    0214C3        6252     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6253     ENDIF
                      6254     
                      6255     
                      6256     END
MACRO ASSEMBLER BLHELI                                      05/25/15 20:01:22 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17F8H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E4CH   A 
CALC_NEXT_COMM_SL~  C ADDR   0D1FH   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B72H   A 
MEASURE_LIPO_WAIT~  C ADDR   0AE4H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A9EH   A 
GOVERNOR_CORR_NEG~  C ADDR   0A60H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
INIT_START . . . .  C ADDR   1530H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13F2H   A 
FIND_THROTTLE_GAI~  C ADDR   1255H   A 
COMM45_NFET. . . .  C ADDR   0FD5H   A 
COMM45_NONDAMP . .  C ADDR   0FD2H   A 
COMM4COMM5 . . . .  C ADDR   0FB0H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D44H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C05H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
TEMP_SKYPUP. . . .  D ADDR   0076H   A 
PREV_RCP . . . . .  D ADDR   0073H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   1229H   A 
GOVERNOR_CHECK_PWM  C ADDR   09EDH   A 
GOVERNOR_ACTIVATE.  C ADDR   093FH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
WAIT_FOR_POWER_ON.  C ADDR   14C3H   A 
THROTTLE_LOW_CAL_~  C ADDR   144AH   A 
ARMING_INITIAL_AR~  C ADDR   13D8H   A 
PROGRAM_BY_TX_CHE~  C ADDR   148BH   A 
SET_DEFAULT_PARAM~  C ADDR   1114H   A 
COMM56_NONDAMP . .  C ADDR   1018H   A 
COMM23_CP. . . . .  C ADDR   0F63H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CCBH   A 
COMM5COMM6 . . . .  C ADDR   0FF1H   A 
CALC_GOVERNOR_INT~  C ADDR   0A78H   A 
CALC_GOVERNOR_TAR~  C ADDR   0976H   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   1272H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   161DH   A 
THROTTLE_HIGH_CAL.  C ADDR   141CH   A 
DECODE_THROTTLE_R~  C ADDR   121BH   A 
STEPPER_STEP_MED_~  C ADDR   0C9DH   A 
INITIALIZE_ALL_TI~  C ADDR   0C51H   A 
STARTUP_PWM_SET_P~  C ADDR   0C45H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
RUN_COUNT_H. . . .  D ADDR   0075H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   1353H   A 
COMM61_CP. . . . .  C ADDR   1074H   A 
COMM_EXIT. . . . .  C ADDR   1083H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D26H   A 
CALC_GOVERNOR_INT~  C ADDR   0A71H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   16F0H   A 
CLEAR_RAM. . . . .  C ADDR   12D5H   A 
SET_BEC_VOLTAGE. .  C ADDR   1245H   A 
DECODE_GOVERNOR_G~  C ADDR   1202H   A 
DEC_STEP_HIGH. . .  C ADDR   10D7H   A 
WAIT_FOR_COMM. . .  C ADDR   0EC5H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D6DH   A 
MEASURE_LIPO_ADD_~  C ADDR   0B61H   A 
CALC_GOVERNOR_PRO~  C ADDR   09AFH   A 
DIV_U16_BY_U16_DI~  C ADDR   0893H   A 
WAIT100MS. . . . .  C ADDR   07FFH   A 
WAIT1MS. . . . . .  C ADDR   07EBH   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   17DBH   A 
RUN2 . . . . . . .  C ADDR   170EH   A 
ARMING_PPM_CHECK .  C ADDR   13E2H   A 
COMM45_CP. . . . .  C ADDR   0FE8H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DDFH   A 
MEASURE_LIPO_UPDA~  C ADDR   0B69H   A 
GOVERNOR_CORR_INT~  C ADDR   0ABDH   A 
GOVERNOR_STORE_PR~  C ADDR   09ABH   A 
DIV_U16_BY_U16_DI~  C ADDR   089DH   A 
WAIT200MS. . . . .  C ADDR   0804H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   172CH   A 
DIRECT_METHOD_STA~  C ADDR   1587H   A 
DECODE_DAMPING_DO~  C ADDR   11AAH   A 
PWM_WAIT . . . . .  C ADDR   0E71H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C15H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AA5H   A 
GOVERNOR_CHECK_IN~  C ADDR   09D5H   A 
DIV_U16_BY_U16_DI~  C ADDR   08B4H   A 
WAIT3MS. . . . . .  C ADDR   07F0H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
RUN_COUNT_L. . . .  D ADDR   0074H   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   1856H   A 
DIRECT_START_CHEC~  C ADDR   17DEH   A 
RUN4 . . . . . . .  C ADDR   174AH   A 
STORE_TIMES_UP_OR~  C ADDR   0DBFH   A 
STORE_TIMES_DECRE~  C ADDR   0DD2H   A 
STEPPER_STEP_SET .  C ADDR   0CB7H   A 
TEMP_AVERAGE_INC .  C ADDR   0BA5H   A 
GOVERNOR_CORR_INT~  C ADDR   0ACEH   A 
MULT_S16_BY_U8_DI~  C ADDR   08C3H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   1768H   A 
COMP_READ. . . . .  C ADDR   0E77H   A 
COMP_WAIT_SET_RES~  C ADDR   0E38H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D73H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AC2H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A0H   A 
GOVERNOR_TARGET_C~  C ADDR   0922H   A 
CALC_GOVERNOR_TAR~  C ADDR   091AH   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   1786H   A 
ARMING_START . . .  C ADDR   13C2H   A 
MEASURE_PWM_FREQ_~  C ADDR   1357H   A 
DECREMENT_STEP_EX~  C ADDR   1104H   A 
COMM_RETURN. . . .  C ADDR   1096H   A 
GOVERNOR_DEACTIVA~  C ADDR   092CH   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   1495H   A 
EVALUATE_COMPARAT~  C ADDR   0E86H   A 
TEMP_CHECK_EXIT. .  C ADDR   0BCFH   A 
GOVERNOR_APPLY_PR~  C ADDR   0A47H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
NORMAL_RUN_CHECKS.  C ADDR   17EBH   A 
DEC_STEP_MED_LOW .  C ADDR   10F2H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E07H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D3AH   A 
CALC_GOVERNOR_PRO~  C ADDR   0977H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
PROGRAM_BY_TX_ENT~  C ADDR   147FH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0EDFH   A 
SKYPUP_03. . . . .  C ADDR   078EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1237H   A 
EVAL_COMP_EXIT . .  C ADDR   0EB0H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E98H   A 
STEPPER_STEP_LOW .  C ADDR   0CABH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B26H   A 
SKYPUP_04. . . . .  C ADDR   07A2H   A 
PCA_INT_SET_TIMEO~  C ADDR   07B7H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   168EH   A 
STEPPER_METHOD_ST~  C ADDR   15C8H   A 
DECODE_PARAMS_DIR~  C ADDR   11E4H   A 
COMM12_DAMP. . . .  C ADDR   0F03H   A 
SETUP_COMM_WAIT. .  C ADDR   0EB1H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CC4H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BFBH   A 
CALC_GOVERNOR_INT~  C ADDR   0A0CH   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   14A1H   A 
THROTTLE_HIGH_CAL~  C ADDR   141AH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DF8H   A 
LOAD_MIN_TIME. . .  C ADDR   0D8FH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D4EH   A 
SET_STARTUP_PWM. .  C ADDR   0C21H   A 
GOVERNOR_STORE_IN~  C ADDR   0A06H   A 
GOVERNOR_ACTIVATE~  C ADDR   0969H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   180EH   A 
DECREMENT_STEP . .  C ADDR   10B5H   A 
COMM23_DAMP. . . .  C ADDR   0F33H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EE1H   A 
ADJUST_TIMING. . .  C ADDR   0D93H   A 
STEPPER_STEP_MED_~  C ADDR   0C81H   A 
MEASURE_LIPO_DIVI~  C ADDR   0B46H   A 
MEASURE_LIPO_START  C ADDR   0AD3H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A70H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A01H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A7H   A 
BEEP_F1. . . . . .  C ADDR   081BH   A 
WAIT1S_LOOP. . . .  C ADDR   0816H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Dh            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
INITIAL_RUN_PHASE~  C ADDR   1807H   A 
TEST_THROTTLE_GAIN  C ADDR   1263H   A 
STEPPER_STEP_MED .  C ADDR   0C8FH   A 
GOVERNOR_STORE_PR~  C ADDR   0A6EH   A 
GOVERNOR_CHECK_PR~  C ADDR   0A32H   A 
MULT_S16_BY_U8_PO~  C ADDR   08DDH   A 
DIV_U16_BY_U16 . .  C ADDR   088BH   A 
BEEP_ONOFF . . . .  C ADDR   083EH   A 
BEEP_F2. . . . . .  C ADDR   0822H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   1246H   A 
DECREMENT_STEPPER~  C ADDR   10A9H   A 
COMM61_DAMP. . . .  C ADDR   1034H   A 
COMM34_DAMP. . . .  C ADDR   0F87H   A 
TEMP_AVERAGE_INC_~  C ADDR   0B95H   A 
GOVERNOR_INT_MAX_~  C ADDR   09FAH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09DEH   A 
BEEP_F3. . . . . .  C ADDR   0829H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
DAMPED_TRANSITION.  C ADDR   16E6H   A 
BEEP_DELAY_SET . .  C ADDR   14EBH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1403H   A 
LOCK_BYTE_OK . . .  C ADDR   1291H   A 
DECODE_PWM_FREQ_L~  C ADDR   11FCH   A 
DECODE_DAMPING_3 .  C ADDR   1182H   A 
CALC_NEW_WAIT_RED~  C ADDR   0D5EH   A 
BEEP_F4. . . . . .  C ADDR   0830H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
DIRECT_START_PARA~  C ADDR   17C3H   A 
THROTTLE_LOW_CAL .  C ADDR   144CH   A 
DECODE_DAMPING_4 .  C ADDR   118CH   A 
COMM45_DAMP. . . .  C ADDR   0FB8H   A 
WAIT_FOR_COMM_SET~  C ADDR   0EF1H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BADH   A 
GOVERNOR_APPLY_IN~  C ADDR   0AA9H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A3DH   A 
BEEP_OFF . . . . .  C ADDR   087FH   A 
WAIT10MS . . . . .  C ADDR   07F5H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
RESET_CAL_DONE . .  C ADDR   12ADH   A 
DECODE_DAMPING_5 .  C ADDR   1196H   A 
DECODE_PARAMETERS.  C ADDR   116EH   A 
STEPPER_TIMER_WAIT  C ADDR   110EH   A 
STORE_TIMES_INCRE~  C ADDR   0DC5H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BF4H   A 
MEASURE_LIPO_CELLS  C ADDR   0AD3H   A 
CALC_GOVERNOR_INT~  C ADDR   09B0H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07D1H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
RUN6_CHECK_SPEED .  C ADDR   1818H   A 
WAIT_FOR_POWER_ON~  C ADDR   1517H   A 
DECODE_DAMPING_6 .  C ADDR   11A0H   A 
DEC_STEP_LOW . . .  C ADDR   10FBH   A 
COMM56_DAMP. . . .  C ADDR   1003H   A 
SWITCH_POWER_OFF .  C ADDR   1097H   A 
WAIT30MS . . . . .  C ADDR   07FAH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   1822H   A 
EVAL_COMP_CHECK_T~  C ADDR   0EA6H   A 
ADJUST_TIMING_TWO~  C ADDR   0DB5H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C20H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A14H   A 
GOVERNOR_ACTIVATE~  C ADDR   0970H   A 
WAIT1S . . . . . .  C ADDR   0814H   A 
WAITXMS_M. . . . .  C ADDR   080BH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   1566H   A 
WAIT_FOR_POWER_ON~  C ADDR   1508H   A 
DECODE_PWM_FREQ_E~  C ADDR   1201H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0EF3H   A 
PWM_WAIT_STARTUP .  C ADDR   0E6CH   A 
START_ADC_CONVERS~  C ADDR   0B6EH   A 
MULT_S16_BY_U8_EX~  C ADDR   0911H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   138DH   A 
LOCK_BYTE_TEST . .  C ADDR   128AH   A 
DEC_STEP_MED_HIGH.  C ADDR   10E0H   A 
COMM_RESTORE_POWER  C ADDR   1094H   A 
COMM12_NONDAMP . .  C ADDR   0F18H   A 
COMM1COMM2 . . . .  C ADDR   0EF9H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BABH   A 
TEMP_AVERAGE_DEC .  C ADDR   0BA1H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A0DH   A 
WAITXMS_O. . . . .  C ADDR   0809H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07C3H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
WAIT_FOR_POWER_ON~  C ADDR   14C8H   A 
DEC_STEP_MED . . .  C ADDR   10E9H   A 
READ_TIMER . . . .  C ADDR   0CCFH   A 
CHECK_VOLTAGE_STA~  C ADDR   0BD3H   A 
CALC_GOVERNOR_INT~  C ADDR   0AD2H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09E7H   A 
MULT_S16_BY_U8_DI~  C ADDR   08F6H   A 
BEEP . . . . . . .  C ADDR   0837H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
COMM23_NFET. . . .  C ADDR   0F50H   A 
COMM23_NONDAMP . .  C ADDR   0F4DH   A 
COMM2COMM3 . . . .  C ADDR   0F2BH   A 
STEPPER_STEP_HIGH.  C ADDR   0C73H   A 
MEASURE_LIPO_CELL~  C ADDR   0B0BH   A 
GOVERNOR_STORE_IN~  C ADDR   0AD0H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A92H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A5BH   A 
GOVERNOR_ACTIVATE~  C ADDR   095DH   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B6DH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A43H   A 
GOVERNOR_CHECK_PR~  C ADDR   0994H   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   1355H   A 
COMM61_NFET. . . .  C ADDR   1059H   A 
COMM61_NONDAMP . .  C ADDR   1056H   A 
COMM6COMM1 . . . .  C ADDR   102CH   A 
COMM34_NONDAMP . .  C ADDR   0F94H   A 
COMM3COMM4 . . . .  C ADDR   0F75H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E25H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E01H   A 
STARTUP_PWM_EXIT .  C ADDR   0C50H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B5DH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A6CH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6203    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     86    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
