MACRO ASSEMBLER BLHELI                                      05/25/15 17:03:10 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
  009F                  49     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        50     
                        51     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                  52     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                        53     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       663     ENDIF
                       664     
                       665     ;**** **** **** **** ****
                       666     ; TX programming defaults
                       667     ;
                       668     ; Parameter dependencies:
                       669     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       670     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       671     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       672     ; - Damping force is only used if DampedLight or Damped is selected
                       673     ;
                       674     ; Multi
  0009                 675     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 676     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 677     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 678     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 679     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 680     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 681     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 682     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 683     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 684     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       685     IF DAMPED_MODE_ENABLE == 1
  0001                 686     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       687     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 690     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 691     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 692     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                 693     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0028                 694     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 40	; Beacon strength
  0005                 695     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       696     ; Common
  0000                 697     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1=Enabled 	0=Disabled
  0003                 698     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 699     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 700     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (used in bidirectional mode)
  0000                 701     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       702     
                       703     ;**** **** **** **** ****
                       704     ; Constant definitions for multi
                       705     IF MODE == 2
                       706     
  0001                 707     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       708     
  000A                 709     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 710     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 711     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 712     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 713     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 714     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 715     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 716     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       717     
  0032                 718     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 719     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       720     
  000A                 721     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 722     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       723     
  0008                 724     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       725     
                       726     ENDIF
                       727     
                       728     ; Skypup 2015.05.25
  0002                 729     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 730     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       731     
                       732     ;**** **** **** **** ****
                       733     ; Temporary register definitions
  REG                  734     TEMP1		EQU	R0
  REG                  735     TEMP2		EQU	R1
  REG                  736     TEMP3		EQU	R2
  REG                  737     TEMP4		EQU	R3
  REG                  738     TEMP5		EQU	R4
  REG                  739     TEMP6		EQU	R5
  REG                  740     TEMP7		EQU	R6
  REG                  741     TEMP8		EQU	R7
                       742     
                       743     ;**** **** **** **** ****
                       744     ; Register definitions
------                 745     DSEG AT 20H					; Variables segment 
                       746     
0020                   747     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   748     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       749     
0022                   750     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   751     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   752     CURRENT_PWM: 				DS	1		; Current pwm
0025                   753     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   754     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   755     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   756     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   757     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   758     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       759     
002B                   760     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 761     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 762     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 763     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 764     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 765     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       766     ;						EQU 	5
                       767     ;						EQU 	6
                       768     ;						EQU 	7
                       769     
002C                   770     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 771     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 772     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 773     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 774     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 775     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 776     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 777     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       778     ;						EQU 	7
                       779     
002D                   780     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 781     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 782     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 783     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 784     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 785     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 786     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       787     ;						EQU 	6	
                       788     ;						EQU 	7	
                       789     
002E                   790     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 791     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 792     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 793     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 794     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 795     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 796     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 797     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 798     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       799     
                       800     ;**** **** **** **** ****
                       801     ; RAM definitions
------                 802     DSEG AT 30H						; Ram data segment, direct addressing
                       803     
0030                   804     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       805     
0031                   806     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   807     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       808     
0033                   809     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   810     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   811     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   812     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   813     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   814     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   815     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       816     
003A                   817     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   818     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   819     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   820     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   821     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   822     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       823     
0040                   824     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   825     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   826     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   827     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   828     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   829     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   830     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   831     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   832     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   833     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       834     
004A                   835     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   836     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   837     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   838     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   839     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   840     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   841     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   842     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       843     
0052                   844     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   845     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   846     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   847     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   848     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   849     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   850     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   851     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   852     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   853     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   854     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   855     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       856     
005E                   857     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   858     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   859     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   860     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   861     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   862     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       863     
0064                   864     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   865     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       866     
0066                   867     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   868     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       869     
0068                   870     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   871     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   872     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   873     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   874     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       875     
006D                   876     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       877     
006E                   878     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   879     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       880     
0070                   881     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   882     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   883     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       884     
                       885     ; Skypup 2015.05.25
0073                   886     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
0074                   887     RUN_COUNT_L: 				DS	1		; 运行循环计数低位
0075                   888     RUN_COUNT_H: 				DS	1		; 运行循环计数高位
0076                   889     TEMP_SKYPUP: 				DS	1		; 临时变量
                       890     
                       891     ; Indirect addressing data segment. The variables below must be in this sequence
------                 892     ISEG AT 080H					
0080                   893     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                   894     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                   895     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                   896     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                   897     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                   898     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                   899     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                   900     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                   901     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                   902     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                   903     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                   904     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                   905     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                   906     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                   907     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                   908     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                   909     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                   910     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                   911     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                   912     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                   913     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                   914     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                   915     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                   916     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                   917     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                   918     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                   919     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                   920     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                   921     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                   922     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                   923     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                       924     
                       925     ; The sequence of the variables below is no longer of importance
009F                   926     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                   927     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                   928     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                   929     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                   930     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                       931     
                       932     
                       933     ; Indirect addressing data segment
------                 934     ISEG AT 0D0H					
00D0                   935     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                       936     
                       937     
                       938     ;**** **** **** **** ****
------                 939     CSEG AT 1A00H            ; "Eeprom" segment
  000B                 940     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                 941     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                 942     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                       943     
1A00    0B             944     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02             945     EEP_FW_SUB_REVISION:  DB 2 
1A02    11             946     EEP_LAYOUT_REVISION:  DB 17 
                       947     
                       948     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                       981     
                       982     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1015     
                      1016     IF MODE == 2
1A03    09            1017     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1018     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1019     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1020     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1021     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1022     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1023     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1024     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1025     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1026     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1027     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1028     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1029     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1030     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1031     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1032     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1033     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1034     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1035     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1036     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1037     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1038     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1039     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1040     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    28            1041     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    28            1042     EEP_PGM_BEACON_STRENGTH:  DB 40 
1A1D    05            1043     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    0D            1044     EEP_PGM_THROTTLE_RATE:  DB 13 
1A1F    02            1045     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1046     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1047     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1048     ENDIF
                      1049     
                      1050     
1A22    FF            1051     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1052     
------                1053     CSEG AT 1A60H
1A60    6F72672E      1054     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1055     
                      1056     ;**** **** **** **** ****
                      1057             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1057+1   CSEG AT 0  ; CODE SEGMENT START
0000    02126B        1057+1   JMP RESET 
------                1057+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1057+1   JMP T0_INT 
------                1057+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1057+1   JMP T2_INT 
------                1057+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1057+1   JMP PCA_INT 
------                1057+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1057+1   JMP T3_INT 
------                1058     CSEG AT 80H			; Code segment after interrupt vectors 
                      1059     
                      1060     ;**** **** **** **** ****
                      1061     
                      1062     ; Table definitions
0080    02030406      1063     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1064     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1065     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1066     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1067     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1070     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1078     IF MODE == 2
                      1079       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1080     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1081       ENDIF
                      1082       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1085     ENDIF
                      1086     
                      1087     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1088     ;
                      1089     ; Timer0 interrupt routine
                      1090     ;
                      1091     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1092     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1093     ;
                      1094     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1095     T0_INT: 	; Used for pwm control
00BA    C2AF          1096     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1097     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1098     	PUSH	ACC		
                      1099     	; Check if pwm is on
00C0    205A10        1100     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1101     
                      1102     	; Do not execute pwm when stopped
00C3    30600A        1103     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1104     	; Do not execute pwm on during demag recovery
00C6    205C07        1105     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1106     	; Pwm on cycle. 
00C9    302F02        1107     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1108     
                      1109     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1110     	CLR	A					
00CD    73            1111     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1112     
                      1113     T0_INT_PWM_ON_LOW_PWM: 
                      1114     
                      1115     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1116     	JMP	T0_INT_PWM_ON_EXECUTE
                      1117     ENDIF
                      1118     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1135     
                      1136     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1137     	JMP	T0_INT_PWM_ON_EXIT
                      1138     
                      1139     
                      1140     T0_INT_PWM_OFF: 
00D3    306306        1141     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1142     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1142+1   CLR P1 . 2 
00D8    C296          1142+1   CLR P1 . 6 
00DA    C295          1142+1   CLR P1 . 5 
                      1143     T0_INT_PWM_OFF_START_CHECKED: 
                      1144     	; Pwm off cycle
00DC    85258A        1145     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1146     	; Clear pwm on flag
00DF    C25A          1147     CLR FLAGS0 . 2 
                      1148     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1149     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1150     	CPL	A						; Full pwm?
00E4    7002          1151     	JNZ	($+4)					; No - branch
00E6    21C6          1152     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1153     
00E8    0563          1154     	INC	PWM_OFF_CNT				; Increment event counter
                      1155     	; Do not execute pwm when stopped
00EA    306013        1156     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1157     
                      1158     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1159     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1160     
                      1161     	; Separate exit commands here for minimum delay
00F0    758B00        1162     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1163     	POP	ACC			; Restore preserved registers
00F5    D0D0          1164     	POP	PSW
                      1165     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1165+1   CLR P1 . 2 
00F9    C296          1165+1   CLR P1 . 6 
00FB    C295          1165+1   CLR P1 . 5 
00FD    D2AF          1166     	SETB	EA			; Enable all interrupts
00FF    32            1167     	RETI
                      1168     
                      1169     T0_INT_PWM_OFF_STOPPED: 
                      1170     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1170+1   CLR P1 . 2 
0102    C296          1170+1   CLR P1 . 6 
0104    C295          1170+1   CLR P1 . 5 
0106    0201B6        1171     	JMP	T0_INT_PWM_OFF_EXIT
                      1172     
                      1173     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1174     SETB FLAGS1 . 5 
010B    C266          1175     CLR FLAGS1 . 6 
010D    E567          1176     	MOV	A, DAMPING_ON
010F    601C          1177     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1178     
0111    C3            1179     	CLR	C
0112    E563          1180     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1181     	DEC	A
0115    9567          1182     	SUBB	A, DAMPING_ON
0117    4014          1183     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1184     
0119    C265          1185     CLR FLAGS1 . 5 
011B    D266          1186     SETB FLAGS1 . 6 
011D    C3            1187     	CLR	C
011E    E563          1188     	MOV	A, PWM_OFF_CNT					
0120    9566          1189     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1190     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1191     
0124    0201B6        1192     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1193     
                      1194     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1195     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1196     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1197     
                      1198     T0_INT_PWM_OFF_DO_DAMPED: 
                      1199     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1200     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1201     
                      1202     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1202+1   CLR P1 . 2 
0132    C296          1202+1   CLR P1 . 6 
0134    C295          1202+1   CLR P1 . 5 
0136    7406          1203     MOV A , # 6 
0138    D5E0FD        1204     	DJNZ	ACC, $	
                      1205     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1205+1   SETB P1 . 3 
013D    D297          1205+1   SETB P1 . 7 
013F    D294          1205+1   SETB P1 . 4 
0141    0201B6        1206     	JMP	T0_INT_PWM_OFF_EXIT
                      1207     
                      1208     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1209     IF DAMPED_MODE_ENABLE == 1
0144    D266          1210     SETB FLAGS1 . 6 
                      1211     ENDIF
                      1212     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1212+1   CLR P1 . 2 
0148    C296          1212+1   CLR P1 . 6 
014A    C295          1212+1   CLR P1 . 5 
014C    E53E          1213     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1214     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1215     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1216     
                      1217     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1220     MOV A , # 6 
0156    D5E0FD        1221     	DJNZ	ACC, $	
                      1222     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1222+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1222+1   SETB P1 . 7 
015E    307502        1222+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1222+1   SETB P1 . 3 
                      1223     ENDIF
0163    0201B6        1224     	JMP	T0_INT_PWM_OFF_EXIT
                      1225     
                      1226     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1227     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1228     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1231     MOV A , # 6 
016B    D5E0FD        1232     	DJNZ	ACC, $	
                      1233     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1233+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1233+1   SETB P1 . 7 
0173    307502        1233+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1233+1   SETB P1 . 3 
                      1234     ENDIF
0178    0201B6        1235     	JMP	T0_INT_PWM_OFF_EXIT
                      1236     
                      1237     T0_INT_PWM_OFF_COMM_3: 
                      1238     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1241     MOV A , # 6 
017D    D5E0FD        1242     	DJNZ	ACC, $	
                      1243     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1243+1   SETB P1 . 4 
                      1244     ENDIF
0182    0201B6        1245     	JMP	T0_INT_PWM_OFF_EXIT
                      1246     
                      1247     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1248     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1249     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1250     
                      1251     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1254     MOV A , # 6 
018D    D5E0FD        1255     	DJNZ	ACC, $	
                      1256     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1256+1   SETB P1 . 4 
                      1257     ENDIF
0192    0201B6        1258     	JMP	T0_INT_PWM_OFF_EXIT
                      1259     
                      1260     T0_INT_PWM_OFF_COMM_5: 
                      1261     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1264     MOV A , # 6 
0197    D5E0FD        1265     	DJNZ	ACC, $	
                      1266     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1266+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1266+1   SETB P1 . 3 
019F    307502        1266+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1266+1   SETB P1 . 7 
                      1267     ENDIF
01A4    0201B6        1268     	JMP	T0_INT_PWM_OFF_EXIT
                      1269     
                      1270     T0_INT_PWM_OFF_COMM_6: 
                      1271     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1274     MOV A , # 6 
01A9    D5E0FD        1275     	DJNZ	ACC, $	
                      1276     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1276+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1276+1   SETB P1 . 3 
01B1    307502        1276+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1276+1   SETB P1 . 7 
                      1277     ENDIF
                      1278     
                      1279     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1280     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1281     	POP	ACC			; Restore preserved registers
01BB    D0D0          1282     	POP	PSW
                      1283     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1283+1   CLR P1 . 2 
01BF    C296          1283+1   CLR P1 . 6 
01C1    C295          1283+1   CLR P1 . 5 
01C3    D2AF          1284     	SETB	EA			; Enable all interrupts
01C5    32            1285     	RETI
                      1286     
                      1287     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1288     	POP	ACC			; Restore preserved registers
01C8    D0D0          1289     	POP	PSW
01CA    D2AF          1290     	SETB	EA			; Enable all interrupts
01CC    32            1291     	RETI
                      1292     
                      1293     
                      1294     
                      1295     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1296     	AJMP	T0_INT_PWM_ON_EXIT
                      1297     
                      1298     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1299     	ANFET_ON	
01CF    E525          1299+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1299+1   JZ ( $+12 ) 
01D3    207502        1299+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1299+1   SETB P1 . 2 
01D8    307502        1299+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1299+1   SETB P1 . 6 
                      1300     	BNFET_OFF
01DD    C295          1300+1   CLR P1 . 5 
01DF    61D3          1301     	AJMP	T0_INT_PWM_ON_EXIT
                      1302     
                      1303     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1304     	BNFET_ON
01E1    E525          1304+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1304+1   JZ ( $+4 ) 
01E5    D295          1304+1   SETB P1 . 5 
                      1305     	CNFET_OFF
01E7    207502        1305+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1305+1   CLR P1 . 6 
01EC    307502        1305+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1305+1   CLR P1 . 2 
01F1    61D3          1306     	AJMP	T0_INT_PWM_ON_EXIT
                      1307     
                      1308     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1309     	CNFET_ON
01F3    E525          1309+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1309+1   JZ ( $+12 ) 
01F7    207502        1309+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1309+1   SETB P1 . 6 
01FC    307502        1309+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1309+1   SETB P1 . 2 
                      1310     	ANFET_OFF
0201    207502        1310+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1310+1   CLR P1 . 2 
0206    307502        1310+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1310+1   CLR P1 . 6 
020B    61D3          1311     	AJMP	T0_INT_PWM_ON_EXIT
                      1312     
                      1313     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1314     	APFET_OFF
020D    207502        1314+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1314+1   CLR P1 . 3 
0212    307502        1314+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1314+1   CLR P1 . 7 
                      1315     	ANFET_ON								; Switch nFETs
0217    E525          1315+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1315+1   JZ ( $+12 ) 
021B    207502        1315+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1315+1   SETB P1 . 2 
0220    307502        1315+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1315+1   SETB P1 . 6 
                      1316     	CPFET_OFF
0225    207502        1316+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1316+1   CLR P1 . 7 
022A    307502        1316+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1316+1   CLR P1 . 3 
                      1317     	BNFET_OFF 							
022F    C295          1317+1   CLR P1 . 5 
0231    61D3          1318     	AJMP	T0_INT_PWM_ON_EXIT
                      1319     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1320     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1321     	APFET_OFF
0233    207502        1321+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1321+1   CLR P1 . 3 
0238    307502        1321+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1321+1   CLR P1 . 7 
                      1322     	CPFET_OFF
023D    207502        1322+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1322+1   CLR P1 . 7 
0242    307502        1322+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1322+1   CLR P1 . 3 
0247    7406          1323     MOV A , # 6 
0249    D5E0FD        1324     	DJNZ ACC,	$
                      1325     	ANFET_ON								; Switch nFETs
024C    E525          1325+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1325+1   JZ ( $+12 ) 
0250    207502        1325+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1325+1   SETB P1 . 2 
0255    307502        1325+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1325+1   SETB P1 . 6 
                      1326     	BNFET_OFF 							
025A    C295          1326+1   CLR P1 . 5 
025C    61D3          1327     	AJMP	T0_INT_PWM_ON_EXIT
                      1328     
                      1329     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1330     	APFET_OFF
025E    207502        1330+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1330+1   CLR P1 . 3 
0263    307502        1330+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1330+1   CLR P1 . 7 
                      1331     	ANFET_ON								; Switch nFETs
0268    E525          1331+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1331+1   JZ ( $+12 ) 
026C    207502        1331+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1331+1   SETB P1 . 2 
0271    307502        1331+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1331+1   SETB P1 . 6 
                      1332     	BPFET_OFF
0276    C294          1332+1   CLR P1 . 4 
                      1333     	BNFET_OFF								
0278    C295          1333+1   CLR P1 . 5 
027A    61D3          1334     	AJMP	T0_INT_PWM_ON_EXIT
                      1335     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1336     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1337     	APFET_OFF
027C    207502        1337+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1337+1   CLR P1 . 3 
0281    307502        1337+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1337+1   CLR P1 . 7 
                      1338     	BPFET_OFF
0286    C294          1338+1   CLR P1 . 4 
0288    7406          1339     MOV A , # 6 
028A    D5E0FD        1340     	DJNZ ACC,	$
                      1341     	ANFET_ON								; Switch nFETs
028D    E525          1341+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1341+1   JZ ( $+12 ) 
0291    207502        1341+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1341+1   SETB P1 . 2 
0296    307502        1341+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1341+1   SETB P1 . 6 
                      1342     	BNFET_OFF								
029B    C295          1342+1   CLR P1 . 5 
029D    61D3          1343     	AJMP	T0_INT_PWM_ON_EXIT
                      1344     
                      1345     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1346     	BPFET_OFF
029F    C294          1346+1   CLR P1 . 4 
                      1347     	BNFET_ON								; Switch nFETs
02A1    E525          1347+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1347+1   JZ ( $+4 ) 
02A5    D295          1347+1   SETB P1 . 5 
                      1348     	APFET_OFF
02A7    207502        1348+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1348+1   CLR P1 . 3 
02AC    307502        1348+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1348+1   CLR P1 . 7 
                      1349     	CNFET_OFF								
02B1    207502        1349+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1349+1   CLR P1 . 6 
02B6    307502        1349+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1349+1   CLR P1 . 2 
02BB    61D3          1350     	AJMP	T0_INT_PWM_ON_EXIT
                      1351     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1352     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1353     	BPFET_OFF
02BD    C294          1353+1   CLR P1 . 4 
                      1354     	APFET_OFF
02BF    207502        1354+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1354+1   CLR P1 . 3 
02C4    307502        1354+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1354+1   CLR P1 . 7 
02C9    7406          1355     MOV A , # 6 
02CB    D5E0FD        1356     	DJNZ ACC,	$
                      1357     	BNFET_ON								; Switch nFETs
02CE    E525          1357+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1357+1   JZ ( $+4 ) 
02D2    D295          1357+1   SETB P1 . 5 
                      1358     	CNFET_OFF								
02D4    207502        1358+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1358+1   CLR P1 . 6 
02D9    307502        1358+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1358+1   CLR P1 . 2 
02DE    61D3          1359     	AJMP	T0_INT_PWM_ON_EXIT
                      1360     
                      1361     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1362     	BPFET_OFF
02E0    C294          1362+1   CLR P1 . 4 
                      1363     	BNFET_ON								; Switch nFETs
02E2    E525          1363+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1363+1   JZ ( $+4 ) 
02E6    D295          1363+1   SETB P1 . 5 
                      1364     	CPFET_OFF
02E8    207502        1364+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1364+1   CLR P1 . 7 
02ED    307502        1364+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1364+1   CLR P1 . 3 
                      1365     	CNFET_OFF								
02F2    207502        1365+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1365+1   CLR P1 . 6 
02F7    307502        1365+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1365+1   CLR P1 . 2 
02FC    61D3          1366     	AJMP	T0_INT_PWM_ON_EXIT
                      1367     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1368     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1369     	BPFET_OFF
02FE    C294          1369+1   CLR P1 . 4 
                      1370     	CPFET_OFF
0300    207502        1370+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1370+1   CLR P1 . 7 
0305    307502        1370+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1370+1   CLR P1 . 3 
030A    7406          1371     MOV A , # 6 
030C    D5E0FD        1372     	DJNZ ACC,	$
                      1373     	BNFET_ON								; Switch nFETs
030F    E525          1373+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1373+1   JZ ( $+4 ) 
0313    D295          1373+1   SETB P1 . 5 
                      1374     	CNFET_OFF								
0315    207502        1374+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1374+1   CLR P1 . 6 
031A    307502        1374+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1374+1   CLR P1 . 2 
031F    61D3          1375     	AJMP	T0_INT_PWM_ON_EXIT
                      1376     
                      1377     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1378     	CPFET_OFF
0321    207502        1378+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1378+1   CLR P1 . 7 
0326    307502        1378+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1378+1   CLR P1 . 3 
                      1379     	CNFET_ON								; Switch nFETs
032B    E525          1379+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1379+1   JZ ( $+12 ) 
032F    207502        1379+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1379+1   SETB P1 . 6 
0334    307502        1379+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1379+1   SETB P1 . 2 
                      1380     	BPFET_OFF
0339    C294          1380+1   CLR P1 . 4 
                      1381     	ANFET_OFF								
033B    207502        1381+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1381+1   CLR P1 . 2 
0340    307502        1381+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1381+1   CLR P1 . 6 
0345    61D3          1382     	AJMP	T0_INT_PWM_ON_EXIT
                      1383     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1384     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1385     	CPFET_OFF
0347    207502        1385+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1385+1   CLR P1 . 7 
034C    307502        1385+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1385+1   CLR P1 . 3 
                      1386     	BPFET_OFF
0351    C294          1386+1   CLR P1 . 4 
0353    7406          1387     MOV A , # 6 
0355    D5E0FD        1388     	DJNZ ACC,	$
                      1389     	CNFET_ON								; Switch nFETs
0358    E525          1389+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1389+1   JZ ( $+12 ) 
035C    207502        1389+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1389+1   SETB P1 . 6 
0361    307502        1389+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1389+1   SETB P1 . 2 
                      1390     	ANFET_OFF								
0366    207502        1390+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1390+1   CLR P1 . 2 
036B    307502        1390+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1390+1   CLR P1 . 6 
0370    61D3          1391     	AJMP	T0_INT_PWM_ON_EXIT
                      1392     
                      1393     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1394     	CPFET_OFF
0372    207502        1394+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1394+1   CLR P1 . 7 
0377    307502        1394+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1394+1   CLR P1 . 3 
                      1395     	CNFET_ON								; Switch nFETs
037C    E525          1395+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1395+1   JZ ( $+12 ) 
0380    207502        1395+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1395+1   SETB P1 . 6 
0385    307502        1395+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1395+1   SETB P1 . 2 
                      1396     	APFET_OFF
038A    207502        1396+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1396+1   CLR P1 . 3 
038F    307502        1396+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1396+1   CLR P1 . 7 
                      1397     	ANFET_OFF								
0394    207502        1397+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1397+1   CLR P1 . 2 
0399    307502        1397+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1397+1   CLR P1 . 6 
039E    61D3          1398     	AJMP	T0_INT_PWM_ON_EXIT
                      1399     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1400     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1401     	CPFET_OFF
03A0    207502        1401+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1401+1   CLR P1 . 7 
03A5    307502        1401+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1401+1   CLR P1 . 3 
                      1402     	APFET_OFF
03AA    207502        1402+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1402+1   CLR P1 . 3 
03AF    307502        1402+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1402+1   CLR P1 . 7 
03B4    7406          1403     MOV A , # 6 
03B6    D5E0FD        1404     	DJNZ ACC,	$
                      1405     	CNFET_ON								; Switch nFETs
03B9    E525          1405+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1405+1   JZ ( $+12 ) 
03BD    207502        1405+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1405+1   SETB P1 . 6 
03C2    307502        1405+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1405+1   SETB P1 . 2 
                      1406     	ANFET_OFF								
03C7    207502        1406+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1406+1   CLR P1 . 2 
03CC    307502        1406+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1406+1   CLR P1 . 6 
03D1    61D3          1407     	AJMP	T0_INT_PWM_ON_EXIT
                      1408     
                      1409     T0_INT_PWM_ON_EXIT: 
                      1410     	; Set timer for coming on cycle length
03D3    E525          1411     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1412     	CPL	A						; cpl is 255-x
03D6    F58A          1413     	MOV	TL0, A					; Write start point for timer
                      1414     	; Set other variables
03D8    758B00        1415     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1416     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1417     SETB FLAGS0 . 2 
                      1418     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1419     	; Exit interrupt
03E0    D0E0          1420     	POP	ACC			; Restore preserved registers
03E2    D0D0          1421     	POP	PSW
03E4    D2AF          1422     	SETB	EA			; Enable all interrupts
03E6    32            1423     	RETI
                      1424     
                      1425     
                      1426     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1427     ;
                      1428     ; Timer2 interrupt routine
                      1429     ;
                      1430     ; No assumptions
                      1431     ;
                      1432     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1433     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1434     	CLR	EA
03E9    C2AD          1435     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1436     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1437     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1438     	PUSH	ACC
03F2    D2D3          1439     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1440     	SETB	EA
                      1441     	; Clear low byte interrupt flag
03F6    C2CE          1442     	CLR	TF2L						; Clear interrupt flag
                      1443     	; Check RC pulse timeout counter
03F8    E528          1444     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1445     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1446     
                      1447     	; Decrement timeout counter (if PWM)
03FC    741F          1448     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1449     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1450     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1451     
0402    1528          1452     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1453     	AJMP	T2_INT_SKIP_START
                      1454     
                      1455     T2_INT_PULSES_ABSENT: 
                      1456     	; Timeout counter has reached zero, pulses are absent
0406    7800          1457     MOV R0 , # 0 
0408    7900          1458     MOV R1 , # 0 
                      1459     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1459+1   MOV A , P0 
040C    307601        1459+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1459+1   CPL A  ; YES - INVERT
0410    30E502        1460     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1461     MOV R0 , # 255 
                      1462     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1462+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1462+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1462+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1462+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1462+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1463     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1463+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1464     CLR FLAGS2 . 1 
                      1465     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1465+1   MOV A , P0 
042A    307601        1465+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1465+1   CPL A  ; YES - INVERT
042E    30E502        1466     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1467     MOV R1 , # 255 
0433    C3            1468     	CLR	C
0434    E8            1469     MOV A , R0 
0435    99            1470     SUBB A , R1 
0436    70CE          1471     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1472     
0438    305903        1473     JNB FLAGS0 . 1 , ( $+6 ) 
                      1474     
043B    752818        1475     MOV RCP_TIMEOUT_CNT , # 24 
                      1476     
043E    741F          1477     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1478     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1479     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1480     
0444    752818        1481     MOV RCP_TIMEOUT_CNT , # 24 
                      1482     
                      1483     
                      1484     T2_INT_PPM_TIMEOUT_SET: 
                      1485     
                      1486     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1487     ; 
                      1488     ; 对 RCP 信号处理
                      1489     ; 1 小于 1500us 最低油门
                      1490     ; 2 大于 1500us 正常处理
                      1491     ; 
                      1492     ;	clr C
                      1493     ;	mov A, Temp1
                      1494     ;	subb A, #80h
                      1495     ;	jnc skypup_01
                      1496     ;	mov	Temp1, #RCP_MIN
                      1497     ; skypup_01:
                      1498     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
0447    8859          1499     MOV NEW_RCP , R0 
0449    D268          1500     SETB FLAGS2 . 0 
                      1501     
                      1502     T2_INT_SKIP_START: 
                      1503     	; Check RC pulse skip counter
044B    E529          1504     	MOV	A, RCP_SKIP_CNT			
044D    6004          1505     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1506     	
                      1507     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1508     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1509     	AJMP	T2_INT_RCP_UPDATE_START
                      1510     
                      1511     T2_INT_SKIP_END: 
0453    741F          1512     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1513     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1514     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1515     
                      1516     	; Skip counter has reached zero, start looking for RC pulses again
                      1517     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1517+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1518     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1518+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1519     	
                      1520     T2_INT_RCP_UPDATE_START: 
                      1521     	; Process updated RC pulse
045E    206802        1522     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1523     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1524     
0463    E559          1525     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1526     MOV R0 , A 
0466    C268          1527     CLR FLAGS2 . 0 
                      1528     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1529     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1530     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1531     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1532     
                      1533     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1536     
                      1537     IF MODE == 2	; Multi
046E    7982          1538     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1539     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1540     ENDIF
                      1541     
                      1542     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1543     	CLR	C
0474    E8            1544     MOV A , R0 
0475    94F0          1545     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1546     	JC	T2_INT_RCP_UPDATE_MULT
                      1547     
0479    74F0          1548     	MOV	A, #240			; Set requested pwm to max
047B    F8            1549     MOV R0 , A 
                      1550     
                      1551     T2_INT_RCP_UPDATE_MULT: 	
                      1552     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1553     MOV A , R0 
047D    C4            1554     	SWAP	A			; After this "0.0625"
047E    540F          1555     	ANL	A, #0FH
0480    28            1556     ADD A , R0 
0481    F8            1557     MOV R0 , A 
                      1558     	; Adjust tail gain
0482    7984          1559     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1560     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1561     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1562     
0489    C3            1563     	CLR	C
048A    13            1564     	RRC	A			; After this "0.5"
048B    C3            1565     	CLR	C
048C    13            1566     	RRC	A			; After this "0.25"
048D    8721          1567     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1568     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1569     
0492    C3            1570     	CLR	C
0493    13            1571     	RRC	A			; After this "0.125"
                      1572     
                      1573     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1574     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1575     
0497    C3            1576     	CLR	C
0498    C8            1577     XCH A , R0 
0499    98            1578     SUBB A , R0 
049A    F8            1579     MOV R0 , A 
049B    81A4          1580     	AJMP	T2_INT_PWM_MIN_RUN
                      1581     
                      1582     T2_INT_RCP_GAIN_POS: 
049D    28            1583     ADD A , R0 
049E    F8            1584     MOV R0 , A 
049F    5003          1585     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1586     
04A1    74FF          1587     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1588     MOV R0 , A 
                      1589     
                      1590     T2_INT_PWM_MIN_RUN:  
                      1591     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1601     
                      1602     T2_INT_PWM_UPDATE:  
                      1603     	; Check if any startup phase flags are set
04A4    E52C          1604     	MOV	A, FLAGS1
04A6    5406          1605     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1606     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1607     
                      1608     	; Update requested_pwm
04AA    8822          1609     MOV REQUESTED_PWM , R0 
                      1610     	; Limit pwm during direct start
04AC    30630A        1611     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1612     
04AF    C3            1613     	CLR	C
04B0    E522          1614     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1615     	SUBB	A, PWM_LIMIT
04B4    4003          1616     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1617     
04B6    855E22        1618     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1619     
                      1620     T2_INT_CURRENT_PWM_UPDATE:  
                      1621     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1622     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1623     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1624     ENDIF
                      1625     
                      1626     	; Update current pwm, with limited throttle change rate
04BE    C3            1627     	CLR	C
04BF    E522          1628     	MOV	A, REQUESTED_PWM	 
04C1    9524          1629     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1630     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1631     
                      1632     	; 缓启动
04C5    78A1          1633     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1634     	;mov	Temp1, #1
04C7    96            1635     SUBB A , @ R0 
                      1636     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1637     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1638     
04CA    E524          1639     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1640     ADD A , @ R0 
                      1641     	; add	A, Temp1
04CD    F524          1642     	MOV	CURRENT_PWM, A
04CF    5009          1643     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1644     
04D1    7524FF        1645     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1646     	JMP	T2_INT_CURRENT_PWM_DONE
                      1647     
                      1648     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1649     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1650     T2_INT_CURRENT_PWM_DONE: 
                      1651     IF MODE >= 1	; Tail or multi
                      1652     	; Set current_pwm_limited
04DA    A824          1653     MOV R0 , CURRENT_PWM 
04DC    C3            1654     	CLR	C
04DD    E524          1655     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1656     	SUBB	A, PWM_LIMIT
04E1    4002          1657     	JC	($+4)					; If current pwm below limit - branch
                      1658     
04E3    A85E          1659     MOV R0 , PWM_LIMIT 
                      1660     
04E5    8825          1661     MOV CURRENT_PWM_LIMITED , R0 
                      1662     ENDIF
                      1663     T2_INT_PWM_EXIT: 	
                      1664     	; Check if high byte flag is set
04E7    20CF0C        1665     	JB	TF2H, T2H_INT		
04EA    D0E0          1666     	POP	ACC			; Restore preserved registers
04EC    D0D0          1667     	POP	PSW
04EE    C2D3          1668     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1669     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1670     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1671     	RETI
                      1672     
                      1673     T2H_INT: 
                      1674     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1675     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1676     MOV R0 , # 1 
                      1677     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1678     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1679     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1680     
                      1681     	; Decrement timeout counter (if PPM)
04FE    741F          1682     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1683     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1684     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1685     
0504    1528          1686     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1687     
                      1688     T2H_INT_RCP_STOP_CHECK: 
                      1689     	; Check RC pulse against stop value
0506    C3            1690     	CLR	C
0507    E559          1691     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1692     SUBB A , # 1 
050B    4005          1693     	JC	T2H_INT_RCP_STOP
                      1694     
                      1695     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1696     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1697     	AJMP	T2H_INT_RCP_GOV_PWM
                      1698     
                      1699     T2H_INT_RCP_STOP: 	
                      1700     	; RC pulse less than stop value
0512    755D00        1701     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1702     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1703     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1704     	ADD	A, #1
051C    F55C          1705     	MOV	RCP_STOP_CNT, A
051E    5003          1706     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1707     
0520    755CFF        1708     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1709     
                      1710     T2H_INT_RCP_GOV_PWM: 
                      1711     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1840     IF MODE == 2	; Multi
0523    E55F          1841     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1842     	ADD	A, #10
0527    5005          1843     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1844     
0529    755FFF        1845     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1846     	AJMP	T2H_INT_RCP_EXIT
                      1847     
                      1848     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1849     	MOV	PWM_LIMIT_SPOOLUP, A
                      1850     ENDIF
                      1851     
                      1852     T2H_INT_RCP_EXIT: 
0530    D0E0          1853     	POP	ACC			; Restore preserved registers
0532    D0D0          1854     	POP	PSW
0534    C2D3          1855     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1856     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1857     	SETB	ET2			; Enable timer2 interrupts
053B    32            1858     	RETI
                      1859     
                      1860     
                      1861     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1862     ;
                      1863     ; Timer3 interrupt routine
                      1864     ;
                      1865     ; No assumptions
                      1866     ;
                      1867     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1868     T3_INT: 	; Used for commutation timing
053C    C2AF          1869     	CLR 	EA			; Disable all interrupts
053E    53917F        1870     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1871     CLR FLAGS0 . 0 
0543    D2AF          1872     	SETB	EA			; Enable all interrupts
0545    32            1873     	RETI
                      1874     
                      1875     
                      1876     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1877     ;
                      1878     ; PCA interrupt routine
                      1879     ;
                      1880     ; No assumptions
                      1881     ;
                      1882     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1883     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          1884     	CLR	EA
0548    53E6EF        1885     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          1886     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          1887     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          1888     	PUSH	ACC
0551    C0F0          1889     	PUSH	B
0553    D2D3          1890     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          1891     	SETB	EA
                      1892     	; Get the PCA counter values
                      1893     	GET_RCP_CAPTURE_VALUES
0557    A8FB          1893+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          1893+1   MOV R1 , PCA0CPH0 
                      1894     	; Clear interrupt flag
                      1895     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          1895+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1896     	; Check which edge it is
055D    306902        1897     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          1898     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      1899     
                      1900     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        1900+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        1900+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        1900+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        1900+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        1900+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          1901     SETB FLAGS2 . 1 
                      1902     	; Read RC signal level
                      1903     	READ_RCP_INT			
0573    E580          1903+1   MOV A , P0 
0575    307601        1903+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            1903+1   CPL A  ; YES - INVERT
                      1904     	; Test RC signal level
0579    20E502        1905     JB ACC . 5 , ( $+5 ) 
057C    A185          1906     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      1907     
                      1908     	; RC pulse was high, store RC pulse start timestamp
057E    8826          1909     MOV RCP_PREV_EDGE_L , R0 
0580    8927          1910     MOV RCP_PREV_EDGE_H , R1 
0582    0207D1        1911     	LJMP	PCA_INT_EXIT				; Exit
                      1912     
                      1913     PCA_INT_FAIL_MINIMUM: 
                      1914     	; Prepare for next interrupt
                      1915     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        1915+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        1915+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        1915+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        1915+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        1915+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1916     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          1916+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          1917     CLR FLAGS2 . 1 
0598    741F          1918     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          1919     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          1920     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      1921     
059E    E1B7          1922     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      1923     
05A0    7800          1924     MOV R0 , # 0 
                      1925     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          1925+1   MOV A , P0 
05A4    307601        1925+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            1925+1   CPL A  ; YES - INVERT
05A8    30E502        1926     JNB ACC . 5 , ( $+5 ) 
05AB    E1B7          1927     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      1928     
                      1929     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1930     ; 
                      1931     ; 对 RCP 信号处理
                      1932     ; 1 小于 1500us 最低油门
                      1933     ; 2 大于 1500us 正常处理
                      1934     ; 
                      1935     ;	clr C
                      1936     ;	mov A, Temp1
                      1937     ;	subb A, #80h
                      1938     ;	jnc skypup_02
                      1939     ;	mov	Temp1, #RCP_MIN
                      1940     ; skypup_02:
                      1941     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1942     
05AD    8859          1943     MOV NEW_RCP , R0 
05AF    E186          1944     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      1945     
                      1946     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      1947     	; Prepare for next interrupt
                      1948     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        1948+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        1948+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        1948+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        1948+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        1948+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          1949     CLR FLAGS2 . 1 
                      1950     	; Check if pwm frequency shall be measured
05C2    205902        1951     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          1952     	AJMP	PCA_INT_FALL				; No - skip measurements
                      1953     
                      1954     	; Set second edge trig only during pwm frequency measurement
                      1955     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        1955+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        1955+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        1955+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        1955+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        1955+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      1956     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          1956+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          1957     SETB FLAGS2 . 1 
                      1958     	; Store edge data to RAM
05DA    8854          1959     MOV RCP_EDGE_L , R0 
05DC    8955          1960     MOV RCP_EDGE_H , R1 
                      1961     	; Calculate pwm frequency
05DE    C3            1962     	CLR	C
05DF    E8            1963     MOV A , R0 
05E0    9552          1964     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            1965     MOV R0 , A 
05E3    E9            1966     MOV A , R1 
05E4    9553          1967     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            1968     MOV R1 , A 
05E7    E4            1969     	CLR	A
05E8    FB            1970     MOV R3 , A 
05E9    7AFA          1971     MOV R2 , # 250 
                      1972     	; Check if pwm frequency is 12kHz
05EB    C3            1973     	CLR	C
05EC    E8            1974     MOV A , R0 
05ED    94C8          1975     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            1976     MOV A , R1 
05F0    9400          1977     	SUBB	A, #HIGH(200)
05F2    5008          1978     	JNC	PCA_INT_CHECK_8KHZ
                      1979     
05F4    E4            1980     	CLR	A
05F5    D2E4          1981     SETB ACC . 4 
05F7    FB            1982     MOV R3 , A 
05F8    7A0A          1983     MOV R2 , # 10 
05FA    C13E          1984     	AJMP	PCA_INT_RESTORE_EDGE
                      1985     
                      1986     PCA_INT_CHECK_8KHZ: 
                      1987     	; Check if pwm frequency is 8kHz
05FC    C3            1988     	CLR	C
05FD    E8            1989     MOV A , R0 
05FE    9468          1990     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            1991     MOV A , R1 
0601    9401          1992     	SUBB	A, #HIGH(360)
0603    5008          1993     	JNC	PCA_INT_CHECK_4KHZ
                      1994     
0605    E4            1995     	CLR	A
0606    D2E3          1996     SETB ACC . 3 
0608    FB            1997     MOV R3 , A 
0609    7A0F          1998     MOV R2 , # 15 
060B    C13E          1999     	AJMP	PCA_INT_RESTORE_EDGE
                      2000     
                      2001     PCA_INT_CHECK_4KHZ: 
                      2002     	; Check if pwm frequency is 4kHz
060D    C3            2003     	CLR	C
060E    E8            2004     MOV A , R0 
060F    94D0          2005     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2006     MOV A , R1 
0612    9402          2007     	SUBB	A, #HIGH(720)
0614    5008          2008     	JNC	PCA_INT_CHECK_2KHZ
                      2009     
0616    E4            2010     	CLR	A
0617    D2E2          2011     SETB ACC . 2 
0619    FB            2012     MOV R3 , A 
061A    7A1E          2013     MOV R2 , # 30 
061C    C13E          2014     	AJMP	PCA_INT_RESTORE_EDGE
                      2015     
                      2016     PCA_INT_CHECK_2KHZ: 
                      2017     	; Check if pwm frequency is 2kHz
061E    C3            2018     	CLR	C
061F    E8            2019     MOV A , R0 
0620    94A0          2020     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2021     MOV A , R1 
0623    9405          2022     	SUBB	A, #HIGH(1440)
0625    5008          2023     	JNC	PCA_INT_CHECK_1KHZ
                      2024     
0627    E4            2025     	CLR	A
0628    D2E1          2026     SETB ACC . 1 
062A    FB            2027     MOV R3 , A 
062B    7A3C          2028     MOV R2 , # 60 
062D    C13E          2029     	AJMP	PCA_INT_RESTORE_EDGE
                      2030     
                      2031     PCA_INT_CHECK_1KHZ: 
                      2032     	; Check if pwm frequency is 1kHz
062F    C3            2033     	CLR	C
0630    E8            2034     MOV A , R0 
0631    9498          2035     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2036     MOV A , R1 
0634    9408          2037     	SUBB	A, #HIGH(2200)
0636    5006          2038     	JNC	PCA_INT_RESTORE_EDGE
                      2039     
0638    E4            2040     	CLR	A
0639    D2E0          2041     SETB ACC . 0 
063B    FB            2042     MOV R3 , A 
063C    7A78          2043     MOV R2 , # 120 
                      2044     
                      2045     PCA_INT_RESTORE_EDGE: 
                      2046     	; Calculate difference between this period and previous period
063E    C3            2047     	CLR	C
063F    E8            2048     MOV A , R0 
0640    9556          2049     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2050     MOV R4 , A 
0643    E9            2051     MOV A , R1 
0644    9557          2052     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2053     MOV R5 , A 
                      2054     	; Make positive
0647    30E708        2055     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2056     MOV A , R4 
064B    F4            2057     	CPL	A
064C    2401          2058     	ADD	A, #1
064E    FC            2059     MOV R4 , A 
064F    ED            2060     MOV A , R5 
0650    F4            2061     	CPL	A
0651    FD            2062     MOV R5 , A 
                      2063     
                      2064     PCA_INT_CHECK_DIFF: 
                      2065     	; Check difference
0652    755800        2066     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2067     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2068     
0657    C3            2069     	CLR	C
0658    EC            2070     MOV A , R4 
0659    9A            2071     SUBB A , R2 
065A    5003          2072     	JNC	PCA_INT_STORE_DATA
                      2073     
065C    755801        2074     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2075     
                      2076     PCA_INT_STORE_DATA: 
                      2077     	; Store previous period
065F    8856          2078     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2079     MOV RCP_PREV_PERIOD_H , R1 
                      2080     	; Restore edge data from RAM
0663    A854          2081     MOV R0 , RCP_EDGE_L 
0665    A955          2082     MOV R1 , RCP_EDGE_H 
                      2083     	; Store pre previous edge
0667    8852          2084     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2085     MOV RCP_PREPREV_EDGE_H , R1 
                      2086     
                      2087     PCA_INT_FALL: 
                      2088     	; RC pulse edge was second, calculate new pulse length
066B    C3            2089     	CLR	C
066C    E8            2090     MOV A , R0 
066D    9526          2091     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2092     MOV R0 , A 
0670    E9            2093     MOV A , R1 
0671    9527          2094     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2095     MOV R1 , A 
0674    307402        2096     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2097     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2098     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2099     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2100     
067E    307202        2101     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2102     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2103     
0683    E9            2104     MOV A , R1 
0684    C3            2105     	CLR	C
0685    13            2106     	RRC	A
0686    F9            2107     MOV R1 , A 
0687    E8            2108     MOV A , R0 
0688    13            2109     	RRC	A
0689    F8            2110     MOV R0 , A 
                      2111     
068A    307102        2112     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2113     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2114     
068F    E9            2115     MOV A , R1 
0690    C3            2116     	CLR	C
0691    13            2117     	RRC	A
0692    F9            2118     MOV R1 , A 
0693    E8            2119     MOV A , R0 
0694    13            2120     	RRC	A
0695    F8            2121     MOV R0 , A 
                      2122     
0696    307002        2123     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2124     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2125     
069B    E9            2126     MOV A , R1 
069C    C3            2127     	CLR	C
069D    13            2128     	RRC	A
069E    FD            2129     MOV R5 , A 
069F    E8            2130     MOV A , R0 
06A0    13            2131     	RRC	A
06A1    FC            2132     MOV R4 , A 
                      2133     	; Skip range limitation if pwm frequency measurement
06A2    205918        2134     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2135     
                      2136     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2137     	CLR	C
06A6    EC            2138     MOV A , R4 
06A7    941C          2139     	SUBB	A, #28
06A9    ED            2140     MOV A , R5 
06AA    9402          2141     	SUBB A, #2
06AC    4003          2142     	JC	($+5)						; No - proceed
                      2143     
06AE    0207B7        2144     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2145     
                      2146     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2147     MOV A , R5 
06B2    7009          2148     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2149     
06B4    C3            2150     	CLR	C
06B5    EC            2151     MOV A , R4 
06B6    94C8          2152     	SUBB	A, #200
06B8    5003          2153     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2154     
06BA    0207B7        2155     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2156     
                      2157     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2158     	; Calculate "1000us" plus throttle minimum
06BD    7400          2159     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2160     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2161     
                      2162     IF MODE >= 1	; Tail or multi
06C2    7888          2163     MOV R0 , # PGM_DIRECTION 
06C4    E6            2164     MOV A , @ R0 
                      2165     ENDIF
06C5    7896          2166     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2167     IF MODE >= 1	; Tail or multi
06C7    B40302        2168     	CJNE	A, #3, ($+5)
                      2169     
06CA    789E          2170     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2171     ENDIF
06CC    E6            2172     MOV A , @ R0 
                      2173     
                      2174     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2175     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2176     MOV R6 , A 
06D0    E4            2177     	CLR	A
06D1    3400          2178     	ADDC	A, #0
06D3    FF            2179     MOV R7 , A 
                      2180     
06D4    C3            2181     	CLR	C
06D5    EC            2182     MOV A , R4 
06D6    9E            2183     SUBB A , R6 
06D7    FC            2184     MOV R4 , A 
06D8    ED            2185     MOV A , R5 
06D9    9F            2186     SUBB A , R7 
06DA    FD            2187     MOV R5 , A 
                      2188     IF MODE >= 1	; Tail or multi
06DB    9208          2189     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2190     MOV R0 , # PGM_DIRECTION 
06DF    E6            2191     MOV A , @ R0 
06E0    B40322        2192     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2193     
06E3    A208          2194     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2195     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2196     
                      2197     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2198     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2199     
06EA    C2AF          2200     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2201     SETB FLAGS3 . 5 
06EE    C1F7          2202     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2203     
                      2204     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2205     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2206     
06F3    C2AF          2207     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2208     CLR FLAGS3 . 5 
                      2209     
                      2210     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2211     	ALL_NFETS_OFF
06F7    C292          2211+1   CLR P1 . 2 
06F9    C296          2211+1   CLR P1 . 6 
06FB    C295          2211+1   CLR P1 . 5 
                      2212     	ALL_PFETS_OFF
06FD    C293          2212+1   CLR P1 . 3 
06FF    C297          2212+1   CLR P1 . 7 
0701    C294          2212+1   CLR P1 . 4 
0703    D2AF          2213     	SETB	EA
                      2214     
                      2215     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2216     	MOV	C, BIT_ACCESS_INT.0
                      2217     ENDIF
0707    5017          2218     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2219     
                      2220     IF MODE >= 1	; Tail or multi
0709    E6            2221     MOV A , @ R0 
070A    B4030D        2222     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2223     
070D    EC            2224     MOV A , R4 
070E    F4            2225     	CPL	A
070F    2401          2226     	ADD	A, #1
0711    FC            2227     MOV R4 , A 
0712    ED            2228     MOV A , R5 
0713    F4            2229     	CPL	A
0714    3400          2230     	ADDC	A, #0
0716    FD            2231     MOV R5 , A 
0717    020720        2232     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2233     
                      2234     PCA_INT_PPM_UNIDIR_NEG: 
                      2235     ENDIF
071A    7800          2236     MOV R0 , # 0 
071C    7900          2237     MOV R1 , # 0 
071E    E16A          2238     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2239     
                      2240     PCA_INT_PPM_NEG_CHECKED: 
                      2241     IF MODE >= 1	; Tail or multi
0720    7888          2242     MOV R0 , # PGM_DIRECTION 
0722    E6            2243     MOV A , @ R0 
0723    B40315        2244     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2245     
0726    EC            2246     MOV A , R4 
0727    33            2247     	RLC	A
0728    FC            2248     MOV R4 A 
0729    ED            2249     MOV A , R5 
072A    33            2250     	RLC	A
072B    FD            2251     MOV R5 A 
072C    C3            2252     	CLR	C							; Subtract deadband
072D    EC            2253     MOV A , R4 
072E    9405          2254     	SUBB	A, #5		
0730    FC            2255     MOV R4 , A 
0731    ED            2256     MOV A , R5 
0732    9400          2257     	SUBB	A, #0
0734    FD            2258     MOV R5 , A 
0735    5004          2259     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2260     
0737    7C00          2261     MOV R4 , # 0 
0739    7D00          2262     MOV R5 , # 0 
                      2263     
                      2264     PCA_INT_PPM_BIDIR_DONE: 
                      2265     ENDIF
073B    C3            2266     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2267     MOV A , R4 
073D    94FF          2268     SUBB A , # 255 
073F    ED            2269     MOV A , R5 
0740    9400          2270     	SUBB	A, #0
0742    4006          2271     	JC	PCA_INT_PPM_MAX_CHECKED
                      2272     
0744    78FF          2273     MOV R0 , # 255 
0746    7900          2274     MOV R1 , # 0 
0748    E16A          2275     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2276     
                      2277     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2278     MOV A , R4 
074B    856EF0        2279     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2280     	MUL	AB
074F    C5F0          2281     	XCH	A, B
0751    A2F7          2282     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2283     	RLC	A
0754    F8            2284     MOV R0 , A 
0755    7900          2285     MOV R1 , # 0 
0757    4003          2286     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2287     	
0759    020786        2288     	JMP	PCA_INT_LIMITED			
                      2289     
                      2290     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2291     MOV R0 , # 255 
075E    7900          2292     MOV R1 , # 0 
0760    020786        2293     	JMP	PCA_INT_LIMITED			
                      2294     
                      2295     PCA_INT_PWM_DIVIDE: 
0763    E9            2296     MOV A , R1 
0764    C3            2297     	CLR	C
0765    13            2298     	RRC	A
0766    F9            2299     MOV R1 , A 
0767    E8            2300     MOV A , R0 
0768    13            2301     	RRC	A
0769    F8            2302     MOV R0 , A 
                      2303     
                      2304     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2305     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2306     MOV A , R1 
076E    6002          2307     	JZ	($+4)
                      2308     
0770    78FF          2309     MOV R0 , # 255 
                      2310     
0772    C3            2311     	CLR	C
0773    E8            2312     MOV A , R0 
0774    13            2313     	RRC	A
0775    38            2314     ADDC A , R0 
0776    F8            2315     MOV R0 , A 
0777    E4            2316     	CLR	A
0778    3400          2317     	ADDC	A, #0
077A    F9            2318     MOV R1 , A 
                      2319     
                      2320     PCA_INT_CHECK_LEGAL_RANGE: 
                      2321     	; Check that RC pulse is within legal range
077B    C3            2322     	CLR	C
077C    E8            2323     MOV A , R0 
077D    94FF          2324     SUBB A , # 255 
077F    E9            2325     MOV A , R1 
0780    9400          2326     	SUBB	A, #0
0782    4002          2327     	JC	PCA_INT_LIMITED
                      2328     
0784    78FF          2329     MOV R0 , # 255 
                      2330     
                      2331     PCA_INT_LIMITED: 
                      2332     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2333     ; 
                      2334     ; 对 RCP 信号处理
                      2335     ; 1 小于 1500us 最低油门
                      2336     ; 2 大于 1500us 正常处理
                      2337     ; 
0786    C3            2338     	CLR C
0787    E8            2339     MOV A , R0 
0788    94A0          2340     SUBB A , # 160 
078A    5002          2341     	JNC SKYPUP_03					; No 跳转
078C    7800          2342     MOV R0 , # 0 
                      2343     SKYPUP_03: 
                      2344     
078E    C3            2345     	CLR C
078F    E8            2346     MOV A , R0 
0790    9573          2347     	SUBB A, PREV_RCP				; 上一个 Rcp > 当前 Rcp ?
0792    400E          2348     	JC SKYPUP_04					; No
                      2349     
0794    9402          2350     SUBB A , # 2 
0796    400A          2351     	JC SKYPUP_04					; No
                      2352     
0798    C3            2353     	CLR C						; 这一句能否去掉? Skypup 2015.05.25
0799    E573          2354     	MOV A, PREV_RCP
079B    2402          2355     ADD A , # 2 
079D    F8            2356     MOV R0 , A 
079E    5002          2357     	JNC SKYPUP_04					; 没有发生进位溢出
                      2358     
07A0    78FF          2359     MOV R0 , # 0FFH 
                      2360     	
                      2361     SKYPUP_04: 
07A2    E559          2362     	MOV A, NEW_RCP
07A4    F573          2363     	MOV PREV_RCP, A
                      2364     
                      2365     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2366     	; RC pulse value accepted
07A6    8859          2367     MOV NEW_RCP , R0 
07A8    D268          2368     SETB FLAGS2 . 0 
07AA    205902        2369     JB FLAGS0 . 1 , ( $+5 ) 
07AD    E1B7          2370     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2371     
07AF    741F          2372     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B1    F4            2373     	CPL	A
07B2    552E          2374     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07B4    4B            2375     ORL A , R3 
07B5    F52E          2376     	MOV	FLAGS3, A
                      2377     
                      2378     PCA_INT_SET_TIMEOUT: 
07B7    752818        2379     MOV RCP_TIMEOUT_CNT , # 24 
07BA    741F          2380     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07BC    552E          2381     	ANL	A, FLAGS3					; Check pwm frequency flags
07BE    7003          2382     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2383     
07C0    75280A        2384     MOV RCP_TIMEOUT_CNT , # 10 
                      2385     
                      2386     PCA_INT_PPM_TIMEOUT_SET: 
07C3    305902        2387     JNB FLAGS0 . 1 , ( $+5 ) 
07C6    E1D1          2388     	AJMP PCA_INT_EXIT				; Yes - exit
                      2389     
07C8    741F          2390     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07CA    552E          2391     	ANL	A, FLAGS3					; Check pwm frequency flags
07CC    6003          2392     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2393     
                      2394     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07CE    53DAFE        2394+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2395     
                      2396     PCA_INT_EXIT: 	; Exit interrupt routine	
07D1    752906        2397     MOV RCP_SKIP_CNT , # 6 
07D4    741F          2398     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07D6    552E          2399     	ANL	A, FLAGS3					; Check pwm frequency flags
07D8    7003          2400     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2401     
07DA    75290A        2402     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2403     
07DD    D0F0          2404     	POP	B			; Restore preserved registers
07DF    D0E0          2405     	POP	ACC			
07E1    D0D0          2406     	POP	PSW
07E3    C2D3          2407     	CLR	PSW.3		; Select register bank 0 for main program routines	
07E5    D2AD          2408     	SETB	ET2			; Enable timer2 interrupts
07E7    43E610        2409     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07EA    32            2410     	RETI
                      2411     
                      2412     
                      2413     
                      2414     
                      2415     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2416     ;
                      2417     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2418     ;
                      2419     ; No assumptions
                      2420     ;
                      2421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2422     WAIT1MS: 	
07EB    7901          2423     MOV R1 , # 1 
07ED    020809        2424     	JMP	WAITXMS_O
                      2425     
                      2426     WAIT3MS: 	
07F0    7903          2427     MOV R1 , # 3 
07F2    020809        2428     	JMP	WAITXMS_O
                      2429     
                      2430     WAIT10MS: 	
07F5    790A          2431     MOV R1 , # 10 
07F7    020809        2432     	JMP	WAITXMS_O
                      2433     
                      2434     WAIT30MS: 	
07FA    791E          2435     MOV R1 , # 30 
07FC    020809        2436     	JMP	WAITXMS_O
                      2437     
                      2438     WAIT100MS: 	
07FF    7964          2439     MOV R1 , # 100 
0801    020809        2440     	JMP	WAITXMS_O
                      2441     
                      2442     WAIT200MS: 	
0804    79C8          2443     MOV R1 , # 200 
0806    020809        2444     	JMP	WAITXMS_O
                      2445     
                      2446     WAITXMS_O: 	; Outer loop
0809    7817          2447     MOV R0 , # 23 
                      2448     WAITXMS_M: 	; Middle loop
080B    E4            2449     	CLR	A
080C    D5E0FD        2450      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
080F    D8FA          2451     DJNZ R0 , WAITXMS_M 
0811    D9F6          2452     DJNZ R1 , WAITXMS_O 
0813    22            2453     	RET
                      2454     
                      2455     
                      2456     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2457     ;
                      2458     ; Beeper routines (4 different entry points) 
                      2459     ;
                      2460     ; No assumptions
                      2461     ;
                      2462     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2463     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0814    7A14          2464     MOV R2 , # 20 
0816    7B78          2465     MOV R3 , # 120 
0818    020830        2466     	JMP	BEEP
                      2467     
                      2468     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
081B    7A10          2469     MOV R2 , # 16 
081D    7B8C          2470     MOV R3 , # 140 
081F    020830        2471     	JMP	BEEP
                      2472     
                      2473     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0822    7A0D          2474     MOV R2 , # 13 
0824    7BB4          2475     MOV R3 , # 180 
0826    020830        2476     	JMP	BEEP
                      2477     
                      2478     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0829    7A0B          2479     MOV R2 , # 11 
082B    7BC8          2480     MOV R3 , # 200 
082D    020830        2481     	JMP	BEEP
                      2482     
                      2483     BEEP: 	; Beep loop start
0830    AC25          2484     MOV R4 , CURRENT_PWM_LIMITED 
0832    752501        2485     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0835    7902          2486     MOV R1 , # 2 
                      2487     BEEP_ONOFF: 
0837    B275          2488     CPL FLAGS3 . 5 
0839    E4            2489     	CLR	A
                      2490     	BPFET_OFF			; BpFET off
083A    C294          2490+1   CLR P1 . 4 
083C    D5E0FD        2491     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2492     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
083F    E525          2492+1   MOV A , CURRENT_PWM_LIMITED 
0841    6002          2492+1   JZ ( $+4 ) 
0843    D295          2492+1   SETB P1 . 5 
0845    D5E0FD        2493     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2494     	BNFET_OFF			; BnFET off again
0848    C295          2494+1   CLR P1 . 5 
084A    D5E0FD        2495     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2496     	BPFET_ON			; BpFET on
084D    D294          2496+1   SETB P1 . 4 
084F    D5E0FD        2497     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2498     	; Turn on nfet
                      2499     	ANFET_ON			; AnFET on
0852    E525          2499+1   MOV A , CURRENT_PWM_LIMITED 
0854    600A          2499+1   JZ ( $+12 ) 
0856    207502        2499+1   JB FLAGS3 . 5 , ( $+5 ) 
0859    D292          2499+1   SETB P1 . 2 
085B    307502        2499+1   JNB FLAGS3 . 5 , ( $+5 ) 
085E    D296          2499+1   SETB P1 . 6 
0860    E56F          2500     	MOV	A, BEEP_STRENGTH
0862    D5E0FD        2501     	DJNZ	ACC, $		
                      2502     	; Turn off nfet
                      2503     	ANFET_OFF			; AnFET off
0865    207502        2503+1   JB FLAGS3 . 5 , ( $+5 ) 
0868    C292          2503+1   CLR P1 . 2 
086A    307502        2503+1   JNB FLAGS3 . 5 , ( $+5 ) 
086D    C296          2503+1   CLR P1 . 6 
086F    7496          2504     	MOV	A, #150		; 25s off
0871    D5E0FD        2505     	DJNZ	ACC, $		
0874    D9C1          2506     DJNZ R1 , BEEP_ONOFF 
                      2507     	; Copy variable
0876    EA            2508     MOV A , R2 
0877    F8            2509     MOV R0 , A 
                      2510     BEEP_OFF: 		; Fets off loop
0878    D5E0FD        2511     	DJNZ	ACC, $
087B    D8FB          2512     DJNZ R0 , BEEP_OFF 
087D    DBB1          2513     DJNZ R3 , BEEP 
                      2514     	BPFET_OFF			; BpFET off
087F    C294          2514+1   CLR P1 . 4 
0881    8C25          2515     MOV CURRENT_PWM_LIMITED , R4 
0883    22            2516     	RET
                      2517     
                      2518     
                      2519     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2520     ;
                      2521     ; Division 16bit unsigned by 16bit unsigned
                      2522     ;
                      2523     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2524     ; Result will be in Temp2/Temp1
                      2525     ;
                      2526     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2527     DIV_U16_BY_U16: 	
0884    C3            2528     	CLR	C       
0885    7C00          2529     MOV R4 , # 0 
0887    7D00          2530     MOV R5 , # 0 
0889    75F000        2531     	MOV	B, #0
                      2532     DIV_U16_BY_U16_DIV1: 
088C    05F0          2533     	INC	B      			; Increment counter for each left shift
088E    EA            2534     MOV A , R2 
088F    33            2535     	RLC	A      		
0890    FA            2536     MOV R2 , A 
0891    EB            2537     MOV A , R3 
0892    33            2538     	RLC	A      	  	
0893    FB            2539     MOV R3 , A 
0894    50F6          2540     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2541     DIV_U16_BY_U16_DIV2:         
0896    EB            2542     MOV A , R3 
0897    13            2543     	RRC	A      
0898    FB            2544     MOV R3 , A 
0899    EA            2545     MOV A , R2 
089A    13            2546     	RRC	A      
089B    FA            2547     MOV R2 , A 
089C    C3            2548     	CLR	C      
089D    E9            2549     MOV A , R1 
089E    FF            2550     MOV R7 , A 
089F    E8            2551     MOV A , R0 
08A0    FE            2552     MOV R6 , A 
08A1    E8            2553     MOV A , R0 
08A2    9A            2554     SUBB A , R2 
08A3    F8            2555     MOV R0 , A 
08A4    E9            2556     MOV A , R1 
08A5    9B            2557     SUBB A , R3 
08A6    F9            2558     MOV R1 , A 
08A7    5004          2559     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08A9    EF            2560     MOV A , R7 
08AA    F9            2561     MOV R1 , A 
08AB    EE            2562     MOV A , R6 
08AC    F8            2563     MOV R0 , A 
                      2564     DIV_U16_BY_U16_DIV3: 
08AD    B3            2565     	CPL	C      			; Invert carry, so it can be directly copied into result
08AE    EC            2566     MOV A , R4 
08AF    33            2567     	RLC	A      			; Shift carry flag into temporary result
08B0    FC            2568     MOV R4 , A 
08B1    ED            2569     MOV A , R5 
08B2    33            2570     	RLC	A
08B3    FD            2571     MOV R5 , A 
08B4    D5F0DF        2572     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08B7    ED            2573     MOV A , R5 
08B8    F9            2574     MOV R1 , A 
08B9    EC            2575     MOV A , R4 
08BA    F8            2576     MOV R0 , A 
08BB    22            2577     	RET
                      2578     
                      2579     
                      2580     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2581     ;
                      2582     ; Multiplication 16bit signed by 8bit unsigned
                      2583     ;
                      2584     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2585     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2586     ;
                      2587     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2588     MULT_S16_BY_U8_DIV_16: 
08BC    E8            2589     MOV A , R0 
08BD    89F0          2590     MOV B , R1 
08BF    8A20          2591     MOV BIT_ACCESS , R2 
08C1    D2D4          2592     	SETB	PSW.4		; Select register bank 2 for math routines
08C3    F8            2593     MOV R0 , A 
08C4    A9F0          2594     MOV R1 , B 
08C6    7B00          2595     MOV R3 , # 0 
08C8    30F70B        2596     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2597     
08CB    7BFF          2598     MOV R3 , # 0FFH 
08CD    F4            2599     	CPL	A
08CE    2401          2600     	ADD	A, #1
08D0    F8            2601     MOV R0 , A 
08D1    E9            2602     MOV A , R1 
08D2    F4            2603     	CPL	A
08D3    3400          2604     	ADDC	A, #0
08D5    F9            2605     MOV R1 , A 
                      2606     MULT_S16_BY_U8_POSITIVE: 
08D6    E8            2607     MOV A , R0 
08D7    8520F0        2608     	MOV	B, BIT_ACCESS
08DA    A4            2609     	MUL	AB
08DB    ADF0          2610     MOV R5 , B 
08DD    F8            2611     MOV R0 , A 
08DE    E9            2612     MOV A , R1 
08DF    8520F0        2613     	MOV	B, BIT_ACCESS
08E2    A4            2614     	MUL	AB
08E3    AFF0          2615     MOV R7 , B 
08E5    FE            2616     MOV R6 , A 
08E6    ED            2617     MOV A , R5 
08E7    2E            2618     ADD A , R6 
08E8    F9            2619     MOV R1 , A 
08E9    7400          2620     	MOV	A, #0
08EB    3F            2621     ADDC A , R7 
08EC    FA            2622     MOV R2 , A 
08ED    7C04          2623     MOV R4 , # 4 
                      2624     MULT_S16_BY_U8_DIV_LOOP: 
08EF    C3            2625     	CLR	C			; Rotate right 
08F0    EA            2626     MOV A , R2 
08F1    13            2627     	RRC	A
08F2    FA            2628     MOV R2 , A 
08F3    E9            2629     MOV A , R1 
08F4    13            2630     	RRC	A
08F5    F9            2631     MOV R1 , A 
08F6    E8            2632     MOV A , R0 
08F7    13            2633     	RRC	A
08F8    F8            2634     MOV R0 , A 
08F9    DCF4          2635     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2636     
08FB    8BF0          2637     MOV B , R3 
08FD    30F70A        2638     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2639     
0900    E8            2640     MOV A , R0 
0901    F4            2641     	CPL	A
0902    2401          2642     	ADD	A, #1
0904    F8            2643     MOV R0 , A 
0905    E9            2644     MOV A , R1 
0906    F4            2645     	CPL	A
0907    3400          2646     	ADDC	A, #0
0909    F9            2647     MOV R1 , A 
                      2648     
                      2649     MULT_S16_BY_U8_EXIT: 
090A    E8            2650     MOV A , R0 
090B    89F0          2651     MOV B , R1 
090D    C2D4          2652     	CLR	PSW.4		; Select normal register bank
090F    F8            2653     MOV R0 , A 
0910    A9F0          2654     MOV R1 , B 
0912    22            2655     	RET
                      2656     
                      2657     
                      2658     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2659     ;
                      2660     ; Calculate governor routines
                      2661     ;
                      2662     ; No assumptions
                      2663     ;
                      2664     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2665     ; The governor task is split into several routines in order to distribute processing time
                      2666     ;
                      2667     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2668     ; First governor routine - calculate governor target
                      2669     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      2809     IF MODE == 2	; Multi
                      2810     CALC_GOVERNOR_TARGET: 
0913    7882          2811     MOV R0 , # PGM_GOV_MODE 
0915    B60403        2812     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0918    02096F        2813     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      2814     
                      2815     GOVERNOR_TARGET_CALC: 
                      2816     	; Stop governor for stop RC pulse	
091B    C3            2817     	CLR	C
091C    E559          2818     	MOV	A, NEW_RCP				; Check RC pulse against stop value
091E    9401          2819     SUBB A , # 1 
0920    4003          2820     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      2821     
0922    020938        2822     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      2823     
                      2824     GOVERNOR_DEACTIVATE: 
0925    852224        2825     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0928    E4            2826     	CLR	A
0929    F540          2827     	MOV	GOV_TARGET_L, A			; Set target to zero
092B    F541          2828     	MOV	GOV_TARGET_H, A
092D    F542          2829     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
092F    F543          2830     	MOV	GOV_INTEGRAL_H, A
0931    F544          2831     	MOV	GOV_INTEGRAL_X, A
0933    F549          2832     	MOV	GOV_ACTIVE, A
0935    02096F        2833     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      2834     
                      2835     GOVERNOR_ACTIVATE: 
0938    7882          2836     MOV R0 , # PGM_GOV_MODE 
093A    E6            2837     MOV A , @ R0 
093B    FC            2838     MOV R4 , A 
093C    754901        2839     	MOV	GOV_ACTIVE, #1
093F    E522          2840     	MOV	A, REQUESTED_PWM			; Load requested pwm
0941    F523          2841     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      2842     	; Calculate comm period target 2*(51000/Requested_Pwm)
0943    7838          2843     MOV R0 , # 38H 
0945    79C7          2844     MOV R1 , # 0C7H 
0947    AA3C          2845     MOV R2 , COMM_PERIOD4X_L 
0949    AB3D          2846     MOV R3 , COMM_PERIOD4X_H 
                      2847     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
094B    C3            2848     	CLR	C
094C    EB            2849     MOV A , R3 
094D    13            2850     	RRC	A
094E    FB            2851     MOV R3 , A 
094F    EA            2852     MOV A , R2 
0950    13            2853     	RRC	A
0951    FA            2854     MOV R2 , A 
                      2855     	; Check range
0952    EC            2856     MOV A , R4 
0953    14            2857     	DEC	A
0954    6013          2858     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      2859     GOVERNOR_ACTIVATE_100K: 
0956    C3            2860     	CLR	C
0957    EB            2861     MOV A , R3 
0958    13            2862     	RRC	A
0959    FB            2863     MOV R3 , A 
095A    EA            2864     MOV A , R2 
095B    13            2865     	RRC	A
095C    FA            2866     MOV R2 , A 
095D    EC            2867     MOV A , R4 
095E    14            2868     	DEC	A
095F    14            2869     	DEC	A
0960    6007          2870     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      2871     GOVERNOR_ACTIVATE_50K: 
0962    C3            2872     	CLR	C
0963    EB            2873     MOV A , R3 
0964    13            2874     	RRC	A
0965    FB            2875     MOV R3 , A 
0966    EA            2876     MOV A , R2 
0967    13            2877     	RRC	A
0968    FA            2878     MOV R2 , A 
                      2879     GOVERNOR_ACTIVATE_RANGE_SET: 
0969    1184          2880     	CALL	DIV_U16_BY_U16
                      2881     	; Store governor target
096B    8840          2882     MOV GOV_TARGET_L , R0 
096D    8941          2883     MOV GOV_TARGET_H , R1 
                      2884     CALC_GOVERNOR_TARGET_EXIT: 
096F    22            2885     	RET						
                      2886     ENDIF
                      2887     
                      2888     
                      2889     ; Second governor routine - calculate governor proportional error
                      2890     CALC_GOVERNOR_PROP_ERROR: 
                      2891     	; Exit if governor is inactive
0970    E549          2892     	MOV	A, GOV_ACTIVE
0972    6034          2893     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      2894     
                      2895     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      2913     IF MODE == 2	; Multi
                      2914     	; Calculate error
0974    C3            2915     	CLR	C
0975    E540          2916     	MOV	A, GOV_TARGET_L
0977    9523          2917     	SUBB	A, GOVERNOR_REQ_PWM
0979    F8            2918     MOV R0 , A 
097A    E541          2919     	MOV	A, GOV_TARGET_H
097C    9400          2920     	SUBB	A, #0
097E    F9            2921     MOV R1 , A 
                      2922     ENDIF
                      2923     	; Check error and limit
097F    500C          2924     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      2925     
0981    C3            2926     	CLR	C
0982    E8            2927     MOV A , R0 
0983    9480          2928     	SUBB	A, #80H					; Is error too negative?
0985    E9            2929     MOV A , R1 
0986    94FF          2930     	SUBB	A, #0FFH
0988    4016          2931     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
098A    0209A4        2932     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2933     
                      2934     GOVERNOR_CHECK_PROP_LIMIT_POS: 
098D    C3            2935     	CLR	C
098E    E8            2936     MOV A , R0 
098F    947F          2937     	SUBB	A, #7FH					; Is error too positive?
0991    E9            2938     MOV A , R1 
0992    9400          2939     	SUBB	A, #00H
0994    5003          2940     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0996    0209A4        2941     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2942     
                      2943     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0999    787F          2944     MOV R0 , # 7FH 
099B    7900          2945     MOV R1 , # 00H 
099D    0209A4        2946     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2947     
                      2948     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09A0    7880          2949     MOV R0 , # 80H 
09A2    79FF          2950     MOV R1 , # 0FFH 
                      2951     
                      2952     GOVERNOR_STORE_PROP_ERROR: 
                      2953     	; Store proportional
09A4    8845          2954     MOV GOV_PROPORTIONAL_L , R0 
09A6    8946          2955     MOV GOV_PROPORTIONAL_H , R1 
                      2956     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09A8    22            2957     	RET						
                      2958     
                      2959     
                      2960     ; Third governor routine - calculate governor integral error
                      2961     CALC_GOVERNOR_INT_ERROR: 
                      2962     	; Exit if governor is inactive
09A9    E549          2963     	MOV	A, GOV_ACTIVE
09AB    6058          2964     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      2965     
                      2966     	; Add proportional to integral
09AD    E545          2967     	MOV	A, GOV_PROPORTIONAL_L
09AF    2542          2968     	ADD	A, GOV_INTEGRAL_L
09B1    F8            2969     MOV R0 , A 
09B2    E546          2970     	MOV	A, GOV_PROPORTIONAL_H
09B4    3543          2971     	ADDC	A, GOV_INTEGRAL_H
09B6    F9            2972     MOV R1 , A 
09B7    854620        2973     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09BA    E4            2974     	CLR	A
09BB    300701        2975     	JNB	BIT_ACCESS.7, ($+4)			
09BE    F4            2976     	CPL	A
09BF    3544          2977     	ADDC	A, GOV_INTEGRAL_X
09C1    FA            2978     MOV R2 , A 
                      2979     	; Check integral and limit
09C2    30E709        2980     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      2981     
09C5    C3            2982     	CLR	C
09C6    EA            2983     MOV A , R2 
09C7    94F0          2984     	SUBB	A, #0F0H					; Is error too negative?
09C9    4015          2985     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09CB    0209E6        2986     	JMP	GOVERNOR_CHECK_PWM
                      2987     
                      2988     GOVERNOR_CHECK_INT_LIMIT_POS: 
09CE    C3            2989     	CLR	C
09CF    EA            2990     MOV A , R2 
09D0    940F          2991     	SUBB	A, #0FH					; Is error too positive?
09D2    5003          2992     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09D4    0209E6        2993     	JMP	GOVERNOR_CHECK_PWM
                      2994     
                      2995     GOVERNOR_LIMIT_INT_ERROR_POS: 
09D7    78FF          2996     MOV R0 , # 0FFH 
09D9    79FF          2997     MOV R1 , # 0FFH 
09DB    7A0F          2998     MOV R2 , # 0FH 
09DD    0209E6        2999     	JMP	GOVERNOR_CHECK_PWM
                      3000     
                      3001     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09E0    7800          3002     MOV R0 , # 00H 
09E2    7900          3003     MOV R1 , # 00H 
09E4    7AF0          3004     MOV R2 , # 0F0H 
                      3005     
                      3006     GOVERNOR_CHECK_PWM: 
                      3007     	; Check current pwm
09E6    C3            3008     	CLR	C
09E7    E524          3009     	MOV	A, CURRENT_PWM
09E9    955E          3010     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09EB    5006          3011     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3012     
09ED    E524          3013     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09EF    6009          3014     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3015     
09F1    21FF          3016     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3017     
                      3018     GOVERNOR_INT_MAX_PWM: 
09F3    E546          3019     	MOV	A, GOV_PROPORTIONAL_H
09F5    20E70D        3020     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3021     
09F8    21FF          3022     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3023     
                      3024     GOVERNOR_INT_MIN_PWM: 
09FA    E546          3025     	MOV	A, GOV_PROPORTIONAL_H
09FC    30E706        3026     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3027     
                      3028     GOVERNOR_STORE_INT_ERROR: 
                      3029     	; Store integral
09FF    8842          3030     MOV GOV_INTEGRAL_L , R0 
0A01    8943          3031     MOV GOV_INTEGRAL_H , R1 
0A03    8A44          3032     MOV GOV_INTEGRAL_X , R2 
                      3033     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A05    22            3034     	RET						
                      3035     
                      3036     
                      3037     ; Fourth governor routine - calculate governor proportional correction
                      3038     CALC_GOVERNOR_PROP_CORRECTION: 
                      3039     	; Exit if governor is inactive
0A06    E549          3040     	MOV	A, GOV_ACTIVE
0A08    7003          3041     	JNZ	CALC_GOVERNOR_PROP_CORR
0A0A    020A69        3042     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3043     
                      3044     CALC_GOVERNOR_PROP_CORR: 
                      3045     	; Load proportional gain
0A0D    789F          3046     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A0F    E6            3047     MOV A , @ R0 
0A10    FA            3048     MOV R2 , A 
                      3049     	; Load proportional
0A11    C3            3050     	CLR	C
0A12    E545          3051     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A14    33            3052     	RLC	A
0A15    F8            3053     MOV R0 , A 
0A16    E546          3054     	MOV	A, GOV_PROPORTIONAL_H
0A18    33            3055     	RLC	A
0A19    F9            3056     MOV R1 , A 
                      3057     	; Apply gain
0A1A    11BC          3058     	CALL	MULT_S16_BY_U8_DIV_16
                      3059     	; Check error and limit (to low byte)
0A1C    E9            3060     MOV A , R1 
0A1D    30E70B        3061     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3062     
0A20    C3            3063     	CLR	C
0A21    E8            3064     MOV A , R0 
0A22    9480          3065     	SUBB	A, #80H					; Is error too negative?
0A24    E9            3066     MOV A , R1 
0A25    94FF          3067     	SUBB	A, #0FFH
0A27    4013          3068     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A29    4140          3069     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3070     
                      3071     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A2B    C3            3072     	CLR	C
0A2C    E8            3073     MOV A , R0 
0A2D    947F          3074     	SUBB	A, #7FH					; Is error too positive?
0A2F    E9            3075     MOV A , R1 
0A30    9400          3076     	SUBB	A, #00H
0A32    5002          3077     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A34    4140          3078     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3079     
                      3080     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A36    787F          3081     MOV R0 , # 7FH 
0A38    7900          3082     MOV R1 , # 00H 
0A3A    4140          3083     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3084     
                      3085     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A3C    7880          3086     MOV R0 , # 80H 
0A3E    79FF          3087     MOV R1 , # 0FFH 
                      3088     
                      3089     GOVERNOR_APPLY_PROP_CORR: 
                      3090     	; Test proportional sign
0A40    E8            3091     MOV A , R0 
0A41    20E715        3092     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3093     
                      3094     	; Subtract positive proportional
0A44    C3            3095     	CLR	C
0A45    E523          3096     	MOV	A, GOVERNOR_REQ_PWM
0A47    98            3097     SUBB A , R0 
0A48    F8            3098     MOV R0 , A 
                      3099     	; Check result
0A49    4009          3100     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3101     
0A4B    C3            3102     	CLR	C
0A4C    E8            3103     MOV A , R0 
0A4D    9401          3104     	SUBB	A, #1
0A4F    4003          3105     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A51    020A67        3106     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3107     
                      3108     GOVERNOR_CORR_PROP_MIN_PWM: 
0A54    7801          3109     MOV R0 , # 1 
0A56    020A67        3110     	JMP	GOVERNOR_STORE_PROP_CORR
                      3111     
                      3112     GOVERNOR_CORR_NEG_PROP: 
                      3113     	; Add negative proportional
0A59    E8            3114     MOV A , R0 
0A5A    F4            3115     	CPL	A
0A5B    2401          3116     	ADD	A, #1
0A5D    2523          3117     	ADD	A, GOVERNOR_REQ_PWM
0A5F    F8            3118     MOV R0 , A 
                      3119     	; Check result
0A60    4003          3120     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A62    020A67        3121     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3122     
                      3123     GOVERNOR_CORR_PROP_MAX_PWM: 
0A65    78FF          3124     MOV R0 , # 255 
                      3125     GOVERNOR_STORE_PROP_CORR: 
                      3126     	; Store proportional pwm
0A67    8847          3127     MOV GOV_PROP_PWM , R0 
                      3128     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A69    22            3129     	RET
                      3130     
                      3131     
                      3132     ; Fifth governor routine - calculate governor integral correction
                      3133     CALC_GOVERNOR_INT_CORRECTION: 
                      3134     	; Exit if governor is inactive
0A6A    E549          3135     	MOV	A, GOV_ACTIVE
0A6C    7003          3136     	JNZ	CALC_GOVERNOR_INT_CORR
0A6E    020ACB        3137     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3138     
                      3139     CALC_GOVERNOR_INT_CORR: 
                      3140     	; Load integral gain
0A71    78A0          3141     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A73    E6            3142     MOV A , @ R0 
0A74    FA            3143     MOV R2 , A 
                      3144     	; Load integral
0A75    A843          3145     MOV R0 , GOV_INTEGRAL_H 
0A77    A944          3146     MOV R1 , GOV_INTEGRAL_X 
                      3147     	; Apply gain
0A79    11BC          3148     	CALL	MULT_S16_BY_U8_DIV_16
                      3149     	; Check integral and limit
0A7B    E9            3150     MOV A , R1 
0A7C    30E70C        3151     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3152     
0A7F    C3            3153     	CLR	C
0A80    E8            3154     MOV A , R0 
0A81    9401          3155     	SUBB	A, #01H					; Is integral too negative?
0A83    E9            3156     MOV A , R1 
0A84    94FF          3157     	SUBB	A, #0FFH
0A86    4016          3158     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A88    020AA2        3159     	JMP	GOVERNOR_APPLY_INT_CORR
                      3160     
                      3161     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A8B    C3            3162     	CLR	C
0A8C    E8            3163     MOV A , R0 
0A8D    94FF          3164     	SUBB	A, #0FFH					; Is integral too positive?
0A8F    E9            3165     MOV A , R1 
0A90    9400          3166     	SUBB	A, #00H
0A92    5003          3167     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A94    020AA2        3168     	JMP	GOVERNOR_APPLY_INT_CORR
                      3169     
                      3170     GOVERNOR_LIMIT_INT_CORR_POS: 
0A97    78FF          3171     MOV R0 , # 0FFH 
0A99    7900          3172     MOV R1 , # 00H 
0A9B    020AA2        3173     	JMP	GOVERNOR_APPLY_INT_CORR
                      3174     
                      3175     GOVERNOR_LIMIT_INT_CORR_NEG: 
0A9E    7801          3176     MOV R0 , # 01H 
0AA0    79FF          3177     MOV R1 , # 0FFH 
                      3178     
                      3179     GOVERNOR_APPLY_INT_CORR: 
                      3180     	; Test integral sign
0AA2    E9            3181     MOV A , R1 
0AA3    20E715        3182     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3183     
                      3184     	; Subtract positive integral
0AA6    C3            3185     	CLR	C
0AA7    E547          3186     	MOV	A, GOV_PROP_PWM
0AA9    98            3187     SUBB A , R0 
0AAA    F8            3188     MOV R0 , A 
                      3189     	; Check result
0AAB    4009          3190     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3191     
0AAD    C3            3192     	CLR	C
0AAE    E8            3193     MOV A , R0 
0AAF    9401          3194     	SUBB	A, #1
0AB1    4003          3195     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0AB3    020AC9        3196     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3197     
                      3198     GOVERNOR_CORR_INT_MIN_PWM: 
0AB6    7800          3199     MOV R0 , # 0 
0AB8    020AC9        3200     	JMP	GOVERNOR_STORE_INT_CORR
                      3201     
                      3202     GOVERNOR_CORR_NEG_INT: 
                      3203     	; Add negative integral
0ABB    E8            3204     MOV A , R0 
0ABC    F4            3205     	CPL	A
0ABD    2401          3206     	ADD	A, #1
0ABF    2547          3207     	ADD	A, GOV_PROP_PWM
0AC1    F8            3208     MOV R0 , A 
                      3209     	; Check result
0AC2    4003          3210     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AC4    020AC9        3211     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3212     
                      3213     GOVERNOR_CORR_INT_MAX_PWM: 
0AC7    78FF          3214     MOV R0 , # 255 
                      3215     GOVERNOR_STORE_INT_CORR: 
                      3216     	; Store current pwm
0AC9    8824          3217     MOV CURRENT_PWM , R0 
                      3218     CALC_GOVERNOR_INT_CORR_EXIT: 
0ACB    22            3219     	RET
                      3220     
                      3221     
                      3222     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3223     ;
                      3224     ; Measure lipo cells
                      3225     ;
                      3226     ; No assumptions
                      3227     ;
                      3228     ; Measure voltage and calculate lipo cells
                      3229     ;
                      3230     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3231     MEASURE_LIPO_CELLS: 
                      3232     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3236     MEASURE_LIPO_START: 
                      3237     	; Load programmed low voltage limit
0ACC    7883          3238     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0ACE    E6            3239     MOV A , @ R0 
0ACF    F520          3240     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3241     	; Set commutation to BpFET on
0AD1    120FEA        3242     	CALL	COMM5COMM6			
                      3243     	; Start adc
                      3244     	START_ADC 
0AD4    75E890        3244+1   MOV ADC0CN , # 90H  ; ADC START
                      3245     	; Wait for ADC reference to settle, and then start again
0AD7    1207EB        3246     	CALL	WAIT1MS
                      3247     	START_ADC
0ADA    75E890        3247+1   MOV ADC0CN , # 90H  ; ADC START
                      3248     	; Wait for ADC conversion to complete
                      3249     MEASURE_LIPO_WAIT_ADC: 
                      3250     	GET_ADC_STATUS 
0ADD    E5E8          3250+1   MOV A , ADC0CN 
0ADF    20ECFB        3251     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3252     	; Read ADC result
                      3253     	READ_ADC_RESULT
0AE2    A8BD          3253+1   MOV R0 , ADC0L 
0AE4    A9BE          3253+1   MOV R1 , ADC0H 
                      3254     	; Stop ADC
                      3255     	STOP_ADC
                      3256     	; Switch power off
0AE6    121090        3257     	CALL	SWITCH_POWER_OFF		
                      3258     	; Set limit step
0AE9    756A55        3259     MOV LIPO_ADC_LIMIT_L , # 85 
0AEC    756B00        3260     MOV LIPO_ADC_LIMIT_H , # 0 
0AEF    C3            3261     	CLR	C
0AF0    7400          3262     MOV A , # 0 
0AF2    13            3263     	RRC	A
0AF3    FD            3264     MOV R5 , A 
0AF4    7455          3265     MOV A , # 85 
0AF6    13            3266     	RRC	A
0AF7    FC            3267     MOV R4 , A 
0AF8    7455          3268     MOV A , # 85 
0AFA    2C            3269     ADD A , R4 
0AFB    FC            3270     MOV R4 , A 
0AFC    7400          3271     MOV A , # 0 
0AFE    3D            3272     ADDC A , R5 
0AFF    FD            3273     MOV R5 , A 
0B00    EC            3274     MOV A , R4 
0B01    FA            3275     MOV R2 , A 
0B02    ED            3276     MOV A , R5 
0B03    FB            3277     MOV R3 , A 
                      3278     MEASURE_LIPO_CELL_LOOP: 
                      3279     	; Check voltage against xS lower limit
0B04    C3            3280     	CLR	C
0B05    E8            3281     MOV A , R0 
0B06    9A            3282     SUBB A , R2 
0B07    E9            3283     MOV A , R1 
0B08    9B            3284     SUBB A , R3 
0B09    4014          3285     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3286     
                      3287     	; Set xS voltage limit
0B0B    E56A          3288     	MOV	A, LIPO_ADC_LIMIT_L		
0B0D    2455          3289     ADD A , # 85 
0B0F    F56A          3290     	MOV	LIPO_ADC_LIMIT_L, A
0B11    E56B          3291     	MOV	A, LIPO_ADC_LIMIT_H		
0B13    3400          3292     ADDC A , # 0 
0B15    F56B          3293     	MOV	LIPO_ADC_LIMIT_H, A
                      3294     	; Set (x+1)S lower limit
0B17    EA            3295     MOV A , R2 
0B18    2C            3296     ADD A , R4 
0B19    FA            3297     MOV R2 , A 
0B1A    EB            3298     MOV A , R3 
0B1B    3D            3299     ADDC A , R5 
0B1C    FB            3300     MOV R3 , A 
0B1D    80E5          3301     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3302     
                      3303     MEASURE_LIPO_ADJUST: 
0B1F    AE6A          3304     MOV R6 , LIPO_ADC_LIMIT_L 
0B21    AF6B          3305     MOV R7 , LIPO_ADC_LIMIT_H 
                      3306     	; Calculate 3.125%
0B23    C3            3307     	CLR	C
0B24    E56B          3308     	MOV	A, LIPO_ADC_LIMIT_H
0B26    13            3309     	RRC	A
0B27    F9            3310     MOV R1 , A 
0B28    E56A          3311     	MOV	A, LIPO_ADC_LIMIT_L	
0B2A    13            3312     	RRC	A
0B2B    F8            3313     MOV R0 , A 
0B2C    C3            3314     	CLR	C
0B2D    E9            3315     MOV A , R1 
0B2E    13            3316     	RRC	A
0B2F    F9            3317     MOV R1 , A 
0B30    E8            3318     MOV A , R0 
0B31    13            3319     	RRC	A
0B32    F8            3320     MOV R0 , A 
0B33    E56A          3321     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B35    28            3322     ADD A , R0 
0B36    F568          3323     	MOV	LIPO_ADC_REFERENCE_L, A
0B38    E56B          3324     	MOV	A, LIPO_ADC_LIMIT_H
0B3A    39            3325     ADDC A , R1 
0B3B    F569          3326     	MOV	LIPO_ADC_REFERENCE_H, A
                      3327     	; Divide three times to get to 3.125%
0B3D    7A03          3328     MOV R2 , # 3 
                      3329     MEASURE_LIPO_DIVIDE_LOOP: 
0B3F    C3            3330     	CLR	C
0B40    E9            3331     MOV A , R1 
0B41    13            3332     	RRC	A
0B42    F9            3333     MOV R1 , A 
0B43    E8            3334     MOV A , R0 
0B44    13            3335     	RRC	A
0B45    F8            3336     MOV R0 , A 
0B46    DAF7          3337     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3338     
                      3339     	; Add the programmed number of 0.1V (or 3.125% increments)
0B48    AA20          3340     MOV R2 , BIT_ACCESS 
0B4A    1A            3341     DEC R2 
0B4B    7009          3342     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3343     
0B4D    756A00        3344     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B50    756B00        3345     	MOV	LIPO_ADC_LIMIT_H, #0
0B53    020B66        3346     	JMP	MEASURE_LIPO_EXIT	
                      3347     
                      3348     MEASURE_LIPO_LIMIT_ON: 
0B56    1A            3349     DEC R2 
0B57    EA            3350     MOV A , R2 
0B58    6008          3351     	JZ	MEASURE_LIPO_UPDATE
                      3352     
                      3353     MEASURE_LIPO_ADD_LOOP: 
0B5A    EE            3354     MOV A , R6 
0B5B    28            3355     ADD A , R0 
0B5C    FE            3356     MOV R6 , A 
0B5D    EF            3357     MOV A , R7 
0B5E    39            3358     ADDC A , R1 
0B5F    FF            3359     MOV R7 , A 
0B60    DAF8          3360     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3361     
                      3362     MEASURE_LIPO_UPDATE: 
                      3363     	; Set ADC limit
0B62    8E6A          3364     MOV LIPO_ADC_LIMIT_L , R6 
0B64    8F6B          3365     MOV LIPO_ADC_LIMIT_H , R7 
                      3366     MEASURE_LIPO_EXIT: 
0B66    22            3367     	RET
                      3368     
                      3369     
                      3370     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3371     ;
                      3372     ; Start ADC conversion
                      3373     ;
                      3374     ; No assumptions
                      3375     ;
                      3376     ; Start conversion used for measuring power supply voltage
                      3377     ;
                      3378     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3379     START_ADC_CONVERSION: 
                      3380     	; Start adc
                      3381     	START_ADC 
0B67    75E890        3381+1   MOV ADC0CN , # 90H  ; ADC START
0B6A    22            3382     	RET
                      3383     
                      3384     
                      3385     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3386     ;
                      3387     ; Check temperature, power supply voltage and limit power
                      3388     ;
                      3389     ; No assumptions
                      3390     ;
                      3391     ; Used to limit main motor power in order to maintain the required voltage
                      3392     ;
                      3393     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3394     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3395     	; Load programmed low voltage limit
0B6B    7883          3396     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B6D    E6            3397     MOV A , @ R0 
0B6E    FF            3398     MOV R7 , A 
                      3399     	; Wait for ADC conversion to complete
                      3400     	GET_ADC_STATUS 
0B6F    E5E8          3400+1   MOV A , ADC0CN 
0B71    20ECF7        3401     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3402     	; Read ADC result
                      3403     	READ_ADC_RESULT
0B74    A8BD          3403+1   MOV R0 , ADC0L 
0B76    A9BE          3403+1   MOV R1 , ADC0H 
                      3404     	; Stop ADC
                      3405     	STOP_ADC
                      3406     
0B78    056C          3407     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B7A    C3            3408     	CLR	C
0B7B    E56C          3409     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B7D    9408          3410     SUBB A , # 8 
0B7F    404B          3411     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3412     
0B81    756C00        3413     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B84    E9            3414     MOV A , R1 
0B85    7007          3415     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3416     
0B87    E56D          3417     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B89    601B          3418     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B8B    020B9A        3419     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3420     
                      3421     TEMP_AVERAGE_INC_DEC: 
0B8E    C3            3422     	CLR	C
0B8F    E8            3423     MOV A , R0 
0B90    956D          3424     	SUBB	A, CURRENT_AVERAGE_TEMP
0B92    6010          3425     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3426     
0B94    E56D          3427     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0B96    5006          3428     	JNC	TEMP_AVERAGE_INC				
                      3429     
0B98    600C          3430     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3431     TEMP_AVERAGE_DEC: 
0B9A    14            3432     	DEC	A						; Decrement average
0B9B    020BA6        3433     	JMP	TEMP_AVERAGE_UPDATED
                      3434     
                      3435     TEMP_AVERAGE_INC: 
0B9E    04            3436     	INC	A						; Increment average
0B9F    60F9          3437     	JZ	TEMP_AVERAGE_DEC
0BA1    020BA6        3438     	JMP	TEMP_AVERAGE_UPDATED
                      3439     
                      3440     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BA4    E56D          3441     	MOV	A, CURRENT_AVERAGE_TEMP
                      3442     TEMP_AVERAGE_UPDATED: 
0BA6    F56D          3443     	MOV	CURRENT_AVERAGE_TEMP, A
0BA8    C3            3444     	CLR	C
0BA9    9472          3445     SUBB A , # 114 
0BAB    401B          3446     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3447     
0BAD    755EC0        3448     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3449     
0BB0    C3            3450     	CLR	C
0BB1    9404          3451     SUBB A , # 4 
0BB3    4013          3452     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3453     
0BB5    755E80        3454     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3455     
0BB8    C3            3456     	CLR	C
0BB9    9404          3457     SUBB A , # 4 
0BBB    400B          3458     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3459     
0BBD    755E40        3460     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3461     
0BC0    C3            3462     	CLR	C
0BC1    9404          3463     SUBB A , # 4 
0BC3    4003          3464     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3465     
0BC5    755E00        3466     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3467     
                      3468     TEMP_CHECK_EXIT: 
                      3469     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BC8    75BB09        3469+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BCB    22            3470     	RET
                      3471     
                      3472     CHECK_VOLTAGE_START: 
                      3473     IF MODE == 0 OR MODE == 2	; Main or multi
                      3474     	; Check if low voltage limiting is enabled
0BCC    EF            3475     MOV A , R7 
0BCD    C3            3476     	CLR	C
0BCE    9401          3477     	SUBB	A, #1					; Is low voltage limit disabled?
0BD0    601B          3478     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3479     
                      3480     	; Check if ADC is saturated
0BD2    C3            3481     	CLR	C
0BD3    E8            3482     MOV A , R0 
0BD4    94FF          3483     	SUBB	A, #0FFH
0BD6    E9            3484     MOV A , R1 
0BD7    9403          3485     	SUBB	A, #03H
0BD9    5012          3486     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3487     
                      3488     	; Check voltage against limit
0BDB    C3            3489     	CLR	C
0BDC    E8            3490     MOV A , R0 
0BDD    956A          3491     	SUBB	A, LIPO_ADC_LIMIT_L
0BDF    E9            3492     MOV A , R1 
0BE0    956B          3493     	SUBB	A, LIPO_ADC_LIMIT_H
0BE2    5009          3494     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3495     
                      3496     	; Decrease pwm limit
0BE4    E55E          3497     	MOV  A, PWM_LIMIT
0BE6    600C          3498     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3499     
0BE8    155E          3500     	DEC	PWM_LIMIT					; Decrement limit
0BEA    020BF4        3501     	JMP	CHECK_VOLTAGE_LIM
                      3502     
                      3503     CHECK_VOLTAGE_GOOD: 
                      3504     	; Increase pwm limit
0BED    E55E          3505     	MOV  A, PWM_LIMIT
0BEF    F4            3506     	CPL	A			
0BF0    6002          3507     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3508     
0BF2    055E          3509     	INC	PWM_LIMIT					; Increment limit
                      3510     
                      3511     CHECK_VOLTAGE_LIM: 
0BF4    A85E          3512     MOV R0 , PWM_LIMIT 
0BF6    C3            3513     	CLR	C
0BF7    E524          3514     	MOV	A, CURRENT_PWM
0BF9    98            3515     SUBB A , R0 
0BFA    5002          3516     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3517     
0BFC    A824          3518     MOV R0 , CURRENT_PWM 
                      3519     
                      3520     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3521     	; Slow spoolup
0BFE    C3            3522     	CLR	C
0BFF    E8            3523     MOV A , R0 
0C00    955F          3524     	SUBB	A, PWM_LIMIT_SPOOLUP
0C02    400A          3525     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3526     
0C04    A85F          3527     MOV R0 , PWM_LIMIT_SPOOLUP 
0C06    E55F          3528     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C08    F4            3529     	CPL	A
0C09    6003          3530     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3531      
0C0B    855F5E        3532     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3533     
                      3534     CHECK_VOLTAGE_EXIT: 
0C0E    8825          3535     MOV CURRENT_PWM_LIMITED , R0 
                      3536     ENDIF
                      3537     	; Set adc mux for next conversion
0C10    C3            3538     	CLR	C
0C11    E56C          3539     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C13    B40703        3540     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3541     
                      3542     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C16    75BB10        3542+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3543     
                      3544     CHECK_VOLTAGE_RET: 
0C19    22            3545     	RET
                      3546     
                      3547     
                      3548     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3549     ;
                      3550     ; Set startup PWM routine
                      3551     ;
                      3552     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3553     ;
                      3554     ; Used for pwm control during startup
                      3555     ;
                      3556     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3557     SET_STARTUP_PWM: 	
                      3558     	; Set pwm values according to startup phase flags
0C1A    306102        3559     JNB FLAGS1 . 1 , ( $+5 ) 
0C1D    7832          3560     MOV R0 , # 50 
0C1F    306202        3561     JNB FLAGS1 . 2 , ( $+5 ) 
0C22    7878          3562     MOV R0 , # 120 
                      3563     
                      3564     	; Update pwm variables if any startup phase flag is set
0C24    E52C          3565     	MOV	A, FLAGS1
0C26    5406          3566     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C28    601F          3567     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3568     
                      3569     	; Adjust startup power
0C2A    E8            3570     MOV A , R0 
0C2B    79A2          3571     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C2D    87F0          3572     MOV B , @ R1 
0C2F    A4            3573     	MUL	AB
0C30    C5F0          3574     	XCH	A, B
0C32    A2F7          3575     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C34    33            3576     	RLC	A
0C35    F8            3577     MOV R0 , A 
0C36    C3            3578     	CLR	C
0C37    E8            3579     MOV A , R0 
0C38    955E          3580     	SUBB	A, PWM_LIMIT	
0C3A    4002          3581     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3582     
0C3C    A85E          3583     MOV R0 , PWM_LIMIT 
                      3584     
                      3585     STARTUP_PWM_SET_PWM: 
                      3586     	; Set pwm variables
0C3E    8822          3587     MOV REQUESTED_PWM , R0 
0C40    8824          3588     MOV CURRENT_PWM , R0 
0C42    8825          3589     MOV CURRENT_PWM_LIMITED , R0 
0C44    306102        3590     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3591     
0C47    8860          3592     MOV PWM_SPOOLUP_BEG , R0 
                      3593     
                      3594     STARTUP_PWM_EXIT: 
0C49    22            3595     	RET
                      3596     
                      3597     
                      3598     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3599     ;
                      3600     ; Initialize all timings routine
                      3601     ;
                      3602     ; No assumptions
                      3603     ;
                      3604     ; Part of initialization before motor start
                      3605     ;
                      3606     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3607     INITIALIZE_ALL_TIMINGS:  
                      3608     	; Load programmed startup rpm
0C4A    788F          3609     MOV R0 , # PGM_STARTUP_RPM 
0C4C    E6            3610     MOV A , @ R0 
0C4D    FF            3611     MOV R7 , A 
                      3612     	; Check startup rpm setting and set step accordingly
0C4E    C3            3613     	CLR	C
0C4F    EF            3614     MOV A , R7 
0C50    9405          3615     	SUBB	A, #5
0C52    5018          3616     	JNC	STEPPER_STEP_HIGH
0C54    C3            3617     	CLR	C
0C55    EF            3618     MOV A , R7 
0C56    9404          3619     	SUBB	A, #4
0C58    5020          3620     	JNC	STEPPER_STEP_MED_HIGH
0C5A    C3            3621     	CLR	C
0C5B    EF            3622     MOV A , R7 
0C5C    9403          3623     	SUBB	A, #3
0C5E    5028          3624     	JNC	STEPPER_STEP_MED
0C60    C3            3625     	CLR	C
0C61    EF            3626     MOV A , R7 
0C62    9402          3627     	SUBB	A, #2
0C64    5030          3628     	JNC	STEPPER_STEP_MED_LOW
0C66    C3            3629     	CLR	C
0C67    EF            3630     MOV A , R7 
0C68    9401          3631     	SUBB	A, #1
0C6A    5038          3632     	JNC	STEPPER_STEP_LOW
                      3633     
                      3634     STEPPER_STEP_HIGH: 
0C6C    7533A0        3635     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C6F    75340F        3636     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C72    75353C        3637     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C75    753605        3638     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C78    81B0          3639     	AJMP	STEPPER_STEP_SET
                      3640     STEPPER_STEP_MED_HIGH: 
0C7A    7533C0        3641     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C7D    753412        3642     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C80    753540        3643     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C83    753606        3644     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C86    81B0          3645     	AJMP	STEPPER_STEP_SET
                      3646     STEPPER_STEP_MED: 
0C88    753370        3647     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C8B    753417        3648     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C8E    7535D0        3649     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C91    753607        3650     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C94    81B0          3651     	AJMP	STEPPER_STEP_SET
                      3652     STEPPER_STEP_MED_LOW: 
0C96    75334C        3653     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C99    75341D        3654     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C9C    7535C4        3655     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C9F    753609        3656     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CA2    81B0          3657     	AJMP	STEPPER_STEP_SET
                      3658     STEPPER_STEP_LOW: 
0CA4    753328        3659     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CA7    753423        3660     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CAA    7535B8        3661     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CAD    75360B        3662     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3663     
                      3664     STEPPER_STEP_SET: 
0CB0    853350        3665     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CB3    853451        3666     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CB6    753C00        3667     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CB9    753D08        3668     	MOV	COMM_PERIOD4X_H, #08H
0CBC    22            3669     	RET
                      3670     
                      3671     
                      3672     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3673     ;
                      3674     ; Calculate next commutation timing routine
                      3675     ;
                      3676     ; No assumptions
                      3677     ;
                      3678     ; Called immediately after each commutation
                      3679     ; Also sets up timer 3 to wait advance timing
                      3680     ; Two entry points are used
                      3681     ;
                      3682     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3683     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CBD    A850          3684     MOV R0 , WT_STEPPER_STEP_L 
0CBF    A951          3685     MOV R1 , WT_STEPPER_STEP_H 
0CC1    020CC8        3686     	JMP	READ_TIMER
                      3687     
                      3688     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CC4    A84A          3689     MOV R0 , WT_ADVANCE_L 
0CC6    A94B          3690     MOV R1 , WT_ADVANCE_H 
                      3691     READ_TIMER: 
                      3692     	; Set up next wait
0CC8    759100        3693     	MOV	TMR3CN, #00H		; Timer3 disabled
0CCB    C3            3694     	CLR	C
0CCC    E4            3695     	CLR	A
0CCD    98            3696     SUBB A , R0 
0CCE    F594          3697     	MOV	TMR3L, A
0CD0    E4            3698     	CLR	A
0CD1    99            3699     SUBB A , R1 
0CD2    F595          3700     	MOV	TMR3H, A
0CD4    759104        3701     	MOV	TMR3CN, #04H		; Timer3 enabled
0CD7    D258          3702     SETB FLAGS0 . 0 
                      3703     	; Read commutation time
0CD9    75C820        3704     	MOV	TMR2CN, #20H		; Timer2 disabled
0CDC    A8CC          3705     MOV R0 , TMR2L 
0CDE    A9CD          3706     MOV R1 , TMR2H 
0CE0    75C824        3707     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3708     	; Calculate this commutation time
0CE3    AA3A          3709     MOV R2 , PREV_COMM_L 
0CE5    AB3B          3710     MOV R3 , PREV_COMM_H 
0CE7    883A          3711     MOV PREV_COMM_L , R0 
0CE9    893B          3712     MOV PREV_COMM_H , R1 
0CEB    C3            3713     	CLR	C
0CEC    E8            3714     MOV A , R0 
0CED    9A            3715     SUBB A , R2 
0CEE    F8            3716     MOV R0 , A 
0CEF    E9            3717     MOV A , R1 
0CF0    9B            3718     SUBB A , R3 
0CF1    F9            3719     MOV R1 , A 
                      3720     	; Calculate next zero cross scan timeout 
0CF2    AA3C          3721     MOV R2 , COMM_PERIOD4X_L 
0CF4    AB3D          3722     MOV R3 , COMM_PERIOD4X_H 
0CF6    C3            3723     	CLR	C
0CF7    EB            3724     MOV A , R3 
0CF8    13            3725     	RRC	A					; Divide by 2
0CF9    FD            3726     MOV R5 , A 
0CFA    EA            3727     MOV A , R2 
0CFB    13            3728     	RRC	A
0CFC    FC            3729     MOV R4 , A 
0CFD    C3            3730     	CLR	C
0CFE    ED            3731     MOV A , R5 
0CFF    13            3732     	RRC	A					; Divide by 2 again
0D00    FD            3733     MOV R5 , A 
0D01    EC            3734     MOV A , R4 
0D02    13            3735     	RRC	A
0D03    FC            3736     MOV R4 , A 
0D04    C3            3737     	CLR	C
0D05    EA            3738     MOV A , R2 
0D06    9C            3739     SUBB A , R4 
0D07    FA            3740     MOV R2 , A 
0D08    EB            3741     MOV A , R3 
0D09    9D            3742     SUBB A , R5 
0D0A    FB            3743     MOV R3 , A 
                      3744     
0D0B    EA            3745     MOV A , R2 
0D0C    28            3746     ADD A , R0 
0D0D    FA            3747     MOV R2 , A 
0D0E    EB            3748     MOV A , R3 
0D0F    39            3749     ADDC A , R1 
0D10    FB            3750     MOV R3 , A 
0D11    8A3C          3751     MOV COMM_PERIOD4X_L , R2 
0D13    8B3D          3752     MOV COMM_PERIOD4X_H , R3 
0D15    4001          3753     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3754     
0D17    22            3755     	RET
                      3756     
                      3757     CALC_NEXT_COMM_SLOW: 
0D18    753CFF        3758     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D1B    753DFF        3759     	MOV	COMM_PERIOD4X_H, #0FFH
0D1E    22            3760     	RET
                      3761     
                      3762     
                      3763     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3764     ;
                      3765     ; Setup zero cross scan wait
                      3766     ;
                      3767     ; No assumptions
                      3768     ;
                      3769     ; Sets up timer 3 to wait the zero cross scan wait time
                      3770     ;
                      3771     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3772     SETUP_ZC_SCAN_WAIT: 
0D1F    759100        3773     	MOV	TMR3CN, #00H		; Timer3 disabled
0D22    C3            3774     	CLR	C
0D23    E4            3775     	CLR	A
0D24    954C          3776     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D26    F594          3777     	MOV	TMR3L, A
0D28    E4            3778     	CLR	A
0D29    954D          3779     	SUBB	A, WT_ZC_SCAN_H		
0D2B    F595          3780     	MOV	TMR3H, A
0D2D    759104        3781     	MOV	TMR3CN, #04H		; Timer3 enabled
0D30    D258          3782     SETB FLAGS0 . 0 
0D32    22            3783     	RET
                      3784     
                      3785     
                      3786     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3787     ;
                      3788     ; Wait advance timing routine
                      3789     ;
                      3790     ; No assumptions
                      3791     ;
                      3792     ; Waits for the advance timing to elapse, waits one zero cross
                      3793     ; wait and sets up the next zero cross wait
                      3794     ;
                      3795     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3796     WAIT_ADVANCE_TIMING: 	
0D33    7F01          3797     MOV R7 , # 1 
0D35    789C          3798     MOV R0 , # PGM_DEMAG_COMP 
0D37    E6            3799     MOV A , @ R0 
0D38    14            3800     	DEC	A
0D39    6002          3801     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      3802     
0D3B    7F02          3803     MOV R7 , # 2 
                      3804     
                      3805     WAIT_ADVANCE_TIMING_WAIT: 
0D3D    305802        3806     JNB FLAGS0 . 0 , ( $+5 ) 
0D40    A13D          3807     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      3808     
0D42    B11F          3809     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D44    DFF7          3810     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      3811     
0D46    22            3812     	RET
                      3813     
                      3814     
                      3815     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3816     ;
                      3817     ; Calculate new wait times routine
                      3818     ;
                      3819     ; No assumptions
                      3820     ;
                      3821     ; Calculates new wait times
                      3822     ;
                      3823     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3824     CALC_NEW_WAIT_TIMES: 	
                      3825     	; Load programmed commutation timing
0D47    7892          3826     MOV R0 , # PGM_COMM_TIMING 
0D49    E6            3827     MOV A , @ R0 
0D4A    FF            3828     MOV R7 , A 
0D4B    7E14          3829     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      3830     IF MODE == 2
0D4D    A83D          3831     MOV R0 , COMM_PERIOD4X_H 
0D4F    C3            3832     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D50    E8            3833     MOV A , R0 
0D51    9404          3834     	SUBB	A, #4
0D53    4002          3835     	JC	CALC_NEW_WAIT_RED_SET
                      3836     
0D55    7804          3837     MOV R0 , # 4 
                      3838     
                      3839     CALC_NEW_WAIT_RED_SET: 
0D57    C3            3840     	CLR	C
0D58    E8            3841     MOV A , R0 
0D59    33            3842     	RLC	A
0D5A    F8            3843     MOV R0 , A 
0D5B    C3            3844     	CLR	C
0D5C    EE            3845     MOV A , R6 
0D5D    98            3846     SUBB A , R0 
0D5E    FE            3847     MOV R6 , A 
                      3848     ENDIF
0D5F    306304        3849     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      3850     
0D62    7F03          3851     MOV R7 , # 3 
0D64    7E00          3852     MOV R6 , # 0 
                      3853     
                      3854     CALC_NEW_WAIT_DIR_START_SET: 
                      3855     	; Load current commutation timing
0D66    A93D          3856     MOV R1 , COMM_PERIOD4X_H 
0D68    A83C          3857     MOV R0 , COMM_PERIOD4X_L 
0D6A    7A04          3858     MOV R2 , # 4 
                      3859     DIVIDE_WAIT_TIMES: 
0D6C    C3            3860     	CLR	C
0D6D    E9            3861     MOV A , R1 
0D6E    13            3862     	RRC	A					; Divide by 2
0D6F    F9            3863     MOV R1 , A 
0D70    E8            3864     MOV A , R0 
0D71    13            3865     	RRC	A
0D72    F8            3866     MOV R0 , A 
0D73    DAF7          3867     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      3868     
0D75    C3            3869     	CLR	C
0D76    E8            3870     MOV A , R0 
0D77    9E            3871     SUBB A , R6 
0D78    F8            3872     MOV R0 , A 
0D79    E9            3873     MOV A , R1 
0D7A    9400          3874     	SUBB	A, #0
0D7C    F9            3875     MOV R1 , A 
0D7D    4009          3876     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      3877     
0D7F    C3            3878     	CLR	C
0D80    E8            3879     MOV A , R0 
0D81    9402          3880     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D83    E9            3881     MOV A , R1 
0D84    9400          3882     	SUBB	A, #0
0D86    5004          3883     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      3884     
                      3885     LOAD_MIN_TIME: 
0D88    7802          3886     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D8A    E4            3887     	CLR	A
0D8B    F9            3888     MOV R1 , A 
                      3889     
                      3890     ADJUST_TIMING: 
0D8C    E9            3891     MOV A , R1 
0D8D    FB            3892     MOV R3 , A 
0D8E    E8            3893     MOV A , R0 
0D8F    FA            3894     MOV R2 , A 
0D90    C3            3895     	CLR	C
0D91    E9            3896     MOV A , R1 
0D92    13            3897     	RRC	A					; Divide by 2
0D93    FD            3898     MOV R5 , A 
0D94    E8            3899     MOV A , R0 
0D95    13            3900     	RRC	A
0D96    FC            3901     MOV R4 , A 
0D97    C3            3902     	CLR	C
0D98    EF            3903     MOV A , R7 
0D99    9403          3904     	SUBB	A, #3				; Is timing normal?
0D9B    602E          3905     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      3906     
0D9D    EF            3907     MOV A , R7 
0D9E    20E00D        3908     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      3909     
0DA1    E8            3910     MOV A , R0 
0DA2    2C            3911     ADD A , R4 
0DA3    F8            3912     MOV R0 , A 
0DA4    E9            3913     MOV A , R1 
0DA5    3D            3914     ADDC A , R5 
0DA6    F9            3915     MOV R1 , A 
0DA7    EC            3916     MOV A , R4 
0DA8    FA            3917     MOV R2 , A 
0DA9    ED            3918     MOV A , R5 
0DAA    FB            3919     MOV R3 , A 
0DAB    020DB8        3920     	JMP	STORE_TIMES_UP_OR_DOWN
                      3921     
                      3922     ADJUST_TIMING_TWO_STEPS: 
0DAE    E8            3923     MOV A , R0 
0DAF    28            3924     ADD A , R0 
0DB0    F8            3925     MOV R0 , A 
0DB1    E9            3926     MOV A , R1 
0DB2    39            3927     ADDC A , R1 
0DB3    F9            3928     MOV R1 , A 
0DB4    7A02          3929     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DB6    E4            3930     	CLR	A
0DB7    FB            3931     MOV R3 , A 
                      3932     
                      3933     STORE_TIMES_UP_OR_DOWN: 
0DB8    C3            3934     	CLR	C
0DB9    EF            3935     MOV A , R7 
0DBA    9403          3936     	SUBB	A, #3				; Is timing higher than normal?
0DBC    400D          3937     	JC	STORE_TIMES_DECREASE	; No - branch
                      3938     
                      3939     STORE_TIMES_INCREASE: 
0DBE    8A4E          3940     MOV WT_COMM_L , R2 
0DC0    8B4F          3941     MOV WT_COMM_H , R3 
0DC2    884A          3942     MOV WT_ADVANCE_L , R0 
0DC4    894B          3943     MOV WT_ADVANCE_H , R1 
0DC6    8C4C          3944     MOV WT_ZC_SCAN_L , R4 
0DC8    8D4D          3945     MOV WT_ZC_SCAN_H , R5 
0DCA    22            3946     	RET
                      3947     
                      3948     STORE_TIMES_DECREASE: 
0DCB    884E          3949     MOV WT_COMM_L , R0 
0DCD    894F          3950     MOV WT_COMM_H , R1 
0DCF    8A4A          3951     MOV WT_ADVANCE_L , R2 
0DD1    8B4B          3952     MOV WT_ADVANCE_H , R3 
0DD3    8C4C          3953     MOV WT_ZC_SCAN_L , R4 
0DD5    8D4D          3954     MOV WT_ZC_SCAN_H , R5 
0DD7    22            3955     	RET
                      3956     
                      3957     
                      3958     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3959     ;
                      3960     ; Wait before zero cross scan routine
                      3961     ;
                      3962     ; No assumptions
                      3963     ;
                      3964     ; Waits for the zero cross scan wait time to elapse
                      3965     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      3966     ;
                      3967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3968     WAIT_BEFORE_ZC_SCAN: 	
0DD8    305802        3969     JNB FLAGS0 . 0 , ( $+5 ) 
0DDB    A1D8          3970     	AJMP	WAIT_BEFORE_ZC_SCAN
                      3971     
0DDD    759100        3972     	MOV	TMR3CN, #00H		; Timer3 disabled
0DE0    C3            3973     	CLR	C
0DE1    E4            3974     	CLR	A
0DE2    953C          3975     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DE4    F594          3976     	MOV	TMR3L, A
0DE6    E4            3977     	CLR	A
0DE7    953D          3978     	SUBB	A, COMM_PERIOD4X_H		
0DE9    F595          3979     	MOV	TMR3H, A
0DEB    759104        3980     	MOV	TMR3CN, #04H		; Timer3 enabled
0DEE    D258          3981     SETB FLAGS0 . 0 
0DF0    22            3982     	RET
                      3983     
                      3984     
                      3985     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3986     ;
                      3987     ; Wait for comparator to go low/high routines
                      3988     ;
                      3989     ; No assumptions
                      3990     ;
                      3991     ; Waits for the zero cross scan wait time to elapse
                      3992     ; Then scans for comparator going low/high
                      3993     ;
                      3994     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3995     WAIT_FOR_COMP_OUT_LOW: 
0DF1    753F00        3996     	MOV	COMP_WAIT_READS, #0
0DF4    752000        3997     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0DF7    020E00        3998     	JMP	WAIT_FOR_COMP_OUT_START
                      3999     
                      4000     WAIT_FOR_COMP_OUT_HIGH: 
0DFA    753F00        4001     	MOV	COMP_WAIT_READS, #0
0DFD    752040        4002     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4003     
                      4004     WAIT_FOR_COMP_OUT_START: 
0E00    D2AF          4005     	SETB	EA						; Enable interrupts
0E02    053F          4006     	INC	COMP_WAIT_READS
0E04    205801        4007     JB FLAGS0 . 0 , ( $+4 ) 
0E07    22            4008     	RET							; Yes - return
                      4009     
                      4010     	; Set default comparator response times
0E08    759D00        4011     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4012     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4015     	; Select number of comparator readings based upon current rotation speed
0E0B    E53D          4016     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E0D    C3            4017     	CLR	C
0E0E    13            4018     	RRC	A						; Divide by 4
0E0F    C3            4019     	CLR	C
0E10    13            4020     	RRC	A
0E11    F8            4021     MOV R0 , A 
0E12    08            4022     INC R0 
0E13    6030          4023     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4024     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E15    306A06        4025     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4026     
0E18    C3            4027     	CLR	C
0E19    13            4028     	RRC	A						; Divide by 4 again
0E1A    C3            4029     	CLR	C
0E1B    13            4030     	RRC	A
0E1C    F8            4031     MOV R0 , A 
0E1D    08            4032     INC R0 
                      4033     
                      4034     COMP_WAIT_SET_MAX_READINGS: 
0E1E    C3            4035     	CLR	C
0E1F    E8            4036     MOV A , R0 
0E20    940A          4037     	SUBB	A, #10
0E22    4002          4038     	JC	($+4)
                      4039     
0E24    780A          4040     MOV R0 , # 10 
                      4041     
0E26    306D08        4042     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4043     
0E29    C3            4044     	CLR	C
0E2A    E8            4045     MOV A , R0 
0E2B    9404          4046     	SUBB	A, #4
0E2D    4002          4047     	JC	($+4)
                      4048     
0E2F    7804          4049     MOV R0 , # 4 
                      4050     
                      4051     COMP_WAIT_SET_RESPONSE_TIME: 
0E31    C3            4052     	CLR	C
0E32    E53D          4053     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E34    9408          4054     	SUBB	A, #8
0E36    400D          4055     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4056     
0E38    759D02        4057     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4058     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E3B    C3            4061     	CLR	C
0E3C    E53D          4062     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E3E    9410          4063     	SUBB	A, #16
0E40    4003          4064     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4065     
0E42    759D03        4066     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4067     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4070     
                      4071     COMP_WAIT_ON_COMP_ABLE: 
0E45    205803        4072     JB FLAGS0 . 0 , ( $+6 ) 
0E48    D2AF          4073     	SETB	EA							; Enable interrupts
0E4A    22            4074     	RET								; Yes - return
                      4075     
0E4B    791E          4076     MOV R1 , # 30 
0E4D    206D02        4077     JB FLAGS2 . 5 , ( $+5 ) 
0E50    790A          4078     MOV R1 , # 10 
0E52    D2AF          4079     	SETB	EA							; Enable interrupts
0E54    00            4080     	NOP								; Allocate only just enough time to capture interrupt
0E55    00            4081     	NOP
0E56    C2AF          4082     	CLR	EA							; Disable interrupts
0E58    205A0A        4083     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4084     
0E5B    793C          4085     MOV R1 , # 60 
0E5D    206D02        4086     JB FLAGS2 . 5 , ( $+5 ) 
0E60    7914          4087     MOV R1 , # 20 
0E62    3066E0        4088     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4089     
                      4090     PWM_WAIT_STARTUP: 						
0E65    306302        4091     JNB FLAGS1 . 3 , PWM_WAIT 
                      4092     
0E68    7978          4093     MOV R1 , # 120 
                      4094     PWM_WAIT: 						
0E6A    C3            4095     	CLR	C
0E6B    E58B          4096     	MOV	A, TL1
0E6D    99            4097     SUBB A , R1 
                      4098     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E6E    40D5          4103     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4104     ENDIF
                      4105     
                      4106     COMP_READ: 
                      4107     	READ_COMP_OUT 					; Read comparator output
0E70    E59B          4107+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E72    F4            4108     	CPL	A
0E73    5440          4109     	ANL	A, #40H
0E75    B52002        4110     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4111     
0E78    C100          4112     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4113     
0E7A    D8C9          4114     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4115     
0E7C    D2AF          4116     	SETB	EA						; Enable interrupts
0E7E    22            4117     	RET							
                      4118     
                      4119     
                      4120     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4121     ;
                      4122     ; Evaluate comparator integrity
                      4123     ;
                      4124     ; No assumptions
                      4125     ;
                      4126     ; Checks comparator signal behaviour versus expected behaviour
                      4127     ;
                      4128     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4129     EVALUATE_COMPARATOR_INTEGRITY: 
0E7F    C25B          4130     CLR FLAGS0 . 3 
                      4131     	; Check if demag compensation is enabled
0E81    789C          4132     MOV R0 , # PGM_DEMAG_COMP 
0E83    E6            4133     MOV A , @ R0 
0E84    14            4134     	DEC	A
0E85    600A          4135     	JZ	EVAL_COMP_NO_DEMAG
                      4136     
                      4137     	; Check if a demag situation has occurred
0E87    E53F          4138     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E89    14            4139     	DEC	A
0E8A    7005          4140     	JNZ	EVAL_COMP_NO_DEMAG
                      4141     
0E8C    206302        4142     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4143     
0E8F    D25B          4144     SETB FLAGS0 . 3 
                      4145     
                      4146     EVAL_COMP_NO_DEMAG: 
0E91    30630B        4147     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4148     
0E94    0538          4149     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0E96    205810        4150     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4151     
0E99    753800        4152     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0E9C    020EA9        4153     	JMP	EVAL_COMP_EXIT
                      4154     
                      4155     EVAL_COMP_CHECK_TIMEOUT: 
0E9F    205807        4156     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EA2    1581          4157     	DEC	SP							; Routine exit without "ret" command
0EA4    1581          4158     	DEC	SP
0EA6    021830        4159     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4160     
                      4161     EVAL_COMP_EXIT: 
0EA9    22            4162     	RET
                      4163     
                      4164     
                      4165     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4166     ;
                      4167     ; Setup commutation timing routine
                      4168     ;
                      4169     ; No assumptions
                      4170     ;
                      4171     ; Sets up and starts wait from commutation to zero cross
                      4172     ;
                      4173     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4174     SETUP_COMM_WAIT:  
0EAA    759100        4175     	MOV	TMR3CN, #00H		; Timer3 disabled
0EAD    C3            4176     	CLR	C
0EAE    E4            4177     	CLR	A
0EAF    954E          4178     	SUBB	A, WT_COMM_L		; Set wait commutation value
0EB1    F594          4179     	MOV	TMR3L, A
0EB3    E4            4180     	CLR	A
0EB4    954F          4181     	SUBB	A, WT_COMM_H		
0EB6    F595          4182     	MOV	TMR3H, A
0EB8    759104        4183     	MOV	TMR3CN, #04H		; Timer3 enabled
0EBB    D258          4184     SETB FLAGS0 . 0 
0EBD    22            4185     	RET
                      4186     
                      4187     
                      4188     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4189     ;
                      4190     ; Wait for commutation routine
                      4191     ;
                      4192     ; No assumptions
                      4193     ;
                      4194     ; Waits from zero cross to commutation 
                      4195     ;
                      4196     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4197     WAIT_FOR_COMM:  
                      4198     	; Increment or reset consecutive count
0EBE    0539          4199     	INC	DEMAG_CONSECUTIVE_CNT
0EC0    205B03        4200     JB FLAGS0 . 3 , ( $+6 ) 
                      4201     
0EC3    753900        4202     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4203     
                      4204     	; Check if a demag situation has occurred
0EC6    305B23        4205     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4206     
                      4207     	; Load programmed demag compensation
0EC9    78A3          4208     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0ECB    E6            4209     MOV A , @ R0 
0ECC    FF            4210     MOV R7 , A 
                      4211     
                      4212     	; Check for power off
0ECD    BF0108        4213     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4214     
0ED0    D25C          4215     SETB FLAGS0 . 4 
                      4216     	ALL_NFETS_OFF
0ED2    C292          4216+1   CLR P1 . 2 
0ED4    C296          4216+1   CLR P1 . 6 
0ED6    C295          4216+1   CLR P1 . 5 
                      4217     
                      4218     	; Wait a blind wait
                      4219     WAIT_FOR_COMM_BLIND: 
0ED8    B11F          4220     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4221     WAIT_DEMAG_DEFAULT_ZC: 	
0EDA    305802        4222     JNB FLAGS0 . 0 , ( $+5 ) 
0EDD    C1DA          4223     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4224     
                      4225     	; Check for power off
0EDF    BF0208        4226     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4227     
0EE2    D25C          4228     SETB FLAGS0 . 4 
                      4229     	ALL_NFETS_OFF
0EE4    C292          4229+1   CLR P1 . 2 
0EE6    C296          4229+1   CLR P1 . 6 
0EE8    C295          4229+1   CLR P1 . 5 
                      4230     
                      4231     WAIT_FOR_COMM_SETUP: 
0EEA    D1AA          4232     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4233     WAIT_FOR_COMM_WAIT: 
0EEC    305802        4234     JNB FLAGS0 . 0 , ( $+5 ) 
0EEF    C1EC          4235     	AJMP	WAIT_FOR_COMM_WAIT					
                      4236     
0EF1    22            4237     	RET
                      4238     
                      4239     
                      4240     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4241     ;
                      4242     ; Commutation routines
                      4243     ;
                      4244     ; No assumptions
                      4245     ;
                      4246     ; Performs commutation switching 
                      4247     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4248     ;
                      4249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4250     COMM1COMM2: 	
0EF2    C2AF          4251     	CLR 	EA					; Disable all interrupts
                      4252     	BPFET_OFF					; Bp off
0EF4    C294          4252+1   CLR P1 . 4 
0EF6    206A03        4253     JB FLAGS2 . 2 , COMM12_DAMP 
0EF9    020F11        4254     	JMP	COMM12_NONDAMP
                      4255     COMM12_DAMP: 
                      4256     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4260     IF DAMPED_MODE_ENABLE == 1
0EFC    900347        4261     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4262     ENDIF
0EFF    30650F        4263     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4264     	CPFET_OFF				
0F02    207502        4264+1   JB FLAGS3 . 5 , ( $+5 ) 
0F05    C297          4264+1   CLR P1 . 7 
0F07    307502        4264+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F0A    C293          4264+1   CLR P1 . 3 
0F0C    7406          4265     MOV A , # 6 
0F0E    D5E0FD        4266     	DJNZ ACC,	$
                      4267     COMM12_NONDAMP: 
                      4268     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4276     	APFET_ON					; Ap on
0F11    207502        4276+1   JB FLAGS3 . 5 , ( $+5 ) 
0F14    D293          4276+1   SETB P1 . 3 
0F16    307502        4276+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F19    D297          4276+1   SETB P1 . 7 
                      4277     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F1B    759F80        4277+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F1E    753E02        4278     	MOV	COMM_PHASE, #2
0F21    02107C        4279     	JMP	COMM_EXIT
                      4280     
                      4281     COMM2COMM3: 	
0F24    C2AF          4282     	CLR 	EA					; Disable all interrupts
0F26    206A03        4283     JB FLAGS2 . 2 , COMM23_DAMP 
0F29    020F46        4284     	JMP	COMM23_NONDAMP
                      4285     COMM23_DAMP: 
                      4286     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4289     IF DAMPED_MODE_ENABLE == 1
0F2C    9002FE        4290     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4291     ENDIF
0F2F    306517        4292     JNB FLAGS1 . 5 , COMM23_NFET 
                      4293     	BPFET_OFF				
0F32    C294          4293+1   CLR P1 . 4 
                      4294     	CPFET_OFF				
0F34    207502        4294+1   JB FLAGS3 . 5 , ( $+5 ) 
0F37    C297          4294+1   CLR P1 . 7 
0F39    307502        4294+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F3C    C293          4294+1   CLR P1 . 3 
0F3E    7406          4295     MOV A , # 6 
0F40    D5E0FD        4296     	DJNZ ACC,	$
0F43    020F49        4297     	JMP	COMM23_NFET
                      4298     COMM23_NONDAMP: 
0F46    9001E1        4299     	MOV	DPTR, #PWM_BFET_ON	
                      4300     COMM23_NFET: 
                      4301     	CNFET_OFF					; Cn off
0F49    207502        4301+1   JB FLAGS3 . 5 , ( $+5 ) 
0F4C    C296          4301+1   CLR P1 . 6 
0F4E    307502        4301+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F51    C292          4301+1   CLR P1 . 2 
0F53    305A06        4302     JNB FLAGS0 . 2 , COMM23_CP 
                      4303     	BNFET_ON					; Yes - Bn on
0F56    E525          4303+1   MOV A , CURRENT_PWM_LIMITED 
0F58    6002          4303+1   JZ ( $+4 ) 
0F5A    D295          4303+1   SETB P1 . 5 
                      4304     COMM23_CP: 
                      4305     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F5C    207503        4305+1   JB FLAGS3 . 5 , ( $+6 ) 
0F5F    759F89        4305+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F62    307503        4305+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F65    759F81        4305+1   MOV CPT0MX , # 81H 
0F68    753E03        4306     	MOV	COMM_PHASE, #3
0F6B    02107C        4307     	JMP	COMM_EXIT
                      4308     
                      4309     COMM3COMM4: 	
0F6E    C2AF          4310     	CLR 	EA					; Disable all interrupts
                      4311     	APFET_OFF					; Ap off
0F70    207502        4311+1   JB FLAGS3 . 5 , ( $+5 ) 
0F73    C293          4311+1   CLR P1 . 3 
0F75    307502        4311+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F78    C297          4311+1   CLR P1 . 7 
0F7A    206A03        4312     JB FLAGS2 . 2 , COMM34_DAMP 
0F7D    020F8D        4313     	JMP	COMM34_NONDAMP
                      4314     COMM34_DAMP: 
                      4315     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4319     IF DAMPED_MODE_ENABLE == 1
0F80    9002BD        4320     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4321     ENDIF
0F83    306507        4322     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4323     	BPFET_OFF				
0F86    C294          4323+1   CLR P1 . 4 
0F88    7406          4324     MOV A , # 6 
0F8A    D5E0FD        4325     	DJNZ ACC,	$
                      4326     COMM34_NONDAMP: 
                      4327     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4335     	CPFET_ON					; Cp on
0F8D    207502        4335+1   JB FLAGS3 . 5 , ( $+5 ) 
0F90    D297          4335+1   SETB P1 . 7 
0F92    307502        4335+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F95    D293          4335+1   SETB P1 . 3 
                      4336     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F97    207503        4336+1   JB FLAGS3 . 5 , ( $+6 ) 
0F9A    759F81        4336+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F9D    307503        4336+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FA0    759F89        4336+1   MOV CPT0MX , # 89H 
0FA3    753E04        4337     	MOV	COMM_PHASE, #4
0FA6    02107C        4338     	JMP	COMM_EXIT
                      4339     
                      4340     COMM4COMM5: 	
0FA9    C2AF          4341     	CLR 	EA					; Disable all interrupts
0FAB    206A03        4342     JB FLAGS2 . 2 , COMM45_DAMP 
0FAE    020FCB        4343     	JMP	COMM45_NONDAMP
                      4344     COMM45_DAMP: 
                      4345     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4348     IF DAMPED_MODE_ENABLE == 1
0FB1    90027C        4349     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4350     ENDIF
0FB4    306517        4351     JNB FLAGS1 . 5 , COMM45_NFET 
                      4352     	APFET_OFF				
0FB7    207502        4352+1   JB FLAGS3 . 5 , ( $+5 ) 
0FBA    C293          4352+1   CLR P1 . 3 
0FBC    307502        4352+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FBF    C297          4352+1   CLR P1 . 7 
                      4353     	BPFET_OFF				
0FC1    C294          4353+1   CLR P1 . 4 
0FC3    7406          4354     MOV A , # 6 
0FC5    D5E0FD        4355     	DJNZ ACC,	$
0FC8    020FCE        4356     	JMP	COMM45_NFET
                      4357     COMM45_NONDAMP: 
0FCB    9001CF        4358     	MOV	DPTR, #PWM_AFET_ON
                      4359     COMM45_NFET: 
                      4360     	BNFET_OFF					; Bn off
0FCE    C295          4360+1   CLR P1 . 5 
0FD0    305A0E        4361     JNB FLAGS0 . 2 , COMM45_CP 
                      4362     	ANFET_ON					; Yes - An on
0FD3    E525          4362+1   MOV A , CURRENT_PWM_LIMITED 
0FD5    600A          4362+1   JZ ( $+12 ) 
0FD7    207502        4362+1   JB FLAGS3 . 5 , ( $+5 ) 
0FDA    D292          4362+1   SETB P1 . 2 
0FDC    307502        4362+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FDF    D296          4362+1   SETB P1 . 6 
                      4363     COMM45_CP: 
                      4364     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FE1    759F80        4364+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FE4    753E05        4365     	MOV	COMM_PHASE, #5
0FE7    02107C        4366     	JMP	COMM_EXIT
                      4367     
                      4368     COMM5COMM6: 	
0FEA    C2AF          4369     	CLR 	EA					; Disable all interrupts
                      4370     	CPFET_OFF					; Cp off
0FEC    207502        4370+1   JB FLAGS3 . 5 , ( $+5 ) 
0FEF    C297          4370+1   CLR P1 . 7 
0FF1    307502        4370+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF4    C293          4370+1   CLR P1 . 3 
0FF6    206A03        4371     JB FLAGS2 . 2 , COMM56_DAMP 
0FF9    021011        4372     	JMP	COMM56_NONDAMP
                      4373     COMM56_DAMP: 
                      4374     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4378     IF DAMPED_MODE_ENABLE == 1
0FFC    900233        4379     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4380     ENDIF
0FFF    30650F        4381     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4382     	APFET_OFF				
1002    207502        4382+1   JB FLAGS3 . 5 , ( $+5 ) 
1005    C293          4382+1   CLR P1 . 3 
1007    307502        4382+1   JNB FLAGS3 . 5 , ( $+5 ) 
100A    C297          4382+1   CLR P1 . 7 
100C    7406          4383     MOV A , # 6 
100E    D5E0FD        4384     	DJNZ ACC,	$
                      4385     COMM56_NONDAMP: 
                      4386     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4394     	BPFET_ON					; Bp on
1011    D294          4394+1   SETB P1 . 4 
                      4395     	SET_COMP_PHASE_C 			; Set comparator to phase C
1013    207503        4395+1   JB FLAGS3 . 5 , ( $+6 ) 
1016    759F89        4395+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1019    307503        4395+1   JNB FLAGS3 . 5 , ( $+6 ) 
101C    759F81        4395+1   MOV CPT0MX , # 81H 
101F    753E06        4396     	MOV	COMM_PHASE, #6
1022    02107C        4397     	JMP	COMM_EXIT
                      4398     
                      4399     COMM6COMM1: 	
1025    C2AF          4400     	CLR 	EA					; Disable all interrupts
1027    206A03        4401     JB FLAGS2 . 2 , COMM61_DAMP 
102A    02104F        4402     	JMP	COMM61_NONDAMP
                      4403     COMM61_DAMP: 
                      4404     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4407     IF DAMPED_MODE_ENABLE == 1
102D    9003A0        4408     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4409     ENDIF
1030    30651F        4410     JNB FLAGS1 . 5 , COMM61_NFET 
                      4411     	APFET_OFF				
1033    207502        4411+1   JB FLAGS3 . 5 , ( $+5 ) 
1036    C293          4411+1   CLR P1 . 3 
1038    307502        4411+1   JNB FLAGS3 . 5 , ( $+5 ) 
103B    C297          4411+1   CLR P1 . 7 
                      4412     	CPFET_OFF				
103D    207502        4412+1   JB FLAGS3 . 5 , ( $+5 ) 
1040    C297          4412+1   CLR P1 . 7 
1042    307502        4412+1   JNB FLAGS3 . 5 , ( $+5 ) 
1045    C293          4412+1   CLR P1 . 3 
1047    7406          4413     MOV A , # 6 
1049    D5E0FD        4414     	DJNZ ACC,	$
104C    021052        4415     	JMP	COMM61_NFET
                      4416     COMM61_NONDAMP: 
104F    9001F3        4417     	MOV	DPTR, #PWM_CFET_ON
                      4418     COMM61_NFET: 
                      4419     	ANFET_OFF					; An off
1052    207502        4419+1   JB FLAGS3 . 5 , ( $+5 ) 
1055    C292          4419+1   CLR P1 . 2 
1057    307502        4419+1   JNB FLAGS3 . 5 , ( $+5 ) 
105A    C296          4419+1   CLR P1 . 6 
105C    305A0E        4420     JNB FLAGS0 . 2 , COMM61_CP 
                      4421     	CNFET_ON					; Yes - Cn on
105F    E525          4421+1   MOV A , CURRENT_PWM_LIMITED 
1061    600A          4421+1   JZ ( $+12 ) 
1063    207502        4421+1   JB FLAGS3 . 5 , ( $+5 ) 
1066    D296          4421+1   SETB P1 . 6 
1068    307502        4421+1   JNB FLAGS3 . 5 , ( $+5 ) 
106B    D292          4421+1   SETB P1 . 2 
                      4422     COMM61_CP: 
                      4423     	SET_COMP_PHASE_A 			; Set comparator to phase A
106D    207503        4423+1   JB FLAGS3 . 5 , ( $+6 ) 
1070    759F81        4423+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1073    307503        4423+1   JNB FLAGS3 . 5 , ( $+6 ) 
1076    759F89        4423+1   MOV CPT0MX , # 89H 
1079    753E01        4424     	MOV	COMM_PHASE, #1
                      4425     
                      4426     COMM_EXIT: 
107C    D2AF          4427     	SETB	EA					; Enable all interrupts
107E    789C          4428     MOV R0 , # PGM_DEMAG_COMP 
1080    E6            4429     MOV A , @ R0 
1081    C3            4430     	CLR	C
1082    9402          4431     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
1084    4007          4432     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4433     
1086    C3            4434     	CLR	C
1087    E539          4435     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1089    9403          4436     	SUBB	A, #3
108B    5002          4437     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4438     
                      4439     COMM_RESTORE_POWER: 
108D    C25C          4440     CLR FLAGS0 . 4 
                      4441     
                      4442     COMM_RETURN: 
108F    22            4443     	RET
                      4444     
                      4445     
                      4446     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4447     ;
                      4448     ; Switch power off routine
                      4449     ;
                      4450     ; No assumptions
                      4451     ;
                      4452     ; Switches all fets off 
                      4453     ;
                      4454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4455     SWITCH_POWER_OFF: 
1090    9001CD        4456     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4457     	ALL_NFETS_OFF			; Turn off all nfets
1093    C292          4457+1   CLR P1 . 2 
1095    C296          4457+1   CLR P1 . 6 
1097    C295          4457+1   CLR P1 . 5 
                      4458     	ALL_PFETS_OFF			; Turn off all pfets
1099    C293          4458+1   CLR P1 . 3 
109B    C297          4458+1   CLR P1 . 7 
109D    C294          4458+1   CLR P1 . 4 
109F    C25A          4459     CLR FLAGS0 . 2 
10A1    22            4460     	RET			
                      4461     
                      4462     
                      4463     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4464     ;
                      4465     ; Decrement stepper step routine
                      4466     ;
                      4467     ; No assumptions
                      4468     ;
                      4469     ; Decrements the stepper step 
                      4470     ;
                      4471     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4472     DECREMENT_STEPPER_STEP: 
10A2    C3            4473     	CLR	C
10A3    E550          4474     	MOV	A, WT_STEPPER_STEP_L
10A5    9535          4475     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
10A7    E551          4476     	MOV	A, WT_STEPPER_STEP_H
10A9    9536          4477     	SUBB	A, STEPPER_STEP_END_H	
10AB    5001          4478     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
10AD    22            4479     	RET
                      4480     
                      4481     DECREMENT_STEP: 
                      4482     	; Load programmed startup acceleration
10AE    7890          4483     MOV R0 , # PGM_STARTUP_ACCEL 
10B0    E6            4484     MOV A , @ R0 
10B1    FF            4485     MOV R7 , A 
                      4486     	; Check acceleration setting and set step size accordingly
10B2    C3            4487     	CLR	C
10B3    EF            4488     MOV A , R7 
10B4    9405          4489     	SUBB	A, #5
10B6    5018          4490     	JNC	DEC_STEP_HIGH
10B8    C3            4491     	CLR	C
10B9    EF            4492     MOV A , R7 
10BA    9404          4493     	SUBB	A, #4
10BC    501B          4494     	JNC	DEC_STEP_MED_HIGH
10BE    C3            4495     	CLR	C
10BF    EF            4496     MOV A , R7 
10C0    9403          4497     	SUBB	A, #3
10C2    501E          4498     	JNC	DEC_STEP_MED
10C4    C3            4499     	CLR	C
10C5    EF            4500     MOV A , R7 
10C6    9402          4501     	SUBB	A, #2
10C8    5021          4502     	JNC	DEC_STEP_MED_LOW
10CA    C3            4503     	CLR	C
10CB    EF            4504     MOV A , R7 
10CC    9401          4505     	SUBB	A, #1
10CE    5024          4506     	JNC	DEC_STEP_LOW
                      4507     
                      4508     DEC_STEP_HIGH: 
10D0    C3            4509     	CLR	C
10D1    E550          4510     	MOV	A, WT_STEPPER_STEP_L
10D3    943C          4511     	SUBB	A, #LOW(30 SHL 1)		
10D5    F8            4512     MOV R0 , A 
10D6    0210FD        4513     	JMP	DECREMENT_STEP_EXIT
                      4514     DEC_STEP_MED_HIGH: 
10D9    C3            4515     	CLR	C
10DA    E550          4516     	MOV	A, WT_STEPPER_STEP_L
10DC    9428          4517     	SUBB	A, #LOW(20 SHL 1)		
10DE    F8            4518     MOV R0 , A 
10DF    0210FD        4519     	JMP	DECREMENT_STEP_EXIT
                      4520     DEC_STEP_MED: 
10E2    C3            4521     	CLR	C
10E3    E550          4522     	MOV	A, WT_STEPPER_STEP_L
10E5    941A          4523     	SUBB	A, #LOW(13 SHL 1)		
10E7    F8            4524     MOV R0 , A 
10E8    0210FD        4525     	JMP	DECREMENT_STEP_EXIT
                      4526     DEC_STEP_MED_LOW: 
10EB    C3            4527     	CLR	C
10EC    E550          4528     	MOV	A, WT_STEPPER_STEP_L
10EE    9412          4529     	SUBB	A, #LOW(9 SHL 1)		
10F0    F8            4530     MOV R0 , A 
10F1    0210FD        4531     	JMP	DECREMENT_STEP_EXIT
                      4532     DEC_STEP_LOW: 
10F4    C3            4533     	CLR	C
10F5    E550          4534     	MOV	A, WT_STEPPER_STEP_L
10F7    940A          4535     	SUBB	A, #LOW(5 SHL 1)		
10F9    F8            4536     MOV R0 , A 
10FA    0210FD        4537     	JMP	DECREMENT_STEP_EXIT
                      4538     
                      4539     DECREMENT_STEP_EXIT: 
10FD    E551          4540     	MOV	A, WT_STEPPER_STEP_H
10FF    9400          4541     	SUBB	A, #0		
1101    F9            4542     MOV R1 , A 
1102    8850          4543     MOV WT_STEPPER_STEP_L , R0 
1104    8951          4544     MOV WT_STEPPER_STEP_H , R1 
1106    22            4545     	RET
                      4546     
                      4547     
                      4548     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4549     ;
                      4550     ; Stepper timer wait
                      4551     ;
                      4552     ; No assumptions
                      4553     ;
                      4554     ; Waits for the stepper step timer to elapse
                      4555     ;
                      4556     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4557     STEPPER_TIMER_WAIT: 
1107    305802        4558     JNB FLAGS0 . 0 , ( $+5 ) 
110A    2107          4559     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
110C    22            4560     	RET
                      4561     
                      4562     
                      4563     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4564     ;
                      4565     ; Set default parameters
                      4566     ;
                      4567     ; No assumptions
                      4568     ;
                      4569     ; Sets default programming parameters
                      4570     ;
                      4571     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4572     SET_DEFAULT_PARAMETERS: 
                      4573     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4634     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4695     IF MODE == 2	; Multi
110D    7880          4696     MOV R0 , # PGM_GOV_P_GAIN 
110F    7609          4697     MOV @ R0 , # 9 
1111    08            4698     INC R0 
1112    7609          4699     MOV @ R0 , # 9 
1114    08            4700     INC R0 
1115    7604          4701     MOV @ R0 , # 4 
1117    08            4702     INC R0 
1118    7601          4703     MOV @ R0 , # 1 
111A    08            4704     INC R0 
111B    7603          4705     MOV @ R0 , # 3 
111D    08            4706     INC R0 
111E    76FF          4707     MOV @ R0 , # 0XFF 
1120    08            4708     INC R0 
1121    7609          4709     MOV @ R0 , # 9 
1123    08            4710     INC R0 
1124    7601          4711     MOV @ R0 , # 1 
1126    08            4712     INC R0 
1127    7601          4713     MOV @ R0 , # 1 
1129    08            4714     INC R0 
112A    7601          4715     MOV @ R0 , # 1 
                      4716     
112C    788C          4717     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
112E    7600          4718     MOV @ R0 , # 0 
1130    08            4719     INC R0 
1131    76FF          4720     MOV @ R0 , # 0XFF 
1133    08            4721     INC R0 
1134    76FF          4722     MOV @ R0 , # 0XFF 
1136    08            4723     INC R0 
1137    7601          4724     MOV @ R0 , # 1 
1139    08            4725     INC R0 
113A    7605          4726     MOV @ R0 , # 5 
113C    08            4727     INC R0 
113D    76FF          4728     MOV @ R0 , # 0XFF 
113F    08            4729     INC R0 
1140    7603          4730     MOV @ R0 , # 3 
1142    08            4731     INC R0 
1143    7606          4732     MOV @ R0 , # 6 
1145    08            4733     INC R0 
1146    76FF          4734     MOV @ R0 , # 0XFF 
1148    08            4735     INC R0 
1149    7602          4736     MOV @ R0 , # 2 
114B    08            4737     INC R0 
114C    7603          4738     MOV @ R0 , # 3 
114E    08            4739     INC R0 
114F    76FA          4740     MOV @ R0 , # 250 
1151    08            4741     INC R0 
1152    7628          4742     MOV @ R0 , # 40 
1154    08            4743     INC R0 
1155    7628          4744     MOV @ R0 , # 40 
1157    08            4745     INC R0 
1158    7605          4746     MOV @ R0 , # 5 
115A    08            4747     INC R0 
115B    760D          4748     MOV @ R0 , # 13 
115D    08            4749     INC R0 
115E    7602          4750     MOV @ R0 , # 2 
1160    08            4751     INC R0 
1161    7600          4752     MOV @ R0 , # 0 
1163    08            4753     INC R0 
1164    767D          4754     MOV @ R0 , # 125 
                      4755     ENDIF
1166    22            4756     	RET
                      4757     
                      4758     
                      4759     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4760     ;
                      4761     ; Decode parameters
                      4762     ;
                      4763     ; No assumptions
                      4764     ;
                      4765     ; Decodes programming parameters
                      4766     ;
                      4767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4768     DECODE_PARAMETERS: 
                      4769     	; Load programmed damping force
1167    7893          4770     MOV R0 , # PGM_DAMPING_FORCE 
1169    E6            4771     MOV A , @ R0 
116A    FF            4772     MOV R7 , A 
                      4773     	; Decode damping
116B    756609        4774     	MOV	DAMPING_PERIOD, #9		; Set default
116E    756701        4775     	MOV	DAMPING_ON, #1
1171    C3            4776     	CLR	C
1172    BF0206        4777     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      4778     
1175    756605        4779     	MOV	DAMPING_PERIOD, #5
1178    756701        4780     	MOV	DAMPING_ON, #1
                      4781     
                      4782     DECODE_DAMPING_3: 
117B    C3            4783     	CLR	C
117C    BF0306        4784     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      4785     
117F    756605        4786     	MOV	DAMPING_PERIOD, #5
1182    756702        4787     	MOV	DAMPING_ON, #2
                      4788     
                      4789     DECODE_DAMPING_4: 
1185    C3            4790     	CLR	C
1186    BF0406        4791     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      4792     
1189    756605        4793     	MOV	DAMPING_PERIOD, #5
118C    756703        4794     	MOV	DAMPING_ON, #3
                      4795     
                      4796     DECODE_DAMPING_5: 
118F    C3            4797     	CLR	C
1190    BF0506        4798     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      4799     
1193    756609        4800     	MOV	DAMPING_PERIOD, #9
1196    756707        4801     	MOV	DAMPING_ON, #7
                      4802     
                      4803     DECODE_DAMPING_6: 
1199    C3            4804     	CLR	C
119A    BF0606        4805     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      4806     
119D    756600        4807     	MOV	DAMPING_PERIOD, #0
11A0    756700        4808     	MOV	DAMPING_ON, #0
                      4809     
                      4810     DECODE_DAMPING_DONE: 
                      4811     	; Load programmed pwm frequency
11A3    7887          4812     MOV R0 , # PGM_PWM_FREQ 
11A5    E6            4813     MOV A , @ R0 
11A6    FF            4814     MOV R7 , A 
                      4815     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      4822     IF MODE >= 1	; Tail or multi
11A7    C26C          4823     CLR FLAGS2 . 4 
11A9    C3            4824     	CLR	C
11AA    BF0302        4825     CJNE R7 , # 3 , ( $+5 ) 
11AD    D26C          4826     SETB FLAGS2 . 4 
11AF    C26B          4827     CLR FLAGS2 . 3 
11B1    C3            4828     	CLR	C
11B2    BF0402        4829     CJNE R7 , # 4 , ( $+5 ) 
11B5    D26B          4830     SETB FLAGS2 . 3 
                      4831     ENDIF
11B7    C26A          4832     CLR FLAGS2 . 2 
11B9    7418          4833     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11BB    552D          4834     	ANL	A, FLAGS2					; Check if any damped mode is set
11BD    6002          4835     	JZ	($+4)
11BF    D26A          4836     SETB FLAGS2 . 2 
11C1    C265          4837     CLR FLAGS1 . 5 
11C3    6002          4838     	JZ	($+4)
11C5    D265          4839     SETB FLAGS1 . 5 
11C7    D266          4840     SETB FLAGS1 . 6 
11C9    6002          4841     	JZ	($+4)
11CB    C266          4842     CLR FLAGS1 . 6 
                      4843     	; Load programmed direction
11CD    7888          4844     MOV R0 , # PGM_DIRECTION 
                      4845     IF MODE >= 1	; Tail or multi
11CF    E6            4846     MOV A , @ R0 
11D0    C3            4847     	CLR	C
11D1    9403          4848     	SUBB	A, #3
11D3    6008          4849     	JZ	DECODE_PARAMS_DIR_SET
                      4850     ENDIF
                      4851     
11D5    C275          4852     CLR FLAGS3 . 5 
11D7    E6            4853     MOV A , @ R0 
11D8    30E102        4854     	JNB	ACC.1, ($+5)
11DB    D275          4855     SETB FLAGS3 . 5 
                      4856     DECODE_PARAMS_DIR_SET: 
11DD    C276          4857     CLR FLAGS3 . 6 
11DF    7889          4858     MOV R0 , # PGM_INPUT_POL 
11E1    E6            4859     MOV A , @ R0 
11E2    30E102        4860     	JNB	ACC.1, ($+5)
11E5    D276          4861     SETB FLAGS3 . 6 
11E7    C3            4862     	CLR	C
11E8    EF            4863     MOV A , R7 
11E9    9402          4864     	SUBB	A, #2
11EB    6008          4865     	JZ	DECODE_PWM_FREQ_LOW
                      4866     
11ED    758E01        4867     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
11F0    D26D          4868     SETB FLAGS2 . 5 
11F2    0211FA        4869     	JMP	DECODE_PWM_FREQ_END
                      4870     
                      4871     DECODE_PWM_FREQ_LOW: 
11F5    758E00        4872     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
11F8    C26D          4873     CLR FLAGS2 . 5 
                      4874     
                      4875     DECODE_PWM_FREQ_END: 
11FA    22            4876     	RET
                      4877     
                      4878     
                      4879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4880     ;
                      4881     ; Decode governor gain
                      4882     ;
                      4883     ; No assumptions
                      4884     ;
                      4885     ; Decodes governor gains
                      4886     ;
                      4887     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4888     DECODE_GOVERNOR_GAINS: 
                      4889     	; Decode governor gains
11FB    7880          4890     MOV R0 , # PGM_GOV_P_GAIN 
11FD    E6            4891     MOV A , @ R0 
11FE    14            4892     	DEC	A	
11FF    900080        4893     	MOV	DPTR, #GOV_GAIN_TABLE
1202    93            4894     	MOVC A, @A+DPTR	
1203    789F          4895     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1205    F6            4896     MOV @ R0 , A 
1206    7881          4897     MOV R0 , # PGM_GOV_I_GAIN 
1208    E6            4898     MOV A , @ R0 
1209    14            4899     	DEC	A	
120A    900080        4900     	MOV	DPTR, #GOV_GAIN_TABLE
120D    93            4901     	MOVC A, @A+DPTR	
120E    78A0          4902     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1210    F6            4903     MOV @ R0 , A 
1211    1190          4904     	CALL	SWITCH_POWER_OFF		; Reset DPTR
1213    22            4905     	RET
                      4906     
                      4907     
                      4908     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4909     ;
                      4910     ; Decode throttle rate
                      4911     ;
                      4912     ; No assumptions
                      4913     ;
                      4914     ; Decodes throttle rate
                      4915     ;
                      4916     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4917     DECODE_THROTTLE_RATE: 
                      4918     	; Decode throttle rate
1214    789B          4919     MOV R0 , # PGM_THROTTLE_RATE 
1216    E6            4920     MOV A , @ R0 
1217    14            4921     	DEC	A	
1218    90008D        4922     	MOV	DPTR, #THROTTLE_RATE_TABLE
121B    93            4923     	MOVC A, @A+DPTR	
121C    78A1          4924     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
121E    F6            4925     MOV @ R0 , A 
121F    1190          4926     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1221    22            4927     	RET
                      4928     
                      4929     
                      4930     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4931     ;
                      4932     ; Decode startup power
                      4933     ;
                      4934     ; No assumptions
                      4935     ;
                      4936     ; Decodes startup power
                      4937     ;
                      4938     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4939     DECODE_STARTUP_POWER: 
                      4940     	; Decode startup power
1222    7886          4941     MOV R0 , # PGM_STARTUP_PWR 
1224    E6            4942     MOV A , @ R0 
1225    14            4943     	DEC	A	
1226    90009A        4944     	MOV	DPTR, #STARTUP_POWER_TABLE
1229    93            4945     	MOVC A, @A+DPTR	
122A    78A2          4946     MOV R0 , # PGM_STARTUP_PWR_DECODED 
122C    F6            4947     MOV @ R0 , A 
122D    1190          4948     	CALL	SWITCH_POWER_OFF			; Reset DPTR
122F    22            4949     	RET
                      4950     
                      4951     
                      4952     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4953     ;
                      4954     ; Decode demag compensation
                      4955     ;
                      4956     ; No assumptions
                      4957     ;
                      4958     ; Decodes throttle rate
                      4959     ;
                      4960     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4961     DECODE_DEMAG_COMP: 
                      4962     	; Decode demag compensation
1230    789C          4963     MOV R0 , # PGM_DEMAG_COMP 
1232    E6            4964     MOV A , @ R0 
1233    14            4965     	DEC	A	
1234    9000A7        4966     	MOV	DPTR, #DEMAG_POWER_TABLE
1237    93            4967     	MOVC A, @A+DPTR	
1238    78A3          4968     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
123A    F6            4969     MOV @ R0 , A 
123B    1190          4970     	CALL	SWITCH_POWER_OFF			; Reset DPTR
123D    22            4971     	RET
                      4972     
                      4973     
                      4974     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4975     ;
                      4976     ; Set BEC voltage
                      4977     ;
                      4978     ; No assumptions
                      4979     ;
                      4980     ; Sets the BEC output voltage low or high
                      4981     ;
                      4982     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4983     SET_BEC_VOLTAGE: 
                      4984     	; Set bec voltage
                      4985     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
123E    22            4995     	RET
                      4996     
                      4997     
                      4998     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4999     ;
                      5000     ; Find throttle gain
                      5001     ;
                      5002     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5003     ;
                      5004     ; Finds throttle gain from throttle calibration values
                      5005     ;
                      5006     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5007     FIND_THROTTLE_GAIN: 
                      5008     	; Load programmed minimum and maximum throttle
123F    7896          5009     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1241    E6            5010     MOV A , @ R0 
1242    FA            5011     MOV R2 , A 
1243    7897          5012     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1245    E6            5013     MOV A , @ R0 
1246    FB            5014     MOV R3 , A 
                      5015     	; Check if full range is chosen
1247    307704        5016     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5017     
124A    7A00          5018     MOV R2 , # 0 
124C    7BFF          5019     MOV R3 , # 255 
                      5020     
                      5021     FIND_THROTTLE_GAIN_CALCULATE: 
                      5022     	; Calculate difference
124E    C3            5023     	CLR	C
124F    EB            5024     MOV A , R3 
1250    9A            5025     SUBB A , R2 
1251    FC            5026     MOV R4 , A 
                      5027     	; Check that difference is minimum 130
1252    C3            5028     	CLR	C
1253    9482          5029     	SUBB	A, #130
1255    5002          5030     	JNC	($+4)
                      5031     
1257    7C82          5032     MOV R4 , # 130 
                      5033     
                      5034     	; Find gain
1259    756E00        5035     	MOV	PPM_THROTTLE_GAIN, #0
                      5036     TEST_THROTTLE_GAIN: 
125C    056E          5037     	INC	PPM_THROTTLE_GAIN
125E    EC            5038     MOV A , R4 
125F    856EF0        5039     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1262    A4            5040     	MUL	AB
1263    C3            5041     	CLR	C
1264    E5F0          5042     	MOV	A, B
1266    9480          5043     	SUBB	A, #128
1268    40F2          5044     	JC	TEST_THROTTLE_GAIN
126A    22            5045     	RET
                      5046     
                      5047     
                      5048     
                      5049     
                      5050     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5051     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5052     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5053     ;
                      5054     ; Main program start
                      5055     ;
                      5056     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5057     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5058     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5059     
                      5060     RESET: 
                      5061     	; Check flash lock byte
126B    E5EF          5062     	MOV	A, RSTSRC			
126D    20E603        5063     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5064     
1270    752000        5065     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5066     
1273    0520          5067     	INC	BIT_ACCESS
1275    903FFF        5068     MOV DPTR , # 16383 
1278    E520          5069     	MOV	A, BIT_ACCESS
127A    14            5070     	DEC	A
127B    6006          5071     	JZ	LOCK_BYTE_TEST
                      5072     
127D    901FFF        5073     MOV DPTR , # 8191 
1280    14            5074     	DEC	A
1281    6000          5075     	JZ	LOCK_BYTE_TEST
                      5076     
                      5077     LOCK_BYTE_TEST: 
1283    93            5078     	MOVC A, @A+DPTR		; Read lock byte
1284    04            5079     	INC	A				
1285    6003          5080     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5081     
                      5082     IF ONE_S_CAPABLE == 0		
1287    75EF12        5083     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5084     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5087     
                      5088     LOCK_BYTE_OK: 
                      5089     	; Select register bank 0 for main program routines
128A    C2D3          5090     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5091     	; Disable the WDT.
128C    53D9BF        5092     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5093     	; Initialize stack
128F    7581C0        5094     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5095     	; Initialize VDD monitor
1292    43FF80        5096     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1295    1207EB        5097     	CALL	WAIT1MS			; Wait at least 100us
                      5098     IF ONE_S_CAPABLE == 0		
1298    75EF02        5099     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5100     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5103     	; Set clock frequency
129B    43B203        5104     	ORL	OSCICN, #03H		; Set clock divider to 1
129E    E5B3          5105     	MOV	A, OSCICL				
12A0    2404          5106     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
12A2    4002          5107     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5108     
12A4    F5B3          5109     	MOV	OSCICL, A
                      5110     
                      5111     RESET_CAL_DONE: 
                      5112     	; Switch power off
12A6    1190          5113     	CALL	SWITCH_POWER_OFF
                      5114     	; Ports initialization
12A8    7580FF        5115     MOV P0 , # 255 
12AB    75A400        5116     MOV P0MDOUT , # 0 
12AE    75F1F0        5117     MOV P0MDIN , # -16 
12B1    75D4DF        5118     MOV P0SKIP , # -33 
12B4    759002        5119     MOV P1 , # 2 
12B7    75A5FC        5120     MOV P1MDOUT , # 252 
12BA    75F2FD        5121     MOV P1MDIN , # -3 
12BD    75D502        5122     MOV P1SKIP , # 2 
                      5123     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12C0    75A610        5126     MOV P2MDOUT , # 16 
                      5127     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5134     	; Initialize the XBAR and related functionality
                      5135     	INITIALIZE_XBAR		
12C3    75A0FF        5135+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12C6    75F3F1        5135+1   MOV P2MDIN , # -15 
12C9    75E241        5135+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5136     	; Clear RAM
12CC    E4            5137     	CLR	A				; Clear accumulator
12CD    F8            5138     MOV R0 , A 
                      5139     CLEAR_RAM: 	
12CE    F6            5140     MOV @ R0 , A 
12CF    D8FD          5141     DJNZ R0 , CLEAR_RAM 
                      5142     	; Set default programmed parameters
12D1    310D          5143     	CALL	SET_DEFAULT_PARAMETERS
                      5144     	; EEPROM 还原为默认值
12D3    1218A9        5145     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      5146     	; Decode parameters
12D6    3167          5147     	CALL	DECODE_PARAMETERS
                      5148     	; Decode governor gains
12D8    31FB          5149     	CALL	DECODE_GOVERNOR_GAINS
                      5150     	; Decode throttle rate
12DA    5114          5151     	CALL	DECODE_THROTTLE_RATE
                      5152     	; Decode startup power
12DC    5122          5153     	CALL	DECODE_STARTUP_POWER
                      5154     	; Decode demag compensation
12DE    5130          5155     	CALL	DECODE_DEMAG_COMP
                      5156     	; Set BEC voltage
12E0    513E          5157     	CALL	SET_BEC_VOLTAGE
                      5158     	; Find throttle gain from stored min and max settings
12E2    513F          5159     	CALL	FIND_THROTTLE_GAIN
                      5160     	; Set beep strength
12E4    7898          5161     MOV R0 , # PGM_BEEP_STRENGTH 
12E6    866F          5162     MOV BEEP_STRENGTH , @ R0 
                      5163     	; Switch power off
12E8    1190          5164     	CALL	SWITCH_POWER_OFF
                      5165     	; Timer control
12EA    758850        5166     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5167     	; Timer mode
12ED    758902        5168     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5169     	; Timer2: clk/12 for 128us and 32ms interrupts
12F0    75C824        5170     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5171     	; Timer3: clk/12 for commutation timing
12F3    759104        5172     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5173     	; PCA
12F6    75D840        5174     	MOV	PCA0CN, #40H		; PCA enabled
                      5175     	; Initializing beep
12F9    C2AF          5176     	CLR	EA				; Disable interrupts explicitly
12FB    120804        5177     	CALL WAIT200MS	
12FE    120814        5178     	CALL BEEP_F1
1301    1207FA        5179     	CALL WAIT30MS
1304    12081B        5180     	CALL BEEP_F2
1307    1207FA        5181     	CALL WAIT30MS
130A    120822        5182     	CALL BEEP_F3
130D    1207FA        5183     	CALL WAIT30MS
                      5184     
                      5185     	; Wait for receiver to initialize
1310    121CB8        5186     	CALL	WAIT1S
1313    120804        5187     	CALL	WAIT200MS
1316    120804        5188     	CALL	WAIT200MS
1319    1207FF        5189     	CALL	WAIT100MS
                      5190     
                      5191     	; Enable interrupts
131C    75A822        5192     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
131F    75B802        5193     	MOV	IP, #02H			; High priority to timer0 interrupts
1322    75E690        5194     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5195     	; Initialize comparator
1325    759B80        5196     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1328    759D03        5197     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5198     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5202     	; Initialize ADC
                      5203     	INITIALIZE_ADC			; Initialize ADC operation
132B    75D10E        5203+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
132E    75BC58        5203+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1331    75BB09        5203+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1334    75BA11        5203+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1337    75E880        5203+1   MOV ADC0CN , # 80H  ; ADC ENABLED
133A    1207EB        5204     	CALL	WAIT1MS
133D    D2AF          5205     	SETB	EA				; Enable all interrupts
                      5206     	; Measure number of lipo cells
133F    120ACC        5207     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5208     	; Initialize rc pulse
                      5209     	RCP_INT_ENABLE		 			; Enable interrupt
1342    43DA01        5209+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5210     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1345    C2D8          5210+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1347    C269          5211     CLR FLAGS2 . 1 
1349    120804        5212     	CALL WAIT200MS
                      5213     	; Set initial arm variable
134C    753001        5214     	MOV	INITIAL_ARM, #1
                      5215     
                      5216     	; Measure PWM frequency
                      5217     MEASURE_PWM_FREQ_INIT: 	
134F    D259          5218     SETB FLAGS0 . 1 
                      5219     MEASURE_PWM_FREQ_START: 	
1351    7A05          5220     MOV R2 , # 5 
                      5221     MEASURE_PWM_FREQ_LOOP: 	
                      5222     	; Check if period diff was accepted
1353    E558          5223     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1355    7002          5224     	JNZ	($+4)
                      5225     
1357    7A05          5226     MOV R2 , # 5 
                      5227     
1359    1207F0        5228     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
135C    E559          5229     	MOV	A, NEW_RCP					; Load value
135E    C3            5230     	CLR	C
135F    9402          5231     SUBB A , # 2 
1361    40EE          5232     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5233     
1363    E52E          5234     	MOV	A, FLAGS3						; Check pwm frequency flags
1365    541F          5235     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1367    855B5A        5236     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
136A    F55B          5237     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
136C    B55AE2        5238     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5239     
136F    DAE2          5240     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5241     
                      5242     	; Clear measure pwm frequency flag
1371    C259          5243     CLR FLAGS0 . 1 
                      5244     	; Set up RC pulse interrupts after pwm frequency measurement
                      5245     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1373    53DACF        5245+1   ANL PCA0CPM0 , # 0CFH 
1376    207603        5245+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1379    43DA20        5245+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
137C    307603        5245+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
137F    43DA10        5245+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5246     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1382    C2D8          5246+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1384    C269          5247     CLR FLAGS2 . 1 
1386    1207FF        5248     	CALL WAIT100MS						; Wait for new RC pulse
                      5249     
                      5250     	; Validate RC pulse
                      5251     VALIDATE_RCP_START: 	
1389    1207F0        5252     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
138C    7802          5253     MOV R0 , # 2 
138E    741F          5254     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1390    552E          5255     	ANL	A, FLAGS3						; Check pwm frequency flags
1392    7002          5256     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5257     
1394    7800          5258     MOV R0 , # 0 
                      5259     
1396    C3            5260     	CLR	C
1397    E559          5261     	MOV	A, NEW_RCP					; Load value
1399    98            5262     SUBB A , R0 
139A    40ED          5263     	JC	VALIDATE_RCP_START				; No - start over
                      5264     
                      5265     	; Beep arm sequence start signal
139C    C2AF          5266     	CLR 	EA							; Disable all interrupts
139E    120814        5267     	CALL BEEP_F1
13A1    1207FA        5268     	CALL WAIT30MS
13A4    120814        5269     	CALL BEEP_F1
13A7    1207FA        5270     	CALL WAIT30MS
13AA    12081B        5271     	CALL BEEP_F2
13AD    1207FA        5272     	CALL WAIT30MS
13B0    12081B        5273     	CALL BEEP_F2
13B3    1207FA        5274     	CALL WAIT30MS
13B6    D2AF          5275     	SETB	EA							; Enable all interrupts
13B8    120804        5276     	CALL WAIT200MS	
                      5277     
                      5278     	; Arming sequence start
13BB    754800        5279     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5280     ARMING_START: 
                      5281     IF MODE >= 1	; Tail or multi
13BE    7888          5282     MOV R0 , # PGM_DIRECTION 
13C0    E6            5283     MOV A , @ R0 
13C1    B40302        5284     	CJNE	A, #3, ($+5)
                      5285     
13C4    8199          5286     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      5287     ENDIF
                      5288     
13C6    1207F0        5289     	CALL WAIT3MS
13C9    788C          5290     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
13CB    E6            5291     MOV A , @ R0 
13CC    C3            5292     	CLR	C
13CD    9401          5293     	SUBB	A, #1				; Is TX programming enabled?
13CF    5003          5294     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5295     
13D1    021499        5296     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5297     
                      5298     ARMING_INITIAL_ARM_CHECK: 
13D4    E530          5299     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
13D6    C3            5300     	CLR	C
13D7    9401          5301     	SUBB	A, #1				; Is it the initial arm sequence?
13D9    5003          5302     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5303     
13DB    021499        5304     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5305     
                      5306     ARMING_PPM_CHECK: 
13DE    741F          5307     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13E0    552E          5308     	ANL	A, FLAGS3				; Check pwm frequency flags
13E2    6035          5309     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5310     
                      5311     	; PWM tx program entry
13E4    C3            5312     	CLR	C
13E5    E559          5313     	MOV	A, NEW_RCP			; Load new RC pulse value
13E7    94FF          5314     SUBB A , # 255 
13E9    5003          5315     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5316     
13EB    021499        5317     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5318     
                      5319     PROGRAM_BY_TX_ENTRY_PWM: 	
13EE    C2AF          5320     	CLR	EA					; Disable all interrupts
13F0    120829        5321     	CALL BEEP_F4
13F3    D2AF          5322     	SETB	EA					; Enable all interrupts
13F5    1207FF        5323     	CALL WAIT100MS
13F8    C3            5324     	CLR	C
13F9    E559          5325     	MOV	A, NEW_RCP			; Load new RC pulse value
13FB    9401          5326     SUBB A , # 1 
13FD    50EF          5327     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5328     
                      5329     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13FF    C2AF          5330     	CLR	EA					; Disable all interrupts
1401    120814        5331     	CALL BEEP_F1
1404    1207F5        5332     	CALL WAIT10MS
1407    120814        5333     	CALL BEEP_F1
140A    D2AF          5334     	SETB	EA					; Enable all interrupts
140C    1207FF        5335     	CALL WAIT100MS
140F    C3            5336     	CLR	C
1410    E559          5337     	MOV	A, NEW_RCP			; Load new RC pulse value
1412    94FF          5338     SUBB A , # 255 
1414    40E9          5339     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5340     
1416    021D3D        5341     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5342     
                      5343     	; PPM throttle calibration and tx program entry
                      5344     THROTTLE_HIGH_CAL_START: 
1419    7F05          5345     MOV R7 , # 5 
                      5346     THROTTLE_HIGH_CAL: 			
141B    D277          5347     SETB FLAGS3 . 7 
141D    513F          5348     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
141F    1207FF        5349     	CALL WAIT100MS				; Wait for new throttle value
1422    C2AF          5350     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1424    C277          5351     CLR FLAGS3 . 7 
1426    513F          5352     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1428    AE59          5353     MOV R6 , NEW_RCP 
142A    C3            5354     	CLR	C
142B    E559          5355     	MOV	A, NEW_RCP			; Load new RC pulse value
142D    947F          5356     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
142F    D2AF          5357     	SETB	EA					; Enable interrupts
1431    4070          5358     	JC	ARM_TARGET_UPDATED		; No - branch
                      5359     
1433    1207EB        5360     	CALL WAIT1MS		
1436    C2AF          5361     	CLR	EA					; Disable all interrupts
1438    120829        5362     	CALL BEEP_F4
143B    D2AF          5363     	SETB	EA					; Enable all interrupts
143D    DFDC          5364     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5365     
143F    C3            5366     	CLR	C
1440    EE            5367     MOV A , R6 
1441    9405          5368     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1443    7897          5369     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1445    F6            5370     MOV @ R0 , A 
1446    120804        5371     	CALL WAIT200MS				
1449    1218A9        5372     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
144C    121CC0        5373     	CALL	SUCCESS_BEEP
                      5374     
                      5375     THROTTLE_LOW_CAL_START: 
144F    7F0A          5376     MOV R7 , # 10 
                      5377     THROTTLE_LOW_CAL: 			
1451    D277          5378     SETB FLAGS3 . 7 
1453    513F          5379     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1455    1207FF        5380     	CALL WAIT100MS
1458    C2AF          5381     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
145A    C277          5382     CLR FLAGS3 . 7 
145C    513F          5383     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
145E    AE59          5384     MOV R6 , NEW_RCP 
1460    C3            5385     	CLR	C
1461    E559          5386     	MOV	A, NEW_RCP			; Load new RC pulse value
1463    947F          5387     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1465    D2AF          5388     	SETB	EA					; Enable interrupts
1467    50E6          5389     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5390     
1469    1207EB        5391     	CALL WAIT1MS		
146C    C2AF          5392     	CLR	EA					; Disable all interrupts
146E    120814        5393     	CALL BEEP_F1
1471    1207F5        5394     	CALL WAIT10MS
1474    120814        5395     	CALL BEEP_F1
1477    D2AF          5396     	SETB	EA					; Enable all interrupts
1479    DFD6          5397     DJNZ R7 , THROTTLE_LOW_CAL 
                      5398     
147B    EE            5399     MOV A , R6 
147C    2405          5400     	ADD	A, #5				; Add about 2%
147E    7896          5401     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1480    F6            5402     MOV @ R0 , A 
1481    120804        5403     	CALL WAIT200MS				
1484    1218A9        5404     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1487    121CEF        5405     	CALL	SUCCESS_BEEP_INVERTED
                      5406     
                      5407     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
148A    1207FF        5408     	CALL WAIT100MS
148D    513F          5409     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
148F    C3            5410     	CLR	C
1490    E559          5411     	MOV	A, NEW_RCP			; Load new RC pulse value
1492    94FF          5412     SUBB A , # 255 
1494    40F4          5413     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5414     
1496    021D3D        5415     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5416     
                      5417     PROGRAM_BY_TX_CHECKED: 
1499    C3            5418     	CLR	C
149A    E559          5419     	MOV	A, NEW_RCP			; Load new RC pulse value
149C    9548          5420     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
149E    4003          5421     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5422     
14A0    855948        5423     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5424     
                      5425     ARM_TARGET_UPDATED: 
14A3    1207FF        5426     	CALL WAIT100MS				; Wait for new throttle value
14A6    C3            5427     	CLR	C
14A7    E559          5428     	MOV	A, NEW_RCP			; Load new RC pulse value
14A9    9401          5429     SUBB A , # 1 
14AB    4002          5430     	JC	ARM_END_BEEP			; Yes - proceed
                      5431     
14AD    61BE          5432     	JMP	ARMING_START			; No - start over
                      5433     
                      5434     ARM_END_BEEP: 
                      5435     	; Beep arm sequence end signal
14AF    C2AF          5436     	CLR 	EA					; Disable all interrupts
14B1    120829        5437     	CALL BEEP_F4
14B4    1207FA        5438     	CALL WAIT30MS
14B7    120829        5439     	CALL BEEP_F4
14BA    1207FA        5440     	CALL WAIT30MS
14BD    120822        5441     	CALL BEEP_F3
14C0    1207FA        5442     	CALL WAIT30MS
14C3    120822        5443     	CALL BEEP_F3
14C6    1207FA        5444     	CALL WAIT30MS
14C9    D2AF          5445     	SETB	EA					; Enable all interrupts
14CB    120804        5446     	CALL WAIT200MS
                      5447     
                      5448     	; Clear initial arm variable
14CE    753000        5449     	MOV	INITIAL_ARM, #0
                      5450     
                      5451     	; Armed and waiting for power on
                      5452     WAIT_FOR_POWER_ON: 
14D1    E4            5453     	CLR	A
14D2    F531          5454     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
14D4    F532          5455     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5456     WAIT_FOR_POWER_ON_LOOP: 
14D6    0531          5457     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
14D8    E531          5458     	MOV	A, POWER_ON_WAIT_CNT_L
14DA    F4            5459     	CPL	A
14DB    7039          5460     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5461     
14DD    0532          5462     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
14DF    789A          5463     MOV R0 , # PGM_BEACON_DELAY 
14E1    E6            5464     MOV A , @ R0 
14E2    7819          5465     MOV R0 , # 25 
14E4    14            5466     	DEC	A
14E5    6012          5467     	JZ	BEEP_DELAY_SET
                      5468     
14E7    7832          5469     MOV R0 , # 50 
14E9    14            5470     	DEC	A
14EA    600D          5471     	JZ	BEEP_DELAY_SET
                      5472     
14EC    787D          5473     MOV R0 , # 125 
14EE    14            5474     	DEC	A
14EF    6008          5475     	JZ	BEEP_DELAY_SET
                      5476     
14F1    78FA          5477     MOV R0 , # 250 
14F3    14            5478     	DEC	A
14F4    6003          5479     	JZ	BEEP_DELAY_SET
                      5480     
14F6    753200        5481     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5482     
                      5483     BEEP_DELAY_SET: 
14F9    C3            5484     	CLR	C
14FA    E532          5485     	MOV	A, POWER_ON_WAIT_CNT_H
14FC    98            5486     SUBB A , R0 
14FD    4017          5487     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5488     
14FF    1532          5489     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1501    7531B4        5490     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
1504    7899          5491     MOV R0 , # PGM_BEACON_STRENGTH 
1506    866F          5492     MOV BEEP_STRENGTH , @ R0 
1508    C2AF          5493     	CLR 	EA					; Disable all interrupts
150A    120829        5494     	CALL BEEP_F4				; Signal that there is no signal
150D    D2AF          5495     	SETB	EA					; Enable all interrupts
150F    7898          5496     MOV R0 , # PGM_BEEP_STRENGTH 
1511    866F          5497     MOV BEEP_STRENGTH , @ R0 
1513    1207FF        5498     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5499     
                      5500     WAIT_FOR_POWER_ON_NO_BEEP: 
1516    1207F5        5501     	CALL WAIT10MS
1519    E528          5502     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
151B    7008          5503     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5504     
151D    741F          5505     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
151F    552E          5506     	ANL	A, FLAGS3						; Check pwm frequency flags
1521    7002          5507     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5508     
1523    614F          5509     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5510     
                      5511     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1525    C3            5512     	CLR	C
1526    E559          5513     	MOV	A, NEW_RCP			; Load new RC pulse value
1528    9406          5514     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
152A    40AA          5515     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5516     
                      5517     IF MODE >= 1	; Tail or multi
152C    7888          5518     MOV R0 , # PGM_DIRECTION 
152E    E6            5519     MOV A , @ R0 
152F    C3            5520     	CLR	C
1530    9403          5521     	SUBB	A, #3
1532    6003          5522     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5523     ENDIF
                      5524     
1534    1207FF        5525     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5526     
1537    E528          5527     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1539    7003          5528     	JNZ	($+5)				; If it is not zero - proceed
                      5529     
153B    02134F        5530     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5531     
                      5532     
                      5533     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5534     ;
                      5535     ; Start entry point
                      5536     ;
                      5537     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5538     INIT_START: 
153E    C2AF          5539     	CLR	EA
1540    1190          5540     	CALL SWITCH_POWER_OFF
1542    E4            5541     	CLR	A
1543    F522          5542     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1545    F523          5543     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1547    F524          5544     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1549    F525          5545     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
154B    D2AF          5546     	SETB	EA
154D    7885          5547     MOV R0 , # PGM_MOTOR_IDLE 
154F    8661          5548     MOV PWM_MOTOR_IDLE , @ R0 
1551    F540          5549     	MOV	GOV_TARGET_L, A		; Set target to zero
1553    F541          5550     	MOV	GOV_TARGET_H, A
1555    F542          5551     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1557    F543          5552     	MOV	GOV_INTEGRAL_H, A
1559    F544          5553     	MOV	GOV_INTEGRAL_X, A
155B    F56C          5554     	MOV	ADC_CONVERSION_CNT, A
155D    F549          5555     	MOV	GOV_ACTIVE, A
155F    F52B          5556     	MOV	FLAGS0, A				; Clear flags0
1561    F52C          5557     	MOV	FLAGS1, A				; Clear flags1
1563    F539          5558     	MOV	DEMAG_CONSECUTIVE_CNT, A
1565    120C4A        5559     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5560     	;**** **** **** **** ****
                      5561     	; Motor start beginning
                      5562     	;**** **** **** **** **** 
1568    756C08        5563     MOV ADC_CONVERSION_CNT , # 8 
                      5564     	SET_ADC_IP_TEMP
156B    75BB10        5564+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
156E    1207EB        5565     	CALL WAIT1MS
1571    120B67        5566     	CALL START_ADC_CONVERSION
                      5567     READ_INITIAL_TEMP: 
                      5568     	GET_ADC_STATUS 
1574    E5E8          5568+1   MOV A , ADC0CN 
1576    20ECFB        5569     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5570     	READ_ADC_RESULT						; Read initial temperature
1579    A8BD          5570+1   MOV R0 , ADC0L 
157B    A9BE          5570+1   MOV R1 , ADC0H 
157D    E9            5571     MOV A , R1 
157E    7001          5572     	JNZ	($+3)							; Is reading below 256?
                      5573     
1580    F8            5574     MOV R0 , A 
                      5575     
1581    886D          5576     MOV CURRENT_AVERAGE_TEMP , R0 
1583    120B6B        5577     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1586    756C08        5578     MOV ADC_CONVERSION_CNT , # 8 
                      5579     	SET_ADC_IP_TEMP
1589    75BB10        5579+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5580     
                      5581     	; Go to the desired startup mode
158C    7895          5582     MOV R0 , # PGM_STARTUP_METHOD 
158E    E6            5583     MOV A , @ R0 
158F    30E003        5584     	JNB	ACC.0, DIRECT_METHOD_START
                      5585     
1592    0215D6        5586     	JMP	STEPPER_METHOD_START
                      5587     
                      5588     DIRECT_METHOD_START: 
                      5589     	; Set up start operating conditions
1595    7887          5590     MOV R0 , # PGM_PWM_FREQ 
1597    E6            5591     MOV A , @ R0 
1598    FE            5592     MOV R6 , A 
1599    7602          5593     MOV @ R0 , # 2 
159B    3167          5594     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
159D    7887          5595     MOV R0 , # PGM_PWM_FREQ 
159F    EE            5596     MOV A , R6 
15A0    F6            5597     MOV @ R0 , A 
                      5598     	; Set max allowed power
15A1    D261          5599     SETB FLAGS1 . 1 
15A3    C2AF          5600     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
15A5    755EFF        5601     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15A8    120C1A        5602     	CALL SET_STARTUP_PWM
15AB    85225E        5603     	MOV	PWM_LIMIT, REQUESTED_PWM
15AE    85225F        5604     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
15B1    D2AF          5605     	SETB	EA
15B3    C261          5606     CLR FLAGS1 . 1 
15B5    752501        5607     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
15B8    855D64        5608     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15BB    756501        5609     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5610     	; Begin startup sequence
15BE    D260          5611     SETB FLAGS1 . 0 
15C0    D263          5612     SETB FLAGS1 . 3 
15C2    753800        5613     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15C5    120FEA        5614     	CALL COMM5COMM6				; Initialize commutation
15C8    1125          5615     	CALL COMM6COMM1				
15CA    120CC4        5616     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
15CD    120C4A        5617     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
15D0    120D47        5618     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15D3    0216FE        5619     	JMP	RUN1
                      5620     
                      5621     
                      5622     STEPPER_METHOD_START: 
                      5623     	; Set up start operating conditions
15D6    7887          5624     MOV R0 , # PGM_PWM_FREQ 
15D8    E6            5625     MOV A , @ R0 
15D9    FE            5626     MOV R6 , A 
15DA    7603          5627     MOV @ R0 , # 3 
15DC    7893          5628     MOV R0 , # PGM_DAMPING_FORCE 
15DE    E6            5629     MOV A , @ R0 
15DF    FD            5630     MOV R5 , A 
15E0    7605          5631     MOV @ R0 , # 5 
15E2    3167          5632     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15E4    7887          5633     MOV R0 , # PGM_PWM_FREQ 
15E6    EE            5634     MOV A , R6 
15E7    F6            5635     MOV @ R0 , A 
15E8    7893          5636     MOV R0 , # PGM_DAMPING_FORCE 
15EA    ED            5637     MOV A , R5 
15EB    F6            5638     MOV @ R0 , A 
                      5639     	; Begin startup sequence
15EC    D260          5640     SETB FLAGS1 . 0 
15EE    D261          5641     SETB FLAGS1 . 1 
15F0    D265          5642     SETB FLAGS1 . 5 
15F2    120FEA        5643     	CALL COMM5COMM6			; Initialize commutation
15F5    1125          5644     	CALL COMM6COMM1			
15F7    755EFF        5645     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15FA    120C1A        5646     	CALL SET_STARTUP_PWM
15FD    1207EB        5647     	CALL WAIT1MS
1600    120EF2        5648     	CALL COMM1COMM2
1603    1207EB        5649     	CALL WAIT1MS
1606    1207EB        5650     	CALL WAIT1MS
1609    120F24        5651     	CALL COMM2COMM3
160C    1207F0        5652     	CALL WAIT3MS			
160F    120F6E        5653     	CALL COMM3COMM4
1612    1207F0        5654     	CALL WAIT3MS			
1615    1207F0        5655     	CALL WAIT3MS			
1618    120FA9        5656     	CALL COMM4COMM5
161B    1207F5        5657     	CALL WAIT10MS				; Settle rotor
161E    120FEA        5658     	CALL COMM5COMM6
1621    1207F0        5659     	CALL WAIT3MS				
1624    1207EB        5660     	CALL WAIT1MS			
1627    C261          5661     CLR FLAGS1 . 1 
1629    D262          5662     SETB FLAGS1 . 2 
                      5663     
                      5664     	;**** **** **** **** ****
                      5665     	; Stepper phase beginning
                      5666     	;**** **** **** **** **** 
                      5667     STEPPER_ROT_BEG: 
162B    120B67        5668     	CALL START_ADC_CONVERSION
162E    120B6B        5669     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1631    120C1A        5670     	CALL SET_STARTUP_PWM
1634    756C08        5671     MOV ADC_CONVERSION_CNT , # 8 
                      5672     	SET_ADC_IP_TEMP
1637    75BB10        5672+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5673     
163A    1125          5674     	CALL COMM6COMM1				; Commutate
163C    120CBD        5675     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
163F    120D47        5676     	CALL CALC_NEW_WAIT_TIMES
1642    11A2          5677     	CALL DECREMENT_STEPPER_STEP
1644    3107          5678     	CALL STEPPER_TIMER_WAIT
                      5679     
1646    120EF2        5680     	CALL COMM1COMM2			
1649    120CBD        5681     	CALL CALC_NEXT_COMM_TIMING_START	
164C    120D47        5682     	CALL CALC_NEW_WAIT_TIMES
164F    11A2          5683     	CALL DECREMENT_STEPPER_STEP
1651    3107          5684     	CALL STEPPER_TIMER_WAIT
                      5685     
1653    120F24        5686     	CALL COMM2COMM3			
1656    120CBD        5687     	CALL CALC_NEXT_COMM_TIMING_START	
1659    120D47        5688     	CALL CALC_NEW_WAIT_TIMES
165C    11A2          5689     	CALL DECREMENT_STEPPER_STEP
165E    3107          5690     	CALL STEPPER_TIMER_WAIT
                      5691     
1660    120F6E        5692     	CALL COMM3COMM4			
1663    120CBD        5693     	CALL CALC_NEXT_COMM_TIMING_START	
1666    120D47        5694     	CALL CALC_NEW_WAIT_TIMES
1669    11A2          5695     	CALL DECREMENT_STEPPER_STEP
166B    3107          5696     	CALL STEPPER_TIMER_WAIT
                      5697     
166D    120FA9        5698     	CALL COMM4COMM5			
1670    120CBD        5699     	CALL CALC_NEXT_COMM_TIMING_START	
1673    120D47        5700     	CALL CALC_NEW_WAIT_TIMES
1676    11A2          5701     	CALL DECREMENT_STEPPER_STEP
1678    3107          5702     	CALL STEPPER_TIMER_WAIT
                      5703     
167A    120FEA        5704     	CALL COMM5COMM6			
167D    120CBD        5705     	CALL CALC_NEXT_COMM_TIMING_START	
1680    120D47        5706     	CALL CALC_NEW_WAIT_TIMES
1683    11A2          5707     	CALL DECREMENT_STEPPER_STEP	
                      5708     	; Check stepper step versus end criteria
1685    C3            5709     	CLR	C
1686    E550          5710     	MOV	A, WT_STEPPER_STEP_L
1688    9535          5711     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
168A    E551          5712     	MOV	A, WT_STEPPER_STEP_H
168C    9536          5713     	SUBB	A, STEPPER_STEP_END_H
168E    400C          5714     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5715     
                      5716     	; Wait for step
1690    3107          5717     	CALL STEPPER_TIMER_WAIT
1692    C3            5718     	CLR	C
1693    E559          5719     	MOV	A, NEW_RCP				; Load new pulse value
1695    9401          5720     SUBB A , # 1 
1697    5092          5721     	JNC	STEPPER_ROT_BEG
                      5722     
1699    021830        5723     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5724     
                      5725     STEPPER_ROT_EXIT: 
                      5726     	; Wait for step
169C    3107          5727     	CALL STEPPER_TIMER_WAIT
                      5728     	; Clear stepper phase
169E    C262          5729     CLR FLAGS1 . 2 
                      5730     	; Set dondamped low pwm frequency
16A0    7887          5731     MOV R0 , # PGM_PWM_FREQ 
16A2    E6            5732     MOV A , @ R0 
16A3    FE            5733     MOV R6 , A 
16A4    7602          5734     MOV @ R0 , # 2 
16A6    3167          5735     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
16A8    7887          5736     MOV R0 , # PGM_PWM_FREQ 
16AA    EE            5737     MOV A , R6 
16AB    F6            5738     MOV @ R0 , A 
                      5739     	; Set spoolup power variables (power is now controlled from RCP)
16AC    85225E        5740     	MOV	PWM_LIMIT, REQUESTED_PWM
16AF    85605F        5741     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
16B2    856025        5742     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
16B5    855D64        5743     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
16B8    756501        5744     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5745     	; Set direct startup phase to acquire sync quickly
16BB    D263          5746     SETB FLAGS1 . 3 
16BD    753800        5747     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
16C0    C2AF          5748     	CLR	EA						; Disable interrupts
                      5749     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
16C2    207502        5749+1   JB FLAGS3 . 5 , ( $+5 ) 
16C5    C293          5749+1   CLR P1 . 3 
16C7    307502        5749+1   JNB FLAGS3 . 5 , ( $+5 ) 
16CA    C297          5749+1   CLR P1 . 7 
                      5750     	CPFET_OFF						; Cp off
16CC    207502        5750+1   JB FLAGS3 . 5 , ( $+5 ) 
16CF    C297          5750+1   CLR P1 . 7 
16D1    307502        5750+1   JNB FLAGS3 . 5 , ( $+5 ) 
16D4    C293          5750+1   CLR P1 . 3 
16D6    742D          5751     	MOV	A, #45					; 8us delay for pfets to go off
16D8    D5E0FD        5752     	DJNZ	ACC, $
16DB    D2AF          5753     	SETB	EA						; Enable interrupts
16DD    1125          5754     	CALL COMM6COMM1				
16DF    120CC4        5755     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16E2    120D33        5756     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16E5    120D47        5757     	CALL CALC_NEW_WAIT_TIMES
16E8    120DD8        5758     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16EB    756C00        5759     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5760     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16EE    75BB09        5760+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16F1    0216FE        5761     	JMP	RUN1
                      5762     
                      5763     
                      5764     
                      5765     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5766     ;
                      5767     ; Run entry point
                      5768     ;
                      5769     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5770     DAMPED_TRANSITION: 
                      5771     	; Transition from nondamped to damped if applicable
16F4    3167          5772     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16F6    1125          5773     	CALL	COMM6COMM1
16F8    756C00        5774     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5775     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16FB    75BB09        5775+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5776     
                      5777     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5778     ; Out_cA changes from low to high
                      5779     RUN1: 
16FE    120DFA        5780     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
1701    120E7F        5781     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1704    120EAA        5782     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1707    120913        5783     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
170A    120EBE        5784     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
170D    120EF2        5785     	CALL COMM1COMM2			; Commutate
1710    120CC4        5786     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1713    120D33        5787     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1716    120D47        5788     	CALL CALC_NEW_WAIT_TIMES
1719    120DD8        5789     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5790     
                      5791     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5792     ; Out_cB changes from high to low
                      5793     RUN2: 
171C    120DF1        5794     	CALL WAIT_FOR_COMP_OUT_LOW
171F    120E7F        5795     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1722    120EAA        5796     	CALL SETUP_COMM_WAIT	
1725    120970        5797     	CALL CALC_GOVERNOR_PROP_ERROR
1728    120EBE        5798     	CALL WAIT_FOR_COMM
172B    120F24        5799     	CALL COMM2COMM3
172E    120CC4        5800     	CALL CALC_NEXT_COMM_TIMING
1731    120D33        5801     	CALL WAIT_ADVANCE_TIMING
1734    120D47        5802     	CALL CALC_NEW_WAIT_TIMES
1737    120DD8        5803     	CALL WAIT_BEFORE_ZC_SCAN	
                      5804     
                      5805     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5806     ; Out_cC changes from low to high
                      5807     RUN3: 
173A    120DFA        5808     	CALL WAIT_FOR_COMP_OUT_HIGH
173D    120E7F        5809     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1740    120EAA        5810     	CALL SETUP_COMM_WAIT	
1743    1209A9        5811     	CALL CALC_GOVERNOR_INT_ERROR
1746    120EBE        5812     	CALL WAIT_FOR_COMM
1749    120F6E        5813     	CALL COMM3COMM4
174C    120CC4        5814     	CALL CALC_NEXT_COMM_TIMING
174F    120D33        5815     	CALL WAIT_ADVANCE_TIMING
1752    120D47        5816     	CALL CALC_NEW_WAIT_TIMES
1755    120DD8        5817     	CALL WAIT_BEFORE_ZC_SCAN	
                      5818     
                      5819     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5820     ; Out_cA changes from high to low
                      5821     RUN4: 
1758    120DF1        5822     	CALL WAIT_FOR_COMP_OUT_LOW
175B    120E7F        5823     	CALL	EVALUATE_COMPARATOR_INTEGRITY
175E    120EAA        5824     	CALL SETUP_COMM_WAIT	
1761    120A06        5825     	CALL CALC_GOVERNOR_PROP_CORRECTION
1764    120EBE        5826     	CALL WAIT_FOR_COMM
1767    120FA9        5827     	CALL COMM4COMM5
176A    120CC4        5828     	CALL CALC_NEXT_COMM_TIMING
176D    120D33        5829     	CALL WAIT_ADVANCE_TIMING
1770    120D47        5830     	CALL CALC_NEW_WAIT_TIMES
1773    120DD8        5831     	CALL WAIT_BEFORE_ZC_SCAN	
                      5832     
                      5833     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5834     ; Out_cB changes from low to high
                      5835     RUN5: 
1776    120DFA        5836     	CALL WAIT_FOR_COMP_OUT_HIGH
1779    120E7F        5837     	CALL	EVALUATE_COMPARATOR_INTEGRITY
177C    120EAA        5838     	CALL SETUP_COMM_WAIT	
177F    120A6A        5839     	CALL CALC_GOVERNOR_INT_CORRECTION
1782    120EBE        5840     	CALL WAIT_FOR_COMM
1785    120FEA        5841     	CALL COMM5COMM6
1788    120CC4        5842     	CALL CALC_NEXT_COMM_TIMING
178B    120D33        5843     	CALL WAIT_ADVANCE_TIMING
178E    120D47        5844     	CALL CALC_NEW_WAIT_TIMES
1791    120DD8        5845     	CALL WAIT_BEFORE_ZC_SCAN	
                      5846     
                      5847     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5848     ; Out_cC changes from high to low
                      5849     RUN6: 
1794    120DF1        5850     	CALL WAIT_FOR_COMP_OUT_LOW
1797    120B67        5851     	CALL START_ADC_CONVERSION
179A    120E7F        5852     	CALL	EVALUATE_COMPARATOR_INTEGRITY
179D    120EAA        5853     	CALL SETUP_COMM_WAIT	
17A0    120B6B        5854     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
17A3    120EBE        5855     	CALL WAIT_FOR_COMM
17A6    1125          5856     	CALL COMM6COMM1
17A8    120CC4        5857     	CALL CALC_NEXT_COMM_TIMING
17AB    120D33        5858     	CALL WAIT_ADVANCE_TIMING
17AE    120D47        5859     	CALL CALC_NEW_WAIT_TIMES
17B1    120DD8        5860     	CALL WAIT_BEFORE_ZC_SCAN	
                      5861     
                      5862     	; Check if it is direct startup
17B4    306342        5863     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      5864     
                      5865     	; Set spoolup power variables
17B7    85605E        5866     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
17BA    85605F        5867     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
17BD    855D64        5868     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
17C0    756501        5869     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5870     	; Check startup ok counter
17C3    7964          5871     MOV R1 , # 100 
17C5    7A14          5872     MOV R2 , # 20 
                      5873     IF MODE >= 1	; Tail or multi
17C7    7888          5874     MOV R0 , # PGM_DIRECTION 
17C9    E6            5875     MOV A , @ R0 
17CA    B40304        5876     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      5877     
17CD    791E          5878     MOV R1 , # 30 
17CF    7A05          5879     MOV R2 , # 5 
                      5880     
                      5881     DIRECT_START_PARAMS_SET: 
                      5882     ENDIF
17D1    C3            5883     	CLR	C
17D2    E538          5884     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
17D4    99            5885     SUBB A , R1 
17D5    4015          5886     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5887     
17D7    C263          5888     CLR FLAGS1 . 3 
17D9    D264          5889     SETB FLAGS1 . 4 
17DB    8A37          5890     MOV STARTUP_ROT_CNT , R2 
                      5891     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      5895     IF MODE == 2	; Multi
17DD    7888          5896     MOV R0 , # PGM_DIRECTION 
17DF    E6            5897     MOV A , @ R0 
17E0    B40306        5898     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      5899     
17E3    755EFF        5900     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17E6    755FFF        5901     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      5902     
                      5903     DIRECT_START_PWM_LIM_SET: 
                      5904     ENDIF
17E9    0217F9        5905     	JMP	NORMAL_RUN_CHECKS
                      5906     
                      5907     DIRECT_START_CHECK_RCP: 
17EC    C3            5908     	CLR	C
17ED    E559          5909     	MOV	A, NEW_RCP				; Load new pulse value
17EF    9401          5910     SUBB A , # 1 
17F1    4003          5911     	JC	($+5)
                      5912     
17F3    0216FE        5913     	LJMP	RUN1						; Continue to run 
                      5914     
17F6    021830        5915     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5916     
                      5917     
                      5918     NORMAL_RUN_CHECKS: 
                      5919     	; Check if it is initial run phase
17F9    306419        5920     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      5921     
                      5922     	; Decrement startup rotaton count
17FC    E537          5923     	MOV	A, STARTUP_ROT_CNT
17FE    14            5924     	DEC	A
                      5925     	; Check number of nondamped rotations
17FF    7005          5926     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      5927     
1801    C264          5928     CLR FLAGS1 . 4 
1803    0216F4        5929     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      5930     
                      5931     NORMAL_RUN_CHECK_STARTUP_ROT: 
1806    F537          5932     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      5933     
1808    C3            5934     	CLR	C
1809    E559          5935     	MOV	A, NEW_RCP				; Load new pulse value
180B    9401          5936     SUBB A , # 1 
180D    4003          5937     	JC	($+5)
                      5938     
180F    0216FE        5939     	LJMP	RUN1						; Continue to run 
                      5940     
1812    021830        5941     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5942     
                      5943     
                      5944     INITIAL_RUN_PHASE_DONE: 
                      5945     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      5958     	; Exit run loop after a given time
1815    C3            5959     	CLR	C
1816    E55C          5960     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1818    94FA          5961     SUBB A , # 250 
181A    5014          5962     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      5963     
                      5964     RUN6_CHECK_RCP_TIMEOUT: 
181C    741F          5965     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
181E    552E          5966     	ANL	A, FLAGS3					; Check pwm frequency flags
1820    7004          5967     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      5968     
1822    E528          5969     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1824    600A          5970     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      5971     
                      5972     RUN6_CHECK_SPEED: 
1826    C3            5973     	CLR	C
1827    E53D          5974     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1829    94F0          5975     	SUBB	A, #0F0H
182B    5003          5976     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
182D    0216FE        5977     	JMP	RUN1						; Go back to run 1
                      5978     
                      5979     
                      5980     RUN_TO_WAIT_FOR_POWER_ON: 	
1830    C2AF          5981     	CLR	EA
1832    121090        5982     	CALL SWITCH_POWER_OFF
1835    7887          5983     MOV R0 , # PGM_PWM_FREQ 
1837    E6            5984     MOV A , @ R0 
1838    FE            5985     MOV R6 , A 
1839    7602          5986     MOV @ R0 , # 2 
183B    121167        5987     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
183E    7887          5988     MOV R0 , # PGM_PWM_FREQ 
1840    EE            5989     MOV A , R6 
1841    F6            5990     MOV @ R0 , A 
1842    E4            5991     	CLR	A
1843    F522          5992     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1845    F523          5993     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1847    F524          5994     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1849    F525          5995     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
184B    F561          5996     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
184D    C260          5997     CLR FLAGS1 . 0 
184F    D2AF          5998     	SETB	EA
1851    1207EB        5999     	CALL	WAIT1MS					; Wait for pwm to be stopped
1854    121090        6000     	CALL SWITCH_POWER_OFF
                      6001     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6032     IF MODE >= 1	; Tail or multi
1857    741F          6033     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1859    552E          6034     	ANL	A, FLAGS3					; Check pwm frequency flags
185B    7007          6035     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6036     
185D    E528          6037     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
185F    7003          6038     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6039     
1861    02134F        6040     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6041     
                      6042     JMP_WAIT_FOR_POWER_ON: 
1864    0214D1        6043     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6044     ENDIF
                      6045     
                      6046     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6047     
                      6048     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      6768     
                      6769     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6770     
                      6771     
                      6772     
                      6773     
                      6774     END
MACRO ASSEMBLER BLHELI                                      05/25/15 17:03:10 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1806H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E45H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D18H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B6BH   A 
MEASURE_LIPO_WAIT~  C ADDR   0ADDH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A97H   A 
GOVERNOR_CORR_NEG~  C ADDR   0A59H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
FUNCTION_BEEP. . .  C ADDR   1D24H   A 
INIT_START . . . .  C ADDR   153EH   A 
PROGRAM_BY_TX_ENT~  C ADDR   13EEH   A 
FIND_THROTTLE_GAI~  C ADDR   124EH   A 
COMM45_NFET. . . .  C ADDR   0FCEH   A 
COMM45_NONDAMP . .  C ADDR   0FCBH   A 
COMM4COMM5 . . . .  C ADDR   0FA9H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D3DH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0BFEH   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
TEMP_SKYPUP. . . .  D ADDR   0076H   A 
PREV_RCP . . . . .  D ADDR   0073H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PARAVAL_BEEP . . .  C ADDR   1D32H   A 
STORE_MULTI_FUNC_~  C ADDR   1C92H   A 
DECODE_STARTUP_PO~  C ADDR   1222H   A 
GOVERNOR_CHECK_PWM  C ADDR   09E6H   A 
GOVERNOR_ACTIVATE.  C ADDR   0938H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
STORE_MULTI_FUNC_~  C ADDR   1C97H   A 
WRITE_EEPROM_SIGN~  C ADDR   1C30H   A 
WAIT_FOR_POWER_ON.  C ADDR   14D1H   A 
THROTTLE_LOW_CAL_~  C ADDR   144FH   A 
ARMING_INITIAL_AR~  C ADDR   13D4H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1499H   A 
ERASE_AND_STORE_A~  C ADDR   18A9H   A 
SET_DEFAULT_PARAM~  C ADDR   110DH   A 
COMM56_NONDAMP . .  C ADDR   1011H   A 
COMM23_CP. . . . .  C ADDR   0F5CH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CC4H   A 
COMM5COMM6 . . . .  C ADDR   0FEAH   A 
CALC_GOVERNOR_INT~  C ADDR   0A71H   A 
CALC_GOVERNOR_TAR~  C ADDR   096FH   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   126BH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FUNCTION_NEXT. . .  C ADDR   1D9BH   A 
STORE_MULTI_FUNC_~  C ADDR   1C9CH   A 
STEPPER_ROT_BEG. .  C ADDR   162BH   A 
THROTTLE_HIGH_CAL.  C ADDR   141BH   A 
DECODE_THROTTLE_R~  C ADDR   1214H   A 
STEPPER_STEP_MED_~  C ADDR   0C96H   A 
INITIALIZE_ALL_TI~  C ADDR   0C4AH   A 
STARTUP_PWM_SET_P~  C ADDR   0C3EH   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
RUN_COUNT_H. . . .  D ADDR   0075H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
PARAVAL_NEXT . . .  C ADDR   1D86H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA1H   A 
WRITE_EEPROM_BYTE.  C ADDR   1C04H   A 
MEASURE_PWM_FREQ_~  C ADDR   134FH   A 
COMM61_CP. . . . .  C ADDR   106DH   A 
COMM_EXIT. . . . .  C ADDR   107CH   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D1FH   A 
CALC_GOVERNOR_INT~  C ADDR   0A6AH   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
FUNC_PARAVAL_WAIT.  C ADDR   1D50H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA6H   A 
WRITE_TAG. . . . .  C ADDR   1C59H   A 
READ_EEPROM_STORE~  C ADDR   1880H   A 
RUN1 . . . . . . .  C ADDR   16FEH   A 
CLEAR_RAM. . . . .  C ADDR   12CEH   A 
SET_BEC_VOLTAGE. .  C ADDR   123EH   A 
DECODE_GOVERNOR_G~  C ADDR   11FBH   A 
DEC_STEP_HIGH. . .  C ADDR   10D0H   A 
WAIT_FOR_COMM. . .  C ADDR   0EBEH   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D66H   A 
MEASURE_LIPO_ADD_~  C ADDR   0B5AH   A 
CALC_GOVERNOR_PRO~  C ADDR   09A8H   A 
DIV_U16_BY_U16_DI~  C ADDR   088CH   A 
WAIT100MS. . . . .  C ADDR   07FFH   A 
WAIT1MS. . . . . .  C ADDR   07EBH   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
FUNCTION_PARAVAL_~  C ADDR   1D1EH   A 
STORE_MULTI_FUNC_~  C ADDR   1CABH   A 
STORE_NEW_VALUE_I~  C ADDR   1C61H   A 
DIRECT_START_PWM_~  C ADDR   17E9H   A 
RUN2 . . . . . . .  C ADDR   171CH   A 
ARMING_PPM_CHECK .  C ADDR   13DEH   A 
COMM45_CP. . . . .  C ADDR   0FE1H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DD8H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B62H   A 
GOVERNOR_CORR_INT~  C ADDR   0AB6H   A 
GOVERNOR_STORE_PR~  C ADDR   09A4H   A 
DIV_U16_BY_U16_DI~  C ADDR   0896H   A 
WAIT200MS. . . . .  C ADDR   0804H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
STORE_MULTI_FUNC_~  C ADDR   1CB0H   A 
RUN3 . . . . . . .  C ADDR   173AH   A 
DIRECT_METHOD_STA~  C ADDR   1595H   A 
DECODE_DAMPING_DO~  C ADDR   11A3H   A 
PWM_WAIT . . . . .  C ADDR   0E6AH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C0EH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A9EH   A 
GOVERNOR_CHECK_IN~  C ADDR   09CEH   A 
DIV_U16_BY_U16_DI~  C ADDR   08ADH   A 
WAIT3MS. . . . . .  C ADDR   07F0H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
RUN_COUNT_L. . . .  D ADDR   0074H   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
BEEP_NO_ENTRY. . .  C ADDR   1D49H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1864H   A 
DIRECT_START_CHEC~  C ADDR   17ECH   A 
RUN4 . . . . . . .  C ADDR   1758H   A 
STORE_TIMES_UP_OR~  C ADDR   0DB8H   A 
STORE_TIMES_DECRE~  C ADDR   0DCBH   A 
STEPPER_STEP_SET .  C ADDR   0CB0H   A 
TEMP_AVERAGE_INC .  C ADDR   0B9EH   A 
GOVERNOR_CORR_INT~  C ADDR   0AC7H   A 
MULT_S16_BY_U8_DI~  C ADDR   08BCH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
READ_TAGS. . . . .  C ADDR   1C3FH   A 
RUN5 . . . . . . .  C ADDR   1776H   A 
COMP_READ. . . . .  C ADDR   0E70H   A 
COMP_WAIT_SET_RES~  C ADDR   0E31H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D6CH   A 
GOVERNOR_CORR_NEG~  C ADDR   0ABBH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0999H   A 
GOVERNOR_TARGET_C~  C ADDR   091BH   A 
CALC_GOVERNOR_TAR~  C ADDR   0913H   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
RUN6 . . . . . . .  C ADDR   1794H   A 
ARMING_START . . .  C ADDR   13BEH   A 
MEASURE_PWM_FREQ_~  C ADDR   1353H   A 
DECREMENT_STEP_EX~  C ADDR   10FDH   A 
COMM_RETURN. . . .  C ADDR   108FH   A 
GOVERNOR_DEACTIVA~  C ADDR   0925H   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
ARM_TARGET_UPDATED  C ADDR   14A3H   A 
EVALUATE_COMPARAT~  C ADDR   0E7FH   A 
TEMP_CHECK_EXIT. .  C ADDR   0BC8H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A40H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
WRITE_EEPROM_BLOC~  C ADDR   18CCH   A 
NORMAL_RUN_CHECKS.  C ADDR   17F9H   A 
DEC_STEP_MED_LOW .  C ADDR   10EBH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E00H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D33H   A 
CALC_GOVERNOR_PRO~  C ADDR   0970H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WRITE_EEPROM_BLOC~  C ADDR   18DAH   A 
READ_ALL_EEPROM_P~  C ADDR   1867H   A 
PROGRAM_BY_TX_ENT~  C ADDR   148AH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0ED8H   A 
SKYPUP_03. . . . .  C ADDR   078EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1230H   A 
EVAL_COMP_EXIT . .  C ADDR   0EA9H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E91H   A 
STEPPER_STEP_LOW .  C ADDR   0CA4H   A 
MEASURE_LIPO_ADJU~  C ADDR   0B1FH   A 
SKYPUP_04. . . . .  C ADDR   07A2H   A 
PCA_INT_SET_TIMEO~  C ADDR   07B7H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   169CH   A 
STEPPER_METHOD_ST~  C ADDR   15D6H   A 
DECODE_PARAMS_DIR~  C ADDR   11DDH   A 
COMM12_DAMP. . . .  C ADDR   0EFCH   A 
SETUP_COMM_WAIT. .  C ADDR   0EAAH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CBDH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BF4H   A 
CALC_GOVERNOR_INT~  C ADDR   0A05H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
ARM_END_BEEP . . .  C ADDR   14AFH   A 
THROTTLE_HIGH_CAL~  C ADDR   1419H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DF1H   A 
LOAD_MIN_TIME. . .  C ADDR   0D88H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D47H   A 
SET_STARTUP_PWM. .  C ADDR   0C1AH   A 
GOVERNOR_STORE_IN~  C ADDR   09FFH   A 
GOVERNOR_ACTIVATE~  C ADDR   0962H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
FUNC_PARAVAL . . .  C ADDR   1D4CH   A 
WAIT1S_LOOP. . . .  C ADDR   1CBAH   A 
STORE_MULTI_FUNC_1  C ADDR   1C65H   A 
RUN6_CHECK_RCP_TI~  C ADDR   181CH   A 
DECREMENT_STEP . .  C ADDR   10AEH   A 
COMM23_DAMP. . . .  C ADDR   0F2CH   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EDAH   A 
ADJUST_TIMING. . .  C ADDR   0D8CH   A 
STEPPER_STEP_MED_~  C ADDR   0C7AH   A 
MEASURE_LIPO_DIVI~  C ADDR   0B3FH   A 
MEASURE_LIPO_START  C ADDR   0ACCH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A69H   A 
GOVERNOR_INT_MIN_~  C ADDR   09FAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A0H   A 
BEEP_F1. . . . . .  C ADDR   0814H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Dh            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
STORE_MULTI_FUNC_2  C ADDR   1C6AH   A 
INITIAL_RUN_PHASE~  C ADDR   1815H   A 
TEST_THROTTLE_GAIN  C ADDR   125CH   A 
STEPPER_STEP_MED .  C ADDR   0C88H   A 
GOVERNOR_STORE_PR~  C ADDR   0A67H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A2BH   A 
MULT_S16_BY_U8_PO~  C ADDR   08D6H   A 
DIV_U16_BY_U16 . .  C ADDR   0884H   A 
BEEP_ONOFF . . . .  C ADDR   0837H   A 
BEEP_F2. . . . . .  C ADDR   081BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1D46H   A 
STORE_MULTI_FUNC_3  C ADDR   1C6FH   A 
SUCCESS_BEEP_INVE~  C ADDR   1CEFH   A 
SUCCESS_BEEP . . .  C ADDR   1CC0H   A 
FIND_THROTTLE_GAIN  C ADDR   123FH   A 
DECREMENT_STEPPER~  C ADDR   10A2H   A 
COMM61_DAMP. . . .  C ADDR   102DH   A 
COMM34_DAMP. . . .  C ADDR   0F80H   A 
TEMP_AVERAGE_INC_~  C ADDR   0B8EH   A 
GOVERNOR_INT_MAX_~  C ADDR   09F3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09D7H   A 
BEEP_F3. . . . . .  C ADDR   0822H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
STORE_MULTI_FUNC_4  C ADDR   1C74H   A 
DAMPED_TRANSITION.  C ADDR   16F4H   A 
BEEP_DELAY_SET . .  C ADDR   14F9H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13FFH   A 
LOCK_BYTE_OK . . .  C ADDR   128AH   A 
DECODE_PWM_FREQ_L~  C ADDR   11F5H   A 
DECODE_DAMPING_3 .  C ADDR   117BH   A 
CALC_NEW_WAIT_RED~  C ADDR   0D57H   A 
BEEP_F4. . . . . .  C ADDR   0829H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
PROGRAM_BY_TX_EXIT  C ADDR   1DAAH   A 
STORE_MULTI_FUNC_5  C ADDR   1C79H   A 
READ_EEPROM_BYTE .  C ADDR   1C00H   A 
DIRECT_START_PARA~  C ADDR   17D1H   A 
THROTTLE_LOW_CAL .  C ADDR   1451H   A 
DECODE_DAMPING_4 .  C ADDR   1185H   A 
COMM45_DAMP. . . .  C ADDR   0FB1H   A 
WAIT_FOR_COMM_SET~  C ADDR   0EEAH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BA6H   A 
GOVERNOR_APPLY_IN~  C ADDR   0AA2H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A36H   A 
BEEP_OFF . . . . .  C ADDR   0878H   A 
WAIT10MS . . . . .  C ADDR   07F5H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
STORE_MULTI_FUNC_6  C ADDR   1C7EH   A 
READ_TAG . . . . .  C ADDR   1C48H   A 
RESET_CAL_DONE . .  C ADDR   12A6H   A 
DECODE_DAMPING_5 .  C ADDR   118FH   A 
DECODE_PARAMETERS.  C ADDR   1167H   A 
STEPPER_TIMER_WAIT  C ADDR   1107H   A 
STORE_TIMES_INCRE~  C ADDR   0DBEH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BEDH   A 
MEASURE_LIPO_CELLS  C ADDR   0ACCH   A 
CALC_GOVERNOR_INT~  C ADDR   09A9H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07D1H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
STORE_MULTI_FUNC_7  C ADDR   1C83H   A 
RUN6_CHECK_SPEED .  C ADDR   1826H   A 
WAIT_FOR_POWER_ON~  C ADDR   1525H   A 
DECODE_DAMPING_6 .  C ADDR   1199H   A 
DEC_STEP_LOW . . .  C ADDR   10F4H   A 
COMM56_DAMP. . . .  C ADDR   0FFCH   A 
SWITCH_POWER_OFF .  C ADDR   1090H   A 
WAIT30MS . . . . .  C ADDR   07FAH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FUNC_PARAVAL_CONT~  C ADDR   1D79H   A 
STORE_MULTI_FUNC_8  C ADDR   1C88H   A 
WRITE_TAGS . . . .  C ADDR   1C52H   A 
WAIT1S . . . . . .  C ADDR   1CB8H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1830H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E9FH   A 
ADJUST_TIMING_TWO~  C ADDR   0DAEH   A 
CHECK_VOLTAGE_RET.  C ADDR   0C19H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A0DH   A 
GOVERNOR_ACTIVATE~  C ADDR   0969H   A 
WAITXMS_M. . . . .  C ADDR   080BH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
STORE_MULTI_FUNC_9  C ADDR   1C8DH   A 
READ_INITIAL_TEMP.  C ADDR   1574H   A 
WAIT_FOR_POWER_ON~  C ADDR   1516H   A 
DECODE_PWM_FREQ_E~  C ADDR   11FAH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0EECH   A 
PWM_WAIT_STARTUP .  C ADDR   0E65H   A 
START_ADC_CONVERS~  C ADDR   0B67H   A 
MULT_S16_BY_U8_EX~  C ADDR   090AH   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
STORE_IN_RAM_EXIT.  C ADDR   1CB5H   A 
VALIDATE_RCP_START  C ADDR   1389H   A 
LOCK_BYTE_TEST . .  C ADDR   1283H   A 
DEC_STEP_MED_HIGH.  C ADDR   10D9H   A 
COMM_RESTORE_POWER  C ADDR   108DH   A 
COMM12_NONDAMP . .  C ADDR   0F11H   A 
COMM1COMM2 . . . .  C ADDR   0EF2H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BA4H   A 
TEMP_AVERAGE_DEC .  C ADDR   0B9AH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A06H   A 
WAITXMS_O. . . . .  C ADDR   0809H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07C3H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
READ_EEPROM_EXIT .  C ADDR   18A8H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D6H   A 
DEC_STEP_MED . . .  C ADDR   10E2H   A 
READ_TIMER . . . .  C ADDR   0CC8H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BCCH   A 
CALC_GOVERNOR_INT~  C ADDR   0ACBH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09E0H   A 
MULT_S16_BY_U8_DI~  C ADDR   08EFH   A 
BEEP . . . . . . .  C ADDR   0830H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
ERASE_FLASH. . . .  C ADDR   1C19H   A 
PROGRAM_BY_TX. . .  C ADDR   1D3DH   A 
COMM23_NFET. . . .  C ADDR   0F49H   A 
COMM23_NONDAMP . .  C ADDR   0F46H   A 
COMM2COMM3 . . . .  C ADDR   0F24H   A 
STEPPER_STEP_HIGH.  C ADDR   0C6CH   A 
MEASURE_LIPO_CELL~  C ADDR   0B04H   A 
GOVERNOR_STORE_IN~  C ADDR   0AC9H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A8BH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A54H   A 
GOVERNOR_ACTIVATE~  C ADDR   0956H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
FUNC_PARAVAL_STORE  C ADDR   1D6BH   A 
WRITE_EEPROM_BYTE~  C ADDR   1C05H   A 
READ_EEPROM_BLOCK1  C ADDR   1890H   A 
READ_EEPROM_READ .  C ADDR   1889H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B66H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A3CH   A 
GOVERNOR_CHECK_PR~  C ADDR   098DH   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
READ_EEPROM_BLOCK2  C ADDR   189EH   A 
MEASURE_PWM_FREQ_~  C ADDR   1351H   A 
COMM61_NFET. . . .  C ADDR   1052H   A 
COMM61_NONDAMP . .  C ADDR   104FH   A 
COMM6COMM1 . . . .  C ADDR   1025H   A 
COMM34_NONDAMP . .  C ADDR   0F8DH   A 
COMM3COMM4 . . . .  C ADDR   0F6EH   A 
COMP_WAIT_SET_MAX~  C ADDR   0E1EH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DFAH   A 
STARTUP_PWM_EXIT .  C ADDR   0C49H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B56H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A65H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6788    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     86    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
