MACRO ASSEMBLER BLHELI                                      05/25/15 15:35:39 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
  009F                  49     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        50     
                        51     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                  52     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                        53     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       663     ENDIF
                       664     
                       665     ;**** **** **** **** ****
                       666     ; TX programming defaults
                       667     ;
                       668     ; Parameter dependencies:
                       669     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       670     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       671     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       672     ; - Damping force is only used if DampedLight or Damped is selected
                       673     ;
                       674     ; Multi
  0009                 675     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 676     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 677     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 678     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 679     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 680     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 681     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 682     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 683     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 684     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       685     IF DAMPED_MODE_ENABLE == 1
  0001                 686     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       687     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 690     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 691     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 692     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                 693     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0028                 694     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 40	; Beacon strength
  0005                 695     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       696     ; Common
  0000                 697     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1=Enabled 	0=Disabled
  0003                 698     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 699     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 700     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (used in bidirectional mode)
  0000                 701     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       702     
                       703     ;**** **** **** **** ****
                       704     ; Constant definitions for multi
                       705     IF MODE == 2
                       706     
  0001                 707     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       708     
  000A                 709     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 710     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 711     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 712     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 713     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 714     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 715     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 716     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       717     
  0032                 718     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 719     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       720     
  000A                 721     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 722     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       723     
  0008                 724     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       725     
                       726     ENDIF
                       727     
                       728     ;**** **** **** **** ****
                       729     ; Temporary register definitions
  REG                  730     TEMP1		EQU	R0
  REG                  731     TEMP2		EQU	R1
  REG                  732     TEMP3		EQU	R2
  REG                  733     TEMP4		EQU	R3
  REG                  734     TEMP5		EQU	R4
  REG                  735     TEMP6		EQU	R5
  REG                  736     TEMP7		EQU	R6
  REG                  737     TEMP8		EQU	R7
                       738     
                       739     ;**** **** **** **** ****
                       740     ; Register definitions
------                 741     DSEG AT 20H					; Variables segment 
                       742     
0020                   743     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   744     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       745     
0022                   746     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   747     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   748     CURRENT_PWM: 				DS	1		; Current pwm
0025                   749     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   750     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   751     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   752     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   753     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   754     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       755     
002B                   756     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 757     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 758     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 759     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 760     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 761     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       762     ;						EQU 	5
                       763     ;						EQU 	6
                       764     ;						EQU 	7
                       765     
002C                   766     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 767     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 768     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 769     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 770     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 771     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 772     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 773     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       774     ;						EQU 	7
                       775     
002D                   776     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 777     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 778     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 779     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 780     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 781     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 782     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       783     ;						EQU 	6	
                       784     ;						EQU 	7	
                       785     
002E                   786     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 787     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 788     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 789     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 790     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 791     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 792     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 793     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 794     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       795     
                       796     ;**** **** **** **** ****
                       797     ; RAM definitions
------                 798     DSEG AT 30H						; Ram data segment, direct addressing
                       799     
0030                   800     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       801     
0031                   802     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   803     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       804     
0033                   805     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   806     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   807     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   808     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   809     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   810     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   811     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       812     
003A                   813     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   814     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   815     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   816     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   817     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   818     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       819     
0040                   820     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   821     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   822     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   823     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   824     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   825     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   826     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   827     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   828     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   829     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       830     
004A                   831     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   832     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   833     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   834     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   835     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   836     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   837     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   838     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       839     
0052                   840     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   841     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   842     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   843     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   844     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   845     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   846     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   847     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   848     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   849     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   850     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   851     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       852     
005E                   853     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   854     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   855     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   856     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   857     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   858     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       859     
0064                   860     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   861     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       862     
0066                   863     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   864     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       865     
0068                   866     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   867     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   868     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   869     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   870     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       871     
006D                   872     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       873     
006E                   874     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   875     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       876     
0070                   877     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   878     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   879     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       880     
                       881     ; Indirect addressing data segment. The variables below must be in this sequence
------                 882     ISEG AT 080H					
0080                   883     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                   884     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                   885     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                   886     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                   887     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                   888     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                   889     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                   890     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                   891     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                   892     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                   893     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                   894     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                   895     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                   896     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                   897     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                   898     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                   899     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                   900     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                   901     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                   902     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                   903     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                   904     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                   905     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                   906     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                   907     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                   908     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                   909     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                   910     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                   911     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                   912     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                   913     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                       914     
                       915     ; The sequence of the variables below is no longer of importance
009F                   916     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                   917     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                   918     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                   919     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                   920     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                       921     
                       922     
                       923     ; Indirect addressing data segment
------                 924     ISEG AT 0D0H					
00D0                   925     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                       926     
                       927     
                       928     ;**** **** **** **** ****
------                 929     CSEG AT 1A00H            ; "Eeprom" segment
  000B                 930     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                 931     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                 932     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                       933     
1A00    0B             934     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02             935     EEP_FW_SUB_REVISION:  DB 2 
1A02    11             936     EEP_LAYOUT_REVISION:  DB 17 
                       937     
                       938     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                       971     
                       972     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1005     
                      1006     IF MODE == 2
1A03    09            1007     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1008     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1009     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1010     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1011     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1012     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1013     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1014     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1015     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1016     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1017     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1018     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1019     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1020     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1021     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1022     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1023     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1024     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1025     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1026     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1027     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1028     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1029     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1030     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    28            1031     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    28            1032     EEP_PGM_BEACON_STRENGTH:  DB 40 
1A1D    05            1033     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1034     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1035     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1036     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1037     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1038     ENDIF
                      1039     
                      1040     
1A22    FF            1041     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1042     
------                1043     CSEG AT 1A60H
1A60    6F72672E      1044     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1045     
                      1046     ;**** **** **** **** ****
                      1047             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1047+1   CSEG AT 0  ; CODE SEGMENT START
0000    021253        1047+1   JMP RESET 
------                1047+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1047+1   JMP T0_INT 
------                1047+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1047+1   JMP T2_INT 
------                1047+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1047+1   JMP PCA_INT 
------                1047+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1047+1   JMP T3_INT 
------                1048     CSEG AT 80H			; Code segment after interrupt vectors 
                      1049     
                      1050     ;**** **** **** **** ****
                      1051     
                      1052     ; Table definitions
0080    02030406      1053     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1054     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1055     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1056     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1057     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1060     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1068     IF MODE == 2
                      1069       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1070     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1071       ENDIF
                      1072       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1075     ENDIF
                      1076     
                      1077     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1078     ;
                      1079     ; Timer0 interrupt routine
                      1080     ;
                      1081     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1082     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1083     ;
                      1084     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1085     T0_INT: 	; Used for pwm control
00BA    C2AF          1086     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1087     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1088     	PUSH	ACC		
                      1089     	; Check if pwm is on
00C0    205A10        1090     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1091     
                      1092     	; Do not execute pwm when stopped
00C3    30600A        1093     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1094     	; Do not execute pwm on during demag recovery
00C6    205C07        1095     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1096     	; Pwm on cycle. 
00C9    302F02        1097     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1098     
                      1099     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1100     	CLR	A					
00CD    73            1101     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1102     
                      1103     T0_INT_PWM_ON_LOW_PWM: 
                      1104     
                      1105     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1106     	JMP	T0_INT_PWM_ON_EXECUTE
                      1107     ENDIF
                      1108     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1125     
                      1126     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1127     	JMP	T0_INT_PWM_ON_EXIT
                      1128     
                      1129     
                      1130     T0_INT_PWM_OFF: 
00D3    306306        1131     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1132     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1132+1   CLR P1 . 2 
00D8    C296          1132+1   CLR P1 . 6 
00DA    C295          1132+1   CLR P1 . 5 
                      1133     T0_INT_PWM_OFF_START_CHECKED: 
                      1134     	; Pwm off cycle
00DC    85258A        1135     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1136     	; Clear pwm on flag
00DF    C25A          1137     CLR FLAGS0 . 2 
                      1138     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1139     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1140     	CPL	A						; Full pwm?
00E4    7002          1141     	JNZ	($+4)					; No - branch
00E6    21C6          1142     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1143     
00E8    0563          1144     	INC	PWM_OFF_CNT				; Increment event counter
                      1145     	; Do not execute pwm when stopped
00EA    306013        1146     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1147     
                      1148     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1149     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1150     
                      1151     	; Separate exit commands here for minimum delay
00F0    758B00        1152     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1153     	POP	ACC			; Restore preserved registers
00F5    D0D0          1154     	POP	PSW
                      1155     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1155+1   CLR P1 . 2 
00F9    C296          1155+1   CLR P1 . 6 
00FB    C295          1155+1   CLR P1 . 5 
00FD    D2AF          1156     	SETB	EA			; Enable all interrupts
00FF    32            1157     	RETI
                      1158     
                      1159     T0_INT_PWM_OFF_STOPPED: 
                      1160     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1160+1   CLR P1 . 2 
0102    C296          1160+1   CLR P1 . 6 
0104    C295          1160+1   CLR P1 . 5 
0106    0201B6        1161     	JMP	T0_INT_PWM_OFF_EXIT
                      1162     
                      1163     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1164     SETB FLAGS1 . 5 
010B    C266          1165     CLR FLAGS1 . 6 
010D    E567          1166     	MOV	A, DAMPING_ON
010F    601C          1167     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1168     
0111    C3            1169     	CLR	C
0112    E563          1170     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1171     	DEC	A
0115    9567          1172     	SUBB	A, DAMPING_ON
0117    4014          1173     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1174     
0119    C265          1175     CLR FLAGS1 . 5 
011B    D266          1176     SETB FLAGS1 . 6 
011D    C3            1177     	CLR	C
011E    E563          1178     	MOV	A, PWM_OFF_CNT					
0120    9566          1179     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1180     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1181     
0124    0201B6        1182     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1183     
                      1184     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1185     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1186     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1187     
                      1188     T0_INT_PWM_OFF_DO_DAMPED: 
                      1189     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1190     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1191     
                      1192     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1192+1   CLR P1 . 2 
0132    C296          1192+1   CLR P1 . 6 
0134    C295          1192+1   CLR P1 . 5 
0136    7406          1193     MOV A , # 6 
0138    D5E0FD        1194     	DJNZ	ACC, $	
                      1195     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1195+1   SETB P1 . 3 
013D    D297          1195+1   SETB P1 . 7 
013F    D294          1195+1   SETB P1 . 4 
0141    0201B6        1196     	JMP	T0_INT_PWM_OFF_EXIT
                      1197     
                      1198     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1199     IF DAMPED_MODE_ENABLE == 1
0144    D266          1200     SETB FLAGS1 . 6 
                      1201     ENDIF
                      1202     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1202+1   CLR P1 . 2 
0148    C296          1202+1   CLR P1 . 6 
014A    C295          1202+1   CLR P1 . 5 
014C    E53E          1203     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1204     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1205     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1206     
                      1207     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1210     MOV A , # 6 
0156    D5E0FD        1211     	DJNZ	ACC, $	
                      1212     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1212+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1212+1   SETB P1 . 7 
015E    307502        1212+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1212+1   SETB P1 . 3 
                      1213     ENDIF
0163    0201B6        1214     	JMP	T0_INT_PWM_OFF_EXIT
                      1215     
                      1216     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1217     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1218     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1221     MOV A , # 6 
016B    D5E0FD        1222     	DJNZ	ACC, $	
                      1223     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1223+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1223+1   SETB P1 . 7 
0173    307502        1223+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1223+1   SETB P1 . 3 
                      1224     ENDIF
0178    0201B6        1225     	JMP	T0_INT_PWM_OFF_EXIT
                      1226     
                      1227     T0_INT_PWM_OFF_COMM_3: 
                      1228     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1231     MOV A , # 6 
017D    D5E0FD        1232     	DJNZ	ACC, $	
                      1233     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1233+1   SETB P1 . 4 
                      1234     ENDIF
0182    0201B6        1235     	JMP	T0_INT_PWM_OFF_EXIT
                      1236     
                      1237     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1238     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1239     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1240     
                      1241     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1244     MOV A , # 6 
018D    D5E0FD        1245     	DJNZ	ACC, $	
                      1246     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1246+1   SETB P1 . 4 
                      1247     ENDIF
0192    0201B6        1248     	JMP	T0_INT_PWM_OFF_EXIT
                      1249     
                      1250     T0_INT_PWM_OFF_COMM_5: 
                      1251     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1254     MOV A , # 6 
0197    D5E0FD        1255     	DJNZ	ACC, $	
                      1256     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1256+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1256+1   SETB P1 . 3 
019F    307502        1256+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1256+1   SETB P1 . 7 
                      1257     ENDIF
01A4    0201B6        1258     	JMP	T0_INT_PWM_OFF_EXIT
                      1259     
                      1260     T0_INT_PWM_OFF_COMM_6: 
                      1261     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1264     MOV A , # 6 
01A9    D5E0FD        1265     	DJNZ	ACC, $	
                      1266     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1266+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1266+1   SETB P1 . 3 
01B1    307502        1266+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1266+1   SETB P1 . 7 
                      1267     ENDIF
                      1268     
                      1269     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1270     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1271     	POP	ACC			; Restore preserved registers
01BB    D0D0          1272     	POP	PSW
                      1273     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1273+1   CLR P1 . 2 
01BF    C296          1273+1   CLR P1 . 6 
01C1    C295          1273+1   CLR P1 . 5 
01C3    D2AF          1274     	SETB	EA			; Enable all interrupts
01C5    32            1275     	RETI
                      1276     
                      1277     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1278     	POP	ACC			; Restore preserved registers
01C8    D0D0          1279     	POP	PSW
01CA    D2AF          1280     	SETB	EA			; Enable all interrupts
01CC    32            1281     	RETI
                      1282     
                      1283     
                      1284     
                      1285     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1286     	AJMP	T0_INT_PWM_ON_EXIT
                      1287     
                      1288     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1289     	ANFET_ON	
01CF    E525          1289+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1289+1   JZ ( $+12 ) 
01D3    207502        1289+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1289+1   SETB P1 . 2 
01D8    307502        1289+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1289+1   SETB P1 . 6 
                      1290     	BNFET_OFF
01DD    C295          1290+1   CLR P1 . 5 
01DF    61D3          1291     	AJMP	T0_INT_PWM_ON_EXIT
                      1292     
                      1293     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1294     	BNFET_ON
01E1    E525          1294+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1294+1   JZ ( $+4 ) 
01E5    D295          1294+1   SETB P1 . 5 
                      1295     	CNFET_OFF
01E7    207502        1295+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1295+1   CLR P1 . 6 
01EC    307502        1295+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1295+1   CLR P1 . 2 
01F1    61D3          1296     	AJMP	T0_INT_PWM_ON_EXIT
                      1297     
                      1298     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1299     	CNFET_ON
01F3    E525          1299+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1299+1   JZ ( $+12 ) 
01F7    207502        1299+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1299+1   SETB P1 . 6 
01FC    307502        1299+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1299+1   SETB P1 . 2 
                      1300     	ANFET_OFF
0201    207502        1300+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1300+1   CLR P1 . 2 
0206    307502        1300+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1300+1   CLR P1 . 6 
020B    61D3          1301     	AJMP	T0_INT_PWM_ON_EXIT
                      1302     
                      1303     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1304     	APFET_OFF
020D    207502        1304+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1304+1   CLR P1 . 3 
0212    307502        1304+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1304+1   CLR P1 . 7 
                      1305     	ANFET_ON								; Switch nFETs
0217    E525          1305+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1305+1   JZ ( $+12 ) 
021B    207502        1305+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1305+1   SETB P1 . 2 
0220    307502        1305+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1305+1   SETB P1 . 6 
                      1306     	CPFET_OFF
0225    207502        1306+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1306+1   CLR P1 . 7 
022A    307502        1306+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1306+1   CLR P1 . 3 
                      1307     	BNFET_OFF 							
022F    C295          1307+1   CLR P1 . 5 
0231    61D3          1308     	AJMP	T0_INT_PWM_ON_EXIT
                      1309     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1310     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1311     	APFET_OFF
0233    207502        1311+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1311+1   CLR P1 . 3 
0238    307502        1311+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1311+1   CLR P1 . 7 
                      1312     	CPFET_OFF
023D    207502        1312+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1312+1   CLR P1 . 7 
0242    307502        1312+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1312+1   CLR P1 . 3 
0247    7406          1313     MOV A , # 6 
0249    D5E0FD        1314     	DJNZ ACC,	$
                      1315     	ANFET_ON								; Switch nFETs
024C    E525          1315+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1315+1   JZ ( $+12 ) 
0250    207502        1315+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1315+1   SETB P1 . 2 
0255    307502        1315+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1315+1   SETB P1 . 6 
                      1316     	BNFET_OFF 							
025A    C295          1316+1   CLR P1 . 5 
025C    61D3          1317     	AJMP	T0_INT_PWM_ON_EXIT
                      1318     
                      1319     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1320     	APFET_OFF
025E    207502        1320+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1320+1   CLR P1 . 3 
0263    307502        1320+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1320+1   CLR P1 . 7 
                      1321     	ANFET_ON								; Switch nFETs
0268    E525          1321+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1321+1   JZ ( $+12 ) 
026C    207502        1321+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1321+1   SETB P1 . 2 
0271    307502        1321+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1321+1   SETB P1 . 6 
                      1322     	BPFET_OFF
0276    C294          1322+1   CLR P1 . 4 
                      1323     	BNFET_OFF								
0278    C295          1323+1   CLR P1 . 5 
027A    61D3          1324     	AJMP	T0_INT_PWM_ON_EXIT
                      1325     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1326     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1327     	APFET_OFF
027C    207502        1327+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1327+1   CLR P1 . 3 
0281    307502        1327+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1327+1   CLR P1 . 7 
                      1328     	BPFET_OFF
0286    C294          1328+1   CLR P1 . 4 
0288    7406          1329     MOV A , # 6 
028A    D5E0FD        1330     	DJNZ ACC,	$
                      1331     	ANFET_ON								; Switch nFETs
028D    E525          1331+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1331+1   JZ ( $+12 ) 
0291    207502        1331+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1331+1   SETB P1 . 2 
0296    307502        1331+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1331+1   SETB P1 . 6 
                      1332     	BNFET_OFF								
029B    C295          1332+1   CLR P1 . 5 
029D    61D3          1333     	AJMP	T0_INT_PWM_ON_EXIT
                      1334     
                      1335     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1336     	BPFET_OFF
029F    C294          1336+1   CLR P1 . 4 
                      1337     	BNFET_ON								; Switch nFETs
02A1    E525          1337+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1337+1   JZ ( $+4 ) 
02A5    D295          1337+1   SETB P1 . 5 
                      1338     	APFET_OFF
02A7    207502        1338+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1338+1   CLR P1 . 3 
02AC    307502        1338+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1338+1   CLR P1 . 7 
                      1339     	CNFET_OFF								
02B1    207502        1339+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1339+1   CLR P1 . 6 
02B6    307502        1339+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1339+1   CLR P1 . 2 
02BB    61D3          1340     	AJMP	T0_INT_PWM_ON_EXIT
                      1341     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1342     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1343     	BPFET_OFF
02BD    C294          1343+1   CLR P1 . 4 
                      1344     	APFET_OFF
02BF    207502        1344+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1344+1   CLR P1 . 3 
02C4    307502        1344+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1344+1   CLR P1 . 7 
02C9    7406          1345     MOV A , # 6 
02CB    D5E0FD        1346     	DJNZ ACC,	$
                      1347     	BNFET_ON								; Switch nFETs
02CE    E525          1347+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1347+1   JZ ( $+4 ) 
02D2    D295          1347+1   SETB P1 . 5 
                      1348     	CNFET_OFF								
02D4    207502        1348+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1348+1   CLR P1 . 6 
02D9    307502        1348+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1348+1   CLR P1 . 2 
02DE    61D3          1349     	AJMP	T0_INT_PWM_ON_EXIT
                      1350     
                      1351     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1352     	BPFET_OFF
02E0    C294          1352+1   CLR P1 . 4 
                      1353     	BNFET_ON								; Switch nFETs
02E2    E525          1353+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1353+1   JZ ( $+4 ) 
02E6    D295          1353+1   SETB P1 . 5 
                      1354     	CPFET_OFF
02E8    207502        1354+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1354+1   CLR P1 . 7 
02ED    307502        1354+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1354+1   CLR P1 . 3 
                      1355     	CNFET_OFF								
02F2    207502        1355+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1355+1   CLR P1 . 6 
02F7    307502        1355+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1355+1   CLR P1 . 2 
02FC    61D3          1356     	AJMP	T0_INT_PWM_ON_EXIT
                      1357     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1358     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1359     	BPFET_OFF
02FE    C294          1359+1   CLR P1 . 4 
                      1360     	CPFET_OFF
0300    207502        1360+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1360+1   CLR P1 . 7 
0305    307502        1360+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1360+1   CLR P1 . 3 
030A    7406          1361     MOV A , # 6 
030C    D5E0FD        1362     	DJNZ ACC,	$
                      1363     	BNFET_ON								; Switch nFETs
030F    E525          1363+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1363+1   JZ ( $+4 ) 
0313    D295          1363+1   SETB P1 . 5 
                      1364     	CNFET_OFF								
0315    207502        1364+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1364+1   CLR P1 . 6 
031A    307502        1364+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1364+1   CLR P1 . 2 
031F    61D3          1365     	AJMP	T0_INT_PWM_ON_EXIT
                      1366     
                      1367     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1368     	CPFET_OFF
0321    207502        1368+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1368+1   CLR P1 . 7 
0326    307502        1368+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1368+1   CLR P1 . 3 
                      1369     	CNFET_ON								; Switch nFETs
032B    E525          1369+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1369+1   JZ ( $+12 ) 
032F    207502        1369+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1369+1   SETB P1 . 6 
0334    307502        1369+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1369+1   SETB P1 . 2 
                      1370     	BPFET_OFF
0339    C294          1370+1   CLR P1 . 4 
                      1371     	ANFET_OFF								
033B    207502        1371+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1371+1   CLR P1 . 2 
0340    307502        1371+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1371+1   CLR P1 . 6 
0345    61D3          1372     	AJMP	T0_INT_PWM_ON_EXIT
                      1373     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1374     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1375     	CPFET_OFF
0347    207502        1375+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1375+1   CLR P1 . 7 
034C    307502        1375+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1375+1   CLR P1 . 3 
                      1376     	BPFET_OFF
0351    C294          1376+1   CLR P1 . 4 
0353    7406          1377     MOV A , # 6 
0355    D5E0FD        1378     	DJNZ ACC,	$
                      1379     	CNFET_ON								; Switch nFETs
0358    E525          1379+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1379+1   JZ ( $+12 ) 
035C    207502        1379+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1379+1   SETB P1 . 6 
0361    307502        1379+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1379+1   SETB P1 . 2 
                      1380     	ANFET_OFF								
0366    207502        1380+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1380+1   CLR P1 . 2 
036B    307502        1380+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1380+1   CLR P1 . 6 
0370    61D3          1381     	AJMP	T0_INT_PWM_ON_EXIT
                      1382     
                      1383     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1384     	CPFET_OFF
0372    207502        1384+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1384+1   CLR P1 . 7 
0377    307502        1384+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1384+1   CLR P1 . 3 
                      1385     	CNFET_ON								; Switch nFETs
037C    E525          1385+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1385+1   JZ ( $+12 ) 
0380    207502        1385+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1385+1   SETB P1 . 6 
0385    307502        1385+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1385+1   SETB P1 . 2 
                      1386     	APFET_OFF
038A    207502        1386+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1386+1   CLR P1 . 3 
038F    307502        1386+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1386+1   CLR P1 . 7 
                      1387     	ANFET_OFF								
0394    207502        1387+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1387+1   CLR P1 . 2 
0399    307502        1387+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1387+1   CLR P1 . 6 
039E    61D3          1388     	AJMP	T0_INT_PWM_ON_EXIT
                      1389     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1390     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1391     	CPFET_OFF
03A0    207502        1391+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1391+1   CLR P1 . 7 
03A5    307502        1391+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1391+1   CLR P1 . 3 
                      1392     	APFET_OFF
03AA    207502        1392+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1392+1   CLR P1 . 3 
03AF    307502        1392+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1392+1   CLR P1 . 7 
03B4    7406          1393     MOV A , # 6 
03B6    D5E0FD        1394     	DJNZ ACC,	$
                      1395     	CNFET_ON								; Switch nFETs
03B9    E525          1395+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1395+1   JZ ( $+12 ) 
03BD    207502        1395+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1395+1   SETB P1 . 6 
03C2    307502        1395+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1395+1   SETB P1 . 2 
                      1396     	ANFET_OFF								
03C7    207502        1396+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1396+1   CLR P1 . 2 
03CC    307502        1396+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1396+1   CLR P1 . 6 
03D1    61D3          1397     	AJMP	T0_INT_PWM_ON_EXIT
                      1398     
                      1399     T0_INT_PWM_ON_EXIT: 
                      1400     	; Set timer for coming on cycle length
03D3    E525          1401     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1402     	CPL	A						; cpl is 255-x
03D6    F58A          1403     	MOV	TL0, A					; Write start point for timer
                      1404     	; Set other variables
03D8    758B00        1405     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1406     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1407     SETB FLAGS0 . 2 
                      1408     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1409     	; Exit interrupt
03E0    D0E0          1410     	POP	ACC			; Restore preserved registers
03E2    D0D0          1411     	POP	PSW
03E4    D2AF          1412     	SETB	EA			; Enable all interrupts
03E6    32            1413     	RETI
                      1414     
                      1415     
                      1416     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1417     ;
                      1418     ; Timer2 interrupt routine
                      1419     ;
                      1420     ; No assumptions
                      1421     ;
                      1422     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1423     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1424     	CLR	EA
03E9    C2AD          1425     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1426     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1427     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1428     	PUSH	ACC
03F2    D2D3          1429     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1430     	SETB	EA
                      1431     	; Clear low byte interrupt flag
03F6    C2CE          1432     	CLR	TF2L						; Clear interrupt flag
                      1433     	; Check RC pulse timeout counter
03F8    E528          1434     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1435     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1436     
                      1437     	; Decrement timeout counter (if PWM)
03FC    741F          1438     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1439     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1440     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1441     
0402    1528          1442     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1443     	AJMP	T2_INT_SKIP_START
                      1444     
                      1445     T2_INT_PULSES_ABSENT: 
                      1446     	; Timeout counter has reached zero, pulses are absent
0406    7800          1447     MOV R0 , # 0 
0408    7900          1448     MOV R1 , # 0 
                      1449     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1449+1   MOV A , P0 
040C    307601        1449+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1449+1   CPL A  ; YES - INVERT
0410    30E502        1450     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1451     MOV R0 , # 255 
                      1452     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1452+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1452+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1452+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1452+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1452+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1453     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1453+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1454     CLR FLAGS2 . 1 
                      1455     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1455+1   MOV A , P0 
042A    307601        1455+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1455+1   CPL A  ; YES - INVERT
042E    30E502        1456     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1457     MOV R1 , # 255 
0433    C3            1458     	CLR	C
0434    E8            1459     MOV A , R0 
0435    99            1460     SUBB A , R1 
0436    70CE          1461     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1462     
0438    305903        1463     JNB FLAGS0 . 1 , ( $+6 ) 
                      1464     
043B    752818        1465     MOV RCP_TIMEOUT_CNT , # 24 
                      1466     
043E    741F          1467     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1468     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1469     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1470     
0444    752818        1471     MOV RCP_TIMEOUT_CNT , # 24 
                      1472     
                      1473     
                      1474     T2_INT_PPM_TIMEOUT_SET: 
                      1475     
                      1476     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1477     ; 
                      1478     ;  RCP 
                      1479     ; 1  1500us 
                      1480     ; 2  1500us 
                      1481     ; 
                      1482     ;	clr C
                      1483     ;	mov A, Temp1
                      1484     ;	subb A, #80h
                      1485     ;	jnc skypup_01
                      1486     ;	mov	Temp1, #RCP_MIN
                      1487     ; skypup_01:
                      1488     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
0447    8859          1489     MOV NEW_RCP , R0 
0449    D268          1490     SETB FLAGS2 . 0 
                      1491     
                      1492     T2_INT_SKIP_START: 
                      1493     	; Check RC pulse skip counter
044B    E529          1494     	MOV	A, RCP_SKIP_CNT			
044D    6004          1495     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1496     	
                      1497     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1498     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1499     	AJMP	T2_INT_RCP_UPDATE_START
                      1500     
                      1501     T2_INT_SKIP_END: 
0453    741F          1502     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1503     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1504     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1505     
                      1506     	; Skip counter has reached zero, start looking for RC pulses again
                      1507     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1507+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1508     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1508+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1509     	
                      1510     T2_INT_RCP_UPDATE_START: 
                      1511     	; Process updated RC pulse
045E    206802        1512     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1513     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1514     
0463    E559          1515     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1516     MOV R0 , A 
0466    C268          1517     CLR FLAGS2 . 0 
                      1518     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1519     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1520     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1521     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1522     
                      1523     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1526     
                      1527     IF MODE == 2	; Multi
046E    7982          1528     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1529     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1530     ENDIF
                      1531     
                      1532     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1533     	CLR	C
0474    E8            1534     MOV A , R0 
0475    94F0          1535     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1536     	JC	T2_INT_RCP_UPDATE_MULT
                      1537     
0479    74F0          1538     	MOV	A, #240			; Set requested pwm to max
047B    F8            1539     MOV R0 , A 
                      1540     
                      1541     T2_INT_RCP_UPDATE_MULT: 	
                      1542     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1543     MOV A , R0 
047D    C4            1544     	SWAP	A			; After this "0.0625"
047E    540F          1545     	ANL	A, #0FH
0480    28            1546     ADD A , R0 
0481    F8            1547     MOV R0 , A 
                      1548     	; Adjust tail gain
0482    7984          1549     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1550     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1551     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1552     
0489    C3            1553     	CLR	C
048A    13            1554     	RRC	A			; After this "0.5"
048B    C3            1555     	CLR	C
048C    13            1556     	RRC	A			; After this "0.25"
048D    8721          1557     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1558     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1559     
0492    C3            1560     	CLR	C
0493    13            1561     	RRC	A			; After this "0.125"
                      1562     
                      1563     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1564     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1565     
0497    C3            1566     	CLR	C
0498    C8            1567     XCH A , R0 
0499    98            1568     SUBB A , R0 
049A    F8            1569     MOV R0 , A 
049B    81A4          1570     	AJMP	T2_INT_PWM_MIN_RUN
                      1571     
                      1572     T2_INT_RCP_GAIN_POS: 
049D    28            1573     ADD A , R0 
049E    F8            1574     MOV R0 , A 
049F    5003          1575     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1576     
04A1    74FF          1577     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1578     MOV R0 , A 
                      1579     
                      1580     T2_INT_PWM_MIN_RUN:  
                      1581     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1591     
                      1592     T2_INT_PWM_UPDATE:  
                      1593     	; Check if any startup phase flags are set
04A4    E52C          1594     	MOV	A, FLAGS1
04A6    5406          1595     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1596     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1597     
                      1598     	; Update requested_pwm
04AA    8822          1599     MOV REQUESTED_PWM , R0 
                      1600     	; Limit pwm during direct start
04AC    30630A        1601     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1602     
04AF    C3            1603     	CLR	C
04B0    E522          1604     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1605     	SUBB	A, PWM_LIMIT
04B4    4003          1606     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1607     
04B6    855E22        1608     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1609     
                      1610     T2_INT_CURRENT_PWM_UPDATE:  
                      1611     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1612     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1613     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1614     ENDIF
                      1615     
                      1616     	; Update current pwm, with limited throttle change rate
04BE    C3            1617     	CLR	C
04BF    E522          1618     	MOV	A, REQUESTED_PWM	 
04C1    9524          1619     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1620     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1621     
                      1622     	; 
                      1623     	; mov	Temp1, #Pgm_Throttle_Rate_Decoded		
04C5    7801          1624     MOV R0 , # 1 
                      1625     	; subb	A, @Temp1					; Is difference larger than throttle change rate?
04C7    98            1626     SUBB A , R0 
04C8    400D          1627     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1628     
04CA    E524          1629     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
                      1630     	; add	A, @Temp1
04CC    28            1631     ADD A , R0 
04CD    F524          1632     	MOV	CURRENT_PWM, A
04CF    5009          1633     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1634     
04D1    7524FF        1635     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1636     	JMP	T2_INT_CURRENT_PWM_DONE
                      1637     
                      1638     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1639     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1640     T2_INT_CURRENT_PWM_DONE: 
                      1641     IF MODE >= 1	; Tail or multi
                      1642     	; Set current_pwm_limited
04DA    A824          1643     MOV R0 , CURRENT_PWM 
04DC    C3            1644     	CLR	C
04DD    E524          1645     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1646     	SUBB	A, PWM_LIMIT
04E1    4002          1647     	JC	($+4)					; If current pwm below limit - branch
                      1648     
04E3    A85E          1649     MOV R0 , PWM_LIMIT 
                      1650     
04E5    8825          1651     MOV CURRENT_PWM_LIMITED , R0 
                      1652     ENDIF
                      1653     T2_INT_PWM_EXIT: 	
                      1654     	; Check if high byte flag is set
04E7    20CF0C        1655     	JB	TF2H, T2H_INT		
04EA    D0E0          1656     	POP	ACC			; Restore preserved registers
04EC    D0D0          1657     	POP	PSW
04EE    C2D3          1658     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1659     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1660     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1661     	RETI
                      1662     
                      1663     T2H_INT: 
                      1664     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1665     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1666     MOV R0 , # 1 
                      1667     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1668     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1669     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1670     
                      1671     	; Decrement timeout counter (if PPM)
04FE    741F          1672     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1673     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1674     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1675     
0504    1528          1676     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1677     
                      1678     T2H_INT_RCP_STOP_CHECK: 
                      1679     	; Check RC pulse against stop value
0506    C3            1680     	CLR	C
0507    E559          1681     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1682     SUBB A , # 1 
050B    4005          1683     	JC	T2H_INT_RCP_STOP
                      1684     
                      1685     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1686     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1687     	AJMP	T2H_INT_RCP_GOV_PWM
                      1688     
                      1689     T2H_INT_RCP_STOP: 	
                      1690     	; RC pulse less than stop value
0512    755D00        1691     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1692     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1693     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1694     	ADD	A, #1
051C    F55C          1695     	MOV	RCP_STOP_CNT, A
051E    5003          1696     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1697     
0520    755CFF        1698     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1699     
                      1700     T2H_INT_RCP_GOV_PWM: 
                      1701     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1830     IF MODE == 2	; Multi
0523    E55F          1831     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1832     	ADD	A, #10
0527    5005          1833     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1834     
0529    755FFF        1835     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1836     	AJMP	T2H_INT_RCP_EXIT
                      1837     
                      1838     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1839     	MOV	PWM_LIMIT_SPOOLUP, A
                      1840     ENDIF
                      1841     
                      1842     T2H_INT_RCP_EXIT: 
0530    D0E0          1843     	POP	ACC			; Restore preserved registers
0532    D0D0          1844     	POP	PSW
0534    C2D3          1845     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1846     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1847     	SETB	ET2			; Enable timer2 interrupts
053B    32            1848     	RETI
                      1849     
                      1850     
                      1851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1852     ;
                      1853     ; Timer3 interrupt routine
                      1854     ;
                      1855     ; No assumptions
                      1856     ;
                      1857     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1858     T3_INT: 	; Used for commutation timing
053C    C2AF          1859     	CLR 	EA			; Disable all interrupts
053E    53917F        1860     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1861     CLR FLAGS0 . 0 
0543    D2AF          1862     	SETB	EA			; Enable all interrupts
0545    32            1863     	RETI
                      1864     
                      1865     
                      1866     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1867     ;
                      1868     ; PCA interrupt routine
                      1869     ;
                      1870     ; No assumptions
                      1871     ;
                      1872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1873     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          1874     	CLR	EA
0548    53E6EF        1875     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          1876     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          1877     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          1878     	PUSH	ACC
0551    C0F0          1879     	PUSH	B
0553    D2D3          1880     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          1881     	SETB	EA
                      1882     	; Get the PCA counter values
                      1883     	GET_RCP_CAPTURE_VALUES
0557    A8FB          1883+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          1883+1   MOV R1 , PCA0CPH0 
                      1884     	; Clear interrupt flag
                      1885     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          1885+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1886     	; Check which edge it is
055D    306902        1887     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          1888     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      1889     
                      1890     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        1890+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        1890+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        1890+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        1890+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        1890+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          1891     SETB FLAGS2 . 1 
                      1892     	; Read RC signal level
                      1893     	READ_RCP_INT			
0573    E580          1893+1   MOV A , P0 
0575    307601        1893+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            1893+1   CPL A  ; YES - INVERT
                      1894     	; Test RC signal level
0579    20E502        1895     JB ACC . 5 , ( $+5 ) 
057C    A185          1896     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      1897     
                      1898     	; RC pulse was high, store RC pulse start timestamp
057E    8826          1899     MOV RCP_PREV_EDGE_L , R0 
0580    8927          1900     MOV RCP_PREV_EDGE_H , R1 
0582    0207B9        1901     	LJMP	PCA_INT_EXIT				; Exit
                      1902     
                      1903     PCA_INT_FAIL_MINIMUM: 
                      1904     	; Prepare for next interrupt
                      1905     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        1905+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        1905+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        1905+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        1905+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        1905+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1906     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          1906+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          1907     CLR FLAGS2 . 1 
0598    741F          1908     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          1909     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          1910     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      1911     
059E    E19F          1912     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      1913     
05A0    7800          1914     MOV R0 , # 0 
                      1915     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          1915+1   MOV A , P0 
05A4    307601        1915+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            1915+1   CPL A  ; YES - INVERT
05A8    30E502        1916     JNB ACC . 5 , ( $+5 ) 
05AB    E19F          1917     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      1918     
                      1919     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1920     ; 
                      1921     ;  RCP 
                      1922     ; 1  1500us 
                      1923     ; 2  1500us 
                      1924     ; 
                      1925     ;	clr C
                      1926     ;	mov A, Temp1
                      1927     ;	subb A, #80h
                      1928     ;	jnc skypup_02
                      1929     ;	mov	Temp1, #RCP_MIN
                      1930     ; skypup_02:
                      1931     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1932     
05AD    8859          1933     MOV NEW_RCP , R0 
05AF    E186          1934     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      1935     
                      1936     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      1937     	; Prepare for next interrupt
                      1938     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        1938+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        1938+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        1938+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        1938+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        1938+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          1939     CLR FLAGS2 . 1 
                      1940     	; Check if pwm frequency shall be measured
05C2    205902        1941     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          1942     	AJMP	PCA_INT_FALL				; No - skip measurements
                      1943     
                      1944     	; Set second edge trig only during pwm frequency measurement
                      1945     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        1945+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        1945+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        1945+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        1945+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        1945+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      1946     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          1946+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          1947     SETB FLAGS2 . 1 
                      1948     	; Store edge data to RAM
05DA    8854          1949     MOV RCP_EDGE_L , R0 
05DC    8955          1950     MOV RCP_EDGE_H , R1 
                      1951     	; Calculate pwm frequency
05DE    C3            1952     	CLR	C
05DF    E8            1953     MOV A , R0 
05E0    9552          1954     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            1955     MOV R0 , A 
05E3    E9            1956     MOV A , R1 
05E4    9553          1957     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            1958     MOV R1 , A 
05E7    E4            1959     	CLR	A
05E8    FB            1960     MOV R3 , A 
05E9    7AFA          1961     MOV R2 , # 250 
                      1962     	; Check if pwm frequency is 12kHz
05EB    C3            1963     	CLR	C
05EC    E8            1964     MOV A , R0 
05ED    94C8          1965     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            1966     MOV A , R1 
05F0    9400          1967     	SUBB	A, #HIGH(200)
05F2    5008          1968     	JNC	PCA_INT_CHECK_8KHZ
                      1969     
05F4    E4            1970     	CLR	A
05F5    D2E4          1971     SETB ACC . 4 
05F7    FB            1972     MOV R3 , A 
05F8    7A0A          1973     MOV R2 , # 10 
05FA    C13E          1974     	AJMP	PCA_INT_RESTORE_EDGE
                      1975     
                      1976     PCA_INT_CHECK_8KHZ: 
                      1977     	; Check if pwm frequency is 8kHz
05FC    C3            1978     	CLR	C
05FD    E8            1979     MOV A , R0 
05FE    9468          1980     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            1981     MOV A , R1 
0601    9401          1982     	SUBB	A, #HIGH(360)
0603    5008          1983     	JNC	PCA_INT_CHECK_4KHZ
                      1984     
0605    E4            1985     	CLR	A
0606    D2E3          1986     SETB ACC . 3 
0608    FB            1987     MOV R3 , A 
0609    7A0F          1988     MOV R2 , # 15 
060B    C13E          1989     	AJMP	PCA_INT_RESTORE_EDGE
                      1990     
                      1991     PCA_INT_CHECK_4KHZ: 
                      1992     	; Check if pwm frequency is 4kHz
060D    C3            1993     	CLR	C
060E    E8            1994     MOV A , R0 
060F    94D0          1995     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            1996     MOV A , R1 
0612    9402          1997     	SUBB	A, #HIGH(720)
0614    5008          1998     	JNC	PCA_INT_CHECK_2KHZ
                      1999     
0616    E4            2000     	CLR	A
0617    D2E2          2001     SETB ACC . 2 
0619    FB            2002     MOV R3 , A 
061A    7A1E          2003     MOV R2 , # 30 
061C    C13E          2004     	AJMP	PCA_INT_RESTORE_EDGE
                      2005     
                      2006     PCA_INT_CHECK_2KHZ: 
                      2007     	; Check if pwm frequency is 2kHz
061E    C3            2008     	CLR	C
061F    E8            2009     MOV A , R0 
0620    94A0          2010     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2011     MOV A , R1 
0623    9405          2012     	SUBB	A, #HIGH(1440)
0625    5008          2013     	JNC	PCA_INT_CHECK_1KHZ
                      2014     
0627    E4            2015     	CLR	A
0628    D2E1          2016     SETB ACC . 1 
062A    FB            2017     MOV R3 , A 
062B    7A3C          2018     MOV R2 , # 60 
062D    C13E          2019     	AJMP	PCA_INT_RESTORE_EDGE
                      2020     
                      2021     PCA_INT_CHECK_1KHZ: 
                      2022     	; Check if pwm frequency is 1kHz
062F    C3            2023     	CLR	C
0630    E8            2024     MOV A , R0 
0631    9498          2025     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2026     MOV A , R1 
0634    9408          2027     	SUBB	A, #HIGH(2200)
0636    5006          2028     	JNC	PCA_INT_RESTORE_EDGE
                      2029     
0638    E4            2030     	CLR	A
0639    D2E0          2031     SETB ACC . 0 
063B    FB            2032     MOV R3 , A 
063C    7A78          2033     MOV R2 , # 120 
                      2034     
                      2035     PCA_INT_RESTORE_EDGE: 
                      2036     	; Calculate difference between this period and previous period
063E    C3            2037     	CLR	C
063F    E8            2038     MOV A , R0 
0640    9556          2039     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2040     MOV R4 , A 
0643    E9            2041     MOV A , R1 
0644    9557          2042     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2043     MOV R5 , A 
                      2044     	; Make positive
0647    30E708        2045     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2046     MOV A , R4 
064B    F4            2047     	CPL	A
064C    2401          2048     	ADD	A, #1
064E    FC            2049     MOV R4 , A 
064F    ED            2050     MOV A , R5 
0650    F4            2051     	CPL	A
0651    FD            2052     MOV R5 , A 
                      2053     
                      2054     PCA_INT_CHECK_DIFF: 
                      2055     	; Check difference
0652    755800        2056     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2057     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2058     
0657    C3            2059     	CLR	C
0658    EC            2060     MOV A , R4 
0659    9A            2061     SUBB A , R2 
065A    5003          2062     	JNC	PCA_INT_STORE_DATA
                      2063     
065C    755801        2064     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2065     
                      2066     PCA_INT_STORE_DATA: 
                      2067     	; Store previous period
065F    8856          2068     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2069     MOV RCP_PREV_PERIOD_H , R1 
                      2070     	; Restore edge data from RAM
0663    A854          2071     MOV R0 , RCP_EDGE_L 
0665    A955          2072     MOV R1 , RCP_EDGE_H 
                      2073     	; Store pre previous edge
0667    8852          2074     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2075     MOV RCP_PREPREV_EDGE_H , R1 
                      2076     
                      2077     PCA_INT_FALL: 
                      2078     	; RC pulse edge was second, calculate new pulse length
066B    C3            2079     	CLR	C
066C    E8            2080     MOV A , R0 
066D    9526          2081     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2082     MOV R0 , A 
0670    E9            2083     MOV A , R1 
0671    9527          2084     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2085     MOV R1 , A 
0674    307402        2086     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2087     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2088     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2089     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2090     
067E    307202        2091     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2092     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2093     
0683    E9            2094     MOV A , R1 
0684    C3            2095     	CLR	C
0685    13            2096     	RRC	A
0686    F9            2097     MOV R1 , A 
0687    E8            2098     MOV A , R0 
0688    13            2099     	RRC	A
0689    F8            2100     MOV R0 , A 
                      2101     
068A    307102        2102     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2103     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2104     
068F    E9            2105     MOV A , R1 
0690    C3            2106     	CLR	C
0691    13            2107     	RRC	A
0692    F9            2108     MOV R1 , A 
0693    E8            2109     MOV A , R0 
0694    13            2110     	RRC	A
0695    F8            2111     MOV R0 , A 
                      2112     
0696    307002        2113     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2114     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2115     
069B    E9            2116     MOV A , R1 
069C    C3            2117     	CLR	C
069D    13            2118     	RRC	A
069E    FD            2119     MOV R5 , A 
069F    E8            2120     MOV A , R0 
06A0    13            2121     	RRC	A
06A1    FC            2122     MOV R4 , A 
                      2123     	; Skip range limitation if pwm frequency measurement
06A2    205918        2124     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2125     
                      2126     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2127     	CLR	C
06A6    EC            2128     MOV A , R4 
06A7    941C          2129     	SUBB	A, #28
06A9    ED            2130     MOV A , R5 
06AA    9402          2131     	SUBB A, #2
06AC    4003          2132     	JC	($+5)						; No - proceed
                      2133     
06AE    02079F        2134     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2135     
                      2136     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2137     MOV A , R5 
06B2    7009          2138     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2139     
06B4    C3            2140     	CLR	C
06B5    EC            2141     MOV A , R4 
06B6    94C8          2142     	SUBB	A, #200
06B8    5003          2143     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2144     
06BA    02079F        2145     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2146     
                      2147     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2148     	; Calculate "1000us" plus throttle minimum
06BD    7400          2149     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2150     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2151     
                      2152     IF MODE >= 1	; Tail or multi
06C2    7888          2153     MOV R0 , # PGM_DIRECTION 
06C4    E6            2154     MOV A , @ R0 
                      2155     ENDIF
06C5    7896          2156     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2157     IF MODE >= 1	; Tail or multi
06C7    B40302        2158     	CJNE	A, #3, ($+5)
                      2159     
06CA    789E          2160     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2161     ENDIF
06CC    E6            2162     MOV A , @ R0 
                      2163     
                      2164     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2165     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2166     MOV R6 , A 
06D0    E4            2167     	CLR	A
06D1    3400          2168     	ADDC	A, #0
06D3    FF            2169     MOV R7 , A 
                      2170     
06D4    C3            2171     	CLR	C
06D5    EC            2172     MOV A , R4 
06D6    9E            2173     SUBB A , R6 
06D7    FC            2174     MOV R4 , A 
06D8    ED            2175     MOV A , R5 
06D9    9F            2176     SUBB A , R7 
06DA    FD            2177     MOV R5 , A 
                      2178     IF MODE >= 1	; Tail or multi
06DB    9208          2179     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2180     MOV R0 , # PGM_DIRECTION 
06DF    E6            2181     MOV A , @ R0 
06E0    B40322        2182     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2183     
06E3    A208          2184     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2185     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2186     
                      2187     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2188     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2189     
06EA    C2AF          2190     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2191     SETB FLAGS3 . 5 
06EE    C1F7          2192     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2193     
                      2194     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2195     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2196     
06F3    C2AF          2197     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2198     CLR FLAGS3 . 5 
                      2199     
                      2200     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2201     	ALL_NFETS_OFF
06F7    C292          2201+1   CLR P1 . 2 
06F9    C296          2201+1   CLR P1 . 6 
06FB    C295          2201+1   CLR P1 . 5 
                      2202     	ALL_PFETS_OFF
06FD    C293          2202+1   CLR P1 . 3 
06FF    C297          2202+1   CLR P1 . 7 
0701    C294          2202+1   CLR P1 . 4 
0703    D2AF          2203     	SETB	EA
                      2204     
                      2205     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2206     	MOV	C, BIT_ACCESS_INT.0
                      2207     ENDIF
0707    5017          2208     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2209     
                      2210     IF MODE >= 1	; Tail or multi
0709    E6            2211     MOV A , @ R0 
070A    B4030D        2212     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2213     
070D    EC            2214     MOV A , R4 
070E    F4            2215     	CPL	A
070F    2401          2216     	ADD	A, #1
0711    FC            2217     MOV R4 , A 
0712    ED            2218     MOV A , R5 
0713    F4            2219     	CPL	A
0714    3400          2220     	ADDC	A, #0
0716    FD            2221     MOV R5 , A 
0717    020720        2222     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2223     
                      2224     PCA_INT_PPM_UNIDIR_NEG: 
                      2225     ENDIF
071A    7800          2226     MOV R0 , # 0 
071C    7900          2227     MOV R1 , # 0 
071E    E16A          2228     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2229     
                      2230     PCA_INT_PPM_NEG_CHECKED: 
                      2231     IF MODE >= 1	; Tail or multi
0720    7888          2232     MOV R0 , # PGM_DIRECTION 
0722    E6            2233     MOV A , @ R0 
0723    B40315        2234     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2235     
0726    EC            2236     MOV A , R4 
0727    33            2237     	RLC	A
0728    FC            2238     MOV R4 A 
0729    ED            2239     MOV A , R5 
072A    33            2240     	RLC	A
072B    FD            2241     MOV R5 A 
072C    C3            2242     	CLR	C							; Subtract deadband
072D    EC            2243     MOV A , R4 
072E    9405          2244     	SUBB	A, #5		
0730    FC            2245     MOV R4 , A 
0731    ED            2246     MOV A , R5 
0732    9400          2247     	SUBB	A, #0
0734    FD            2248     MOV R5 , A 
0735    5004          2249     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2250     
0737    7C00          2251     MOV R4 , # 0 
0739    7D00          2252     MOV R5 , # 0 
                      2253     
                      2254     PCA_INT_PPM_BIDIR_DONE: 
                      2255     ENDIF
073B    C3            2256     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2257     MOV A , R4 
073D    94FF          2258     SUBB A , # 255 
073F    ED            2259     MOV A , R5 
0740    9400          2260     	SUBB	A, #0
0742    4006          2261     	JC	PCA_INT_PPM_MAX_CHECKED
                      2262     
0744    78FF          2263     MOV R0 , # 255 
0746    7900          2264     MOV R1 , # 0 
0748    E16A          2265     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2266     
                      2267     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2268     MOV A , R4 
074B    856EF0        2269     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2270     	MUL	AB
074F    C5F0          2271     	XCH	A, B
0751    A2F7          2272     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2273     	RLC	A
0754    F8            2274     MOV R0 , A 
0755    7900          2275     MOV R1 , # 0 
0757    4003          2276     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2277     	
0759    020786        2278     	JMP	PCA_INT_LIMITED			
                      2279     
                      2280     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2281     MOV R0 , # 255 
075E    7900          2282     MOV R1 , # 0 
0760    020786        2283     	JMP	PCA_INT_LIMITED			
                      2284     
                      2285     PCA_INT_PWM_DIVIDE: 
0763    E9            2286     MOV A , R1 
0764    C3            2287     	CLR	C
0765    13            2288     	RRC	A
0766    F9            2289     MOV R1 , A 
0767    E8            2290     MOV A , R0 
0768    13            2291     	RRC	A
0769    F8            2292     MOV R0 , A 
                      2293     
                      2294     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2295     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2296     MOV A , R1 
076E    6002          2297     	JZ	($+4)
                      2298     
0770    78FF          2299     MOV R0 , # 255 
                      2300     
0772    C3            2301     	CLR	C
0773    E8            2302     MOV A , R0 
0774    13            2303     	RRC	A
0775    38            2304     ADDC A , R0 
0776    F8            2305     MOV R0 , A 
0777    E4            2306     	CLR	A
0778    3400          2307     	ADDC	A, #0
077A    F9            2308     MOV R1 , A 
                      2309     
                      2310     PCA_INT_CHECK_LEGAL_RANGE: 
                      2311     	; Check that RC pulse is within legal range
077B    C3            2312     	CLR	C
077C    E8            2313     MOV A , R0 
077D    94FF          2314     SUBB A , # 255 
077F    E9            2315     MOV A , R1 
0780    9400          2316     	SUBB	A, #0
0782    4002          2317     	JC	PCA_INT_LIMITED
                      2318     
0784    78FF          2319     MOV R0 , # 255 
                      2320     
                      2321     PCA_INT_LIMITED: 
                      2322     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2323     ; 
                      2324     ;  RCP 
                      2325     ; 1  1500us 
                      2326     ; 2  1500us 
                      2327     ; 
0786    C3            2328     	CLR C
0787    E8            2329     MOV A , R0 
0788    9480          2330     	SUBB A, #80H
078A    5002          2331     	JNC SKYPUP_03
078C    7800          2332     MOV R0 , # 0 
                      2333     SKYPUP_03: 
                      2334     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2335     	; RC pulse value accepted
078E    8859          2336     MOV NEW_RCP , R0 
0790    D268          2337     SETB FLAGS2 . 0 
0792    205902        2338     JB FLAGS0 . 1 , ( $+5 ) 
0795    E19F          2339     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2340     
0797    741F          2341     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0799    F4            2342     	CPL	A
079A    552E          2343     	ANL	A, FLAGS3					; Clear all pwm frequency flags
079C    4B            2344     ORL A , R3 
079D    F52E          2345     	MOV	FLAGS3, A
                      2346     
                      2347     PCA_INT_SET_TIMEOUT: 
079F    752818        2348     MOV RCP_TIMEOUT_CNT , # 24 
07A2    741F          2349     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07A4    552E          2350     	ANL	A, FLAGS3					; Check pwm frequency flags
07A6    7003          2351     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2352     
07A8    75280A        2353     MOV RCP_TIMEOUT_CNT , # 10 
                      2354     
                      2355     PCA_INT_PPM_TIMEOUT_SET: 
07AB    305902        2356     JNB FLAGS0 . 1 , ( $+5 ) 
07AE    E1B9          2357     	AJMP PCA_INT_EXIT				; Yes - exit
                      2358     
07B0    741F          2359     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B2    552E          2360     	ANL	A, FLAGS3					; Check pwm frequency flags
07B4    6003          2361     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2362     
                      2363     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07B6    53DAFE        2363+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2364     
                      2365     PCA_INT_EXIT: 	; Exit interrupt routine	
07B9    752906        2366     MOV RCP_SKIP_CNT , # 6 
07BC    741F          2367     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07BE    552E          2368     	ANL	A, FLAGS3					; Check pwm frequency flags
07C0    7003          2369     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2370     
07C2    75290A        2371     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2372     
07C5    D0F0          2373     	POP	B			; Restore preserved registers
07C7    D0E0          2374     	POP	ACC			
07C9    D0D0          2375     	POP	PSW
07CB    C2D3          2376     	CLR	PSW.3		; Select register bank 0 for main program routines	
07CD    D2AD          2377     	SETB	ET2			; Enable timer2 interrupts
07CF    43E610        2378     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07D2    32            2379     	RETI
                      2380     
                      2381     
                      2382     
                      2383     
                      2384     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2385     ;
                      2386     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2387     ;
                      2388     ; No assumptions
                      2389     ;
                      2390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2391     WAIT1MS: 	
07D3    7901          2392     MOV R1 , # 1 
07D5    0207F1        2393     	JMP	WAITXMS_O
                      2394     
                      2395     WAIT3MS: 	
07D8    7903          2396     MOV R1 , # 3 
07DA    0207F1        2397     	JMP	WAITXMS_O
                      2398     
                      2399     WAIT10MS: 	
07DD    790A          2400     MOV R1 , # 10 
07DF    0207F1        2401     	JMP	WAITXMS_O
                      2402     
                      2403     WAIT30MS: 	
07E2    791E          2404     MOV R1 , # 30 
07E4    0207F1        2405     	JMP	WAITXMS_O
                      2406     
                      2407     WAIT100MS: 	
07E7    7964          2408     MOV R1 , # 100 
07E9    0207F1        2409     	JMP	WAITXMS_O
                      2410     
                      2411     WAIT200MS: 	
07EC    79C8          2412     MOV R1 , # 200 
07EE    0207F1        2413     	JMP	WAITXMS_O
                      2414     
                      2415     WAITXMS_O: 	; Outer loop
07F1    7817          2416     MOV R0 , # 23 
                      2417     WAITXMS_M: 	; Middle loop
07F3    E4            2418     	CLR	A
07F4    D5E0FD        2419      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
07F7    D8FA          2420     DJNZ R0 , WAITXMS_M 
07F9    D9F6          2421     DJNZ R1 , WAITXMS_O 
07FB    22            2422     	RET
                      2423     
                      2424     
                      2425     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2426     ;
                      2427     ; Beeper routines (4 different entry points) 
                      2428     ;
                      2429     ; No assumptions
                      2430     ;
                      2431     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2432     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
07FC    7A14          2433     MOV R2 , # 20 
07FE    7B78          2434     MOV R3 , # 120 
0800    020818        2435     	JMP	BEEP
                      2436     
                      2437     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0803    7A10          2438     MOV R2 , # 16 
0805    7B8C          2439     MOV R3 , # 140 
0807    020818        2440     	JMP	BEEP
                      2441     
                      2442     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
080A    7A0D          2443     MOV R2 , # 13 
080C    7BB4          2444     MOV R3 , # 180 
080E    020818        2445     	JMP	BEEP
                      2446     
                      2447     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0811    7A0B          2448     MOV R2 , # 11 
0813    7BC8          2449     MOV R3 , # 200 
0815    020818        2450     	JMP	BEEP
                      2451     
                      2452     BEEP: 	; Beep loop start
0818    AC25          2453     MOV R4 , CURRENT_PWM_LIMITED 
081A    752501        2454     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
081D    7902          2455     MOV R1 , # 2 
                      2456     BEEP_ONOFF: 
081F    B275          2457     CPL FLAGS3 . 5 
0821    E4            2458     	CLR	A
                      2459     	BPFET_OFF			; BpFET off
0822    C294          2459+1   CLR P1 . 4 
0824    D5E0FD        2460     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2461     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0827    E525          2461+1   MOV A , CURRENT_PWM_LIMITED 
0829    6002          2461+1   JZ ( $+4 ) 
082B    D295          2461+1   SETB P1 . 5 
082D    D5E0FD        2462     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2463     	BNFET_OFF			; BnFET off again
0830    C295          2463+1   CLR P1 . 5 
0832    D5E0FD        2464     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2465     	BPFET_ON			; BpFET on
0835    D294          2465+1   SETB P1 . 4 
0837    D5E0FD        2466     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2467     	; Turn on nfet
                      2468     	ANFET_ON			; AnFET on
083A    E525          2468+1   MOV A , CURRENT_PWM_LIMITED 
083C    600A          2468+1   JZ ( $+12 ) 
083E    207502        2468+1   JB FLAGS3 . 5 , ( $+5 ) 
0841    D292          2468+1   SETB P1 . 2 
0843    307502        2468+1   JNB FLAGS3 . 5 , ( $+5 ) 
0846    D296          2468+1   SETB P1 . 6 
0848    E56F          2469     	MOV	A, BEEP_STRENGTH
084A    D5E0FD        2470     	DJNZ	ACC, $		
                      2471     	; Turn off nfet
                      2472     	ANFET_OFF			; AnFET off
084D    207502        2472+1   JB FLAGS3 . 5 , ( $+5 ) 
0850    C292          2472+1   CLR P1 . 2 
0852    307502        2472+1   JNB FLAGS3 . 5 , ( $+5 ) 
0855    C296          2472+1   CLR P1 . 6 
0857    7496          2473     	MOV	A, #150		; 25s off
0859    D5E0FD        2474     	DJNZ	ACC, $		
085C    D9C1          2475     DJNZ R1 , BEEP_ONOFF 
                      2476     	; Copy variable
085E    EA            2477     MOV A , R2 
085F    F8            2478     MOV R0 , A 
                      2479     BEEP_OFF: 		; Fets off loop
0860    D5E0FD        2480     	DJNZ	ACC, $
0863    D8FB          2481     DJNZ R0 , BEEP_OFF 
0865    DBB1          2482     DJNZ R3 , BEEP 
                      2483     	BPFET_OFF			; BpFET off
0867    C294          2483+1   CLR P1 . 4 
0869    8C25          2484     MOV CURRENT_PWM_LIMITED , R4 
086B    22            2485     	RET
                      2486     
                      2487     
                      2488     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2489     ;
                      2490     ; Division 16bit unsigned by 16bit unsigned
                      2491     ;
                      2492     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2493     ; Result will be in Temp2/Temp1
                      2494     ;
                      2495     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2496     DIV_U16_BY_U16: 	
086C    C3            2497     	CLR	C       
086D    7C00          2498     MOV R4 , # 0 
086F    7D00          2499     MOV R5 , # 0 
0871    75F000        2500     	MOV	B, #0
                      2501     DIV_U16_BY_U16_DIV1: 
0874    05F0          2502     	INC	B      			; Increment counter for each left shift
0876    EA            2503     MOV A , R2 
0877    33            2504     	RLC	A      		
0878    FA            2505     MOV R2 , A 
0879    EB            2506     MOV A , R3 
087A    33            2507     	RLC	A      	  	
087B    FB            2508     MOV R3 , A 
087C    50F6          2509     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2510     DIV_U16_BY_U16_DIV2:         
087E    EB            2511     MOV A , R3 
087F    13            2512     	RRC	A      
0880    FB            2513     MOV R3 , A 
0881    EA            2514     MOV A , R2 
0882    13            2515     	RRC	A      
0883    FA            2516     MOV R2 , A 
0884    C3            2517     	CLR	C      
0885    E9            2518     MOV A , R1 
0886    FF            2519     MOV R7 , A 
0887    E8            2520     MOV A , R0 
0888    FE            2521     MOV R6 , A 
0889    E8            2522     MOV A , R0 
088A    9A            2523     SUBB A , R2 
088B    F8            2524     MOV R0 , A 
088C    E9            2525     MOV A , R1 
088D    9B            2526     SUBB A , R3 
088E    F9            2527     MOV R1 , A 
088F    5004          2528     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0891    EF            2529     MOV A , R7 
0892    F9            2530     MOV R1 , A 
0893    EE            2531     MOV A , R6 
0894    F8            2532     MOV R0 , A 
                      2533     DIV_U16_BY_U16_DIV3: 
0895    B3            2534     	CPL	C      			; Invert carry, so it can be directly copied into result
0896    EC            2535     MOV A , R4 
0897    33            2536     	RLC	A      			; Shift carry flag into temporary result
0898    FC            2537     MOV R4 , A 
0899    ED            2538     MOV A , R5 
089A    33            2539     	RLC	A
089B    FD            2540     MOV R5 , A 
089C    D5F0DF        2541     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
089F    ED            2542     MOV A , R5 
08A0    F9            2543     MOV R1 , A 
08A1    EC            2544     MOV A , R4 
08A2    F8            2545     MOV R0 , A 
08A3    22            2546     	RET
                      2547     
                      2548     
                      2549     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2550     ;
                      2551     ; Multiplication 16bit signed by 8bit unsigned
                      2552     ;
                      2553     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2554     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2555     ;
                      2556     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2557     MULT_S16_BY_U8_DIV_16: 
08A4    E8            2558     MOV A , R0 
08A5    89F0          2559     MOV B , R1 
08A7    8A20          2560     MOV BIT_ACCESS , R2 
08A9    D2D4          2561     	SETB	PSW.4		; Select register bank 2 for math routines
08AB    F8            2562     MOV R0 , A 
08AC    A9F0          2563     MOV R1 , B 
08AE    7B00          2564     MOV R3 , # 0 
08B0    30F70B        2565     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2566     
08B3    7BFF          2567     MOV R3 , # 0FFH 
08B5    F4            2568     	CPL	A
08B6    2401          2569     	ADD	A, #1
08B8    F8            2570     MOV R0 , A 
08B9    E9            2571     MOV A , R1 
08BA    F4            2572     	CPL	A
08BB    3400          2573     	ADDC	A, #0
08BD    F9            2574     MOV R1 , A 
                      2575     MULT_S16_BY_U8_POSITIVE: 
08BE    E8            2576     MOV A , R0 
08BF    8520F0        2577     	MOV	B, BIT_ACCESS
08C2    A4            2578     	MUL	AB
08C3    ADF0          2579     MOV R5 , B 
08C5    F8            2580     MOV R0 , A 
08C6    E9            2581     MOV A , R1 
08C7    8520F0        2582     	MOV	B, BIT_ACCESS
08CA    A4            2583     	MUL	AB
08CB    AFF0          2584     MOV R7 , B 
08CD    FE            2585     MOV R6 , A 
08CE    ED            2586     MOV A , R5 
08CF    2E            2587     ADD A , R6 
08D0    F9            2588     MOV R1 , A 
08D1    7400          2589     	MOV	A, #0
08D3    3F            2590     ADDC A , R7 
08D4    FA            2591     MOV R2 , A 
08D5    7C04          2592     MOV R4 , # 4 
                      2593     MULT_S16_BY_U8_DIV_LOOP: 
08D7    C3            2594     	CLR	C			; Rotate right 
08D8    EA            2595     MOV A , R2 
08D9    13            2596     	RRC	A
08DA    FA            2597     MOV R2 , A 
08DB    E9            2598     MOV A , R1 
08DC    13            2599     	RRC	A
08DD    F9            2600     MOV R1 , A 
08DE    E8            2601     MOV A , R0 
08DF    13            2602     	RRC	A
08E0    F8            2603     MOV R0 , A 
08E1    DCF4          2604     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2605     
08E3    8BF0          2606     MOV B , R3 
08E5    30F70A        2607     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2608     
08E8    E8            2609     MOV A , R0 
08E9    F4            2610     	CPL	A
08EA    2401          2611     	ADD	A, #1
08EC    F8            2612     MOV R0 , A 
08ED    E9            2613     MOV A , R1 
08EE    F4            2614     	CPL	A
08EF    3400          2615     	ADDC	A, #0
08F1    F9            2616     MOV R1 , A 
                      2617     
                      2618     MULT_S16_BY_U8_EXIT: 
08F2    E8            2619     MOV A , R0 
08F3    89F0          2620     MOV B , R1 
08F5    C2D4          2621     	CLR	PSW.4		; Select normal register bank
08F7    F8            2622     MOV R0 , A 
08F8    A9F0          2623     MOV R1 , B 
08FA    22            2624     	RET
                      2625     
                      2626     
                      2627     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2628     ;
                      2629     ; Calculate governor routines
                      2630     ;
                      2631     ; No assumptions
                      2632     ;
                      2633     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2634     ; The governor task is split into several routines in order to distribute processing time
                      2635     ;
                      2636     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2637     ; First governor routine - calculate governor target
                      2638     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      2778     IF MODE == 2	; Multi
                      2779     CALC_GOVERNOR_TARGET: 
08FB    7882          2780     MOV R0 , # PGM_GOV_MODE 
08FD    B60403        2781     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0900    020957        2782     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      2783     
                      2784     GOVERNOR_TARGET_CALC: 
                      2785     	; Stop governor for stop RC pulse	
0903    C3            2786     	CLR	C
0904    E559          2787     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0906    9401          2788     SUBB A , # 1 
0908    4003          2789     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      2790     
090A    020920        2791     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      2792     
                      2793     GOVERNOR_DEACTIVATE: 
090D    852224        2794     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0910    E4            2795     	CLR	A
0911    F540          2796     	MOV	GOV_TARGET_L, A			; Set target to zero
0913    F541          2797     	MOV	GOV_TARGET_H, A
0915    F542          2798     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0917    F543          2799     	MOV	GOV_INTEGRAL_H, A
0919    F544          2800     	MOV	GOV_INTEGRAL_X, A
091B    F549          2801     	MOV	GOV_ACTIVE, A
091D    020957        2802     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      2803     
                      2804     GOVERNOR_ACTIVATE: 
0920    7882          2805     MOV R0 , # PGM_GOV_MODE 
0922    E6            2806     MOV A , @ R0 
0923    FC            2807     MOV R4 , A 
0924    754901        2808     	MOV	GOV_ACTIVE, #1
0927    E522          2809     	MOV	A, REQUESTED_PWM			; Load requested pwm
0929    F523          2810     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      2811     	; Calculate comm period target 2*(51000/Requested_Pwm)
092B    7838          2812     MOV R0 , # 38H 
092D    79C7          2813     MOV R1 , # 0C7H 
092F    AA3C          2814     MOV R2 , COMM_PERIOD4X_L 
0931    AB3D          2815     MOV R3 , COMM_PERIOD4X_H 
                      2816     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
0933    C3            2817     	CLR	C
0934    EB            2818     MOV A , R3 
0935    13            2819     	RRC	A
0936    FB            2820     MOV R3 , A 
0937    EA            2821     MOV A , R2 
0938    13            2822     	RRC	A
0939    FA            2823     MOV R2 , A 
                      2824     	; Check range
093A    EC            2825     MOV A , R4 
093B    14            2826     	DEC	A
093C    6013          2827     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      2828     GOVERNOR_ACTIVATE_100K: 
093E    C3            2829     	CLR	C
093F    EB            2830     MOV A , R3 
0940    13            2831     	RRC	A
0941    FB            2832     MOV R3 , A 
0942    EA            2833     MOV A , R2 
0943    13            2834     	RRC	A
0944    FA            2835     MOV R2 , A 
0945    EC            2836     MOV A , R4 
0946    14            2837     	DEC	A
0947    14            2838     	DEC	A
0948    6007          2839     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      2840     GOVERNOR_ACTIVATE_50K: 
094A    C3            2841     	CLR	C
094B    EB            2842     MOV A , R3 
094C    13            2843     	RRC	A
094D    FB            2844     MOV R3 , A 
094E    EA            2845     MOV A , R2 
094F    13            2846     	RRC	A
0950    FA            2847     MOV R2 , A 
                      2848     GOVERNOR_ACTIVATE_RANGE_SET: 
0951    116C          2849     	CALL	DIV_U16_BY_U16
                      2850     	; Store governor target
0953    8840          2851     MOV GOV_TARGET_L , R0 
0955    8941          2852     MOV GOV_TARGET_H , R1 
                      2853     CALC_GOVERNOR_TARGET_EXIT: 
0957    22            2854     	RET						
                      2855     ENDIF
                      2856     
                      2857     
                      2858     ; Second governor routine - calculate governor proportional error
                      2859     CALC_GOVERNOR_PROP_ERROR: 
                      2860     	; Exit if governor is inactive
0958    E549          2861     	MOV	A, GOV_ACTIVE
095A    6034          2862     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      2863     
                      2864     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      2882     IF MODE == 2	; Multi
                      2883     	; Calculate error
095C    C3            2884     	CLR	C
095D    E540          2885     	MOV	A, GOV_TARGET_L
095F    9523          2886     	SUBB	A, GOVERNOR_REQ_PWM
0961    F8            2887     MOV R0 , A 
0962    E541          2888     	MOV	A, GOV_TARGET_H
0964    9400          2889     	SUBB	A, #0
0966    F9            2890     MOV R1 , A 
                      2891     ENDIF
                      2892     	; Check error and limit
0967    500C          2893     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      2894     
0969    C3            2895     	CLR	C
096A    E8            2896     MOV A , R0 
096B    9480          2897     	SUBB	A, #80H					; Is error too negative?
096D    E9            2898     MOV A , R1 
096E    94FF          2899     	SUBB	A, #0FFH
0970    4016          2900     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0972    02098C        2901     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2902     
                      2903     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0975    C3            2904     	CLR	C
0976    E8            2905     MOV A , R0 
0977    947F          2906     	SUBB	A, #7FH					; Is error too positive?
0979    E9            2907     MOV A , R1 
097A    9400          2908     	SUBB	A, #00H
097C    5003          2909     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
097E    02098C        2910     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2911     
                      2912     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0981    787F          2913     MOV R0 , # 7FH 
0983    7900          2914     MOV R1 , # 00H 
0985    02098C        2915     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2916     
                      2917     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0988    7880          2918     MOV R0 , # 80H 
098A    79FF          2919     MOV R1 , # 0FFH 
                      2920     
                      2921     GOVERNOR_STORE_PROP_ERROR: 
                      2922     	; Store proportional
098C    8845          2923     MOV GOV_PROPORTIONAL_L , R0 
098E    8946          2924     MOV GOV_PROPORTIONAL_H , R1 
                      2925     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0990    22            2926     	RET						
                      2927     
                      2928     
                      2929     ; Third governor routine - calculate governor integral error
                      2930     CALC_GOVERNOR_INT_ERROR: 
                      2931     	; Exit if governor is inactive
0991    E549          2932     	MOV	A, GOV_ACTIVE
0993    6058          2933     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      2934     
                      2935     	; Add proportional to integral
0995    E545          2936     	MOV	A, GOV_PROPORTIONAL_L
0997    2542          2937     	ADD	A, GOV_INTEGRAL_L
0999    F8            2938     MOV R0 , A 
099A    E546          2939     	MOV	A, GOV_PROPORTIONAL_H
099C    3543          2940     	ADDC	A, GOV_INTEGRAL_H
099E    F9            2941     MOV R1 , A 
099F    854620        2942     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09A2    E4            2943     	CLR	A
09A3    300701        2944     	JNB	BIT_ACCESS.7, ($+4)			
09A6    F4            2945     	CPL	A
09A7    3544          2946     	ADDC	A, GOV_INTEGRAL_X
09A9    FA            2947     MOV R2 , A 
                      2948     	; Check integral and limit
09AA    30E709        2949     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      2950     
09AD    C3            2951     	CLR	C
09AE    EA            2952     MOV A , R2 
09AF    94F0          2953     	SUBB	A, #0F0H					; Is error too negative?
09B1    4015          2954     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09B3    0209CE        2955     	JMP	GOVERNOR_CHECK_PWM
                      2956     
                      2957     GOVERNOR_CHECK_INT_LIMIT_POS: 
09B6    C3            2958     	CLR	C
09B7    EA            2959     MOV A , R2 
09B8    940F          2960     	SUBB	A, #0FH					; Is error too positive?
09BA    5003          2961     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09BC    0209CE        2962     	JMP	GOVERNOR_CHECK_PWM
                      2963     
                      2964     GOVERNOR_LIMIT_INT_ERROR_POS: 
09BF    78FF          2965     MOV R0 , # 0FFH 
09C1    79FF          2966     MOV R1 , # 0FFH 
09C3    7A0F          2967     MOV R2 , # 0FH 
09C5    0209CE        2968     	JMP	GOVERNOR_CHECK_PWM
                      2969     
                      2970     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09C8    7800          2971     MOV R0 , # 00H 
09CA    7900          2972     MOV R1 , # 00H 
09CC    7AF0          2973     MOV R2 , # 0F0H 
                      2974     
                      2975     GOVERNOR_CHECK_PWM: 
                      2976     	; Check current pwm
09CE    C3            2977     	CLR	C
09CF    E524          2978     	MOV	A, CURRENT_PWM
09D1    955E          2979     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09D3    5006          2980     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      2981     
09D5    E524          2982     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09D7    6009          2983     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      2984     
09D9    21E7          2985     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      2986     
                      2987     GOVERNOR_INT_MAX_PWM: 
09DB    E546          2988     	MOV	A, GOV_PROPORTIONAL_H
09DD    20E70D        2989     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      2990     
09E0    21E7          2991     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      2992     
                      2993     GOVERNOR_INT_MIN_PWM: 
09E2    E546          2994     	MOV	A, GOV_PROPORTIONAL_H
09E4    30E706        2995     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      2996     
                      2997     GOVERNOR_STORE_INT_ERROR: 
                      2998     	; Store integral
09E7    8842          2999     MOV GOV_INTEGRAL_L , R0 
09E9    8943          3000     MOV GOV_INTEGRAL_H , R1 
09EB    8A44          3001     MOV GOV_INTEGRAL_X , R2 
                      3002     CALC_GOVERNOR_INT_ERROR_EXIT: 
09ED    22            3003     	RET						
                      3004     
                      3005     
                      3006     ; Fourth governor routine - calculate governor proportional correction
                      3007     CALC_GOVERNOR_PROP_CORRECTION: 
                      3008     	; Exit if governor is inactive
09EE    E549          3009     	MOV	A, GOV_ACTIVE
09F0    7003          3010     	JNZ	CALC_GOVERNOR_PROP_CORR
09F2    020A51        3011     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3012     
                      3013     CALC_GOVERNOR_PROP_CORR: 
                      3014     	; Load proportional gain
09F5    789F          3015     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
09F7    E6            3016     MOV A , @ R0 
09F8    FA            3017     MOV R2 , A 
                      3018     	; Load proportional
09F9    C3            3019     	CLR	C
09FA    E545          3020     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
09FC    33            3021     	RLC	A
09FD    F8            3022     MOV R0 , A 
09FE    E546          3023     	MOV	A, GOV_PROPORTIONAL_H
0A00    33            3024     	RLC	A
0A01    F9            3025     MOV R1 , A 
                      3026     	; Apply gain
0A02    11A4          3027     	CALL	MULT_S16_BY_U8_DIV_16
                      3028     	; Check error and limit (to low byte)
0A04    E9            3029     MOV A , R1 
0A05    30E70B        3030     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3031     
0A08    C3            3032     	CLR	C
0A09    E8            3033     MOV A , R0 
0A0A    9480          3034     	SUBB	A, #80H					; Is error too negative?
0A0C    E9            3035     MOV A , R1 
0A0D    94FF          3036     	SUBB	A, #0FFH
0A0F    4013          3037     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A11    4128          3038     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3039     
                      3040     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A13    C3            3041     	CLR	C
0A14    E8            3042     MOV A , R0 
0A15    947F          3043     	SUBB	A, #7FH					; Is error too positive?
0A17    E9            3044     MOV A , R1 
0A18    9400          3045     	SUBB	A, #00H
0A1A    5002          3046     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A1C    4128          3047     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3048     
                      3049     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A1E    787F          3050     MOV R0 , # 7FH 
0A20    7900          3051     MOV R1 , # 00H 
0A22    4128          3052     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3053     
                      3054     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A24    7880          3055     MOV R0 , # 80H 
0A26    79FF          3056     MOV R1 , # 0FFH 
                      3057     
                      3058     GOVERNOR_APPLY_PROP_CORR: 
                      3059     	; Test proportional sign
0A28    E8            3060     MOV A , R0 
0A29    20E715        3061     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3062     
                      3063     	; Subtract positive proportional
0A2C    C3            3064     	CLR	C
0A2D    E523          3065     	MOV	A, GOVERNOR_REQ_PWM
0A2F    98            3066     SUBB A , R0 
0A30    F8            3067     MOV R0 , A 
                      3068     	; Check result
0A31    4009          3069     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3070     
0A33    C3            3071     	CLR	C
0A34    E8            3072     MOV A , R0 
0A35    9401          3073     	SUBB	A, #1
0A37    4003          3074     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A39    020A4F        3075     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3076     
                      3077     GOVERNOR_CORR_PROP_MIN_PWM: 
0A3C    7801          3078     MOV R0 , # 1 
0A3E    020A4F        3079     	JMP	GOVERNOR_STORE_PROP_CORR
                      3080     
                      3081     GOVERNOR_CORR_NEG_PROP: 
                      3082     	; Add negative proportional
0A41    E8            3083     MOV A , R0 
0A42    F4            3084     	CPL	A
0A43    2401          3085     	ADD	A, #1
0A45    2523          3086     	ADD	A, GOVERNOR_REQ_PWM
0A47    F8            3087     MOV R0 , A 
                      3088     	; Check result
0A48    4003          3089     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A4A    020A4F        3090     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3091     
                      3092     GOVERNOR_CORR_PROP_MAX_PWM: 
0A4D    78FF          3093     MOV R0 , # 255 
                      3094     GOVERNOR_STORE_PROP_CORR: 
                      3095     	; Store proportional pwm
0A4F    8847          3096     MOV GOV_PROP_PWM , R0 
                      3097     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A51    22            3098     	RET
                      3099     
                      3100     
                      3101     ; Fifth governor routine - calculate governor integral correction
                      3102     CALC_GOVERNOR_INT_CORRECTION: 
                      3103     	; Exit if governor is inactive
0A52    E549          3104     	MOV	A, GOV_ACTIVE
0A54    7003          3105     	JNZ	CALC_GOVERNOR_INT_CORR
0A56    020AB3        3106     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3107     
                      3108     CALC_GOVERNOR_INT_CORR: 
                      3109     	; Load integral gain
0A59    78A0          3110     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A5B    E6            3111     MOV A , @ R0 
0A5C    FA            3112     MOV R2 , A 
                      3113     	; Load integral
0A5D    A843          3114     MOV R0 , GOV_INTEGRAL_H 
0A5F    A944          3115     MOV R1 , GOV_INTEGRAL_X 
                      3116     	; Apply gain
0A61    11A4          3117     	CALL	MULT_S16_BY_U8_DIV_16
                      3118     	; Check integral and limit
0A63    E9            3119     MOV A , R1 
0A64    30E70C        3120     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3121     
0A67    C3            3122     	CLR	C
0A68    E8            3123     MOV A , R0 
0A69    9401          3124     	SUBB	A, #01H					; Is integral too negative?
0A6B    E9            3125     MOV A , R1 
0A6C    94FF          3126     	SUBB	A, #0FFH
0A6E    4016          3127     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A70    020A8A        3128     	JMP	GOVERNOR_APPLY_INT_CORR
                      3129     
                      3130     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A73    C3            3131     	CLR	C
0A74    E8            3132     MOV A , R0 
0A75    94FF          3133     	SUBB	A, #0FFH					; Is integral too positive?
0A77    E9            3134     MOV A , R1 
0A78    9400          3135     	SUBB	A, #00H
0A7A    5003          3136     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A7C    020A8A        3137     	JMP	GOVERNOR_APPLY_INT_CORR
                      3138     
                      3139     GOVERNOR_LIMIT_INT_CORR_POS: 
0A7F    78FF          3140     MOV R0 , # 0FFH 
0A81    7900          3141     MOV R1 , # 00H 
0A83    020A8A        3142     	JMP	GOVERNOR_APPLY_INT_CORR
                      3143     
                      3144     GOVERNOR_LIMIT_INT_CORR_NEG: 
0A86    7801          3145     MOV R0 , # 01H 
0A88    79FF          3146     MOV R1 , # 0FFH 
                      3147     
                      3148     GOVERNOR_APPLY_INT_CORR: 
                      3149     	; Test integral sign
0A8A    E9            3150     MOV A , R1 
0A8B    20E715        3151     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3152     
                      3153     	; Subtract positive integral
0A8E    C3            3154     	CLR	C
0A8F    E547          3155     	MOV	A, GOV_PROP_PWM
0A91    98            3156     SUBB A , R0 
0A92    F8            3157     MOV R0 , A 
                      3158     	; Check result
0A93    4009          3159     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3160     
0A95    C3            3161     	CLR	C
0A96    E8            3162     MOV A , R0 
0A97    9401          3163     	SUBB	A, #1
0A99    4003          3164     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0A9B    020AB1        3165     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3166     
                      3167     GOVERNOR_CORR_INT_MIN_PWM: 
0A9E    7800          3168     MOV R0 , # 0 
0AA0    020AB1        3169     	JMP	GOVERNOR_STORE_INT_CORR
                      3170     
                      3171     GOVERNOR_CORR_NEG_INT: 
                      3172     	; Add negative integral
0AA3    E8            3173     MOV A , R0 
0AA4    F4            3174     	CPL	A
0AA5    2401          3175     	ADD	A, #1
0AA7    2547          3176     	ADD	A, GOV_PROP_PWM
0AA9    F8            3177     MOV R0 , A 
                      3178     	; Check result
0AAA    4003          3179     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AAC    020AB1        3180     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3181     
                      3182     GOVERNOR_CORR_INT_MAX_PWM: 
0AAF    78FF          3183     MOV R0 , # 255 
                      3184     GOVERNOR_STORE_INT_CORR: 
                      3185     	; Store current pwm
0AB1    8824          3186     MOV CURRENT_PWM , R0 
                      3187     CALC_GOVERNOR_INT_CORR_EXIT: 
0AB3    22            3188     	RET
                      3189     
                      3190     
                      3191     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3192     ;
                      3193     ; Measure lipo cells
                      3194     ;
                      3195     ; No assumptions
                      3196     ;
                      3197     ; Measure voltage and calculate lipo cells
                      3198     ;
                      3199     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3200     MEASURE_LIPO_CELLS: 
                      3201     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3205     MEASURE_LIPO_START: 
                      3206     	; Load programmed low voltage limit
0AB4    7883          3207     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AB6    E6            3208     MOV A , @ R0 
0AB7    F520          3209     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3210     	; Set commutation to BpFET on
0AB9    120FD2        3211     	CALL	COMM5COMM6			
                      3212     	; Start adc
                      3213     	START_ADC 
0ABC    75E890        3213+1   MOV ADC0CN , # 90H  ; ADC START
                      3214     	; Wait for ADC reference to settle, and then start again
0ABF    1207D3        3215     	CALL	WAIT1MS
                      3216     	START_ADC
0AC2    75E890        3216+1   MOV ADC0CN , # 90H  ; ADC START
                      3217     	; Wait for ADC conversion to complete
                      3218     MEASURE_LIPO_WAIT_ADC: 
                      3219     	GET_ADC_STATUS 
0AC5    E5E8          3219+1   MOV A , ADC0CN 
0AC7    20ECFB        3220     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3221     	; Read ADC result
                      3222     	READ_ADC_RESULT
0ACA    A8BD          3222+1   MOV R0 , ADC0L 
0ACC    A9BE          3222+1   MOV R1 , ADC0H 
                      3223     	; Stop ADC
                      3224     	STOP_ADC
                      3225     	; Switch power off
0ACE    121078        3226     	CALL	SWITCH_POWER_OFF		
                      3227     	; Set limit step
0AD1    756A55        3228     MOV LIPO_ADC_LIMIT_L , # 85 
0AD4    756B00        3229     MOV LIPO_ADC_LIMIT_H , # 0 
0AD7    C3            3230     	CLR	C
0AD8    7400          3231     MOV A , # 0 
0ADA    13            3232     	RRC	A
0ADB    FD            3233     MOV R5 , A 
0ADC    7455          3234     MOV A , # 85 
0ADE    13            3235     	RRC	A
0ADF    FC            3236     MOV R4 , A 
0AE0    7455          3237     MOV A , # 85 
0AE2    2C            3238     ADD A , R4 
0AE3    FC            3239     MOV R4 , A 
0AE4    7400          3240     MOV A , # 0 
0AE6    3D            3241     ADDC A , R5 
0AE7    FD            3242     MOV R5 , A 
0AE8    EC            3243     MOV A , R4 
0AE9    FA            3244     MOV R2 , A 
0AEA    ED            3245     MOV A , R5 
0AEB    FB            3246     MOV R3 , A 
                      3247     MEASURE_LIPO_CELL_LOOP: 
                      3248     	; Check voltage against xS lower limit
0AEC    C3            3249     	CLR	C
0AED    E8            3250     MOV A , R0 
0AEE    9A            3251     SUBB A , R2 
0AEF    E9            3252     MOV A , R1 
0AF0    9B            3253     SUBB A , R3 
0AF1    4014          3254     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3255     
                      3256     	; Set xS voltage limit
0AF3    E56A          3257     	MOV	A, LIPO_ADC_LIMIT_L		
0AF5    2455          3258     ADD A , # 85 
0AF7    F56A          3259     	MOV	LIPO_ADC_LIMIT_L, A
0AF9    E56B          3260     	MOV	A, LIPO_ADC_LIMIT_H		
0AFB    3400          3261     ADDC A , # 0 
0AFD    F56B          3262     	MOV	LIPO_ADC_LIMIT_H, A
                      3263     	; Set (x+1)S lower limit
0AFF    EA            3264     MOV A , R2 
0B00    2C            3265     ADD A , R4 
0B01    FA            3266     MOV R2 , A 
0B02    EB            3267     MOV A , R3 
0B03    3D            3268     ADDC A , R5 
0B04    FB            3269     MOV R3 , A 
0B05    80E5          3270     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3271     
                      3272     MEASURE_LIPO_ADJUST: 
0B07    AE6A          3273     MOV R6 , LIPO_ADC_LIMIT_L 
0B09    AF6B          3274     MOV R7 , LIPO_ADC_LIMIT_H 
                      3275     	; Calculate 3.125%
0B0B    C3            3276     	CLR	C
0B0C    E56B          3277     	MOV	A, LIPO_ADC_LIMIT_H
0B0E    13            3278     	RRC	A
0B0F    F9            3279     MOV R1 , A 
0B10    E56A          3280     	MOV	A, LIPO_ADC_LIMIT_L	
0B12    13            3281     	RRC	A
0B13    F8            3282     MOV R0 , A 
0B14    C3            3283     	CLR	C
0B15    E9            3284     MOV A , R1 
0B16    13            3285     	RRC	A
0B17    F9            3286     MOV R1 , A 
0B18    E8            3287     MOV A , R0 
0B19    13            3288     	RRC	A
0B1A    F8            3289     MOV R0 , A 
0B1B    E56A          3290     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B1D    28            3291     ADD A , R0 
0B1E    F568          3292     	MOV	LIPO_ADC_REFERENCE_L, A
0B20    E56B          3293     	MOV	A, LIPO_ADC_LIMIT_H
0B22    39            3294     ADDC A , R1 
0B23    F569          3295     	MOV	LIPO_ADC_REFERENCE_H, A
                      3296     	; Divide three times to get to 3.125%
0B25    7A03          3297     MOV R2 , # 3 
                      3298     MEASURE_LIPO_DIVIDE_LOOP: 
0B27    C3            3299     	CLR	C
0B28    E9            3300     MOV A , R1 
0B29    13            3301     	RRC	A
0B2A    F9            3302     MOV R1 , A 
0B2B    E8            3303     MOV A , R0 
0B2C    13            3304     	RRC	A
0B2D    F8            3305     MOV R0 , A 
0B2E    DAF7          3306     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3307     
                      3308     	; Add the programmed number of 0.1V (or 3.125% increments)
0B30    AA20          3309     MOV R2 , BIT_ACCESS 
0B32    1A            3310     DEC R2 
0B33    7009          3311     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3312     
0B35    756A00        3313     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B38    756B00        3314     	MOV	LIPO_ADC_LIMIT_H, #0
0B3B    020B4E        3315     	JMP	MEASURE_LIPO_EXIT	
                      3316     
                      3317     MEASURE_LIPO_LIMIT_ON: 
0B3E    1A            3318     DEC R2 
0B3F    EA            3319     MOV A , R2 
0B40    6008          3320     	JZ	MEASURE_LIPO_UPDATE
                      3321     
                      3322     MEASURE_LIPO_ADD_LOOP: 
0B42    EE            3323     MOV A , R6 
0B43    28            3324     ADD A , R0 
0B44    FE            3325     MOV R6 , A 
0B45    EF            3326     MOV A , R7 
0B46    39            3327     ADDC A , R1 
0B47    FF            3328     MOV R7 , A 
0B48    DAF8          3329     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3330     
                      3331     MEASURE_LIPO_UPDATE: 
                      3332     	; Set ADC limit
0B4A    8E6A          3333     MOV LIPO_ADC_LIMIT_L , R6 
0B4C    8F6B          3334     MOV LIPO_ADC_LIMIT_H , R7 
                      3335     MEASURE_LIPO_EXIT: 
0B4E    22            3336     	RET
                      3337     
                      3338     
                      3339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3340     ;
                      3341     ; Start ADC conversion
                      3342     ;
                      3343     ; No assumptions
                      3344     ;
                      3345     ; Start conversion used for measuring power supply voltage
                      3346     ;
                      3347     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3348     START_ADC_CONVERSION: 
                      3349     	; Start adc
                      3350     	START_ADC 
0B4F    75E890        3350+1   MOV ADC0CN , # 90H  ; ADC START
0B52    22            3351     	RET
                      3352     
                      3353     
                      3354     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3355     ;
                      3356     ; Check temperature, power supply voltage and limit power
                      3357     ;
                      3358     ; No assumptions
                      3359     ;
                      3360     ; Used to limit main motor power in order to maintain the required voltage
                      3361     ;
                      3362     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3363     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3364     	; Load programmed low voltage limit
0B53    7883          3365     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B55    E6            3366     MOV A , @ R0 
0B56    FF            3367     MOV R7 , A 
                      3368     	; Wait for ADC conversion to complete
                      3369     	GET_ADC_STATUS 
0B57    E5E8          3369+1   MOV A , ADC0CN 
0B59    20ECF7        3370     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3371     	; Read ADC result
                      3372     	READ_ADC_RESULT
0B5C    A8BD          3372+1   MOV R0 , ADC0L 
0B5E    A9BE          3372+1   MOV R1 , ADC0H 
                      3373     	; Stop ADC
                      3374     	STOP_ADC
                      3375     
0B60    056C          3376     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B62    C3            3377     	CLR	C
0B63    E56C          3378     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B65    9408          3379     SUBB A , # 8 
0B67    404B          3380     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3381     
0B69    756C00        3382     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B6C    E9            3383     MOV A , R1 
0B6D    7007          3384     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3385     
0B6F    E56D          3386     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B71    601B          3387     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B73    020B82        3388     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3389     
                      3390     TEMP_AVERAGE_INC_DEC: 
0B76    C3            3391     	CLR	C
0B77    E8            3392     MOV A , R0 
0B78    956D          3393     	SUBB	A, CURRENT_AVERAGE_TEMP
0B7A    6010          3394     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3395     
0B7C    E56D          3396     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0B7E    5006          3397     	JNC	TEMP_AVERAGE_INC				
                      3398     
0B80    600C          3399     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3400     TEMP_AVERAGE_DEC: 
0B82    14            3401     	DEC	A						; Decrement average
0B83    020B8E        3402     	JMP	TEMP_AVERAGE_UPDATED
                      3403     
                      3404     TEMP_AVERAGE_INC: 
0B86    04            3405     	INC	A						; Increment average
0B87    60F9          3406     	JZ	TEMP_AVERAGE_DEC
0B89    020B8E        3407     	JMP	TEMP_AVERAGE_UPDATED
                      3408     
                      3409     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0B8C    E56D          3410     	MOV	A, CURRENT_AVERAGE_TEMP
                      3411     TEMP_AVERAGE_UPDATED: 
0B8E    F56D          3412     	MOV	CURRENT_AVERAGE_TEMP, A
0B90    C3            3413     	CLR	C
0B91    9472          3414     SUBB A , # 114 
0B93    401B          3415     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3416     
0B95    755EC0        3417     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3418     
0B98    C3            3419     	CLR	C
0B99    9404          3420     SUBB A , # 4 
0B9B    4013          3421     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3422     
0B9D    755E80        3423     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3424     
0BA0    C3            3425     	CLR	C
0BA1    9404          3426     SUBB A , # 4 
0BA3    400B          3427     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3428     
0BA5    755E40        3429     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3430     
0BA8    C3            3431     	CLR	C
0BA9    9404          3432     SUBB A , # 4 
0BAB    4003          3433     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3434     
0BAD    755E00        3435     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3436     
                      3437     TEMP_CHECK_EXIT: 
                      3438     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BB0    75BB09        3438+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BB3    22            3439     	RET
                      3440     
                      3441     CHECK_VOLTAGE_START: 
                      3442     IF MODE == 0 OR MODE == 2	; Main or multi
                      3443     	; Check if low voltage limiting is enabled
0BB4    EF            3444     MOV A , R7 
0BB5    C3            3445     	CLR	C
0BB6    9401          3446     	SUBB	A, #1					; Is low voltage limit disabled?
0BB8    601B          3447     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3448     
                      3449     	; Check if ADC is saturated
0BBA    C3            3450     	CLR	C
0BBB    E8            3451     MOV A , R0 
0BBC    94FF          3452     	SUBB	A, #0FFH
0BBE    E9            3453     MOV A , R1 
0BBF    9403          3454     	SUBB	A, #03H
0BC1    5012          3455     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3456     
                      3457     	; Check voltage against limit
0BC3    C3            3458     	CLR	C
0BC4    E8            3459     MOV A , R0 
0BC5    956A          3460     	SUBB	A, LIPO_ADC_LIMIT_L
0BC7    E9            3461     MOV A , R1 
0BC8    956B          3462     	SUBB	A, LIPO_ADC_LIMIT_H
0BCA    5009          3463     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3464     
                      3465     	; Decrease pwm limit
0BCC    E55E          3466     	MOV  A, PWM_LIMIT
0BCE    600C          3467     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3468     
0BD0    155E          3469     	DEC	PWM_LIMIT					; Decrement limit
0BD2    020BDC        3470     	JMP	CHECK_VOLTAGE_LIM
                      3471     
                      3472     CHECK_VOLTAGE_GOOD: 
                      3473     	; Increase pwm limit
0BD5    E55E          3474     	MOV  A, PWM_LIMIT
0BD7    F4            3475     	CPL	A			
0BD8    6002          3476     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3477     
0BDA    055E          3478     	INC	PWM_LIMIT					; Increment limit
                      3479     
                      3480     CHECK_VOLTAGE_LIM: 
0BDC    A85E          3481     MOV R0 , PWM_LIMIT 
0BDE    C3            3482     	CLR	C
0BDF    E524          3483     	MOV	A, CURRENT_PWM
0BE1    98            3484     SUBB A , R0 
0BE2    5002          3485     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3486     
0BE4    A824          3487     MOV R0 , CURRENT_PWM 
                      3488     
                      3489     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3490     	; Slow spoolup
0BE6    C3            3491     	CLR	C
0BE7    E8            3492     MOV A , R0 
0BE8    955F          3493     	SUBB	A, PWM_LIMIT_SPOOLUP
0BEA    400A          3494     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3495     
0BEC    A85F          3496     MOV R0 , PWM_LIMIT_SPOOLUP 
0BEE    E55F          3497     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0BF0    F4            3498     	CPL	A
0BF1    6003          3499     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3500      
0BF3    855F5E        3501     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3502     
                      3503     CHECK_VOLTAGE_EXIT: 
0BF6    8825          3504     MOV CURRENT_PWM_LIMITED , R0 
                      3505     ENDIF
                      3506     	; Set adc mux for next conversion
0BF8    C3            3507     	CLR	C
0BF9    E56C          3508     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0BFB    B40703        3509     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3510     
                      3511     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0BFE    75BB10        3511+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3512     
                      3513     CHECK_VOLTAGE_RET: 
0C01    22            3514     	RET
                      3515     
                      3516     
                      3517     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3518     ;
                      3519     ; Set startup PWM routine
                      3520     ;
                      3521     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3522     ;
                      3523     ; Used for pwm control during startup
                      3524     ;
                      3525     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3526     SET_STARTUP_PWM: 	
                      3527     	; Set pwm values according to startup phase flags
0C02    306102        3528     JNB FLAGS1 . 1 , ( $+5 ) 
0C05    7832          3529     MOV R0 , # 50 
0C07    306202        3530     JNB FLAGS1 . 2 , ( $+5 ) 
0C0A    7878          3531     MOV R0 , # 120 
                      3532     
                      3533     	; Update pwm variables if any startup phase flag is set
0C0C    E52C          3534     	MOV	A, FLAGS1
0C0E    5406          3535     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C10    601F          3536     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3537     
                      3538     	; Adjust startup power
0C12    E8            3539     MOV A , R0 
0C13    79A2          3540     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C15    87F0          3541     MOV B , @ R1 
0C17    A4            3542     	MUL	AB
0C18    C5F0          3543     	XCH	A, B
0C1A    A2F7          3544     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C1C    33            3545     	RLC	A
0C1D    F8            3546     MOV R0 , A 
0C1E    C3            3547     	CLR	C
0C1F    E8            3548     MOV A , R0 
0C20    955E          3549     	SUBB	A, PWM_LIMIT	
0C22    4002          3550     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3551     
0C24    A85E          3552     MOV R0 , PWM_LIMIT 
                      3553     
                      3554     STARTUP_PWM_SET_PWM: 
                      3555     	; Set pwm variables
0C26    8822          3556     MOV REQUESTED_PWM , R0 
0C28    8824          3557     MOV CURRENT_PWM , R0 
0C2A    8825          3558     MOV CURRENT_PWM_LIMITED , R0 
0C2C    306102        3559     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3560     
0C2F    8860          3561     MOV PWM_SPOOLUP_BEG , R0 
                      3562     
                      3563     STARTUP_PWM_EXIT: 
0C31    22            3564     	RET
                      3565     
                      3566     
                      3567     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3568     ;
                      3569     ; Initialize all timings routine
                      3570     ;
                      3571     ; No assumptions
                      3572     ;
                      3573     ; Part of initialization before motor start
                      3574     ;
                      3575     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3576     INITIALIZE_ALL_TIMINGS:  
                      3577     	; Load programmed startup rpm
0C32    788F          3578     MOV R0 , # PGM_STARTUP_RPM 
0C34    E6            3579     MOV A , @ R0 
0C35    FF            3580     MOV R7 , A 
                      3581     	; Check startup rpm setting and set step accordingly
0C36    C3            3582     	CLR	C
0C37    EF            3583     MOV A , R7 
0C38    9405          3584     	SUBB	A, #5
0C3A    5018          3585     	JNC	STEPPER_STEP_HIGH
0C3C    C3            3586     	CLR	C
0C3D    EF            3587     MOV A , R7 
0C3E    9404          3588     	SUBB	A, #4
0C40    5020          3589     	JNC	STEPPER_STEP_MED_HIGH
0C42    C3            3590     	CLR	C
0C43    EF            3591     MOV A , R7 
0C44    9403          3592     	SUBB	A, #3
0C46    5028          3593     	JNC	STEPPER_STEP_MED
0C48    C3            3594     	CLR	C
0C49    EF            3595     MOV A , R7 
0C4A    9402          3596     	SUBB	A, #2
0C4C    5030          3597     	JNC	STEPPER_STEP_MED_LOW
0C4E    C3            3598     	CLR	C
0C4F    EF            3599     MOV A , R7 
0C50    9401          3600     	SUBB	A, #1
0C52    5038          3601     	JNC	STEPPER_STEP_LOW
                      3602     
                      3603     STEPPER_STEP_HIGH: 
0C54    7533A0        3604     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C57    75340F        3605     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C5A    75353C        3606     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C5D    753605        3607     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C60    8198          3608     	AJMP	STEPPER_STEP_SET
                      3609     STEPPER_STEP_MED_HIGH: 
0C62    7533C0        3610     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C65    753412        3611     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C68    753540        3612     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C6B    753606        3613     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C6E    8198          3614     	AJMP	STEPPER_STEP_SET
                      3615     STEPPER_STEP_MED: 
0C70    753370        3616     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C73    753417        3617     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C76    7535D0        3618     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C79    753607        3619     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C7C    8198          3620     	AJMP	STEPPER_STEP_SET
                      3621     STEPPER_STEP_MED_LOW: 
0C7E    75334C        3622     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C81    75341D        3623     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C84    7535C4        3624     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C87    753609        3625     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0C8A    8198          3626     	AJMP	STEPPER_STEP_SET
                      3627     STEPPER_STEP_LOW: 
0C8C    753328        3628     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0C8F    753423        3629     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0C92    7535B8        3630     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0C95    75360B        3631     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3632     
                      3633     STEPPER_STEP_SET: 
0C98    853350        3634     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0C9B    853451        3635     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0C9E    753C00        3636     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CA1    753D08        3637     	MOV	COMM_PERIOD4X_H, #08H
0CA4    22            3638     	RET
                      3639     
                      3640     
                      3641     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3642     ;
                      3643     ; Calculate next commutation timing routine
                      3644     ;
                      3645     ; No assumptions
                      3646     ;
                      3647     ; Called immediately after each commutation
                      3648     ; Also sets up timer 3 to wait advance timing
                      3649     ; Two entry points are used
                      3650     ;
                      3651     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3652     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CA5    A850          3653     MOV R0 , WT_STEPPER_STEP_L 
0CA7    A951          3654     MOV R1 , WT_STEPPER_STEP_H 
0CA9    020CB0        3655     	JMP	READ_TIMER
                      3656     
                      3657     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CAC    A84A          3658     MOV R0 , WT_ADVANCE_L 
0CAE    A94B          3659     MOV R1 , WT_ADVANCE_H 
                      3660     READ_TIMER: 
                      3661     	; Set up next wait
0CB0    759100        3662     	MOV	TMR3CN, #00H		; Timer3 disabled
0CB3    C3            3663     	CLR	C
0CB4    E4            3664     	CLR	A
0CB5    98            3665     SUBB A , R0 
0CB6    F594          3666     	MOV	TMR3L, A
0CB8    E4            3667     	CLR	A
0CB9    99            3668     SUBB A , R1 
0CBA    F595          3669     	MOV	TMR3H, A
0CBC    759104        3670     	MOV	TMR3CN, #04H		; Timer3 enabled
0CBF    D258          3671     SETB FLAGS0 . 0 
                      3672     	; Read commutation time
0CC1    75C820        3673     	MOV	TMR2CN, #20H		; Timer2 disabled
0CC4    A8CC          3674     MOV R0 , TMR2L 
0CC6    A9CD          3675     MOV R1 , TMR2H 
0CC8    75C824        3676     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3677     	; Calculate this commutation time
0CCB    AA3A          3678     MOV R2 , PREV_COMM_L 
0CCD    AB3B          3679     MOV R3 , PREV_COMM_H 
0CCF    883A          3680     MOV PREV_COMM_L , R0 
0CD1    893B          3681     MOV PREV_COMM_H , R1 
0CD3    C3            3682     	CLR	C
0CD4    E8            3683     MOV A , R0 
0CD5    9A            3684     SUBB A , R2 
0CD6    F8            3685     MOV R0 , A 
0CD7    E9            3686     MOV A , R1 
0CD8    9B            3687     SUBB A , R3 
0CD9    F9            3688     MOV R1 , A 
                      3689     	; Calculate next zero cross scan timeout 
0CDA    AA3C          3690     MOV R2 , COMM_PERIOD4X_L 
0CDC    AB3D          3691     MOV R3 , COMM_PERIOD4X_H 
0CDE    C3            3692     	CLR	C
0CDF    EB            3693     MOV A , R3 
0CE0    13            3694     	RRC	A					; Divide by 2
0CE1    FD            3695     MOV R5 , A 
0CE2    EA            3696     MOV A , R2 
0CE3    13            3697     	RRC	A
0CE4    FC            3698     MOV R4 , A 
0CE5    C3            3699     	CLR	C
0CE6    ED            3700     MOV A , R5 
0CE7    13            3701     	RRC	A					; Divide by 2 again
0CE8    FD            3702     MOV R5 , A 
0CE9    EC            3703     MOV A , R4 
0CEA    13            3704     	RRC	A
0CEB    FC            3705     MOV R4 , A 
0CEC    C3            3706     	CLR	C
0CED    EA            3707     MOV A , R2 
0CEE    9C            3708     SUBB A , R4 
0CEF    FA            3709     MOV R2 , A 
0CF0    EB            3710     MOV A , R3 
0CF1    9D            3711     SUBB A , R5 
0CF2    FB            3712     MOV R3 , A 
                      3713     
0CF3    EA            3714     MOV A , R2 
0CF4    28            3715     ADD A , R0 
0CF5    FA            3716     MOV R2 , A 
0CF6    EB            3717     MOV A , R3 
0CF7    39            3718     ADDC A , R1 
0CF8    FB            3719     MOV R3 , A 
0CF9    8A3C          3720     MOV COMM_PERIOD4X_L , R2 
0CFB    8B3D          3721     MOV COMM_PERIOD4X_H , R3 
0CFD    4001          3722     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3723     
0CFF    22            3724     	RET
                      3725     
                      3726     CALC_NEXT_COMM_SLOW: 
0D00    753CFF        3727     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D03    753DFF        3728     	MOV	COMM_PERIOD4X_H, #0FFH
0D06    22            3729     	RET
                      3730     
                      3731     
                      3732     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3733     ;
                      3734     ; Setup zero cross scan wait
                      3735     ;
                      3736     ; No assumptions
                      3737     ;
                      3738     ; Sets up timer 3 to wait the zero cross scan wait time
                      3739     ;
                      3740     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3741     SETUP_ZC_SCAN_WAIT: 
0D07    759100        3742     	MOV	TMR3CN, #00H		; Timer3 disabled
0D0A    C3            3743     	CLR	C
0D0B    E4            3744     	CLR	A
0D0C    954C          3745     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D0E    F594          3746     	MOV	TMR3L, A
0D10    E4            3747     	CLR	A
0D11    954D          3748     	SUBB	A, WT_ZC_SCAN_H		
0D13    F595          3749     	MOV	TMR3H, A
0D15    759104        3750     	MOV	TMR3CN, #04H		; Timer3 enabled
0D18    D258          3751     SETB FLAGS0 . 0 
0D1A    22            3752     	RET
                      3753     
                      3754     
                      3755     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3756     ;
                      3757     ; Wait advance timing routine
                      3758     ;
                      3759     ; No assumptions
                      3760     ;
                      3761     ; Waits for the advance timing to elapse, waits one zero cross
                      3762     ; wait and sets up the next zero cross wait
                      3763     ;
                      3764     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3765     WAIT_ADVANCE_TIMING: 	
0D1B    7F01          3766     MOV R7 , # 1 
0D1D    789C          3767     MOV R0 , # PGM_DEMAG_COMP 
0D1F    E6            3768     MOV A , @ R0 
0D20    14            3769     	DEC	A
0D21    6002          3770     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      3771     
0D23    7F02          3772     MOV R7 , # 2 
                      3773     
                      3774     WAIT_ADVANCE_TIMING_WAIT: 
0D25    305802        3775     JNB FLAGS0 . 0 , ( $+5 ) 
0D28    A125          3776     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      3777     
0D2A    B107          3778     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D2C    DFF7          3779     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      3780     
0D2E    22            3781     	RET
                      3782     
                      3783     
                      3784     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3785     ;
                      3786     ; Calculate new wait times routine
                      3787     ;
                      3788     ; No assumptions
                      3789     ;
                      3790     ; Calculates new wait times
                      3791     ;
                      3792     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3793     CALC_NEW_WAIT_TIMES: 	
                      3794     	; Load programmed commutation timing
0D2F    7892          3795     MOV R0 , # PGM_COMM_TIMING 
0D31    E6            3796     MOV A , @ R0 
0D32    FF            3797     MOV R7 , A 
0D33    7E14          3798     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      3799     IF MODE == 2
0D35    A83D          3800     MOV R0 , COMM_PERIOD4X_H 
0D37    C3            3801     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D38    E8            3802     MOV A , R0 
0D39    9404          3803     	SUBB	A, #4
0D3B    4002          3804     	JC	CALC_NEW_WAIT_RED_SET
                      3805     
0D3D    7804          3806     MOV R0 , # 4 
                      3807     
                      3808     CALC_NEW_WAIT_RED_SET: 
0D3F    C3            3809     	CLR	C
0D40    E8            3810     MOV A , R0 
0D41    33            3811     	RLC	A
0D42    F8            3812     MOV R0 , A 
0D43    C3            3813     	CLR	C
0D44    EE            3814     MOV A , R6 
0D45    98            3815     SUBB A , R0 
0D46    FE            3816     MOV R6 , A 
                      3817     ENDIF
0D47    306304        3818     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      3819     
0D4A    7F03          3820     MOV R7 , # 3 
0D4C    7E00          3821     MOV R6 , # 0 
                      3822     
                      3823     CALC_NEW_WAIT_DIR_START_SET: 
                      3824     	; Load current commutation timing
0D4E    A93D          3825     MOV R1 , COMM_PERIOD4X_H 
0D50    A83C          3826     MOV R0 , COMM_PERIOD4X_L 
0D52    7A04          3827     MOV R2 , # 4 
                      3828     DIVIDE_WAIT_TIMES: 
0D54    C3            3829     	CLR	C
0D55    E9            3830     MOV A , R1 
0D56    13            3831     	RRC	A					; Divide by 2
0D57    F9            3832     MOV R1 , A 
0D58    E8            3833     MOV A , R0 
0D59    13            3834     	RRC	A
0D5A    F8            3835     MOV R0 , A 
0D5B    DAF7          3836     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      3837     
0D5D    C3            3838     	CLR	C
0D5E    E8            3839     MOV A , R0 
0D5F    9E            3840     SUBB A , R6 
0D60    F8            3841     MOV R0 , A 
0D61    E9            3842     MOV A , R1 
0D62    9400          3843     	SUBB	A, #0
0D64    F9            3844     MOV R1 , A 
0D65    4009          3845     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      3846     
0D67    C3            3847     	CLR	C
0D68    E8            3848     MOV A , R0 
0D69    9402          3849     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D6B    E9            3850     MOV A , R1 
0D6C    9400          3851     	SUBB	A, #0
0D6E    5004          3852     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      3853     
                      3854     LOAD_MIN_TIME: 
0D70    7802          3855     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D72    E4            3856     	CLR	A
0D73    F9            3857     MOV R1 , A 
                      3858     
                      3859     ADJUST_TIMING: 
0D74    E9            3860     MOV A , R1 
0D75    FB            3861     MOV R3 , A 
0D76    E8            3862     MOV A , R0 
0D77    FA            3863     MOV R2 , A 
0D78    C3            3864     	CLR	C
0D79    E9            3865     MOV A , R1 
0D7A    13            3866     	RRC	A					; Divide by 2
0D7B    FD            3867     MOV R5 , A 
0D7C    E8            3868     MOV A , R0 
0D7D    13            3869     	RRC	A
0D7E    FC            3870     MOV R4 , A 
0D7F    C3            3871     	CLR	C
0D80    EF            3872     MOV A , R7 
0D81    9403          3873     	SUBB	A, #3				; Is timing normal?
0D83    602E          3874     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      3875     
0D85    EF            3876     MOV A , R7 
0D86    20E00D        3877     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      3878     
0D89    E8            3879     MOV A , R0 
0D8A    2C            3880     ADD A , R4 
0D8B    F8            3881     MOV R0 , A 
0D8C    E9            3882     MOV A , R1 
0D8D    3D            3883     ADDC A , R5 
0D8E    F9            3884     MOV R1 , A 
0D8F    EC            3885     MOV A , R4 
0D90    FA            3886     MOV R2 , A 
0D91    ED            3887     MOV A , R5 
0D92    FB            3888     MOV R3 , A 
0D93    020DA0        3889     	JMP	STORE_TIMES_UP_OR_DOWN
                      3890     
                      3891     ADJUST_TIMING_TWO_STEPS: 
0D96    E8            3892     MOV A , R0 
0D97    28            3893     ADD A , R0 
0D98    F8            3894     MOV R0 , A 
0D99    E9            3895     MOV A , R1 
0D9A    39            3896     ADDC A , R1 
0D9B    F9            3897     MOV R1 , A 
0D9C    7A02          3898     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0D9E    E4            3899     	CLR	A
0D9F    FB            3900     MOV R3 , A 
                      3901     
                      3902     STORE_TIMES_UP_OR_DOWN: 
0DA0    C3            3903     	CLR	C
0DA1    EF            3904     MOV A , R7 
0DA2    9403          3905     	SUBB	A, #3				; Is timing higher than normal?
0DA4    400D          3906     	JC	STORE_TIMES_DECREASE	; No - branch
                      3907     
                      3908     STORE_TIMES_INCREASE: 
0DA6    8A4E          3909     MOV WT_COMM_L , R2 
0DA8    8B4F          3910     MOV WT_COMM_H , R3 
0DAA    884A          3911     MOV WT_ADVANCE_L , R0 
0DAC    894B          3912     MOV WT_ADVANCE_H , R1 
0DAE    8C4C          3913     MOV WT_ZC_SCAN_L , R4 
0DB0    8D4D          3914     MOV WT_ZC_SCAN_H , R5 
0DB2    22            3915     	RET
                      3916     
                      3917     STORE_TIMES_DECREASE: 
0DB3    884E          3918     MOV WT_COMM_L , R0 
0DB5    894F          3919     MOV WT_COMM_H , R1 
0DB7    8A4A          3920     MOV WT_ADVANCE_L , R2 
0DB9    8B4B          3921     MOV WT_ADVANCE_H , R3 
0DBB    8C4C          3922     MOV WT_ZC_SCAN_L , R4 
0DBD    8D4D          3923     MOV WT_ZC_SCAN_H , R5 
0DBF    22            3924     	RET
                      3925     
                      3926     
                      3927     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3928     ;
                      3929     ; Wait before zero cross scan routine
                      3930     ;
                      3931     ; No assumptions
                      3932     ;
                      3933     ; Waits for the zero cross scan wait time to elapse
                      3934     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      3935     ;
                      3936     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3937     WAIT_BEFORE_ZC_SCAN: 	
0DC0    305802        3938     JNB FLAGS0 . 0 , ( $+5 ) 
0DC3    A1C0          3939     	AJMP	WAIT_BEFORE_ZC_SCAN
                      3940     
0DC5    759100        3941     	MOV	TMR3CN, #00H		; Timer3 disabled
0DC8    C3            3942     	CLR	C
0DC9    E4            3943     	CLR	A
0DCA    953C          3944     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DCC    F594          3945     	MOV	TMR3L, A
0DCE    E4            3946     	CLR	A
0DCF    953D          3947     	SUBB	A, COMM_PERIOD4X_H		
0DD1    F595          3948     	MOV	TMR3H, A
0DD3    759104        3949     	MOV	TMR3CN, #04H		; Timer3 enabled
0DD6    D258          3950     SETB FLAGS0 . 0 
0DD8    22            3951     	RET
                      3952     
                      3953     
                      3954     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3955     ;
                      3956     ; Wait for comparator to go low/high routines
                      3957     ;
                      3958     ; No assumptions
                      3959     ;
                      3960     ; Waits for the zero cross scan wait time to elapse
                      3961     ; Then scans for comparator going low/high
                      3962     ;
                      3963     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3964     WAIT_FOR_COMP_OUT_LOW: 
0DD9    753F00        3965     	MOV	COMP_WAIT_READS, #0
0DDC    752000        3966     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0DDF    020DE8        3967     	JMP	WAIT_FOR_COMP_OUT_START
                      3968     
                      3969     WAIT_FOR_COMP_OUT_HIGH: 
0DE2    753F00        3970     	MOV	COMP_WAIT_READS, #0
0DE5    752040        3971     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      3972     
                      3973     WAIT_FOR_COMP_OUT_START: 
0DE8    D2AF          3974     	SETB	EA						; Enable interrupts
0DEA    053F          3975     	INC	COMP_WAIT_READS
0DEC    205801        3976     JB FLAGS0 . 0 , ( $+4 ) 
0DEF    22            3977     	RET							; Yes - return
                      3978     
                      3979     	; Set default comparator response times
0DF0    759D00        3980     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      3981     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      3984     	; Select number of comparator readings based upon current rotation speed
0DF3    E53D          3985     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0DF5    C3            3986     	CLR	C
0DF6    13            3987     	RRC	A						; Divide by 4
0DF7    C3            3988     	CLR	C
0DF8    13            3989     	RRC	A
0DF9    F8            3990     MOV R0 , A 
0DFA    08            3991     INC R0 
0DFB    6030          3992     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      3993     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0DFD    306A06        3994     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      3995     
0E00    C3            3996     	CLR	C
0E01    13            3997     	RRC	A						; Divide by 4 again
0E02    C3            3998     	CLR	C
0E03    13            3999     	RRC	A
0E04    F8            4000     MOV R0 , A 
0E05    08            4001     INC R0 
                      4002     
                      4003     COMP_WAIT_SET_MAX_READINGS: 
0E06    C3            4004     	CLR	C
0E07    E8            4005     MOV A , R0 
0E08    940A          4006     	SUBB	A, #10
0E0A    4002          4007     	JC	($+4)
                      4008     
0E0C    780A          4009     MOV R0 , # 10 
                      4010     
0E0E    306D08        4011     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4012     
0E11    C3            4013     	CLR	C
0E12    E8            4014     MOV A , R0 
0E13    9404          4015     	SUBB	A, #4
0E15    4002          4016     	JC	($+4)
                      4017     
0E17    7804          4018     MOV R0 , # 4 
                      4019     
                      4020     COMP_WAIT_SET_RESPONSE_TIME: 
0E19    C3            4021     	CLR	C
0E1A    E53D          4022     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E1C    9408          4023     	SUBB	A, #8
0E1E    400D          4024     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4025     
0E20    759D02        4026     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4027     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E23    C3            4030     	CLR	C
0E24    E53D          4031     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E26    9410          4032     	SUBB	A, #16
0E28    4003          4033     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4034     
0E2A    759D03        4035     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4036     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4039     
                      4040     COMP_WAIT_ON_COMP_ABLE: 
0E2D    205803        4041     JB FLAGS0 . 0 , ( $+6 ) 
0E30    D2AF          4042     	SETB	EA							; Enable interrupts
0E32    22            4043     	RET								; Yes - return
                      4044     
0E33    791E          4045     MOV R1 , # 30 
0E35    206D02        4046     JB FLAGS2 . 5 , ( $+5 ) 
0E38    790A          4047     MOV R1 , # 10 
0E3A    D2AF          4048     	SETB	EA							; Enable interrupts
0E3C    00            4049     	NOP								; Allocate only just enough time to capture interrupt
0E3D    00            4050     	NOP
0E3E    C2AF          4051     	CLR	EA							; Disable interrupts
0E40    205A0A        4052     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4053     
0E43    793C          4054     MOV R1 , # 60 
0E45    206D02        4055     JB FLAGS2 . 5 , ( $+5 ) 
0E48    7914          4056     MOV R1 , # 20 
0E4A    3066E0        4057     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4058     
                      4059     PWM_WAIT_STARTUP: 						
0E4D    306302        4060     JNB FLAGS1 . 3 , PWM_WAIT 
                      4061     
0E50    7978          4062     MOV R1 , # 120 
                      4063     PWM_WAIT: 						
0E52    C3            4064     	CLR	C
0E53    E58B          4065     	MOV	A, TL1
0E55    99            4066     SUBB A , R1 
                      4067     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E56    40D5          4072     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4073     ENDIF
                      4074     
                      4075     COMP_READ: 
                      4076     	READ_COMP_OUT 					; Read comparator output
0E58    E59B          4076+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E5A    F4            4077     	CPL	A
0E5B    5440          4078     	ANL	A, #40H
0E5D    B52002        4079     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4080     
0E60    A1E8          4081     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4082     
0E62    D8C9          4083     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4084     
0E64    D2AF          4085     	SETB	EA						; Enable interrupts
0E66    22            4086     	RET							
                      4087     
                      4088     
                      4089     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4090     ;
                      4091     ; Evaluate comparator integrity
                      4092     ;
                      4093     ; No assumptions
                      4094     ;
                      4095     ; Checks comparator signal behaviour versus expected behaviour
                      4096     ;
                      4097     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4098     EVALUATE_COMPARATOR_INTEGRITY: 
0E67    C25B          4099     CLR FLAGS0 . 3 
                      4100     	; Check if demag compensation is enabled
0E69    789C          4101     MOV R0 , # PGM_DEMAG_COMP 
0E6B    E6            4102     MOV A , @ R0 
0E6C    14            4103     	DEC	A
0E6D    600A          4104     	JZ	EVAL_COMP_NO_DEMAG
                      4105     
                      4106     	; Check if a demag situation has occurred
0E6F    E53F          4107     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E71    14            4108     	DEC	A
0E72    7005          4109     	JNZ	EVAL_COMP_NO_DEMAG
                      4110     
0E74    206302        4111     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4112     
0E77    D25B          4113     SETB FLAGS0 . 3 
                      4114     
                      4115     EVAL_COMP_NO_DEMAG: 
0E79    30630B        4116     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4117     
0E7C    0538          4118     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0E7E    205810        4119     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4120     
0E81    753800        4121     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0E84    020E91        4122     	JMP	EVAL_COMP_EXIT
                      4123     
                      4124     EVAL_COMP_CHECK_TIMEOUT: 
0E87    205807        4125     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0E8A    1581          4126     	DEC	SP							; Routine exit without "ret" command
0E8C    1581          4127     	DEC	SP
0E8E    0217F9        4128     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4129     
                      4130     EVAL_COMP_EXIT: 
0E91    22            4131     	RET
                      4132     
                      4133     
                      4134     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4135     ;
                      4136     ; Setup commutation timing routine
                      4137     ;
                      4138     ; No assumptions
                      4139     ;
                      4140     ; Sets up and starts wait from commutation to zero cross
                      4141     ;
                      4142     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4143     SETUP_COMM_WAIT:  
0E92    759100        4144     	MOV	TMR3CN, #00H		; Timer3 disabled
0E95    C3            4145     	CLR	C
0E96    E4            4146     	CLR	A
0E97    954E          4147     	SUBB	A, WT_COMM_L		; Set wait commutation value
0E99    F594          4148     	MOV	TMR3L, A
0E9B    E4            4149     	CLR	A
0E9C    954F          4150     	SUBB	A, WT_COMM_H		
0E9E    F595          4151     	MOV	TMR3H, A
0EA0    759104        4152     	MOV	TMR3CN, #04H		; Timer3 enabled
0EA3    D258          4153     SETB FLAGS0 . 0 
0EA5    22            4154     	RET
                      4155     
                      4156     
                      4157     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4158     ;
                      4159     ; Wait for commutation routine
                      4160     ;
                      4161     ; No assumptions
                      4162     ;
                      4163     ; Waits from zero cross to commutation 
                      4164     ;
                      4165     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4166     WAIT_FOR_COMM:  
                      4167     	; Increment or reset consecutive count
0EA6    0539          4168     	INC	DEMAG_CONSECUTIVE_CNT
0EA8    205B03        4169     JB FLAGS0 . 3 , ( $+6 ) 
                      4170     
0EAB    753900        4171     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4172     
                      4173     	; Check if a demag situation has occurred
0EAE    305B23        4174     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4175     
                      4176     	; Load programmed demag compensation
0EB1    78A3          4177     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0EB3    E6            4178     MOV A , @ R0 
0EB4    FF            4179     MOV R7 , A 
                      4180     
                      4181     	; Check for power off
0EB5    BF0108        4182     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4183     
0EB8    D25C          4184     SETB FLAGS0 . 4 
                      4185     	ALL_NFETS_OFF
0EBA    C292          4185+1   CLR P1 . 2 
0EBC    C296          4185+1   CLR P1 . 6 
0EBE    C295          4185+1   CLR P1 . 5 
                      4186     
                      4187     	; Wait a blind wait
                      4188     WAIT_FOR_COMM_BLIND: 
0EC0    B107          4189     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4190     WAIT_DEMAG_DEFAULT_ZC: 	
0EC2    305802        4191     JNB FLAGS0 . 0 , ( $+5 ) 
0EC5    C1C2          4192     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4193     
                      4194     	; Check for power off
0EC7    BF0208        4195     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4196     
0ECA    D25C          4197     SETB FLAGS0 . 4 
                      4198     	ALL_NFETS_OFF
0ECC    C292          4198+1   CLR P1 . 2 
0ECE    C296          4198+1   CLR P1 . 6 
0ED0    C295          4198+1   CLR P1 . 5 
                      4199     
                      4200     WAIT_FOR_COMM_SETUP: 
0ED2    D192          4201     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4202     WAIT_FOR_COMM_WAIT: 
0ED4    305802        4203     JNB FLAGS0 . 0 , ( $+5 ) 
0ED7    C1D4          4204     	AJMP	WAIT_FOR_COMM_WAIT					
                      4205     
0ED9    22            4206     	RET
                      4207     
                      4208     
                      4209     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4210     ;
                      4211     ; Commutation routines
                      4212     ;
                      4213     ; No assumptions
                      4214     ;
                      4215     ; Performs commutation switching 
                      4216     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4217     ;
                      4218     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4219     COMM1COMM2: 	
0EDA    C2AF          4220     	CLR 	EA					; Disable all interrupts
                      4221     	BPFET_OFF					; Bp off
0EDC    C294          4221+1   CLR P1 . 4 
0EDE    206A03        4222     JB FLAGS2 . 2 , COMM12_DAMP 
0EE1    020EF9        4223     	JMP	COMM12_NONDAMP
                      4224     COMM12_DAMP: 
                      4225     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4229     IF DAMPED_MODE_ENABLE == 1
0EE4    900347        4230     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4231     ENDIF
0EE7    30650F        4232     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4233     	CPFET_OFF				
0EEA    207502        4233+1   JB FLAGS3 . 5 , ( $+5 ) 
0EED    C297          4233+1   CLR P1 . 7 
0EEF    307502        4233+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EF2    C293          4233+1   CLR P1 . 3 
0EF4    7406          4234     MOV A , # 6 
0EF6    D5E0FD        4235     	DJNZ ACC,	$
                      4236     COMM12_NONDAMP: 
                      4237     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4245     	APFET_ON					; Ap on
0EF9    207502        4245+1   JB FLAGS3 . 5 , ( $+5 ) 
0EFC    D293          4245+1   SETB P1 . 3 
0EFE    307502        4245+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F01    D297          4245+1   SETB P1 . 7 
                      4246     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F03    759F80        4246+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F06    753E02        4247     	MOV	COMM_PHASE, #2
0F09    021064        4248     	JMP	COMM_EXIT
                      4249     
                      4250     COMM2COMM3: 	
0F0C    C2AF          4251     	CLR 	EA					; Disable all interrupts
0F0E    206A03        4252     JB FLAGS2 . 2 , COMM23_DAMP 
0F11    020F2E        4253     	JMP	COMM23_NONDAMP
                      4254     COMM23_DAMP: 
                      4255     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4258     IF DAMPED_MODE_ENABLE == 1
0F14    9002FE        4259     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4260     ENDIF
0F17    306517        4261     JNB FLAGS1 . 5 , COMM23_NFET 
                      4262     	BPFET_OFF				
0F1A    C294          4262+1   CLR P1 . 4 
                      4263     	CPFET_OFF				
0F1C    207502        4263+1   JB FLAGS3 . 5 , ( $+5 ) 
0F1F    C297          4263+1   CLR P1 . 7 
0F21    307502        4263+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F24    C293          4263+1   CLR P1 . 3 
0F26    7406          4264     MOV A , # 6 
0F28    D5E0FD        4265     	DJNZ ACC,	$
0F2B    020F31        4266     	JMP	COMM23_NFET
                      4267     COMM23_NONDAMP: 
0F2E    9001E1        4268     	MOV	DPTR, #PWM_BFET_ON	
                      4269     COMM23_NFET: 
                      4270     	CNFET_OFF					; Cn off
0F31    207502        4270+1   JB FLAGS3 . 5 , ( $+5 ) 
0F34    C296          4270+1   CLR P1 . 6 
0F36    307502        4270+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F39    C292          4270+1   CLR P1 . 2 
0F3B    305A06        4271     JNB FLAGS0 . 2 , COMM23_CP 
                      4272     	BNFET_ON					; Yes - Bn on
0F3E    E525          4272+1   MOV A , CURRENT_PWM_LIMITED 
0F40    6002          4272+1   JZ ( $+4 ) 
0F42    D295          4272+1   SETB P1 . 5 
                      4273     COMM23_CP: 
                      4274     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F44    207503        4274+1   JB FLAGS3 . 5 , ( $+6 ) 
0F47    759F89        4274+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F4A    307503        4274+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F4D    759F81        4274+1   MOV CPT0MX , # 81H 
0F50    753E03        4275     	MOV	COMM_PHASE, #3
0F53    021064        4276     	JMP	COMM_EXIT
                      4277     
                      4278     COMM3COMM4: 	
0F56    C2AF          4279     	CLR 	EA					; Disable all interrupts
                      4280     	APFET_OFF					; Ap off
0F58    207502        4280+1   JB FLAGS3 . 5 , ( $+5 ) 
0F5B    C293          4280+1   CLR P1 . 3 
0F5D    307502        4280+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F60    C297          4280+1   CLR P1 . 7 
0F62    206A03        4281     JB FLAGS2 . 2 , COMM34_DAMP 
0F65    020F75        4282     	JMP	COMM34_NONDAMP
                      4283     COMM34_DAMP: 
                      4284     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4288     IF DAMPED_MODE_ENABLE == 1
0F68    9002BD        4289     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4290     ENDIF
0F6B    306507        4291     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4292     	BPFET_OFF				
0F6E    C294          4292+1   CLR P1 . 4 
0F70    7406          4293     MOV A , # 6 
0F72    D5E0FD        4294     	DJNZ ACC,	$
                      4295     COMM34_NONDAMP: 
                      4296     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4304     	CPFET_ON					; Cp on
0F75    207502        4304+1   JB FLAGS3 . 5 , ( $+5 ) 
0F78    D297          4304+1   SETB P1 . 7 
0F7A    307502        4304+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F7D    D293          4304+1   SETB P1 . 3 
                      4305     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F7F    207503        4305+1   JB FLAGS3 . 5 , ( $+6 ) 
0F82    759F81        4305+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F85    307503        4305+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F88    759F89        4305+1   MOV CPT0MX , # 89H 
0F8B    753E04        4306     	MOV	COMM_PHASE, #4
0F8E    021064        4307     	JMP	COMM_EXIT
                      4308     
                      4309     COMM4COMM5: 	
0F91    C2AF          4310     	CLR 	EA					; Disable all interrupts
0F93    206A03        4311     JB FLAGS2 . 2 , COMM45_DAMP 
0F96    020FB3        4312     	JMP	COMM45_NONDAMP
                      4313     COMM45_DAMP: 
                      4314     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4317     IF DAMPED_MODE_ENABLE == 1
0F99    90027C        4318     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4319     ENDIF
0F9C    306517        4320     JNB FLAGS1 . 5 , COMM45_NFET 
                      4321     	APFET_OFF				
0F9F    207502        4321+1   JB FLAGS3 . 5 , ( $+5 ) 
0FA2    C293          4321+1   CLR P1 . 3 
0FA4    307502        4321+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FA7    C297          4321+1   CLR P1 . 7 
                      4322     	BPFET_OFF				
0FA9    C294          4322+1   CLR P1 . 4 
0FAB    7406          4323     MOV A , # 6 
0FAD    D5E0FD        4324     	DJNZ ACC,	$
0FB0    020FB6        4325     	JMP	COMM45_NFET
                      4326     COMM45_NONDAMP: 
0FB3    9001CF        4327     	MOV	DPTR, #PWM_AFET_ON
                      4328     COMM45_NFET: 
                      4329     	BNFET_OFF					; Bn off
0FB6    C295          4329+1   CLR P1 . 5 
0FB8    305A0E        4330     JNB FLAGS0 . 2 , COMM45_CP 
                      4331     	ANFET_ON					; Yes - An on
0FBB    E525          4331+1   MOV A , CURRENT_PWM_LIMITED 
0FBD    600A          4331+1   JZ ( $+12 ) 
0FBF    207502        4331+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC2    D292          4331+1   SETB P1 . 2 
0FC4    307502        4331+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FC7    D296          4331+1   SETB P1 . 6 
                      4332     COMM45_CP: 
                      4333     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FC9    759F80        4333+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FCC    753E05        4334     	MOV	COMM_PHASE, #5
0FCF    021064        4335     	JMP	COMM_EXIT
                      4336     
                      4337     COMM5COMM6: 	
0FD2    C2AF          4338     	CLR 	EA					; Disable all interrupts
                      4339     	CPFET_OFF					; Cp off
0FD4    207502        4339+1   JB FLAGS3 . 5 , ( $+5 ) 
0FD7    C297          4339+1   CLR P1 . 7 
0FD9    307502        4339+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FDC    C293          4339+1   CLR P1 . 3 
0FDE    206A03        4340     JB FLAGS2 . 2 , COMM56_DAMP 
0FE1    020FF9        4341     	JMP	COMM56_NONDAMP
                      4342     COMM56_DAMP: 
                      4343     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4347     IF DAMPED_MODE_ENABLE == 1
0FE4    900233        4348     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4349     ENDIF
0FE7    30650F        4350     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4351     	APFET_OFF				
0FEA    207502        4351+1   JB FLAGS3 . 5 , ( $+5 ) 
0FED    C293          4351+1   CLR P1 . 3 
0FEF    307502        4351+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF2    C297          4351+1   CLR P1 . 7 
0FF4    7406          4352     MOV A , # 6 
0FF6    D5E0FD        4353     	DJNZ ACC,	$
                      4354     COMM56_NONDAMP: 
                      4355     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4363     	BPFET_ON					; Bp on
0FF9    D294          4363+1   SETB P1 . 4 
                      4364     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FFB    207503        4364+1   JB FLAGS3 . 5 , ( $+6 ) 
0FFE    759F89        4364+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1001    307503        4364+1   JNB FLAGS3 . 5 , ( $+6 ) 
1004    759F81        4364+1   MOV CPT0MX , # 81H 
1007    753E06        4365     	MOV	COMM_PHASE, #6
100A    021064        4366     	JMP	COMM_EXIT
                      4367     
                      4368     COMM6COMM1: 	
100D    C2AF          4369     	CLR 	EA					; Disable all interrupts
100F    206A03        4370     JB FLAGS2 . 2 , COMM61_DAMP 
1012    021037        4371     	JMP	COMM61_NONDAMP
                      4372     COMM61_DAMP: 
                      4373     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4376     IF DAMPED_MODE_ENABLE == 1
1015    9003A0        4377     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4378     ENDIF
1018    30651F        4379     JNB FLAGS1 . 5 , COMM61_NFET 
                      4380     	APFET_OFF				
101B    207502        4380+1   JB FLAGS3 . 5 , ( $+5 ) 
101E    C293          4380+1   CLR P1 . 3 
1020    307502        4380+1   JNB FLAGS3 . 5 , ( $+5 ) 
1023    C297          4380+1   CLR P1 . 7 
                      4381     	CPFET_OFF				
1025    207502        4381+1   JB FLAGS3 . 5 , ( $+5 ) 
1028    C297          4381+1   CLR P1 . 7 
102A    307502        4381+1   JNB FLAGS3 . 5 , ( $+5 ) 
102D    C293          4381+1   CLR P1 . 3 
102F    7406          4382     MOV A , # 6 
1031    D5E0FD        4383     	DJNZ ACC,	$
1034    02103A        4384     	JMP	COMM61_NFET
                      4385     COMM61_NONDAMP: 
1037    9001F3        4386     	MOV	DPTR, #PWM_CFET_ON
                      4387     COMM61_NFET: 
                      4388     	ANFET_OFF					; An off
103A    207502        4388+1   JB FLAGS3 . 5 , ( $+5 ) 
103D    C292          4388+1   CLR P1 . 2 
103F    307502        4388+1   JNB FLAGS3 . 5 , ( $+5 ) 
1042    C296          4388+1   CLR P1 . 6 
1044    305A0E        4389     JNB FLAGS0 . 2 , COMM61_CP 
                      4390     	CNFET_ON					; Yes - Cn on
1047    E525          4390+1   MOV A , CURRENT_PWM_LIMITED 
1049    600A          4390+1   JZ ( $+12 ) 
104B    207502        4390+1   JB FLAGS3 . 5 , ( $+5 ) 
104E    D296          4390+1   SETB P1 . 6 
1050    307502        4390+1   JNB FLAGS3 . 5 , ( $+5 ) 
1053    D292          4390+1   SETB P1 . 2 
                      4391     COMM61_CP: 
                      4392     	SET_COMP_PHASE_A 			; Set comparator to phase A
1055    207503        4392+1   JB FLAGS3 . 5 , ( $+6 ) 
1058    759F81        4392+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
105B    307503        4392+1   JNB FLAGS3 . 5 , ( $+6 ) 
105E    759F89        4392+1   MOV CPT0MX , # 89H 
1061    753E01        4393     	MOV	COMM_PHASE, #1
                      4394     
                      4395     COMM_EXIT: 
1064    D2AF          4396     	SETB	EA					; Enable all interrupts
1066    789C          4397     MOV R0 , # PGM_DEMAG_COMP 
1068    E6            4398     MOV A , @ R0 
1069    C3            4399     	CLR	C
106A    9402          4400     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
106C    4007          4401     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4402     
106E    C3            4403     	CLR	C
106F    E539          4404     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1071    9403          4405     	SUBB	A, #3
1073    5002          4406     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4407     
                      4408     COMM_RESTORE_POWER: 
1075    C25C          4409     CLR FLAGS0 . 4 
                      4410     
                      4411     COMM_RETURN: 
1077    22            4412     	RET
                      4413     
                      4414     
                      4415     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4416     ;
                      4417     ; Switch power off routine
                      4418     ;
                      4419     ; No assumptions
                      4420     ;
                      4421     ; Switches all fets off 
                      4422     ;
                      4423     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4424     SWITCH_POWER_OFF: 
1078    9001CD        4425     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4426     	ALL_NFETS_OFF			; Turn off all nfets
107B    C292          4426+1   CLR P1 . 2 
107D    C296          4426+1   CLR P1 . 6 
107F    C295          4426+1   CLR P1 . 5 
                      4427     	ALL_PFETS_OFF			; Turn off all pfets
1081    C293          4427+1   CLR P1 . 3 
1083    C297          4427+1   CLR P1 . 7 
1085    C294          4427+1   CLR P1 . 4 
1087    C25A          4428     CLR FLAGS0 . 2 
1089    22            4429     	RET			
                      4430     
                      4431     
                      4432     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4433     ;
                      4434     ; Decrement stepper step routine
                      4435     ;
                      4436     ; No assumptions
                      4437     ;
                      4438     ; Decrements the stepper step 
                      4439     ;
                      4440     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4441     DECREMENT_STEPPER_STEP: 
108A    C3            4442     	CLR	C
108B    E550          4443     	MOV	A, WT_STEPPER_STEP_L
108D    9535          4444     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
108F    E551          4445     	MOV	A, WT_STEPPER_STEP_H
1091    9536          4446     	SUBB	A, STEPPER_STEP_END_H	
1093    5001          4447     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
1095    22            4448     	RET
                      4449     
                      4450     DECREMENT_STEP: 
                      4451     	; Load programmed startup acceleration
1096    7890          4452     MOV R0 , # PGM_STARTUP_ACCEL 
1098    E6            4453     MOV A , @ R0 
1099    FF            4454     MOV R7 , A 
                      4455     	; Check acceleration setting and set step size accordingly
109A    C3            4456     	CLR	C
109B    EF            4457     MOV A , R7 
109C    9405          4458     	SUBB	A, #5
109E    5018          4459     	JNC	DEC_STEP_HIGH
10A0    C3            4460     	CLR	C
10A1    EF            4461     MOV A , R7 
10A2    9404          4462     	SUBB	A, #4
10A4    501B          4463     	JNC	DEC_STEP_MED_HIGH
10A6    C3            4464     	CLR	C
10A7    EF            4465     MOV A , R7 
10A8    9403          4466     	SUBB	A, #3
10AA    501E          4467     	JNC	DEC_STEP_MED
10AC    C3            4468     	CLR	C
10AD    EF            4469     MOV A , R7 
10AE    9402          4470     	SUBB	A, #2
10B0    5021          4471     	JNC	DEC_STEP_MED_LOW
10B2    C3            4472     	CLR	C
10B3    EF            4473     MOV A , R7 
10B4    9401          4474     	SUBB	A, #1
10B6    5024          4475     	JNC	DEC_STEP_LOW
                      4476     
                      4477     DEC_STEP_HIGH: 
10B8    C3            4478     	CLR	C
10B9    E550          4479     	MOV	A, WT_STEPPER_STEP_L
10BB    943C          4480     	SUBB	A, #LOW(30 SHL 1)		
10BD    F8            4481     MOV R0 , A 
10BE    0210E5        4482     	JMP	DECREMENT_STEP_EXIT
                      4483     DEC_STEP_MED_HIGH: 
10C1    C3            4484     	CLR	C
10C2    E550          4485     	MOV	A, WT_STEPPER_STEP_L
10C4    9428          4486     	SUBB	A, #LOW(20 SHL 1)		
10C6    F8            4487     MOV R0 , A 
10C7    0210E5        4488     	JMP	DECREMENT_STEP_EXIT
                      4489     DEC_STEP_MED: 
10CA    C3            4490     	CLR	C
10CB    E550          4491     	MOV	A, WT_STEPPER_STEP_L
10CD    941A          4492     	SUBB	A, #LOW(13 SHL 1)		
10CF    F8            4493     MOV R0 , A 
10D0    0210E5        4494     	JMP	DECREMENT_STEP_EXIT
                      4495     DEC_STEP_MED_LOW: 
10D3    C3            4496     	CLR	C
10D4    E550          4497     	MOV	A, WT_STEPPER_STEP_L
10D6    9412          4498     	SUBB	A, #LOW(9 SHL 1)		
10D8    F8            4499     MOV R0 , A 
10D9    0210E5        4500     	JMP	DECREMENT_STEP_EXIT
                      4501     DEC_STEP_LOW: 
10DC    C3            4502     	CLR	C
10DD    E550          4503     	MOV	A, WT_STEPPER_STEP_L
10DF    940A          4504     	SUBB	A, #LOW(5 SHL 1)		
10E1    F8            4505     MOV R0 , A 
10E2    0210E5        4506     	JMP	DECREMENT_STEP_EXIT
                      4507     
                      4508     DECREMENT_STEP_EXIT: 
10E5    E551          4509     	MOV	A, WT_STEPPER_STEP_H
10E7    9400          4510     	SUBB	A, #0		
10E9    F9            4511     MOV R1 , A 
10EA    8850          4512     MOV WT_STEPPER_STEP_L , R0 
10EC    8951          4513     MOV WT_STEPPER_STEP_H , R1 
10EE    22            4514     	RET
                      4515     
                      4516     
                      4517     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4518     ;
                      4519     ; Stepper timer wait
                      4520     ;
                      4521     ; No assumptions
                      4522     ;
                      4523     ; Waits for the stepper step timer to elapse
                      4524     ;
                      4525     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4526     STEPPER_TIMER_WAIT: 
10EF    305802        4527     JNB FLAGS0 . 0 , ( $+5 ) 
10F2    01EF          4528     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
10F4    22            4529     	RET
                      4530     
                      4531     
                      4532     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4533     ;
                      4534     ; Set default parameters
                      4535     ;
                      4536     ; No assumptions
                      4537     ;
                      4538     ; Sets default programming parameters
                      4539     ;
                      4540     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4541     SET_DEFAULT_PARAMETERS: 
                      4542     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4603     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4664     IF MODE == 2	; Multi
10F5    7880          4665     MOV R0 , # PGM_GOV_P_GAIN 
10F7    7609          4666     MOV @ R0 , # 9 
10F9    08            4667     INC R0 
10FA    7609          4668     MOV @ R0 , # 9 
10FC    08            4669     INC R0 
10FD    7604          4670     MOV @ R0 , # 4 
10FF    08            4671     INC R0 
1100    7601          4672     MOV @ R0 , # 1 
1102    08            4673     INC R0 
1103    7603          4674     MOV @ R0 , # 3 
1105    08            4675     INC R0 
1106    76FF          4676     MOV @ R0 , # 0XFF 
1108    08            4677     INC R0 
1109    7609          4678     MOV @ R0 , # 9 
110B    08            4679     INC R0 
110C    7601          4680     MOV @ R0 , # 1 
110E    08            4681     INC R0 
110F    7601          4682     MOV @ R0 , # 1 
1111    08            4683     INC R0 
1112    7601          4684     MOV @ R0 , # 1 
                      4685     
1114    788C          4686     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1116    7600          4687     MOV @ R0 , # 0 
1118    08            4688     INC R0 
1119    76FF          4689     MOV @ R0 , # 0XFF 
111B    08            4690     INC R0 
111C    76FF          4691     MOV @ R0 , # 0XFF 
111E    08            4692     INC R0 
111F    7601          4693     MOV @ R0 , # 1 
1121    08            4694     INC R0 
1122    7605          4695     MOV @ R0 , # 5 
1124    08            4696     INC R0 
1125    76FF          4697     MOV @ R0 , # 0XFF 
1127    08            4698     INC R0 
1128    7603          4699     MOV @ R0 , # 3 
112A    08            4700     INC R0 
112B    7606          4701     MOV @ R0 , # 6 
112D    08            4702     INC R0 
112E    76FF          4703     MOV @ R0 , # 0XFF 
1130    08            4704     INC R0 
1131    7602          4705     MOV @ R0 , # 2 
1133    08            4706     INC R0 
1134    7603          4707     MOV @ R0 , # 3 
1136    08            4708     INC R0 
1137    76FA          4709     MOV @ R0 , # 250 
1139    08            4710     INC R0 
113A    7628          4711     MOV @ R0 , # 40 
113C    08            4712     INC R0 
113D    7628          4713     MOV @ R0 , # 40 
113F    08            4714     INC R0 
1140    7605          4715     MOV @ R0 , # 5 
1142    08            4716     INC R0 
1143    7601          4717     MOV @ R0 , # 1 
1145    08            4718     INC R0 
1146    7602          4719     MOV @ R0 , # 2 
1148    08            4720     INC R0 
1149    7600          4721     MOV @ R0 , # 0 
114B    08            4722     INC R0 
114C    767D          4723     MOV @ R0 , # 125 
                      4724     ENDIF
114E    22            4725     	RET
                      4726     
                      4727     
                      4728     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4729     ;
                      4730     ; Decode parameters
                      4731     ;
                      4732     ; No assumptions
                      4733     ;
                      4734     ; Decodes programming parameters
                      4735     ;
                      4736     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4737     DECODE_PARAMETERS: 
                      4738     	; Load programmed damping force
114F    7893          4739     MOV R0 , # PGM_DAMPING_FORCE 
1151    E6            4740     MOV A , @ R0 
1152    FF            4741     MOV R7 , A 
                      4742     	; Decode damping
1153    756609        4743     	MOV	DAMPING_PERIOD, #9		; Set default
1156    756701        4744     	MOV	DAMPING_ON, #1
1159    C3            4745     	CLR	C
115A    BF0206        4746     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      4747     
115D    756605        4748     	MOV	DAMPING_PERIOD, #5
1160    756701        4749     	MOV	DAMPING_ON, #1
                      4750     
                      4751     DECODE_DAMPING_3: 
1163    C3            4752     	CLR	C
1164    BF0306        4753     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      4754     
1167    756605        4755     	MOV	DAMPING_PERIOD, #5
116A    756702        4756     	MOV	DAMPING_ON, #2
                      4757     
                      4758     DECODE_DAMPING_4: 
116D    C3            4759     	CLR	C
116E    BF0406        4760     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      4761     
1171    756605        4762     	MOV	DAMPING_PERIOD, #5
1174    756703        4763     	MOV	DAMPING_ON, #3
                      4764     
                      4765     DECODE_DAMPING_5: 
1177    C3            4766     	CLR	C
1178    BF0506        4767     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      4768     
117B    756609        4769     	MOV	DAMPING_PERIOD, #9
117E    756707        4770     	MOV	DAMPING_ON, #7
                      4771     
                      4772     DECODE_DAMPING_6: 
1181    C3            4773     	CLR	C
1182    BF0606        4774     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      4775     
1185    756600        4776     	MOV	DAMPING_PERIOD, #0
1188    756700        4777     	MOV	DAMPING_ON, #0
                      4778     
                      4779     DECODE_DAMPING_DONE: 
                      4780     	; Load programmed pwm frequency
118B    7887          4781     MOV R0 , # PGM_PWM_FREQ 
118D    E6            4782     MOV A , @ R0 
118E    FF            4783     MOV R7 , A 
                      4784     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      4791     IF MODE >= 1	; Tail or multi
118F    C26C          4792     CLR FLAGS2 . 4 
1191    C3            4793     	CLR	C
1192    BF0302        4794     CJNE R7 , # 3 , ( $+5 ) 
1195    D26C          4795     SETB FLAGS2 . 4 
1197    C26B          4796     CLR FLAGS2 . 3 
1199    C3            4797     	CLR	C
119A    BF0402        4798     CJNE R7 , # 4 , ( $+5 ) 
119D    D26B          4799     SETB FLAGS2 . 3 
                      4800     ENDIF
119F    C26A          4801     CLR FLAGS2 . 2 
11A1    7418          4802     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11A3    552D          4803     	ANL	A, FLAGS2					; Check if any damped mode is set
11A5    6002          4804     	JZ	($+4)
11A7    D26A          4805     SETB FLAGS2 . 2 
11A9    C265          4806     CLR FLAGS1 . 5 
11AB    6002          4807     	JZ	($+4)
11AD    D265          4808     SETB FLAGS1 . 5 
11AF    D266          4809     SETB FLAGS1 . 6 
11B1    6002          4810     	JZ	($+4)
11B3    C266          4811     CLR FLAGS1 . 6 
                      4812     	; Load programmed direction
11B5    7888          4813     MOV R0 , # PGM_DIRECTION 
                      4814     IF MODE >= 1	; Tail or multi
11B7    E6            4815     MOV A , @ R0 
11B8    C3            4816     	CLR	C
11B9    9403          4817     	SUBB	A, #3
11BB    6008          4818     	JZ	DECODE_PARAMS_DIR_SET
                      4819     ENDIF
                      4820     
11BD    C275          4821     CLR FLAGS3 . 5 
11BF    E6            4822     MOV A , @ R0 
11C0    30E102        4823     	JNB	ACC.1, ($+5)
11C3    D275          4824     SETB FLAGS3 . 5 
                      4825     DECODE_PARAMS_DIR_SET: 
11C5    C276          4826     CLR FLAGS3 . 6 
11C7    7889          4827     MOV R0 , # PGM_INPUT_POL 
11C9    E6            4828     MOV A , @ R0 
11CA    30E102        4829     	JNB	ACC.1, ($+5)
11CD    D276          4830     SETB FLAGS3 . 6 
11CF    C3            4831     	CLR	C
11D0    EF            4832     MOV A , R7 
11D1    9402          4833     	SUBB	A, #2
11D3    6008          4834     	JZ	DECODE_PWM_FREQ_LOW
                      4835     
11D5    758E01        4836     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
11D8    D26D          4837     SETB FLAGS2 . 5 
11DA    0211E2        4838     	JMP	DECODE_PWM_FREQ_END
                      4839     
                      4840     DECODE_PWM_FREQ_LOW: 
11DD    758E00        4841     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
11E0    C26D          4842     CLR FLAGS2 . 5 
                      4843     
                      4844     DECODE_PWM_FREQ_END: 
11E2    22            4845     	RET
                      4846     
                      4847     
                      4848     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4849     ;
                      4850     ; Decode governor gain
                      4851     ;
                      4852     ; No assumptions
                      4853     ;
                      4854     ; Decodes governor gains
                      4855     ;
                      4856     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4857     DECODE_GOVERNOR_GAINS: 
                      4858     	; Decode governor gains
11E3    7880          4859     MOV R0 , # PGM_GOV_P_GAIN 
11E5    E6            4860     MOV A , @ R0 
11E6    14            4861     	DEC	A	
11E7    900080        4862     	MOV	DPTR, #GOV_GAIN_TABLE
11EA    93            4863     	MOVC A, @A+DPTR	
11EB    789F          4864     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
11ED    F6            4865     MOV @ R0 , A 
11EE    7881          4866     MOV R0 , # PGM_GOV_I_GAIN 
11F0    E6            4867     MOV A , @ R0 
11F1    14            4868     	DEC	A	
11F2    900080        4869     	MOV	DPTR, #GOV_GAIN_TABLE
11F5    93            4870     	MOVC A, @A+DPTR	
11F6    78A0          4871     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
11F8    F6            4872     MOV @ R0 , A 
11F9    1178          4873     	CALL	SWITCH_POWER_OFF		; Reset DPTR
11FB    22            4874     	RET
                      4875     
                      4876     
                      4877     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4878     ;
                      4879     ; Decode throttle rate
                      4880     ;
                      4881     ; No assumptions
                      4882     ;
                      4883     ; Decodes throttle rate
                      4884     ;
                      4885     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4886     DECODE_THROTTLE_RATE: 
                      4887     	; Decode throttle rate
11FC    789B          4888     MOV R0 , # PGM_THROTTLE_RATE 
11FE    E6            4889     MOV A , @ R0 
11FF    14            4890     	DEC	A	
1200    90008D        4891     	MOV	DPTR, #THROTTLE_RATE_TABLE
1203    93            4892     	MOVC A, @A+DPTR	
1204    78A1          4893     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
1206    F6            4894     MOV @ R0 , A 
1207    1178          4895     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1209    22            4896     	RET
                      4897     
                      4898     
                      4899     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4900     ;
                      4901     ; Decode startup power
                      4902     ;
                      4903     ; No assumptions
                      4904     ;
                      4905     ; Decodes startup power
                      4906     ;
                      4907     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4908     DECODE_STARTUP_POWER: 
                      4909     	; Decode startup power
120A    7886          4910     MOV R0 , # PGM_STARTUP_PWR 
120C    E6            4911     MOV A , @ R0 
120D    14            4912     	DEC	A	
120E    90009A        4913     	MOV	DPTR, #STARTUP_POWER_TABLE
1211    93            4914     	MOVC A, @A+DPTR	
1212    78A2          4915     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1214    F6            4916     MOV @ R0 , A 
1215    1178          4917     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1217    22            4918     	RET
                      4919     
                      4920     
                      4921     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4922     ;
                      4923     ; Decode demag compensation
                      4924     ;
                      4925     ; No assumptions
                      4926     ;
                      4927     ; Decodes throttle rate
                      4928     ;
                      4929     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4930     DECODE_DEMAG_COMP: 
                      4931     	; Decode demag compensation
1218    789C          4932     MOV R0 , # PGM_DEMAG_COMP 
121A    E6            4933     MOV A , @ R0 
121B    14            4934     	DEC	A	
121C    9000A7        4935     	MOV	DPTR, #DEMAG_POWER_TABLE
121F    93            4936     	MOVC A, @A+DPTR	
1220    78A3          4937     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
1222    F6            4938     MOV @ R0 , A 
1223    1178          4939     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1225    22            4940     	RET
                      4941     
                      4942     
                      4943     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4944     ;
                      4945     ; Set BEC voltage
                      4946     ;
                      4947     ; No assumptions
                      4948     ;
                      4949     ; Sets the BEC output voltage low or high
                      4950     ;
                      4951     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4952     SET_BEC_VOLTAGE: 
                      4953     	; Set bec voltage
                      4954     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1226    22            4964     	RET
                      4965     
                      4966     
                      4967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4968     ;
                      4969     ; Find throttle gain
                      4970     ;
                      4971     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      4972     ;
                      4973     ; Finds throttle gain from throttle calibration values
                      4974     ;
                      4975     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4976     FIND_THROTTLE_GAIN: 
                      4977     	; Load programmed minimum and maximum throttle
1227    7896          4978     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1229    E6            4979     MOV A , @ R0 
122A    FA            4980     MOV R2 , A 
122B    7897          4981     MOV R0 , # PGM_PPM_MAX_THROTTLE 
122D    E6            4982     MOV A , @ R0 
122E    FB            4983     MOV R3 , A 
                      4984     	; Check if full range is chosen
122F    307704        4985     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      4986     
1232    7A00          4987     MOV R2 , # 0 
1234    7BFF          4988     MOV R3 , # 255 
                      4989     
                      4990     FIND_THROTTLE_GAIN_CALCULATE: 
                      4991     	; Calculate difference
1236    C3            4992     	CLR	C
1237    EB            4993     MOV A , R3 
1238    9A            4994     SUBB A , R2 
1239    FC            4995     MOV R4 , A 
                      4996     	; Check that difference is minimum 130
123A    C3            4997     	CLR	C
123B    9482          4998     	SUBB	A, #130
123D    5002          4999     	JNC	($+4)
                      5000     
123F    7C82          5001     MOV R4 , # 130 
                      5002     
                      5003     	; Find gain
1241    756E00        5004     	MOV	PPM_THROTTLE_GAIN, #0
                      5005     TEST_THROTTLE_GAIN: 
1244    056E          5006     	INC	PPM_THROTTLE_GAIN
1246    EC            5007     MOV A , R4 
1247    856EF0        5008     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
124A    A4            5009     	MUL	AB
124B    C3            5010     	CLR	C
124C    E5F0          5011     	MOV	A, B
124E    9480          5012     	SUBB	A, #128
1250    40F2          5013     	JC	TEST_THROTTLE_GAIN
1252    22            5014     	RET
                      5015     
                      5016     
                      5017     
                      5018     
                      5019     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5020     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5021     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5022     ;
                      5023     ; Main program start
                      5024     ;
                      5025     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5026     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5028     
                      5029     RESET: 
                      5030     	; Check flash lock byte
1253    E5EF          5031     	MOV	A, RSTSRC			
1255    20E603        5032     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5033     
1258    752000        5034     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5035     
125B    0520          5036     	INC	BIT_ACCESS
125D    903FFF        5037     MOV DPTR , # 16383 
1260    E520          5038     	MOV	A, BIT_ACCESS
1262    14            5039     	DEC	A
1263    6006          5040     	JZ	LOCK_BYTE_TEST
                      5041     
1265    901FFF        5042     MOV DPTR , # 8191 
1268    14            5043     	DEC	A
1269    6000          5044     	JZ	LOCK_BYTE_TEST
                      5045     
                      5046     LOCK_BYTE_TEST: 
126B    93            5047     	MOVC A, @A+DPTR		; Read lock byte
126C    04            5048     	INC	A				
126D    6003          5049     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5050     
                      5051     IF ONE_S_CAPABLE == 0		
126F    75EF12        5052     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5053     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5056     
                      5057     LOCK_BYTE_OK: 
                      5058     	; Select register bank 0 for main program routines
1272    C2D3          5059     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5060     	; Disable the WDT.
1274    53D9BF        5061     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5062     	; Initialize stack
1277    7581C0        5063     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5064     	; Initialize VDD monitor
127A    43FF80        5065     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
127D    1207D3        5066     	CALL	WAIT1MS			; Wait at least 100us
                      5067     IF ONE_S_CAPABLE == 0		
1280    75EF02        5068     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5069     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5072     	; Set clock frequency
1283    43B203        5073     	ORL	OSCICN, #03H		; Set clock divider to 1
1286    E5B3          5074     	MOV	A, OSCICL				
1288    2404          5075     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
128A    4002          5076     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5077     
128C    F5B3          5078     	MOV	OSCICL, A
                      5079     
                      5080     RESET_CAL_DONE: 
                      5081     	; Switch power off
128E    1178          5082     	CALL	SWITCH_POWER_OFF
                      5083     	; Ports initialization
1290    7580FF        5084     MOV P0 , # 255 
1293    75A400        5085     MOV P0MDOUT , # 0 
1296    75F1F0        5086     MOV P0MDIN , # -16 
1299    75D4DF        5087     MOV P0SKIP , # -33 
129C    759002        5088     MOV P1 , # 2 
129F    75A5FC        5089     MOV P1MDOUT , # 252 
12A2    75F2FD        5090     MOV P1MDIN , # -3 
12A5    75D502        5091     MOV P1SKIP , # 2 
                      5092     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12A8    75A610        5095     MOV P2MDOUT , # 16 
                      5096     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5103     	; Initialize the XBAR and related functionality
                      5104     	INITIALIZE_XBAR		
12AB    75A0FF        5104+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12AE    75F3F1        5104+1   MOV P2MDIN , # -15 
12B1    75E241        5104+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5105     	; Clear RAM
12B4    E4            5106     	CLR	A				; Clear accumulator
12B5    F8            5107     MOV R0 , A 
                      5108     CLEAR_RAM: 	
12B6    F6            5109     MOV @ R0 , A 
12B7    D8FD          5110     DJNZ R0 , CLEAR_RAM 
                      5111     	; Set default programmed parameters
12B9    11F5          5112     	CALL	SET_DEFAULT_PARAMETERS
                      5113     	; EEPROM 
12BB    121871        5114     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      5115     	; Decode parameters
12BE    314F          5116     	CALL	DECODE_PARAMETERS
                      5117     	; Decode governor gains
12C0    31E3          5118     	CALL	DECODE_GOVERNOR_GAINS
                      5119     	; Decode throttle rate
12C2    31FC          5120     	CALL	DECODE_THROTTLE_RATE
                      5121     	; Decode startup power
12C4    510A          5122     	CALL	DECODE_STARTUP_POWER
                      5123     	; Decode demag compensation
12C6    5118          5124     	CALL	DECODE_DEMAG_COMP
                      5125     	; Set BEC voltage
12C8    5126          5126     	CALL	SET_BEC_VOLTAGE
                      5127     	; Find throttle gain from stored min and max settings
12CA    5127          5128     	CALL	FIND_THROTTLE_GAIN
                      5129     	; Set beep strength
12CC    7898          5130     MOV R0 , # PGM_BEEP_STRENGTH 
12CE    866F          5131     MOV BEEP_STRENGTH , @ R0 
                      5132     	; Switch power off
12D0    1178          5133     	CALL	SWITCH_POWER_OFF
                      5134     	; Timer control
12D2    758850        5135     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5136     	; Timer mode
12D5    758902        5137     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5138     	; Timer2: clk/12 for 128us and 32ms interrupts
12D8    75C824        5139     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5140     	; Timer3: clk/12 for commutation timing
12DB    759104        5141     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5142     	; PCA
12DE    75D840        5143     	MOV	PCA0CN, #40H		; PCA enabled
                      5144     	; Initializing beep
12E1    C2AF          5145     	CLR	EA				; Disable interrupts explicitly
12E3    1207EC        5146     	CALL WAIT200MS	
12E6    1207FC        5147     	CALL BEEP_F1
12E9    1207E2        5148     	CALL WAIT30MS
12EC    120803        5149     	CALL BEEP_F2
12EF    1207E2        5150     	CALL WAIT30MS
12F2    12080A        5151     	CALL BEEP_F3
12F5    1207E2        5152     	CALL WAIT30MS
                      5153     
                      5154     	; Wait for receiver to initialize
12F8    121CB8        5155     	CALL	WAIT1S
12FB    1207EC        5156     	CALL	WAIT200MS
12FE    1207EC        5157     	CALL	WAIT200MS
1301    1207E7        5158     	CALL	WAIT100MS
                      5159     
                      5160     	; Enable interrupts
1304    75A822        5161     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1307    75B802        5162     	MOV	IP, #02H			; High priority to timer0 interrupts
130A    75E690        5163     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5164     	; Initialize comparator
130D    759B80        5165     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1310    759D03        5166     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5167     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5171     	; Initialize ADC
                      5172     	INITIALIZE_ADC			; Initialize ADC operation
1313    75D10E        5172+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1316    75BC58        5172+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1319    75BB09        5172+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
131C    75BA11        5172+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
131F    75E880        5172+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1322    1207D3        5173     	CALL	WAIT1MS
1325    D2AF          5174     	SETB	EA				; Enable all interrupts
                      5175     	; Measure number of lipo cells
1327    120AB4        5176     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5177     	; Initialize rc pulse
                      5178     	RCP_INT_ENABLE		 			; Enable interrupt
132A    43DA01        5178+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5179     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
132D    C2D8          5179+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
132F    C269          5180     CLR FLAGS2 . 1 
1331    1207EC        5181     	CALL WAIT200MS
                      5182     	; Set initial arm variable
1334    753001        5183     	MOV	INITIAL_ARM, #1
                      5184     
                      5185     	; Measure PWM frequency
                      5186     MEASURE_PWM_FREQ_INIT: 	
1337    D259          5187     SETB FLAGS0 . 1 
                      5188     MEASURE_PWM_FREQ_START: 	
1339    7A05          5189     MOV R2 , # 5 
                      5190     MEASURE_PWM_FREQ_LOOP: 	
                      5191     	; Check if period diff was accepted
133B    E558          5192     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
133D    7002          5193     	JNZ	($+4)
                      5194     
133F    7A05          5195     MOV R2 , # 5 
                      5196     
1341    1207D8        5197     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1344    E559          5198     	MOV	A, NEW_RCP					; Load value
1346    C3            5199     	CLR	C
1347    9402          5200     SUBB A , # 2 
1349    40EE          5201     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5202     
134B    E52E          5203     	MOV	A, FLAGS3						; Check pwm frequency flags
134D    541F          5204     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
134F    855B5A        5205     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1352    F55B          5206     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1354    B55AE2        5207     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5208     
1357    DAE2          5209     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5210     
                      5211     	; Clear measure pwm frequency flag
1359    C259          5212     CLR FLAGS0 . 1 
                      5213     	; Set up RC pulse interrupts after pwm frequency measurement
                      5214     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
135B    53DACF        5214+1   ANL PCA0CPM0 , # 0CFH 
135E    207603        5214+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1361    43DA20        5214+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1364    307603        5214+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1367    43DA10        5214+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5215     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
136A    C2D8          5215+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
136C    C269          5216     CLR FLAGS2 . 1 
136E    1207E7        5217     	CALL WAIT100MS						; Wait for new RC pulse
                      5218     
                      5219     	; Validate RC pulse
                      5220     VALIDATE_RCP_START: 	
1371    1207D8        5221     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1374    7802          5222     MOV R0 , # 2 
1376    741F          5223     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1378    552E          5224     	ANL	A, FLAGS3						; Check pwm frequency flags
137A    7002          5225     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5226     
137C    7800          5227     MOV R0 , # 0 
                      5228     
137E    C3            5229     	CLR	C
137F    E559          5230     	MOV	A, NEW_RCP					; Load value
1381    98            5231     SUBB A , R0 
1382    40ED          5232     	JC	VALIDATE_RCP_START				; No - start over
                      5233     
                      5234     	; Beep arm sequence start signal
1384    C2AF          5235     	CLR 	EA							; Disable all interrupts
1386    1207FC        5236     	CALL BEEP_F1						; Signal that RC pulse is ready
1389    1207FC        5237     	CALL BEEP_F1
138C    1207FC        5238     	CALL BEEP_F1
138F    D2AF          5239     	SETB	EA							; Enable all interrupts
1391    1207EC        5240     	CALL WAIT200MS	
                      5241     
                      5242     	; Arming sequence start
1394    754800        5243     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5244     ARMING_START: 
                      5245     IF MODE >= 1	; Tail or multi
1397    7888          5246     MOV R0 , # PGM_DIRECTION 
1399    E6            5247     MOV A , @ R0 
139A    B40302        5248     	CJNE	A, #3, ($+5)
                      5249     
139D    8172          5250     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      5251     ENDIF
                      5252     
139F    1207D8        5253     	CALL WAIT3MS
13A2    788C          5254     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
13A4    E6            5255     MOV A , @ R0 
13A5    C3            5256     	CLR	C
13A6    9401          5257     	SUBB	A, #1				; Is TX programming enabled?
13A8    5003          5258     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5259     
13AA    021472        5260     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5261     
                      5262     ARMING_INITIAL_ARM_CHECK: 
13AD    E530          5263     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
13AF    C3            5264     	CLR	C
13B0    9401          5265     	SUBB	A, #1				; Is it the initial arm sequence?
13B2    5003          5266     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5267     
13B4    021472        5268     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5269     
                      5270     ARMING_PPM_CHECK: 
13B7    741F          5271     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13B9    552E          5272     	ANL	A, FLAGS3				; Check pwm frequency flags
13BB    6035          5273     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5274     
                      5275     	; PWM tx program entry
13BD    C3            5276     	CLR	C
13BE    E559          5277     	MOV	A, NEW_RCP			; Load new RC pulse value
13C0    94FF          5278     SUBB A , # 255 
13C2    5003          5279     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5280     
13C4    021472        5281     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5282     
                      5283     PROGRAM_BY_TX_ENTRY_PWM: 	
13C7    C2AF          5284     	CLR	EA					; Disable all interrupts
13C9    120811        5285     	CALL BEEP_F4
13CC    D2AF          5286     	SETB	EA					; Enable all interrupts
13CE    1207E7        5287     	CALL WAIT100MS
13D1    C3            5288     	CLR	C
13D2    E559          5289     	MOV	A, NEW_RCP			; Load new RC pulse value
13D4    9401          5290     SUBB A , # 1 
13D6    50EF          5291     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5292     
                      5293     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13D8    C2AF          5294     	CLR	EA					; Disable all interrupts
13DA    1207FC        5295     	CALL BEEP_F1
13DD    1207DD        5296     	CALL WAIT10MS
13E0    1207FC        5297     	CALL BEEP_F1
13E3    D2AF          5298     	SETB	EA					; Enable all interrupts
13E5    1207E7        5299     	CALL WAIT100MS
13E8    C3            5300     	CLR	C
13E9    E559          5301     	MOV	A, NEW_RCP			; Load new RC pulse value
13EB    94FF          5302     SUBB A , # 255 
13ED    40E9          5303     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5304     
13EF    021D3D        5305     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5306     
                      5307     	; PPM throttle calibration and tx program entry
                      5308     THROTTLE_HIGH_CAL_START: 
13F2    7F05          5309     MOV R7 , # 5 
                      5310     THROTTLE_HIGH_CAL: 			
13F4    D277          5311     SETB FLAGS3 . 7 
13F6    5127          5312     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13F8    1207E7        5313     	CALL WAIT100MS				; Wait for new throttle value
13FB    C2AF          5314     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13FD    C277          5315     CLR FLAGS3 . 7 
13FF    5127          5316     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1401    AE59          5317     MOV R6 , NEW_RCP 
1403    C3            5318     	CLR	C
1404    E559          5319     	MOV	A, NEW_RCP			; Load new RC pulse value
1406    947F          5320     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1408    D2AF          5321     	SETB	EA					; Enable interrupts
140A    4070          5322     	JC	ARM_TARGET_UPDATED		; No - branch
                      5323     
140C    1207D3        5324     	CALL WAIT1MS		
140F    C2AF          5325     	CLR	EA					; Disable all interrupts
1411    120811        5326     	CALL BEEP_F4
1414    D2AF          5327     	SETB	EA					; Enable all interrupts
1416    DFDC          5328     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5329     
1418    C3            5330     	CLR	C
1419    EE            5331     MOV A , R6 
141A    9405          5332     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
141C    7897          5333     MOV R0 , # PGM_PPM_MAX_THROTTLE 
141E    F6            5334     MOV @ R0 , A 
141F    1207EC        5335     	CALL WAIT200MS				
1422    121871        5336     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1425    121CC0        5337     	CALL	SUCCESS_BEEP
                      5338     
                      5339     THROTTLE_LOW_CAL_START: 
1428    7F0A          5340     MOV R7 , # 10 
                      5341     THROTTLE_LOW_CAL: 			
142A    D277          5342     SETB FLAGS3 . 7 
142C    5127          5343     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
142E    1207E7        5344     	CALL WAIT100MS
1431    C2AF          5345     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1433    C277          5346     CLR FLAGS3 . 7 
1435    5127          5347     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1437    AE59          5348     MOV R6 , NEW_RCP 
1439    C3            5349     	CLR	C
143A    E559          5350     	MOV	A, NEW_RCP			; Load new RC pulse value
143C    947F          5351     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
143E    D2AF          5352     	SETB	EA					; Enable interrupts
1440    50E6          5353     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5354     
1442    1207D3        5355     	CALL WAIT1MS		
1445    C2AF          5356     	CLR	EA					; Disable all interrupts
1447    1207FC        5357     	CALL BEEP_F1
144A    1207DD        5358     	CALL WAIT10MS
144D    1207FC        5359     	CALL BEEP_F1
1450    D2AF          5360     	SETB	EA					; Enable all interrupts
1452    DFD6          5361     DJNZ R7 , THROTTLE_LOW_CAL 
                      5362     
1454    EE            5363     MOV A , R6 
1455    2405          5364     	ADD	A, #5				; Add about 2%
1457    7896          5365     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1459    F6            5366     MOV @ R0 , A 
145A    1207EC        5367     	CALL WAIT200MS				
145D    121871        5368     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1460    121CEF        5369     	CALL	SUCCESS_BEEP_INVERTED
                      5370     
                      5371     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
1463    1207E7        5372     	CALL WAIT100MS
1466    5127          5373     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1468    C3            5374     	CLR	C
1469    E559          5375     	MOV	A, NEW_RCP			; Load new RC pulse value
146B    94FF          5376     SUBB A , # 255 
146D    40F4          5377     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5378     
146F    021D3D        5379     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5380     
                      5381     PROGRAM_BY_TX_CHECKED: 
1472    C3            5382     	CLR	C
1473    E559          5383     	MOV	A, NEW_RCP			; Load new RC pulse value
1475    9548          5384     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1477    4003          5385     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5386     
1479    855948        5387     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5388     
                      5389     ARM_TARGET_UPDATED: 
147C    1207E7        5390     	CALL WAIT100MS				; Wait for new throttle value
147F    C3            5391     	CLR	C
1480    E559          5392     	MOV	A, NEW_RCP			; Load new RC pulse value
1482    9401          5393     SUBB A , # 1 
1484    4002          5394     	JC	ARM_END_BEEP			; Yes - proceed
                      5395     
1486    6197          5396     	JMP	ARMING_START			; No - start over
                      5397     
                      5398     ARM_END_BEEP: 
                      5399     	; Beep arm sequence end signal
1488    C2AF          5400     	CLR 	EA					; Disable all interrupts
148A    120811        5401     	CALL BEEP_F4				; Signal that rcpulse is ready
148D    120811        5402     	CALL BEEP_F4
1490    120811        5403     	CALL BEEP_F4
1493    D2AF          5404     	SETB	EA					; Enable all interrupts
1495    1207EC        5405     	CALL WAIT200MS
                      5406     
                      5407     	; Clear initial arm variable
1498    753000        5408     	MOV	INITIAL_ARM, #0
                      5409     
                      5410     	; Armed and waiting for power on
                      5411     WAIT_FOR_POWER_ON: 
149B    E4            5412     	CLR	A
149C    F531          5413     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
149E    F532          5414     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5415     WAIT_FOR_POWER_ON_LOOP: 
14A0    0531          5416     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
14A2    E531          5417     	MOV	A, POWER_ON_WAIT_CNT_L
14A4    F4            5418     	CPL	A
14A5    7039          5419     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5420     
14A7    0532          5421     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
14A9    789A          5422     MOV R0 , # PGM_BEACON_DELAY 
14AB    E6            5423     MOV A , @ R0 
14AC    7819          5424     MOV R0 , # 25 
14AE    14            5425     	DEC	A
14AF    6012          5426     	JZ	BEEP_DELAY_SET
                      5427     
14B1    7832          5428     MOV R0 , # 50 
14B3    14            5429     	DEC	A
14B4    600D          5430     	JZ	BEEP_DELAY_SET
                      5431     
14B6    787D          5432     MOV R0 , # 125 
14B8    14            5433     	DEC	A
14B9    6008          5434     	JZ	BEEP_DELAY_SET
                      5435     
14BB    78FA          5436     MOV R0 , # 250 
14BD    14            5437     	DEC	A
14BE    6003          5438     	JZ	BEEP_DELAY_SET
                      5439     
14C0    753200        5440     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5441     
                      5442     BEEP_DELAY_SET: 
14C3    C3            5443     	CLR	C
14C4    E532          5444     	MOV	A, POWER_ON_WAIT_CNT_H
14C6    98            5445     SUBB A , R0 
14C7    4017          5446     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5447     
14C9    1532          5448     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14CB    7531B4        5449     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14CE    7899          5450     MOV R0 , # PGM_BEACON_STRENGTH 
14D0    866F          5451     MOV BEEP_STRENGTH , @ R0 
14D2    C2AF          5452     	CLR 	EA					; Disable all interrupts
14D4    120811        5453     	CALL BEEP_F4				; Signal that there is no signal
14D7    D2AF          5454     	SETB	EA					; Enable all interrupts
14D9    7898          5455     MOV R0 , # PGM_BEEP_STRENGTH 
14DB    866F          5456     MOV BEEP_STRENGTH , @ R0 
14DD    1207E7        5457     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5458     
                      5459     WAIT_FOR_POWER_ON_NO_BEEP: 
14E0    1207DD        5460     	CALL WAIT10MS
14E3    E528          5461     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14E5    7008          5462     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5463     
14E7    741F          5464     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
14E9    552E          5465     	ANL	A, FLAGS3						; Check pwm frequency flags
14EB    7002          5466     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5467     
14ED    6137          5468     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5469     
                      5470     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14EF    C3            5471     	CLR	C
14F0    E559          5472     	MOV	A, NEW_RCP			; Load new RC pulse value
14F2    9406          5473     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
14F4    40AA          5474     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5475     
                      5476     IF MODE >= 1	; Tail or multi
14F6    7888          5477     MOV R0 , # PGM_DIRECTION 
14F8    E6            5478     MOV A , @ R0 
14F9    C3            5479     	CLR	C
14FA    9403          5480     	SUBB	A, #3
14FC    6003          5481     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5482     ENDIF
                      5483     
14FE    1207E7        5484     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5485     
1501    E528          5486     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1503    7003          5487     	JNZ	($+5)				; If it is not zero - proceed
                      5488     
1505    021337        5489     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5490     
                      5491     
                      5492     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5493     ;
                      5494     ; Start entry point
                      5495     ;
                      5496     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5497     INIT_START: 
1508    C2AF          5498     	CLR	EA
150A    1178          5499     	CALL SWITCH_POWER_OFF
150C    E4            5500     	CLR	A
150D    F522          5501     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
150F    F523          5502     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1511    F524          5503     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1513    F525          5504     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1515    D2AF          5505     	SETB	EA
1517    7885          5506     MOV R0 , # PGM_MOTOR_IDLE 
1519    8661          5507     MOV PWM_MOTOR_IDLE , @ R0 
151B    F540          5508     	MOV	GOV_TARGET_L, A		; Set target to zero
151D    F541          5509     	MOV	GOV_TARGET_H, A
151F    F542          5510     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1521    F543          5511     	MOV	GOV_INTEGRAL_H, A
1523    F544          5512     	MOV	GOV_INTEGRAL_X, A
1525    F56C          5513     	MOV	ADC_CONVERSION_CNT, A
1527    F549          5514     	MOV	GOV_ACTIVE, A
1529    F52B          5515     	MOV	FLAGS0, A				; Clear flags0
152B    F52C          5516     	MOV	FLAGS1, A				; Clear flags1
152D    F539          5517     	MOV	DEMAG_CONSECUTIVE_CNT, A
152F    120C32        5518     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5519     	;**** **** **** **** ****
                      5520     	; Motor start beginning
                      5521     	;**** **** **** **** **** 
1532    756C08        5522     MOV ADC_CONVERSION_CNT , # 8 
                      5523     	SET_ADC_IP_TEMP
1535    75BB10        5523+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1538    1207D3        5524     	CALL WAIT1MS
153B    120B4F        5525     	CALL START_ADC_CONVERSION
                      5526     READ_INITIAL_TEMP: 
                      5527     	GET_ADC_STATUS 
153E    E5E8          5527+1   MOV A , ADC0CN 
1540    20ECFB        5528     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5529     	READ_ADC_RESULT						; Read initial temperature
1543    A8BD          5529+1   MOV R0 , ADC0L 
1545    A9BE          5529+1   MOV R1 , ADC0H 
1547    E9            5530     MOV A , R1 
1548    7001          5531     	JNZ	($+3)							; Is reading below 256?
                      5532     
154A    F8            5533     MOV R0 , A 
                      5534     
154B    886D          5535     MOV CURRENT_AVERAGE_TEMP , R0 
154D    120B53        5536     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1550    756C08        5537     MOV ADC_CONVERSION_CNT , # 8 
                      5538     	SET_ADC_IP_TEMP
1553    75BB10        5538+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5539     
                      5540     	; Go to the desired startup mode
1556    7895          5541     MOV R0 , # PGM_STARTUP_METHOD 
1558    E6            5542     MOV A , @ R0 
1559    30E003        5543     	JNB	ACC.0, DIRECT_METHOD_START
                      5544     
155C    0215A0        5545     	JMP	STEPPER_METHOD_START
                      5546     
                      5547     DIRECT_METHOD_START: 
                      5548     	; Set up start operating conditions
155F    7887          5549     MOV R0 , # PGM_PWM_FREQ 
1561    E6            5550     MOV A , @ R0 
1562    FE            5551     MOV R6 , A 
1563    7602          5552     MOV @ R0 , # 2 
1565    314F          5553     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1567    7887          5554     MOV R0 , # PGM_PWM_FREQ 
1569    EE            5555     MOV A , R6 
156A    F6            5556     MOV @ R0 , A 
                      5557     	; Set max allowed power
156B    D261          5558     SETB FLAGS1 . 1 
156D    C2AF          5559     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
156F    755EFF        5560     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1572    120C02        5561     	CALL SET_STARTUP_PWM
1575    85225E        5562     	MOV	PWM_LIMIT, REQUESTED_PWM
1578    85225F        5563     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
157B    D2AF          5564     	SETB	EA
157D    C261          5565     CLR FLAGS1 . 1 
157F    752501        5566     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
1582    855D64        5567     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1585    756501        5568     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5569     	; Begin startup sequence
1588    D260          5570     SETB FLAGS1 . 0 
158A    D263          5571     SETB FLAGS1 . 3 
158C    753800        5572     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
158F    120FD2        5573     	CALL COMM5COMM6				; Initialize commutation
1592    110D          5574     	CALL COMM6COMM1				
1594    120CAC        5575     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1597    120C32        5576     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
159A    120D2F        5577     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
159D    0216C8        5578     	JMP	RUN1
                      5579     
                      5580     
                      5581     STEPPER_METHOD_START: 
                      5582     	; Set up start operating conditions
15A0    7887          5583     MOV R0 , # PGM_PWM_FREQ 
15A2    E6            5584     MOV A , @ R0 
15A3    FE            5585     MOV R6 , A 
15A4    7603          5586     MOV @ R0 , # 3 
15A6    7893          5587     MOV R0 , # PGM_DAMPING_FORCE 
15A8    E6            5588     MOV A , @ R0 
15A9    FD            5589     MOV R5 , A 
15AA    7605          5590     MOV @ R0 , # 5 
15AC    314F          5591     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15AE    7887          5592     MOV R0 , # PGM_PWM_FREQ 
15B0    EE            5593     MOV A , R6 
15B1    F6            5594     MOV @ R0 , A 
15B2    7893          5595     MOV R0 , # PGM_DAMPING_FORCE 
15B4    ED            5596     MOV A , R5 
15B5    F6            5597     MOV @ R0 , A 
                      5598     	; Begin startup sequence
15B6    D260          5599     SETB FLAGS1 . 0 
15B8    D261          5600     SETB FLAGS1 . 1 
15BA    D265          5601     SETB FLAGS1 . 5 
15BC    120FD2        5602     	CALL COMM5COMM6			; Initialize commutation
15BF    110D          5603     	CALL COMM6COMM1			
15C1    755EFF        5604     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15C4    120C02        5605     	CALL SET_STARTUP_PWM
15C7    1207D3        5606     	CALL WAIT1MS
15CA    120EDA        5607     	CALL COMM1COMM2
15CD    1207D3        5608     	CALL WAIT1MS
15D0    1207D3        5609     	CALL WAIT1MS
15D3    120F0C        5610     	CALL COMM2COMM3
15D6    1207D8        5611     	CALL WAIT3MS			
15D9    120F56        5612     	CALL COMM3COMM4
15DC    1207D8        5613     	CALL WAIT3MS			
15DF    1207D8        5614     	CALL WAIT3MS			
15E2    120F91        5615     	CALL COMM4COMM5
15E5    1207DD        5616     	CALL WAIT10MS				; Settle rotor
15E8    120FD2        5617     	CALL COMM5COMM6
15EB    1207D8        5618     	CALL WAIT3MS				
15EE    1207D3        5619     	CALL WAIT1MS			
15F1    C261          5620     CLR FLAGS1 . 1 
15F3    D262          5621     SETB FLAGS1 . 2 
                      5622     
                      5623     	;**** **** **** **** ****
                      5624     	; Stepper phase beginning
                      5625     	;**** **** **** **** **** 
                      5626     STEPPER_ROT_BEG: 
15F5    120B4F        5627     	CALL START_ADC_CONVERSION
15F8    120B53        5628     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15FB    120C02        5629     	CALL SET_STARTUP_PWM
15FE    756C08        5630     MOV ADC_CONVERSION_CNT , # 8 
                      5631     	SET_ADC_IP_TEMP
1601    75BB10        5631+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5632     
1604    110D          5633     	CALL COMM6COMM1				; Commutate
1606    120CA5        5634     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
1609    120D2F        5635     	CALL CALC_NEW_WAIT_TIMES
160C    118A          5636     	CALL DECREMENT_STEPPER_STEP
160E    11EF          5637     	CALL STEPPER_TIMER_WAIT
                      5638     
1610    120EDA        5639     	CALL COMM1COMM2			
1613    120CA5        5640     	CALL CALC_NEXT_COMM_TIMING_START	
1616    120D2F        5641     	CALL CALC_NEW_WAIT_TIMES
1619    118A          5642     	CALL DECREMENT_STEPPER_STEP
161B    11EF          5643     	CALL STEPPER_TIMER_WAIT
                      5644     
161D    120F0C        5645     	CALL COMM2COMM3			
1620    120CA5        5646     	CALL CALC_NEXT_COMM_TIMING_START	
1623    120D2F        5647     	CALL CALC_NEW_WAIT_TIMES
1626    118A          5648     	CALL DECREMENT_STEPPER_STEP
1628    11EF          5649     	CALL STEPPER_TIMER_WAIT
                      5650     
162A    120F56        5651     	CALL COMM3COMM4			
162D    120CA5        5652     	CALL CALC_NEXT_COMM_TIMING_START	
1630    120D2F        5653     	CALL CALC_NEW_WAIT_TIMES
1633    118A          5654     	CALL DECREMENT_STEPPER_STEP
1635    11EF          5655     	CALL STEPPER_TIMER_WAIT
                      5656     
1637    120F91        5657     	CALL COMM4COMM5			
163A    120CA5        5658     	CALL CALC_NEXT_COMM_TIMING_START	
163D    120D2F        5659     	CALL CALC_NEW_WAIT_TIMES
1640    118A          5660     	CALL DECREMENT_STEPPER_STEP
1642    11EF          5661     	CALL STEPPER_TIMER_WAIT
                      5662     
1644    120FD2        5663     	CALL COMM5COMM6			
1647    120CA5        5664     	CALL CALC_NEXT_COMM_TIMING_START	
164A    120D2F        5665     	CALL CALC_NEW_WAIT_TIMES
164D    118A          5666     	CALL DECREMENT_STEPPER_STEP	
                      5667     	; Check stepper step versus end criteria
164F    C3            5668     	CLR	C
1650    E550          5669     	MOV	A, WT_STEPPER_STEP_L
1652    9535          5670     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1654    E551          5671     	MOV	A, WT_STEPPER_STEP_H
1656    9536          5672     	SUBB	A, STEPPER_STEP_END_H
1658    400C          5673     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5674     
                      5675     	; Wait for step
165A    11EF          5676     	CALL STEPPER_TIMER_WAIT
165C    C3            5677     	CLR	C
165D    E559          5678     	MOV	A, NEW_RCP				; Load new pulse value
165F    9401          5679     SUBB A , # 1 
1661    5092          5680     	JNC	STEPPER_ROT_BEG
                      5681     
1663    0217F9        5682     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5683     
                      5684     STEPPER_ROT_EXIT: 
                      5685     	; Wait for step
1666    11EF          5686     	CALL STEPPER_TIMER_WAIT
                      5687     	; Clear stepper phase
1668    C262          5688     CLR FLAGS1 . 2 
                      5689     	; Set dondamped low pwm frequency
166A    7887          5690     MOV R0 , # PGM_PWM_FREQ 
166C    E6            5691     MOV A , @ R0 
166D    FE            5692     MOV R6 , A 
166E    7602          5693     MOV @ R0 , # 2 
1670    314F          5694     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1672    7887          5695     MOV R0 , # PGM_PWM_FREQ 
1674    EE            5696     MOV A , R6 
1675    F6            5697     MOV @ R0 , A 
                      5698     	; Set spoolup power variables (power is now controlled from RCP)
1676    85225E        5699     	MOV	PWM_LIMIT, REQUESTED_PWM
1679    85605F        5700     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
167C    856025        5701     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
167F    855D64        5702     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1682    756501        5703     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5704     	; Set direct startup phase to acquire sync quickly
1685    D263          5705     SETB FLAGS1 . 3 
1687    753800        5706     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
168A    C2AF          5707     	CLR	EA						; Disable interrupts
                      5708     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
168C    207502        5708+1   JB FLAGS3 . 5 , ( $+5 ) 
168F    C293          5708+1   CLR P1 . 3 
1691    307502        5708+1   JNB FLAGS3 . 5 , ( $+5 ) 
1694    C297          5708+1   CLR P1 . 7 
                      5709     	CPFET_OFF						; Cp off
1696    207502        5709+1   JB FLAGS3 . 5 , ( $+5 ) 
1699    C297          5709+1   CLR P1 . 7 
169B    307502        5709+1   JNB FLAGS3 . 5 , ( $+5 ) 
169E    C293          5709+1   CLR P1 . 3 
16A0    742D          5710     	MOV	A, #45					; 8us delay for pfets to go off
16A2    D5E0FD        5711     	DJNZ	ACC, $
16A5    D2AF          5712     	SETB	EA						; Enable interrupts
16A7    110D          5713     	CALL COMM6COMM1				
16A9    120CAC        5714     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16AC    120D1B        5715     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16AF    120D2F        5716     	CALL CALC_NEW_WAIT_TIMES
16B2    120DC0        5717     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16B5    756C00        5718     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5719     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16B8    75BB09        5719+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16BB    0216C8        5720     	JMP	RUN1
                      5721     
                      5722     
                      5723     
                      5724     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5725     ;
                      5726     ; Run entry point
                      5727     ;
                      5728     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5729     DAMPED_TRANSITION: 
                      5730     	; Transition from nondamped to damped if applicable
16BE    314F          5731     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16C0    110D          5732     	CALL	COMM6COMM1
16C2    756C00        5733     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5734     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16C5    75BB09        5734+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5735     
                      5736     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5737     ; Out_cA changes from low to high
                      5738     RUN1: 
16C8    120DE2        5739     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16CB    120E67        5740     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16CE    120E92        5741     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16D1    1208FB        5742     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16D4    120EA6        5743     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16D7    120EDA        5744     	CALL COMM1COMM2			; Commutate
16DA    120CAC        5745     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
16DD    120D1B        5746     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
16E0    120D2F        5747     	CALL CALC_NEW_WAIT_TIMES
16E3    120DC0        5748     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5749     
                      5750     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5751     ; Out_cB changes from high to low
                      5752     RUN2: 
16E6    120DD9        5753     	CALL WAIT_FOR_COMP_OUT_LOW
16E9    120E67        5754     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16EC    120E92        5755     	CALL SETUP_COMM_WAIT	
16EF    120958        5756     	CALL CALC_GOVERNOR_PROP_ERROR
16F2    120EA6        5757     	CALL WAIT_FOR_COMM
16F5    120F0C        5758     	CALL COMM2COMM3
16F8    120CAC        5759     	CALL CALC_NEXT_COMM_TIMING
16FB    120D1B        5760     	CALL WAIT_ADVANCE_TIMING
16FE    120D2F        5761     	CALL CALC_NEW_WAIT_TIMES
1701    120DC0        5762     	CALL WAIT_BEFORE_ZC_SCAN	
                      5763     
                      5764     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5765     ; Out_cC changes from low to high
                      5766     RUN3: 
1704    120DE2        5767     	CALL WAIT_FOR_COMP_OUT_HIGH
1707    120E67        5768     	CALL	EVALUATE_COMPARATOR_INTEGRITY
170A    120E92        5769     	CALL SETUP_COMM_WAIT	
170D    120991        5770     	CALL CALC_GOVERNOR_INT_ERROR
1710    120EA6        5771     	CALL WAIT_FOR_COMM
1713    120F56        5772     	CALL COMM3COMM4
1716    120CAC        5773     	CALL CALC_NEXT_COMM_TIMING
1719    120D1B        5774     	CALL WAIT_ADVANCE_TIMING
171C    120D2F        5775     	CALL CALC_NEW_WAIT_TIMES
171F    120DC0        5776     	CALL WAIT_BEFORE_ZC_SCAN	
                      5777     
                      5778     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5779     ; Out_cA changes from high to low
                      5780     RUN4: 
1722    120DD9        5781     	CALL WAIT_FOR_COMP_OUT_LOW
1725    120E67        5782     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1728    120E92        5783     	CALL SETUP_COMM_WAIT	
172B    1209EE        5784     	CALL CALC_GOVERNOR_PROP_CORRECTION
172E    120EA6        5785     	CALL WAIT_FOR_COMM
1731    120F91        5786     	CALL COMM4COMM5
1734    120CAC        5787     	CALL CALC_NEXT_COMM_TIMING
1737    120D1B        5788     	CALL WAIT_ADVANCE_TIMING
173A    120D2F        5789     	CALL CALC_NEW_WAIT_TIMES
173D    120DC0        5790     	CALL WAIT_BEFORE_ZC_SCAN	
                      5791     
                      5792     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5793     ; Out_cB changes from low to high
                      5794     RUN5: 
1740    120DE2        5795     	CALL WAIT_FOR_COMP_OUT_HIGH
1743    120E67        5796     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1746    120E92        5797     	CALL SETUP_COMM_WAIT	
1749    120A52        5798     	CALL CALC_GOVERNOR_INT_CORRECTION
174C    120EA6        5799     	CALL WAIT_FOR_COMM
174F    120FD2        5800     	CALL COMM5COMM6
1752    120CAC        5801     	CALL CALC_NEXT_COMM_TIMING
1755    120D1B        5802     	CALL WAIT_ADVANCE_TIMING
1758    120D2F        5803     	CALL CALC_NEW_WAIT_TIMES
175B    120DC0        5804     	CALL WAIT_BEFORE_ZC_SCAN	
                      5805     
                      5806     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5807     ; Out_cC changes from high to low
                      5808     RUN6: 
175E    120DD9        5809     	CALL WAIT_FOR_COMP_OUT_LOW
1761    120B4F        5810     	CALL START_ADC_CONVERSION
1764    120E67        5811     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1767    120E92        5812     	CALL SETUP_COMM_WAIT	
176A    120B53        5813     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
176D    120EA6        5814     	CALL WAIT_FOR_COMM
1770    110D          5815     	CALL COMM6COMM1
1772    120CAC        5816     	CALL CALC_NEXT_COMM_TIMING
1775    120D1B        5817     	CALL WAIT_ADVANCE_TIMING
1778    120D2F        5818     	CALL CALC_NEW_WAIT_TIMES
177B    120DC0        5819     	CALL WAIT_BEFORE_ZC_SCAN	
                      5820     
                      5821     	; Check if it is direct startup
177E    306342        5822     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      5823     
                      5824     	; Set spoolup power variables
1781    85605E        5825     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1784    85605F        5826     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1787    855D64        5827     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
178A    756501        5828     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5829     	; Check startup ok counter
178D    7964          5830     MOV R1 , # 100 
178F    7A14          5831     MOV R2 , # 20 
                      5832     IF MODE >= 1	; Tail or multi
1791    7888          5833     MOV R0 , # PGM_DIRECTION 
1793    E6            5834     MOV A , @ R0 
1794    B40304        5835     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      5836     
1797    791E          5837     MOV R1 , # 30 
1799    7A05          5838     MOV R2 , # 5 
                      5839     
                      5840     DIRECT_START_PARAMS_SET: 
                      5841     ENDIF
179B    C3            5842     	CLR	C
179C    E538          5843     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
179E    99            5844     SUBB A , R1 
179F    4015          5845     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5846     
17A1    C263          5847     CLR FLAGS1 . 3 
17A3    D264          5848     SETB FLAGS1 . 4 
17A5    8A37          5849     MOV STARTUP_ROT_CNT , R2 
                      5850     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      5854     IF MODE == 2	; Multi
17A7    7888          5855     MOV R0 , # PGM_DIRECTION 
17A9    E6            5856     MOV A , @ R0 
17AA    B40306        5857     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      5858     
17AD    755EFF        5859     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17B0    755FFF        5860     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      5861     
                      5862     DIRECT_START_PWM_LIM_SET: 
                      5863     ENDIF
17B3    0217C3        5864     	JMP	NORMAL_RUN_CHECKS
                      5865     
                      5866     DIRECT_START_CHECK_RCP: 
17B6    C3            5867     	CLR	C
17B7    E559          5868     	MOV	A, NEW_RCP				; Load new pulse value
17B9    9401          5869     SUBB A , # 1 
17BB    4003          5870     	JC	($+5)
                      5871     
17BD    0216C8        5872     	LJMP	RUN1						; Continue to run 
                      5873     
17C0    0217F9        5874     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5875     
                      5876     
                      5877     NORMAL_RUN_CHECKS: 
                      5878     	; Check if it is initial run phase
17C3    306419        5879     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      5880     
                      5881     	; Decrement startup rotaton count
17C6    E537          5882     	MOV	A, STARTUP_ROT_CNT
17C8    14            5883     	DEC	A
                      5884     	; Check number of nondamped rotations
17C9    7005          5885     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      5886     
17CB    C264          5887     CLR FLAGS1 . 4 
17CD    0216BE        5888     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      5889     
                      5890     NORMAL_RUN_CHECK_STARTUP_ROT: 
17D0    F537          5891     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      5892     
17D2    C3            5893     	CLR	C
17D3    E559          5894     	MOV	A, NEW_RCP				; Load new pulse value
17D5    9401          5895     SUBB A , # 1 
17D7    4003          5896     	JC	($+5)
                      5897     
17D9    0216C8        5898     	LJMP	RUN1						; Continue to run 
                      5899     
17DC    0217F9        5900     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5901     
                      5902     
                      5903     INITIAL_RUN_PHASE_DONE: 
                      5904     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      5917     	; Exit run loop after a given time
17DF    C3            5918     	CLR	C
17E0    E55C          5919     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
17E2    94FA          5920     SUBB A , # 250 
17E4    5013          5921     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      5922     
                      5923     RUN6_CHECK_RCP_TIMEOUT: 
17E6    741F          5924     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
17E8    552E          5925     	ANL	A, FLAGS3					; Check pwm frequency flags
17EA    7004          5926     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      5927     
17EC    E528          5928     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17EE    6009          5929     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      5930     
                      5931     RUN6_CHECK_SPEED: 
17F0    C3            5932     	CLR	C
17F1    E53D          5933     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
17F3    94F0          5934     	SUBB	A, #0F0H
17F5    5002          5935     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
17F7    C1C8          5936     	JMP	RUN1						; Go back to run 1
                      5937     
                      5938     
                      5939     RUN_TO_WAIT_FOR_POWER_ON: 	
17F9    C2AF          5940     	CLR	EA
17FB    1178          5941     	CALL SWITCH_POWER_OFF
17FD    7887          5942     MOV R0 , # PGM_PWM_FREQ 
17FF    E6            5943     MOV A , @ R0 
1800    FE            5944     MOV R6 , A 
1801    7602          5945     MOV @ R0 , # 2 
1803    12114F        5946     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1806    7887          5947     MOV R0 , # PGM_PWM_FREQ 
1808    EE            5948     MOV A , R6 
1809    F6            5949     MOV @ R0 , A 
180A    E4            5950     	CLR	A
180B    F522          5951     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
180D    F523          5952     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
180F    F524          5953     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1811    F525          5954     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1813    F561          5955     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1815    C260          5956     CLR FLAGS1 . 0 
1817    D2AF          5957     	SETB	EA
1819    1207D3        5958     	CALL	WAIT1MS					; Wait for pwm to be stopped
181C    121078        5959     	CALL SWITCH_POWER_OFF
                      5960     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      5991     IF MODE >= 1	; Tail or multi
181F    741F          5992     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1821    552E          5993     	ANL	A, FLAGS3					; Check pwm frequency flags
1823    7007          5994     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      5995     
1825    E528          5996     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1827    7003          5997     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      5998     
1829    021337        5999     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6000     
                      6001     JMP_WAIT_FOR_POWER_ON: 
182C    02149B        6002     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6003     ENDIF
                      6004     
                      6005     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6006     
                      6007     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      6727     
                      6728     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6729     
                      6730     
                      6731     
                      6732     
                      6733     END
MACRO ASSEMBLER BLHELI                                      05/25/15 15:35:39 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17D0H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E2DH   A 
CALC_NEXT_COMM_SL~  C ADDR   0D00H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B53H   A 
MEASURE_LIPO_WAIT~  C ADDR   0AC5H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A7FH   A 
GOVERNOR_CORR_NEG~  C ADDR   0A41H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
FUNCTION_BEEP. . .  C ADDR   1D24H   A 
INIT_START . . . .  C ADDR   1508H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13C7H   A 
FIND_THROTTLE_GAI~  C ADDR   1236H   A 
COMM45_NFET. . . .  C ADDR   0FB6H   A 
COMM45_NONDAMP . .  C ADDR   0FB3H   A 
COMM4COMM5 . . . .  C ADDR   0F91H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D25H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0BE6H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PARAVAL_BEEP . . .  C ADDR   1D32H   A 
STORE_MULTI_FUNC_~  C ADDR   1C92H   A 
DECODE_STARTUP_PO~  C ADDR   120AH   A 
GOVERNOR_CHECK_PWM  C ADDR   09CEH   A 
GOVERNOR_ACTIVATE.  C ADDR   0920H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
STORE_MULTI_FUNC_~  C ADDR   1C97H   A 
WRITE_EEPROM_SIGN~  C ADDR   1C30H   A 
WAIT_FOR_POWER_ON.  C ADDR   149BH   A 
THROTTLE_LOW_CAL_~  C ADDR   1428H   A 
ARMING_INITIAL_AR~  C ADDR   13ADH   A 
PROGRAM_BY_TX_CHE~  C ADDR   1472H   A 
ERASE_AND_STORE_A~  C ADDR   1871H   A 
SET_DEFAULT_PARAM~  C ADDR   10F5H   A 
COMM56_NONDAMP . .  C ADDR   0FF9H   A 
COMM23_CP. . . . .  C ADDR   0F44H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CACH   A 
COMM5COMM6 . . . .  C ADDR   0FD2H   A 
CALC_GOVERNOR_INT~  C ADDR   0A59H   A 
CALC_GOVERNOR_TAR~  C ADDR   0957H   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   1253H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FUNCTION_NEXT. . .  C ADDR   1D9BH   A 
STORE_MULTI_FUNC_~  C ADDR   1C9CH   A 
STEPPER_ROT_BEG. .  C ADDR   15F5H   A 
THROTTLE_HIGH_CAL.  C ADDR   13F4H   A 
DECODE_THROTTLE_R~  C ADDR   11FCH   A 
STEPPER_STEP_MED_~  C ADDR   0C7EH   A 
INITIALIZE_ALL_TI~  C ADDR   0C32H   A 
STARTUP_PWM_SET_P~  C ADDR   0C26H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
PARAVAL_NEXT . . .  C ADDR   1D86H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA1H   A 
WRITE_EEPROM_BYTE.  C ADDR   1C04H   A 
MEASURE_PWM_FREQ_~  C ADDR   1337H   A 
COMM61_CP. . . . .  C ADDR   1055H   A 
COMM_EXIT. . . . .  C ADDR   1064H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D07H   A 
CALC_GOVERNOR_INT~  C ADDR   0A52H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
FUNC_PARAVAL_WAIT.  C ADDR   1D50H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA6H   A 
WRITE_TAG. . . . .  C ADDR   1C59H   A 
READ_EEPROM_STORE~  C ADDR   1848H   A 
RUN1 . . . . . . .  C ADDR   16C8H   A 
CLEAR_RAM. . . . .  C ADDR   12B6H   A 
SET_BEC_VOLTAGE. .  C ADDR   1226H   A 
DECODE_GOVERNOR_G~  C ADDR   11E3H   A 
DEC_STEP_HIGH. . .  C ADDR   10B8H   A 
WAIT_FOR_COMM. . .  C ADDR   0EA6H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D4EH   A 
MEASURE_LIPO_ADD_~  C ADDR   0B42H   A 
CALC_GOVERNOR_PRO~  C ADDR   0990H   A 
DIV_U16_BY_U16_DI~  C ADDR   0874H   A 
WAIT100MS. . . . .  C ADDR   07E7H   A 
WAIT1MS. . . . . .  C ADDR   07D3H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
FUNCTION_PARAVAL_~  C ADDR   1D1EH   A 
STORE_MULTI_FUNC_~  C ADDR   1CABH   A 
STORE_NEW_VALUE_I~  C ADDR   1C61H   A 
DIRECT_START_PWM_~  C ADDR   17B3H   A 
RUN2 . . . . . . .  C ADDR   16E6H   A 
ARMING_PPM_CHECK .  C ADDR   13B7H   A 
COMM45_CP. . . . .  C ADDR   0FC9H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DC0H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B4AH   A 
GOVERNOR_CORR_INT~  C ADDR   0A9EH   A 
GOVERNOR_STORE_PR~  C ADDR   098CH   A 
DIV_U16_BY_U16_DI~  C ADDR   087EH   A 
WAIT200MS. . . . .  C ADDR   07ECH   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
STORE_MULTI_FUNC_~  C ADDR   1CB0H   A 
RUN3 . . . . . . .  C ADDR   1704H   A 
DIRECT_METHOD_STA~  C ADDR   155FH   A 
DECODE_DAMPING_DO~  C ADDR   118BH   A 
PWM_WAIT . . . . .  C ADDR   0E52H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0BF6H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A86H   A 
GOVERNOR_CHECK_IN~  C ADDR   09B6H   A 
DIV_U16_BY_U16_DI~  C ADDR   0895H   A 
WAIT3MS. . . . . .  C ADDR   07D8H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
BEEP_NO_ENTRY. . .  C ADDR   1D49H   A 
JMP_WAIT_FOR_POWE~  C ADDR   182CH   A 
DIRECT_START_CHEC~  C ADDR   17B6H   A 
RUN4 . . . . . . .  C ADDR   1722H   A 
STORE_TIMES_UP_OR~  C ADDR   0DA0H   A 
STORE_TIMES_DECRE~  C ADDR   0DB3H   A 
STEPPER_STEP_SET .  C ADDR   0C98H   A 
TEMP_AVERAGE_INC .  C ADDR   0B86H   A 
GOVERNOR_CORR_INT~  C ADDR   0AAFH   A 
MULT_S16_BY_U8_DI~  C ADDR   08A4H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
READ_TAGS. . . . .  C ADDR   1C3FH   A 
RUN5 . . . . . . .  C ADDR   1740H   A 
COMP_READ. . . . .  C ADDR   0E58H   A 
COMP_WAIT_SET_RES~  C ADDR   0E19H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D54H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AA3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0981H   A 
GOVERNOR_TARGET_C~  C ADDR   0903H   A 
CALC_GOVERNOR_TAR~  C ADDR   08FBH   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
RUN6 . . . . . . .  C ADDR   175EH   A 
ARMING_START . . .  C ADDR   1397H   A 
MEASURE_PWM_FREQ_~  C ADDR   133BH   A 
DECREMENT_STEP_EX~  C ADDR   10E5H   A 
COMM_RETURN. . . .  C ADDR   1077H   A 
GOVERNOR_DEACTIVA~  C ADDR   090DH   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
ARM_TARGET_UPDATED  C ADDR   147CH   A 
EVALUATE_COMPARAT~  C ADDR   0E67H   A 
TEMP_CHECK_EXIT. .  C ADDR   0BB0H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A28H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
WRITE_EEPROM_BLOC~  C ADDR   1894H   A 
NORMAL_RUN_CHECKS.  C ADDR   17C3H   A 
DEC_STEP_MED_LOW .  C ADDR   10D3H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DE8H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D1BH   A 
CALC_GOVERNOR_PRO~  C ADDR   0958H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WRITE_EEPROM_BLOC~  C ADDR   18A2H   A 
READ_ALL_EEPROM_P~  C ADDR   182FH   A 
PROGRAM_BY_TX_ENT~  C ADDR   1463H   A 
WAIT_FOR_COMM_BLI~  C ADDR   0EC0H   A 
SKYPUP_03. . . . .  C ADDR   078EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1218H   A 
EVAL_COMP_EXIT . .  C ADDR   0E91H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E79H   A 
STEPPER_STEP_LOW .  C ADDR   0C8CH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B07H   A 
PCA_INT_SET_TIMEO~  C ADDR   079FH   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   1666H   A 
STEPPER_METHOD_ST~  C ADDR   15A0H   A 
DECODE_PARAMS_DIR~  C ADDR   11C5H   A 
COMM12_DAMP. . . .  C ADDR   0EE4H   A 
SETUP_COMM_WAIT. .  C ADDR   0E92H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CA5H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BDCH   A 
CALC_GOVERNOR_INT~  C ADDR   09EDH   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
ARM_END_BEEP . . .  C ADDR   1488H   A 
THROTTLE_HIGH_CAL~  C ADDR   13F2H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DD9H   A 
LOAD_MIN_TIME. . .  C ADDR   0D70H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D2FH   A 
SET_STARTUP_PWM. .  C ADDR   0C02H   A 
GOVERNOR_STORE_IN~  C ADDR   09E7H   A 
GOVERNOR_ACTIVATE~  C ADDR   094AH   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
FUNC_PARAVAL . . .  C ADDR   1D4CH   A 
WAIT1S_LOOP. . . .  C ADDR   1CBAH   A 
STORE_MULTI_FUNC_1  C ADDR   1C65H   A 
RUN6_CHECK_RCP_TI~  C ADDR   17E6H   A 
DECREMENT_STEP . .  C ADDR   1096H   A 
COMM23_DAMP. . . .  C ADDR   0F14H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EC2H   A 
ADJUST_TIMING. . .  C ADDR   0D74H   A 
STEPPER_STEP_MED_~  C ADDR   0C62H   A 
MEASURE_LIPO_DIVI~  C ADDR   0B27H   A 
MEASURE_LIPO_START  C ADDR   0AB4H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A51H   A 
GOVERNOR_INT_MIN_~  C ADDR   09E2H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0988H   A 
BEEP_F1. . . . . .  C ADDR   07FCH   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
STORE_MULTI_FUNC_2  C ADDR   1C6AH   A 
INITIAL_RUN_PHASE~  C ADDR   17DFH   A 
TEST_THROTTLE_GAIN  C ADDR   1244H   A 
STEPPER_STEP_MED .  C ADDR   0C70H   A 
GOVERNOR_STORE_PR~  C ADDR   0A4FH   A 
GOVERNOR_CHECK_PR~  C ADDR   0A13H   A 
MULT_S16_BY_U8_PO~  C ADDR   08BEH   A 
DIV_U16_BY_U16 . .  C ADDR   086CH   A 
BEEP_ONOFF . . . .  C ADDR   081FH   A 
BEEP_F2. . . . . .  C ADDR   0803H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1D46H   A 
STORE_MULTI_FUNC_3  C ADDR   1C6FH   A 
SUCCESS_BEEP_INVE~  C ADDR   1CEFH   A 
SUCCESS_BEEP . . .  C ADDR   1CC0H   A 
FIND_THROTTLE_GAIN  C ADDR   1227H   A 
DECREMENT_STEPPER~  C ADDR   108AH   A 
COMM61_DAMP. . . .  C ADDR   1015H   A 
COMM34_DAMP. . . .  C ADDR   0F68H   A 
TEMP_AVERAGE_INC_~  C ADDR   0B76H   A 
GOVERNOR_INT_MAX_~  C ADDR   09DBH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09BFH   A 
BEEP_F3. . . . . .  C ADDR   080AH   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
STORE_MULTI_FUNC_4  C ADDR   1C74H   A 
DAMPED_TRANSITION.  C ADDR   16BEH   A 
BEEP_DELAY_SET . .  C ADDR   14C3H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13D8H   A 
LOCK_BYTE_OK . . .  C ADDR   1272H   A 
DECODE_PWM_FREQ_L~  C ADDR   11DDH   A 
DECODE_DAMPING_3 .  C ADDR   1163H   A 
CALC_NEW_WAIT_RED~  C ADDR   0D3FH   A 
BEEP_F4. . . . . .  C ADDR   0811H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
PROGRAM_BY_TX_EXIT  C ADDR   1DAAH   A 
STORE_MULTI_FUNC_5  C ADDR   1C79H   A 
READ_EEPROM_BYTE .  C ADDR   1C00H   A 
DIRECT_START_PARA~  C ADDR   179BH   A 
THROTTLE_LOW_CAL .  C ADDR   142AH   A 
DECODE_DAMPING_4 .  C ADDR   116DH   A 
COMM45_DAMP. . . .  C ADDR   0F99H   A 
WAIT_FOR_COMM_SET~  C ADDR   0ED2H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B8EH   A 
GOVERNOR_APPLY_IN~  C ADDR   0A8AH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A1EH   A 
BEEP_OFF . . . . .  C ADDR   0860H   A 
WAIT10MS . . . . .  C ADDR   07DDH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
STORE_MULTI_FUNC_6  C ADDR   1C7EH   A 
READ_TAG . . . . .  C ADDR   1C48H   A 
RESET_CAL_DONE . .  C ADDR   128EH   A 
DECODE_DAMPING_5 .  C ADDR   1177H   A 
DECODE_PARAMETERS.  C ADDR   114FH   A 
STEPPER_TIMER_WAIT  C ADDR   10EFH   A 
STORE_TIMES_INCRE~  C ADDR   0DA6H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BD5H   A 
MEASURE_LIPO_CELLS  C ADDR   0AB4H   A 
CALC_GOVERNOR_INT~  C ADDR   0991H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07B9H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
STORE_MULTI_FUNC_7  C ADDR   1C83H   A 
RUN6_CHECK_SPEED .  C ADDR   17F0H   A 
WAIT_FOR_POWER_ON~  C ADDR   14EFH   A 
DECODE_DAMPING_6 .  C ADDR   1181H   A 
DEC_STEP_LOW . . .  C ADDR   10DCH   A 
COMM56_DAMP. . . .  C ADDR   0FE4H   A 
SWITCH_POWER_OFF .  C ADDR   1078H   A 
WAIT30MS . . . . .  C ADDR   07E2H   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FUNC_PARAVAL_CONT~  C ADDR   1D79H   A 
STORE_MULTI_FUNC_8  C ADDR   1C88H   A 
WRITE_TAGS . . . .  C ADDR   1C52H   A 
WAIT1S . . . . . .  C ADDR   1CB8H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   17F9H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E87H   A 
ADJUST_TIMING_TWO~  C ADDR   0D96H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C01H   A 
CALC_GOVERNOR_PRO~  C ADDR   09F5H   A 
GOVERNOR_ACTIVATE~  C ADDR   0951H   A 
WAITXMS_M. . . . .  C ADDR   07F3H   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
STORE_MULTI_FUNC_9  C ADDR   1C8DH   A 
READ_INITIAL_TEMP.  C ADDR   153EH   A 
WAIT_FOR_POWER_ON~  C ADDR   14E0H   A 
DECODE_PWM_FREQ_E~  C ADDR   11E2H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0ED4H   A 
PWM_WAIT_STARTUP .  C ADDR   0E4DH   A 
START_ADC_CONVERS~  C ADDR   0B4FH   A 
MULT_S16_BY_U8_EX~  C ADDR   08F2H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
STORE_IN_RAM_EXIT.  C ADDR   1CB5H   A 
VALIDATE_RCP_START  C ADDR   1371H   A 
LOCK_BYTE_TEST . .  C ADDR   126BH   A 
DEC_STEP_MED_HIGH.  C ADDR   10C1H   A 
COMM_RESTORE_POWER  C ADDR   1075H   A 
COMM12_NONDAMP . .  C ADDR   0EF9H   A 
COMM1COMM2 . . . .  C ADDR   0EDAH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B8CH   A 
TEMP_AVERAGE_DEC .  C ADDR   0B82H   A 
CALC_GOVERNOR_PRO~  C ADDR   09EEH   A 
WAITXMS_O. . . . .  C ADDR   07F1H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07ABH   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
READ_EEPROM_EXIT .  C ADDR   1870H   A 
WAIT_FOR_POWER_ON~  C ADDR   14A0H   A 
DEC_STEP_MED . . .  C ADDR   10CAH   A 
READ_TIMER . . . .  C ADDR   0CB0H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BB4H   A 
CALC_GOVERNOR_INT~  C ADDR   0AB3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09C8H   A 
MULT_S16_BY_U8_DI~  C ADDR   08D7H   A 
BEEP . . . . . . .  C ADDR   0818H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
ERASE_FLASH. . . .  C ADDR   1C19H   A 
PROGRAM_BY_TX. . .  C ADDR   1D3DH   A 
COMM23_NFET. . . .  C ADDR   0F31H   A 
COMM23_NONDAMP . .  C ADDR   0F2EH   A 
COMM2COMM3 . . . .  C ADDR   0F0CH   A 
STEPPER_STEP_HIGH.  C ADDR   0C54H   A 
MEASURE_LIPO_CELL~  C ADDR   0AECH   A 
GOVERNOR_STORE_IN~  C ADDR   0AB1H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A73H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A3CH   A 
GOVERNOR_ACTIVATE~  C ADDR   093EH   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
FUNC_PARAVAL_STORE  C ADDR   1D6BH   A 
WRITE_EEPROM_BYTE~  C ADDR   1C05H   A 
READ_EEPROM_BLOCK1  C ADDR   1858H   A 
READ_EEPROM_READ .  C ADDR   1851H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B4EH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A24H   A 
GOVERNOR_CHECK_PR~  C ADDR   0975H   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
READ_EEPROM_BLOCK2  C ADDR   1866H   A 
MEASURE_PWM_FREQ_~  C ADDR   1339H   A 
COMM61_NFET. . . .  C ADDR   103AH   A 
COMM61_NONDAMP . .  C ADDR   1037H   A 
COMM6COMM1 . . . .  C ADDR   100DH   A 
COMM34_NONDAMP . .  C ADDR   0F75H   A 
COMM3COMM4 . . . .  C ADDR   0F56H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E06H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DE2H   A 
STARTUP_PWM_EXIT .  C ADDR   0C31H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B3EH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A4DH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6732    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     82    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
