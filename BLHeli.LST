MACRO ASSEMBLER BLHELI                                      05/28/15 15:39:24 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\TURNIGY_PLUSH_40A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=48) OBJECT(OUTPUT\TURNIGY_PLUSH_40A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  002E                  56     TURNIGY_PLUSH_40A_MAIN 			EQU 46
  002F                  57     TURNIGY_PLUSH_40A_TAIL 			EQU 47   
  0030                  58     TURNIGY_PLUSH_40A_MULTI 			EQU 48   
  004C                  59     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  60     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  61     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  62     SKYWALKER_20A_MAIN 				EQU 91
  005C                  63     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  64     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  65     SKYWALKER_40A_MAIN 				EQU 94
  005F                  66     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  67     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  68     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  69     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  70     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        71     
                        72     ;**** **** **** **** ****
                        73     ; ESC selection statements
                        74     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        78     
                        79     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        83     
                        84     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        88     
                        89     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        93     
                        94     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        98     
                        99     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       103     
                       104     IF BESC == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       108     
                       109     IF BESC == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       113     
                       114     IF BESC == TURNIGY_PLUSH_40A_MULTI
  0002                 115     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       116     $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                       669     ENDIF
                       670     
                       671     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       675     
                       676     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       680     
                       681     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       685     
                       686     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       690     
                       691     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       695     
                       696     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       700     
                       701     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       705     
                       706     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       710     
                       711     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       715     
                       716     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       720     
                       721     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       725     
                       726     IF BESC == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       730     
                       731     
                       732     ;**** **** **** **** ****
                       733     ; TX programming defaults
                       734     ;
                       735     ; Parameter dependencies:
                       736     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       737     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       738     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       739     ; - Damping force is only used if DampedLight or Damped is selected
                       740     ;
                       741     ; Main
  0007                 742     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 743     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 744     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 745     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 746     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 747     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 748     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 749     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 750     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 751     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 752     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 753     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 754     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 755     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 756     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 757     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 758     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 759     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 760     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       761     ; Tail
  0003                 762     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 763     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 764     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 765     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 766     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 767     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 768     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       769     IF DAMPED_MODE_ENABLE == 1
  0004                 770     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       771     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 774     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 775     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 776     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 777     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 778     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 779     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       780     ; Multi
  0009                 781     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 782     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 783     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 784     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 785     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 786     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 787     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 788     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 789     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 790     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       791     IF DAMPED_MODE_ENABLE == 1
  0001                 792     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       793     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 796     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 797     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 798     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0014                 799     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 20	; Beep strength
  0014                 800     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 20	; Beacon strength
  0005                 801     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       802     ; Common
  0000                 803     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 804     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 805     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 806     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 807     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       808     
                       809     ;**** **** **** **** ****
                       810     ; Constant definitions for main
                       811     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       833     ; Constant definitions for tail
                       834     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       855     ; Constant definitions for multi
                       856     IF MODE == 2
                       857     
  0001                 858     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       859     
  000A                 860     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 861     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 862     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 863     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 864     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 865     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 866     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 867     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       868     
  0032                 869     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 870     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       871     
  000A                 872     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 873     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       874     
  0008                 875     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       876     
                       877     ENDIF
                       878     
                       879     ;**** **** **** **** ****
                       880     ; Temporary register definitions
  REG                  881     TEMP1		EQU	R0
  REG                  882     TEMP2		EQU	R1
  REG                  883     TEMP3		EQU	R2
  REG                  884     TEMP4		EQU	R3
  REG                  885     TEMP5		EQU	R4
  REG                  886     TEMP6		EQU	R5
  REG                  887     TEMP7		EQU	R6
  REG                  888     TEMP8		EQU	R7
                       889     
                       890     ;**** **** **** **** ****
                       891     ; Register definitions
------                 892     DSEG AT 20H					; Variables segment 
                       893     
0020                   894     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   895     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       896     
0022                   897     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   898     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   899     CURRENT_PWM: 				DS	1		; Current pwm
0025                   900     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   901     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   902     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   903     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   904     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   905     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       906     
002B                   907     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 908     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 909     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 910     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 911     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 912     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       913     ;						EQU 	5
                       914     ;						EQU 	6
                       915     ;						EQU 	7
                       916     
002C                   917     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 918     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 919     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 920     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 921     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 922     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 923     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 924     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       925     ;						EQU 	7
                       926     
002D                   927     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 928     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 929     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 930     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 931     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 932     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 933     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       934     ;						EQU 	6	
                       935     ;						EQU 	7	
                       936     
002E                   937     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 938     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 939     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 940     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 941     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 942     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 943     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 944     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 945     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       946     
                       947     ;**** **** **** **** ****
                       948     ; RAM definitions
------                 949     DSEG AT 30H						; Ram data segment, direct addressing
                       950     
0030                   951     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       952     
0031                   953     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   954     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       955     
0033                   956     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   957     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   958     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   959     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   960     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   961     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   962     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       963     
003A                   964     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   965     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   966     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   967     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   968     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   969     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       970     
0040                   971     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   972     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   973     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   974     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   975     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   976     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   977     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   978     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   979     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   980     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       981     
004A                   982     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   983     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   984     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   985     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   986     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   987     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   988     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   989     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       990     
0052                   991     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   992     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   993     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   994     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   995     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   996     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   997     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   998     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   999     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  1000     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  1001     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                  1002     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      1003     
005E                  1004     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                  1005     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                  1006     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                  1007     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                  1008     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                  1009     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      1010     
0064                  1011     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                  1012     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                      1013     
0066                  1014     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                  1015     DAMPING_ON: 				DS	1		; Damping on part of damping period
                      1016     
0068                  1017     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                  1018     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                  1019     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                  1020     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                  1021     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      1022     
006D                  1023     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      1024     
006E                  1025     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                  1026     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      1027     
0070                  1028     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                  1029     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                  1030     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      1031     
                      1032     
                      1033     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1034     ;
                      1035     ; Skypup 2015.05.25
                      1036     ; 宏定义
                      1037     ;
                      1038     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1039     ;
  0002                1040     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                1041     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                      1042     ;
  00FF                1043     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                1044     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                      1045     ;
  0002                1046     HOLD_FULL_H		EQU	02H	; 650 0x028A 高位
  008A                1047     HOLD_FULL_L		EQU	8AH	; 650 0x028A 低位
  0029                1048     HOLD_CRUISE_H		EQU	29H	; 10500 0x2904 高位
  0004                1049     HOLD_CRUISE_L		EQU	04H	; 10500 0x2904 低位
                      1050     
                      1051     
                      1052     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1053     ;
                      1054     ; Skypup 2015.05.25
                      1055     ; 变量定义
                      1056     ;
                      1057     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1058     ;
0073                  1059     FLAG_BEFORE_ARM: 			DS	1		; 标记在解锁前需要 New_Rcp 为一个较大的值
0074                  1060     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                      1061     ;
0075                  1062     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                1063     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1064     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1065     ;
0076                  1066     NHOLD_L: 					DS	1		; nHold 低位
0077                  1067     NHOLD_H: 					DS	1		; nHold 高位
                      1068     ;
0078                  1069     CSTATE: 					DS	1		; 状态
                      1070     ;
                      1071     ;	State 状态矩阵
                      1072     ; 
                      1073     ;	00   ->   10   ->   20   ->   00
                      1074     ; 
                      1075     ;	00:Wait          -> 10
                      1076     ;	10:Full          -> 20
                      1077     ;	20:Cruise        -> 00
  0000                1078     STATE_WAIT		EQU	00H
  0010                1079     STATE_FULL		EQU	10H
  0020                1080     STATE_CRUISE		EQU	20H
                      1081     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1082     
                      1083     ; Indirect addressing data segment. The variables below must be in this sequence
------                1084     ISEG AT 080H					
0080                  1085     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1086     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1087     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1088     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1089     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1090     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1091     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1092     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1093     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1094     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1095     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1096     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1097     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1098     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1099     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1100     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1101     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1102     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1103     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1104     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1105     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1106     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1107     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1108     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1109     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1110     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1111     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1112     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1113     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1114     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1115     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1116     
                      1117     ; The sequence of the variables below is no longer of importance
009F                  1118     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1119     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1120     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1121     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1122     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1123     
                      1124     
                      1125     ; Indirect addressing data segment
------                1126     ISEG AT 0D0H					
00D0                  1127     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1128     
                      1129     
                      1130     ;**** **** **** **** ****
------                1131     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1132     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1133     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1134     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1135     
1A00    0B            1136     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1137     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1138     EEP_LAYOUT_REVISION:  DB 17 
                      1139     
                      1140     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1173     
                      1174     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1207     
                      1208     IF MODE == 2
1A03    09            1209     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1210     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1211     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1212     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1213     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1214     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1215     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1216     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1217     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1218     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1219     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1220     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1221     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1222     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1223     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1224     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1225     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1226     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1227     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1228     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1229     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1230     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1231     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1232     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    14            1233     EEP_PGM_BEEP_STRENGTH:  DB 20 
1A1C    14            1234     EEP_PGM_BEACON_STRENGTH:  DB 20 
1A1D    05            1235     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1236     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1237     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1238     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1239     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1240     ENDIF
                      1241     
                      1242     
1A22    FF            1243     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1244     
------                1245     CSEG AT 1A60H
1A60    6F72672E      1246     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1247     
                      1248     ;**** **** **** **** ****
                      1249             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1249+1   CSEG AT 0  ; CODE SEGMENT START
0000    0212F2        1249+1   JMP RESET 
------                1249+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1249+1   JMP T0_INT 
------                1249+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1249+1   JMP T2_INT 
------                1249+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1249+1   JMP PCA_INT 
------                1249+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1249+1   JMP T3_INT 
------                1250     CSEG AT 80H			; Code segment after interrupt vectors 
                      1251     
                      1252     ;**** **** **** **** ****
                      1253     
                      1254     ; Table definitions
0080    02030406      1255     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1256     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1257     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1258     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1259     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1262     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1270     IF MODE == 2
                      1271       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1272     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1273       ENDIF
                      1274       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1277     ENDIF
                      1278     
                      1279     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1280     ;
                      1281     ; Timer0 interrupt routine
                      1282     ;
                      1283     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1284     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1285     ;
                      1286     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1287     T0_INT: 	; Used for pwm control
00BA    C2AF          1288     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1289     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1290     	PUSH	ACC		
                      1291     	; Check if pwm is on
00C0    205A10        1292     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1293     
                      1294     	; Do not execute pwm when stopped
00C3    30600A        1295     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1296     	; Do not execute pwm on during demag recovery
00C6    205C07        1297     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1298     	; Pwm on cycle. 
00C9    302F02        1299     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1300     
                      1301     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1302     	CLR	A					
00CD    73            1303     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1304     
                      1305     T0_INT_PWM_ON_LOW_PWM: 
                      1306     
                      1307     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1308     	JMP	T0_INT_PWM_ON_EXECUTE
                      1309     ENDIF
                      1310     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1327     
                      1328     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1329     	JMP	T0_INT_PWM_ON_EXIT
                      1330     
                      1331     
                      1332     T0_INT_PWM_OFF: 
00D3    306306        1333     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1334     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C2B1          1334+1   CLR P3 . 1 
00D8    C287          1334+1   CLR P0 . 7 
00DA    C281          1334+1   CLR P0 . 1 
                      1335     T0_INT_PWM_OFF_START_CHECKED: 
                      1336     	; Pwm off cycle
00DC    85258A        1337     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1338     	; Clear pwm on flag
00DF    C25A          1339     CLR FLAGS0 . 2 
                      1340     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1341     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1342     	CPL	A						; Full pwm?
00E4    7002          1343     	JNZ	($+4)					; No - branch
00E6    21C6          1344     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1345     
00E8    0563          1346     	INC	PWM_OFF_CNT				; Increment event counter
                      1347     	; Do not execute pwm when stopped
00EA    306013        1348     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1349     
                      1350     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1351     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1352     
                      1353     	; Separate exit commands here for minimum delay
00F0    758B00        1354     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1355     	POP	ACC			; Restore preserved registers
00F5    D0D0          1356     	POP	PSW
                      1357     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C2B1          1357+1   CLR P3 . 1 
00F9    C287          1357+1   CLR P0 . 7 
00FB    C281          1357+1   CLR P0 . 1 
00FD    D2AF          1358     	SETB	EA			; Enable all interrupts
00FF    32            1359     	RETI
                      1360     
                      1361     T0_INT_PWM_OFF_STOPPED: 
                      1362     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C2B1          1362+1   CLR P3 . 1 
0102    C287          1362+1   CLR P0 . 7 
0104    C281          1362+1   CLR P0 . 1 
0106    0201B6        1363     	JMP	T0_INT_PWM_OFF_EXIT
                      1364     
                      1365     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1366     SETB FLAGS1 . 5 
010B    C266          1367     CLR FLAGS1 . 6 
010D    E567          1368     	MOV	A, DAMPING_ON
010F    601C          1369     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1370     
0111    C3            1371     	CLR	C
0112    E563          1372     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1373     	DEC	A
0115    9567          1374     	SUBB	A, DAMPING_ON
0117    4014          1375     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1376     
0119    C265          1377     CLR FLAGS1 . 5 
011B    D266          1378     SETB FLAGS1 . 6 
011D    C3            1379     	CLR	C
011E    E563          1380     	MOV	A, PWM_OFF_CNT					
0120    9566          1381     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1382     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1383     
0124    0201B6        1384     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1385     
                      1386     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1387     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1388     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1389     
                      1390     T0_INT_PWM_OFF_DO_DAMPED: 
                      1391     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1392     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1393     
                      1394     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C2B1          1394+1   CLR P3 . 1 
0132    C287          1394+1   CLR P0 . 7 
0134    C281          1394+1   CLR P0 . 1 
0136    7406          1395     MOV A , # 6 
0138    D5E0FD        1396     	DJNZ	ACC, $	
                      1397     	ALL_PFETS_ON 					; Switch on all pfets
013B    D282          1397+1   SETB P0 . 2 
013D    D286          1397+1   SETB P0 . 6 
013F    D280          1397+1   SETB P0 . 0 
0141    0201B6        1398     	JMP	T0_INT_PWM_OFF_EXIT
                      1399     
                      1400     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1401     IF DAMPED_MODE_ENABLE == 1
0144    D266          1402     SETB FLAGS1 . 6 
                      1403     ENDIF
                      1404     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C2B1          1404+1   CLR P3 . 1 
0148    C287          1404+1   CLR P0 . 7 
014A    C281          1404+1   CLR P0 . 1 
014C    E53E          1405     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1406     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1407     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1408     
                      1409     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1412     MOV A , # 6 
0156    D5E0FD        1413     	DJNZ	ACC, $	
                      1414     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1414+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D280          1414+1   SETB P0 . 0 
015E    307502        1414+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D282          1414+1   SETB P0 . 2 
                      1415     ENDIF
0163    0201B6        1416     	JMP	T0_INT_PWM_OFF_EXIT
                      1417     
                      1418     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1419     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1420     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1423     MOV A , # 6 
016B    D5E0FD        1424     	DJNZ	ACC, $	
                      1425     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1425+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D280          1425+1   SETB P0 . 0 
0173    307502        1425+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D282          1425+1   SETB P0 . 2 
                      1426     ENDIF
0178    0201B6        1427     	JMP	T0_INT_PWM_OFF_EXIT
                      1428     
                      1429     T0_INT_PWM_OFF_COMM_3: 
                      1430     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1433     MOV A , # 6 
017D    D5E0FD        1434     	DJNZ	ACC, $	
                      1435     	BPFET_ON			; Comm phase 3 - turn on B
0180    D286          1435+1   SETB P0 . 6 
                      1436     ENDIF
0182    0201B6        1437     	JMP	T0_INT_PWM_OFF_EXIT
                      1438     
                      1439     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1440     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1441     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1442     
                      1443     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1446     MOV A , # 6 
018D    D5E0FD        1447     	DJNZ	ACC, $	
                      1448     	BPFET_ON			; Comm phase 4 - turn on B
0190    D286          1448+1   SETB P0 . 6 
                      1449     ENDIF
0192    0201B6        1450     	JMP	T0_INT_PWM_OFF_EXIT
                      1451     
                      1452     T0_INT_PWM_OFF_COMM_5: 
                      1453     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1456     MOV A , # 6 
0197    D5E0FD        1457     	DJNZ	ACC, $	
                      1458     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1458+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D282          1458+1   SETB P0 . 2 
019F    307502        1458+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D280          1458+1   SETB P0 . 0 
                      1459     ENDIF
01A4    0201B6        1460     	JMP	T0_INT_PWM_OFF_EXIT
                      1461     
                      1462     T0_INT_PWM_OFF_COMM_6: 
                      1463     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1466     MOV A , # 6 
01A9    D5E0FD        1467     	DJNZ	ACC, $	
                      1468     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1468+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D282          1468+1   SETB P0 . 2 
01B1    307502        1468+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D280          1468+1   SETB P0 . 0 
                      1469     ENDIF
                      1470     
                      1471     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1472     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1473     	POP	ACC			; Restore preserved registers
01BB    D0D0          1474     	POP	PSW
                      1475     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C2B1          1475+1   CLR P3 . 1 
01BF    C287          1475+1   CLR P0 . 7 
01C1    C281          1475+1   CLR P0 . 1 
01C3    D2AF          1476     	SETB	EA			; Enable all interrupts
01C5    32            1477     	RETI
                      1478     
                      1479     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1480     	POP	ACC			; Restore preserved registers
01C8    D0D0          1481     	POP	PSW
01CA    D2AF          1482     	SETB	EA			; Enable all interrupts
01CC    32            1483     	RETI
                      1484     
                      1485     
                      1486     
                      1487     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1488     	AJMP	T0_INT_PWM_ON_EXIT
                      1489     
                      1490     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1491     	ANFET_ON	
01CF    E525          1491+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1491+1   JZ ( $+12 ) 
01D3    207502        1491+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D2B1          1491+1   SETB P3 . 1 
01D8    307502        1491+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D281          1491+1   SETB P0 . 1 
                      1492     	BNFET_OFF
01DD    C287          1492+1   CLR P0 . 7 
01DF    61D3          1493     	AJMP	T0_INT_PWM_ON_EXIT
                      1494     
                      1495     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1496     	BNFET_ON
01E1    E525          1496+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1496+1   JZ ( $+4 ) 
01E5    D287          1496+1   SETB P0 . 7 
                      1497     	CNFET_OFF
01E7    207502        1497+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C281          1497+1   CLR P0 . 1 
01EC    307502        1497+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C2B1          1497+1   CLR P3 . 1 
01F1    61D3          1498     	AJMP	T0_INT_PWM_ON_EXIT
                      1499     
                      1500     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1501     	CNFET_ON
01F3    E525          1501+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1501+1   JZ ( $+12 ) 
01F7    207502        1501+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D281          1501+1   SETB P0 . 1 
01FC    307502        1501+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D2B1          1501+1   SETB P3 . 1 
                      1502     	ANFET_OFF
0201    207502        1502+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C2B1          1502+1   CLR P3 . 1 
0206    307502        1502+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C281          1502+1   CLR P0 . 1 
020B    61D3          1503     	AJMP	T0_INT_PWM_ON_EXIT
                      1504     
                      1505     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1506     	APFET_OFF
020D    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C282          1506+1   CLR P0 . 2 
0212    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C280          1506+1   CLR P0 . 0 
                      1507     	ANFET_ON								; Switch nFETs
0217    E525          1507+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1507+1   JZ ( $+12 ) 
021B    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D2B1          1507+1   SETB P3 . 1 
0220    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D281          1507+1   SETB P0 . 1 
                      1508     	CPFET_OFF
0225    207502        1508+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C280          1508+1   CLR P0 . 0 
022A    307502        1508+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C282          1508+1   CLR P0 . 2 
                      1509     	BNFET_OFF 							
022F    C287          1509+1   CLR P0 . 7 
0231    61D3          1510     	AJMP	T0_INT_PWM_ON_EXIT
                      1511     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1512     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1513     	APFET_OFF
0233    207502        1513+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C282          1513+1   CLR P0 . 2 
0238    307502        1513+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C280          1513+1   CLR P0 . 0 
                      1514     	CPFET_OFF
023D    207502        1514+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C280          1514+1   CLR P0 . 0 
0242    307502        1514+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C282          1514+1   CLR P0 . 2 
0247    7406          1515     MOV A , # 6 
0249    D5E0FD        1516     	DJNZ ACC,	$
                      1517     	ANFET_ON								; Switch nFETs
024C    E525          1517+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1517+1   JZ ( $+12 ) 
0250    207502        1517+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D2B1          1517+1   SETB P3 . 1 
0255    307502        1517+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D281          1517+1   SETB P0 . 1 
                      1518     	BNFET_OFF 							
025A    C287          1518+1   CLR P0 . 7 
025C    61D3          1519     	AJMP	T0_INT_PWM_ON_EXIT
                      1520     
                      1521     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1522     	APFET_OFF
025E    207502        1522+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C282          1522+1   CLR P0 . 2 
0263    307502        1522+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C280          1522+1   CLR P0 . 0 
                      1523     	ANFET_ON								; Switch nFETs
0268    E525          1523+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1523+1   JZ ( $+12 ) 
026C    207502        1523+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D2B1          1523+1   SETB P3 . 1 
0271    307502        1523+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D281          1523+1   SETB P0 . 1 
                      1524     	BPFET_OFF
0276    C286          1524+1   CLR P0 . 6 
                      1525     	BNFET_OFF								
0278    C287          1525+1   CLR P0 . 7 
027A    61D3          1526     	AJMP	T0_INT_PWM_ON_EXIT
                      1527     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1528     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1529     	APFET_OFF
027C    207502        1529+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C282          1529+1   CLR P0 . 2 
0281    307502        1529+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C280          1529+1   CLR P0 . 0 
                      1530     	BPFET_OFF
0286    C286          1530+1   CLR P0 . 6 
0288    7406          1531     MOV A , # 6 
028A    D5E0FD        1532     	DJNZ ACC,	$
                      1533     	ANFET_ON								; Switch nFETs
028D    E525          1533+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1533+1   JZ ( $+12 ) 
0291    207502        1533+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D2B1          1533+1   SETB P3 . 1 
0296    307502        1533+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D281          1533+1   SETB P0 . 1 
                      1534     	BNFET_OFF								
029B    C287          1534+1   CLR P0 . 7 
029D    61D3          1535     	AJMP	T0_INT_PWM_ON_EXIT
                      1536     
                      1537     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1538     	BPFET_OFF
029F    C286          1538+1   CLR P0 . 6 
                      1539     	BNFET_ON								; Switch nFETs
02A1    E525          1539+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1539+1   JZ ( $+4 ) 
02A5    D287          1539+1   SETB P0 . 7 
                      1540     	APFET_OFF
02A7    207502        1540+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C282          1540+1   CLR P0 . 2 
02AC    307502        1540+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C280          1540+1   CLR P0 . 0 
                      1541     	CNFET_OFF								
02B1    207502        1541+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C281          1541+1   CLR P0 . 1 
02B6    307502        1541+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C2B1          1541+1   CLR P3 . 1 
02BB    61D3          1542     	AJMP	T0_INT_PWM_ON_EXIT
                      1543     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1544     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1545     	BPFET_OFF
02BD    C286          1545+1   CLR P0 . 6 
                      1546     	APFET_OFF
02BF    207502        1546+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C282          1546+1   CLR P0 . 2 
02C4    307502        1546+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C280          1546+1   CLR P0 . 0 
02C9    7406          1547     MOV A , # 6 
02CB    D5E0FD        1548     	DJNZ ACC,	$
                      1549     	BNFET_ON								; Switch nFETs
02CE    E525          1549+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1549+1   JZ ( $+4 ) 
02D2    D287          1549+1   SETB P0 . 7 
                      1550     	CNFET_OFF								
02D4    207502        1550+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C281          1550+1   CLR P0 . 1 
02D9    307502        1550+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C2B1          1550+1   CLR P3 . 1 
02DE    61D3          1551     	AJMP	T0_INT_PWM_ON_EXIT
                      1552     
                      1553     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1554     	BPFET_OFF
02E0    C286          1554+1   CLR P0 . 6 
                      1555     	BNFET_ON								; Switch nFETs
02E2    E525          1555+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1555+1   JZ ( $+4 ) 
02E6    D287          1555+1   SETB P0 . 7 
                      1556     	CPFET_OFF
02E8    207502        1556+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C280          1556+1   CLR P0 . 0 
02ED    307502        1556+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C282          1556+1   CLR P0 . 2 
                      1557     	CNFET_OFF								
02F2    207502        1557+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C281          1557+1   CLR P0 . 1 
02F7    307502        1557+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C2B1          1557+1   CLR P3 . 1 
02FC    61D3          1558     	AJMP	T0_INT_PWM_ON_EXIT
                      1559     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1560     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1561     	BPFET_OFF
02FE    C286          1561+1   CLR P0 . 6 
                      1562     	CPFET_OFF
0300    207502        1562+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C280          1562+1   CLR P0 . 0 
0305    307502        1562+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C282          1562+1   CLR P0 . 2 
030A    7406          1563     MOV A , # 6 
030C    D5E0FD        1564     	DJNZ ACC,	$
                      1565     	BNFET_ON								; Switch nFETs
030F    E525          1565+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1565+1   JZ ( $+4 ) 
0313    D287          1565+1   SETB P0 . 7 
                      1566     	CNFET_OFF								
0315    207502        1566+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C281          1566+1   CLR P0 . 1 
031A    307502        1566+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C2B1          1566+1   CLR P3 . 1 
031F    61D3          1567     	AJMP	T0_INT_PWM_ON_EXIT
                      1568     
                      1569     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1570     	CPFET_OFF
0321    207502        1570+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C280          1570+1   CLR P0 . 0 
0326    307502        1570+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C282          1570+1   CLR P0 . 2 
                      1571     	CNFET_ON								; Switch nFETs
032B    E525          1571+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1571+1   JZ ( $+12 ) 
032F    207502        1571+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D281          1571+1   SETB P0 . 1 
0334    307502        1571+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D2B1          1571+1   SETB P3 . 1 
                      1572     	BPFET_OFF
0339    C286          1572+1   CLR P0 . 6 
                      1573     	ANFET_OFF								
033B    207502        1573+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C2B1          1573+1   CLR P3 . 1 
0340    307502        1573+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C281          1573+1   CLR P0 . 1 
0345    61D3          1574     	AJMP	T0_INT_PWM_ON_EXIT
                      1575     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1576     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1577     	CPFET_OFF
0347    207502        1577+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C280          1577+1   CLR P0 . 0 
034C    307502        1577+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C282          1577+1   CLR P0 . 2 
                      1578     	BPFET_OFF
0351    C286          1578+1   CLR P0 . 6 
0353    7406          1579     MOV A , # 6 
0355    D5E0FD        1580     	DJNZ ACC,	$
                      1581     	CNFET_ON								; Switch nFETs
0358    E525          1581+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1581+1   JZ ( $+12 ) 
035C    207502        1581+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D281          1581+1   SETB P0 . 1 
0361    307502        1581+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D2B1          1581+1   SETB P3 . 1 
                      1582     	ANFET_OFF								
0366    207502        1582+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C2B1          1582+1   CLR P3 . 1 
036B    307502        1582+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C281          1582+1   CLR P0 . 1 
0370    61D3          1583     	AJMP	T0_INT_PWM_ON_EXIT
                      1584     
                      1585     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1586     	CPFET_OFF
0372    207502        1586+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C280          1586+1   CLR P0 . 0 
0377    307502        1586+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C282          1586+1   CLR P0 . 2 
                      1587     	CNFET_ON								; Switch nFETs
037C    E525          1587+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1587+1   JZ ( $+12 ) 
0380    207502        1587+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D281          1587+1   SETB P0 . 1 
0385    307502        1587+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D2B1          1587+1   SETB P3 . 1 
                      1588     	APFET_OFF
038A    207502        1588+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C282          1588+1   CLR P0 . 2 
038F    307502        1588+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C280          1588+1   CLR P0 . 0 
                      1589     	ANFET_OFF								
0394    207502        1589+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C2B1          1589+1   CLR P3 . 1 
0399    307502        1589+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C281          1589+1   CLR P0 . 1 
039E    61D3          1590     	AJMP	T0_INT_PWM_ON_EXIT
                      1591     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1592     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1593     	CPFET_OFF
03A0    207502        1593+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C280          1593+1   CLR P0 . 0 
03A5    307502        1593+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C282          1593+1   CLR P0 . 2 
                      1594     	APFET_OFF
03AA    207502        1594+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C282          1594+1   CLR P0 . 2 
03AF    307502        1594+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C280          1594+1   CLR P0 . 0 
03B4    7406          1595     MOV A , # 6 
03B6    D5E0FD        1596     	DJNZ ACC,	$
                      1597     	CNFET_ON								; Switch nFETs
03B9    E525          1597+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1597+1   JZ ( $+12 ) 
03BD    207502        1597+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D281          1597+1   SETB P0 . 1 
03C2    307502        1597+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D2B1          1597+1   SETB P3 . 1 
                      1598     	ANFET_OFF								
03C7    207502        1598+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C2B1          1598+1   CLR P3 . 1 
03CC    307502        1598+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C281          1598+1   CLR P0 . 1 
03D1    61D3          1599     	AJMP	T0_INT_PWM_ON_EXIT
                      1600     
                      1601     T0_INT_PWM_ON_EXIT: 
                      1602     	; Set timer for coming on cycle length
03D3    E525          1603     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1604     	CPL	A						; cpl is 255-x
03D6    F58A          1605     	MOV	TL0, A					; Write start point for timer
                      1606     	; Set other variables
03D8    758B00        1607     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1608     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1609     SETB FLAGS0 . 2 
                      1610     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1611     	; Exit interrupt
03E0    D0E0          1612     	POP	ACC			; Restore preserved registers
03E2    D0D0          1613     	POP	PSW
03E4    D2AF          1614     	SETB	EA			; Enable all interrupts
03E6    32            1615     	RETI
                      1616     
                      1617     
                      1618     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1619     ;
                      1620     ; Timer2 interrupt routine
                      1621     ;
                      1622     ; No assumptions
                      1623     ;
                      1624     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1625     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1626     	CLR	EA
03E9    C2AD          1627     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1628     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1629     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1630     	PUSH	ACC
03F2    D2D3          1631     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1632     	SETB	EA
                      1633     	; Clear low byte interrupt flag
03F6    C2CE          1634     	CLR	TF2L						; Clear interrupt flag
                      1635     	; Check RC pulse timeout counter
03F8    E528          1636     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1637     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1638     
                      1639     	; Decrement timeout counter (if PWM)
03FC    741F          1640     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1641     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1642     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1643     
0402    1528          1644     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1645     	AJMP	T2_INT_SKIP_START
                      1646     
                      1647     T2_INT_PULSES_ABSENT: 
                      1648     	; Timeout counter has reached zero, pulses are absent
0406    7800          1649     MOV R0 , # 0 
0408    7900          1650     MOV R1 , # 0 
                      1651     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1651+1   MOV A , P0 
040C    307601        1651+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1651+1   CPL A  ; YES - INVERT
0410    30E502        1652     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1653     MOV R0 , # 255 
                      1654     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1654+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1654+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1654+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1654+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1654+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1655     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1655+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1656     CLR FLAGS2 . 1 
                      1657     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1657+1   MOV A , P0 
042A    307601        1657+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1657+1   CPL A  ; YES - INVERT
042E    30E502        1658     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1659     MOV R1 , # 255 
0433    C3            1660     	CLR	C
0434    E8            1661     MOV A , R0 
0435    99            1662     SUBB A , R1 
0436    70CE          1663     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1664     
0438    305903        1665     JNB FLAGS0 . 1 , ( $+6 ) 
                      1666     
043B    752818        1667     MOV RCP_TIMEOUT_CNT , # 24 
                      1668     
043E    741F          1669     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1670     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1671     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1672     
0444    752818        1673     MOV RCP_TIMEOUT_CNT , # 24 
                      1674     
                      1675     
                      1676     T2_INT_PPM_TIMEOUT_SET: 
                      1677     
                      1678     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1679     ; 
                      1680     ; 对 RCP 信号处理
                      1681     ; 1 小于 1500us 最低油门
                      1682     ; 2 大于 1500us 正常处理
                      1683     ; 
                      1684     ;	clr C
                      1685     ;	mov A, Temp1
                      1686     ;	subb A, #80h
                      1687     ;	jnc skypup_01
                      1688     ;	mov	Temp1, #RCP_MIN
                      1689     ; skypup_01:
                      1690     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1691     MOV NEW_RCP , R0 
0449    D268          1692     SETB FLAGS2 . 0 
                      1693     
                      1694     T2_INT_SKIP_START: 
                      1695     	; Check RC pulse skip counter
044B    E529          1696     	MOV	A, RCP_SKIP_CNT			
044D    6004          1697     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1698     	
                      1699     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1700     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1701     	AJMP	T2_INT_RCP_UPDATE_START
                      1702     
                      1703     T2_INT_SKIP_END: 
0453    741F          1704     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1705     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1706     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1707     
                      1708     	; Skip counter has reached zero, start looking for RC pulses again
                      1709     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1709+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1710     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1710+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1711     	
                      1712     T2_INT_RCP_UPDATE_START: 
                      1713     	; Process updated RC pulse
045E    206802        1714     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1715     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1716     
0463    E559          1717     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1718     MOV R0 , A 
0466    C268          1719     CLR FLAGS2 . 0 
                      1720     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1721     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1722     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1723     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1724     
                      1725     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1728     
                      1729     IF MODE == 2	; Multi
046E    7982          1730     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1731     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1732     ENDIF
                      1733     
                      1734     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1735     	CLR	C
0474    E8            1736     MOV A , R0 
0475    94F0          1737     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1738     	JC	T2_INT_RCP_UPDATE_MULT
                      1739     
0479    74F0          1740     	MOV	A, #240			; Set requested pwm to max
047B    F8            1741     MOV R0 , A 
                      1742     
                      1743     T2_INT_RCP_UPDATE_MULT: 	
                      1744     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1745     MOV A , R0 
047D    C4            1746     	SWAP	A			; After this "0.0625"
047E    540F          1747     	ANL	A, #0FH
0480    28            1748     ADD A , R0 
0481    F8            1749     MOV R0 , A 
                      1750     	; Adjust tail gain
0482    7984          1751     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1752     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1753     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1754     
0489    C3            1755     	CLR	C
048A    13            1756     	RRC	A			; After this "0.5"
048B    C3            1757     	CLR	C
048C    13            1758     	RRC	A			; After this "0.25"
048D    8721          1759     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1760     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1761     
0492    C3            1762     	CLR	C
0493    13            1763     	RRC	A			; After this "0.125"
                      1764     
                      1765     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1766     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1767     
0497    C3            1768     	CLR	C
0498    C8            1769     XCH A , R0 
0499    98            1770     SUBB A , R0 
049A    F8            1771     MOV R0 , A 
049B    81A4          1772     	AJMP	T2_INT_PWM_MIN_RUN
                      1773     
                      1774     T2_INT_RCP_GAIN_POS: 
049D    28            1775     ADD A , R0 
049E    F8            1776     MOV R0 , A 
049F    5003          1777     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1778     
04A1    74FF          1779     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1780     MOV R0 , A 
                      1781     
                      1782     T2_INT_PWM_MIN_RUN:  
                      1783     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1793     
                      1794     T2_INT_PWM_UPDATE:  
                      1795     	; Check if any startup phase flags are set
04A4    E52C          1796     	MOV	A, FLAGS1
04A6    5406          1797     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1798     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1799     
                      1800     	; Update requested_pwm
04AA    8822          1801     MOV REQUESTED_PWM , R0 
                      1802     	; Limit pwm during direct start
04AC    30630A        1803     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1804     
04AF    C3            1805     	CLR	C
04B0    E522          1806     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1807     	SUBB	A, PWM_LIMIT
04B4    4003          1808     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1809     
04B6    855E22        1810     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1811     
                      1812     T2_INT_CURRENT_PWM_UPDATE:  
                      1813     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1814     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1815     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1816     ENDIF
                      1817     
                      1818     	; Update current pwm, with limited throttle change rate
04BE    C3            1819     	CLR	C
04BF    E522          1820     	MOV	A, REQUESTED_PWM	 
04C1    9524          1821     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1822     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1823     
                      1824     	; 缓启动
04C5    78A1          1825     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1826     	;mov	Temp1, #1
04C7    96            1827     SUBB A , @ R0 
                      1828     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1829     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1830     
04CA    E524          1831     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1832     ADD A , @ R0 
                      1833     	; add	A, Temp1
04CD    F524          1834     	MOV	CURRENT_PWM, A
04CF    5009          1835     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1836     
04D1    7524FF        1837     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1838     	JMP	T2_INT_CURRENT_PWM_DONE
                      1839     
                      1840     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1841     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1842     T2_INT_CURRENT_PWM_DONE: 
                      1843     IF MODE >= 1	; Tail or multi
                      1844     	; Set current_pwm_limited
04DA    A824          1845     MOV R0 , CURRENT_PWM 
04DC    C3            1846     	CLR	C
04DD    E524          1847     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1848     	SUBB	A, PWM_LIMIT
04E1    4002          1849     	JC	($+4)					; If current pwm below limit - branch
                      1850     
04E3    A85E          1851     MOV R0 , PWM_LIMIT 
                      1852     
04E5    8825          1853     MOV CURRENT_PWM_LIMITED , R0 
                      1854     ENDIF
                      1855     T2_INT_PWM_EXIT: 	
                      1856     	; Check if high byte flag is set
04E7    20CF0C        1857     	JB	TF2H, T2H_INT		
04EA    D0E0          1858     	POP	ACC			; Restore preserved registers
04EC    D0D0          1859     	POP	PSW
04EE    C2D3          1860     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1861     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1862     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1863     	RETI
                      1864     
                      1865     T2H_INT: 
                      1866     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1867     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1868     MOV R0 , # 1 
                      1869     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1870     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1871     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1872     
                      1873     	; Decrement timeout counter (if PPM)
04FE    741F          1874     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1875     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1876     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1877     
0504    1528          1878     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1879     
                      1880     T2H_INT_RCP_STOP_CHECK: 
                      1881     	; Check RC pulse against stop value
0506    C3            1882     	CLR	C
0507    E559          1883     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1884     SUBB A , # 1 
050B    4005          1885     	JC	T2H_INT_RCP_STOP
                      1886     
                      1887     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1888     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1889     	AJMP	T2H_INT_RCP_GOV_PWM
                      1890     
                      1891     T2H_INT_RCP_STOP: 	
                      1892     	; RC pulse less than stop value
0512    755D00        1893     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1894     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1895     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1896     	ADD	A, #1
051C    F55C          1897     	MOV	RCP_STOP_CNT, A
051E    5003          1898     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1899     
0520    755CFF        1900     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1901     
                      1902     T2H_INT_RCP_GOV_PWM: 
                      1903     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      2032     IF MODE == 2	; Multi
0523    E55F          2033     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          2034     	ADD	A, #10
0527    5005          2035     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      2036     
0529    755FFF        2037     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          2038     	AJMP	T2H_INT_RCP_EXIT
                      2039     
                      2040     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          2041     	MOV	PWM_LIMIT_SPOOLUP, A
                      2042     ENDIF
                      2043     
                      2044     T2H_INT_RCP_EXIT: 
0530    D0E0          2045     	POP	ACC			; Restore preserved registers
0532    D0D0          2046     	POP	PSW
0534    C2D3          2047     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        2048     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          2049     	SETB	ET2			; Enable timer2 interrupts
053B    32            2050     	RETI
                      2051     
                      2052     
                      2053     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2054     ;
                      2055     ; Timer3 interrupt routine
                      2056     ;
                      2057     ; No assumptions
                      2058     ;
                      2059     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2060     T3_INT: 	; Used for commutation timing
053C    C2AF          2061     	CLR 	EA			; Disable all interrupts
053E    53917F        2062     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          2063     CLR FLAGS0 . 0 
0543    D2AF          2064     	SETB	EA			; Enable all interrupts
0545    32            2065     	RETI
                      2066     
                      2067     
                      2068     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2069     ;
                      2070     ; PCA interrupt routine
                      2071     ;
                      2072     ; No assumptions
                      2073     ;
                      2074     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2075     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2076     	CLR	EA
0548    53E6EF        2077     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2078     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2079     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2080     	PUSH	ACC
0551    C0F0          2081     	PUSH	B
0553    D2D3          2082     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2083     	SETB	EA
                      2084     	; Get the PCA counter values
                      2085     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2085+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2085+1   MOV R1 , PCA0CPH0 
                      2086     	; Clear interrupt flag
                      2087     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2087+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2088     	; Check which edge it is
055D    306902        2089     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B3          2090     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2091     
                      2092     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2092+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2092+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2092+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2092+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2092+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2093     SETB FLAGS2 . 1 
                      2094     	; Read RC signal level
                      2095     	READ_RCP_INT			
0573    E580          2095+1   MOV A , P0 
0575    307601        2095+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2095+1   CPL A  ; YES - INVERT
                      2096     	; Test RC signal level
0579    20E502        2097     JB ACC . 5 , ( $+5 ) 
057C    A185          2098     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2099     
                      2100     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2101     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2102     MOV RCP_PREV_EDGE_H , R1 
0582    020846        2103     	LJMP	PCA_INT_EXIT				; Exit
                      2104     
                      2105     PCA_INT_FAIL_MINIMUM: 
                      2106     	; Prepare for next interrupt
                      2107     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2107+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2107+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2107+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2107+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2107+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2108     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2108+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2109     CLR FLAGS2 . 1 
0598    741F          2110     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2111     	ANL	A, FLAGS3					; Check pwm frequency flags
                      2112     	; jnz	($+4)					; If a flag is set (PWM) - proceed
059C    7003          2113     	JNZ	LINE_TEMP01					; If a flag is set (PWM) - proceed, Skypup 2015.05.26
                      2114     
                      2115     	; ajmp	pca_int_set_timeout			; If PPM - ignore trig as noise
059E    02082C        2116     	LJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise, Skypup 2015.05.26
                      2117     LINE_TEMP01: 
                      2118     
05A1    7800          2119     MOV R0 , # 0 
                      2120     	READ_RCP_INT 					; Test RC signal level again
05A3    E580          2120+1   MOV A , P0 
05A5    307601        2120+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A8    F4            2120+1   CPL A  ; YES - INVERT
                      2121     	; jnb	ACC.Rcp_In, ($+5)			; Is it high?
05A9    30E503        2122     JNB ACC . 5 , LINE_TEMP02 
                      2123     	; ajmp	pca_int_set_timeout			; Yes - set new timeout and exit
05AC    02082C        2124     	LJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit, Skypup 2015.05.26
                      2125     LINE_TEMP02: 
                      2126     
                      2127     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2128     ; 
                      2129     ; 对 RCP 信号处理
                      2130     ; 1 小于 1500us 最低油门
                      2131     ; 2 大于 1500us 正常处理
                      2132     ; 
                      2133     ;	clr C
                      2134     ;	mov A, Temp1
                      2135     ;	subb A, #80h
                      2136     ;	jnc skypup_02
                      2137     ;	mov	Temp1, #RCP_MIN
                      2138     ; skypup_02:
                      2139     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2140     
05AF    8859          2141     MOV NEW_RCP , R0 
05B1    E188          2142     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2143     
                      2144     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2145     	; Prepare for next interrupt
                      2146     	RCP_INT_FIRST 					; Set first edge trig
05B3    53DACF        2146+1   ANL PCA0CPM0 , # 0CFH 
05B6    207603        2146+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B9    43DA20        2146+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BC    307603        2146+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BF    43DA10        2146+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C2    C269          2147     CLR FLAGS2 . 1 
                      2148     	; Check if pwm frequency shall be measured
05C4    205902        2149     JB FLAGS0 . 1 , ( $+5 ) 
05C7    C16D          2150     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2151     
                      2152     	; Set second edge trig only during pwm frequency measurement
                      2153     	RCP_INT_SECOND 				; Set second edge trig
05C9    53DACF        2153+1   ANL PCA0CPM0 , # 0CFH 
05CC    207603        2153+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CF    43DA10        2153+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D2    307603        2153+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D5    43DA20        2153+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2154     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D8    C2D8          2154+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05DA    D269          2155     SETB FLAGS2 . 1 
                      2156     	; Store edge data to RAM
05DC    8854          2157     MOV RCP_EDGE_L , R0 
05DE    8955          2158     MOV RCP_EDGE_H , R1 
                      2159     	; Calculate pwm frequency
05E0    C3            2160     	CLR	C
05E1    E8            2161     MOV A , R0 
05E2    9552          2162     	SUBB	A, RCP_PREPREV_EDGE_L	
05E4    F8            2163     MOV R0 , A 
05E5    E9            2164     MOV A , R1 
05E6    9553          2165     	SUBB	A, RCP_PREPREV_EDGE_H
05E8    F9            2166     MOV R1 , A 
05E9    E4            2167     	CLR	A
05EA    FB            2168     MOV R3 , A 
05EB    7AFA          2169     MOV R2 , # 250 
                      2170     	; Check if pwm frequency is 12kHz
05ED    C3            2171     	CLR	C
05EE    E8            2172     MOV A , R0 
05EF    94C8          2173     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05F1    E9            2174     MOV A , R1 
05F2    9400          2175     	SUBB	A, #HIGH(200)
05F4    5008          2176     	JNC	PCA_INT_CHECK_8KHZ
                      2177     
05F6    E4            2178     	CLR	A
05F7    D2E4          2179     SETB ACC . 4 
05F9    FB            2180     MOV R3 , A 
05FA    7A0A          2181     MOV R2 , # 10 
05FC    C140          2182     	AJMP	PCA_INT_RESTORE_EDGE
                      2183     
                      2184     PCA_INT_CHECK_8KHZ: 
                      2185     	; Check if pwm frequency is 8kHz
05FE    C3            2186     	CLR	C
05FF    E8            2187     MOV A , R0 
0600    9468          2188     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0602    E9            2189     MOV A , R1 
0603    9401          2190     	SUBB	A, #HIGH(360)
0605    5008          2191     	JNC	PCA_INT_CHECK_4KHZ
                      2192     
0607    E4            2193     	CLR	A
0608    D2E3          2194     SETB ACC . 3 
060A    FB            2195     MOV R3 , A 
060B    7A0F          2196     MOV R2 , # 15 
060D    C140          2197     	AJMP	PCA_INT_RESTORE_EDGE
                      2198     
                      2199     PCA_INT_CHECK_4KHZ: 
                      2200     	; Check if pwm frequency is 4kHz
060F    C3            2201     	CLR	C
0610    E8            2202     MOV A , R0 
0611    94D0          2203     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0613    E9            2204     MOV A , R1 
0614    9402          2205     	SUBB	A, #HIGH(720)
0616    5008          2206     	JNC	PCA_INT_CHECK_2KHZ
                      2207     
0618    E4            2208     	CLR	A
0619    D2E2          2209     SETB ACC . 2 
061B    FB            2210     MOV R3 , A 
061C    7A1E          2211     MOV R2 , # 30 
061E    C140          2212     	AJMP	PCA_INT_RESTORE_EDGE
                      2213     
                      2214     PCA_INT_CHECK_2KHZ: 
                      2215     	; Check if pwm frequency is 2kHz
0620    C3            2216     	CLR	C
0621    E8            2217     MOV A , R0 
0622    94A0          2218     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0624    E9            2219     MOV A , R1 
0625    9405          2220     	SUBB	A, #HIGH(1440)
0627    5008          2221     	JNC	PCA_INT_CHECK_1KHZ
                      2222     
0629    E4            2223     	CLR	A
062A    D2E1          2224     SETB ACC . 1 
062C    FB            2225     MOV R3 , A 
062D    7A3C          2226     MOV R2 , # 60 
062F    C140          2227     	AJMP	PCA_INT_RESTORE_EDGE
                      2228     
                      2229     PCA_INT_CHECK_1KHZ: 
                      2230     	; Check if pwm frequency is 1kHz
0631    C3            2231     	CLR	C
0632    E8            2232     MOV A , R0 
0633    9498          2233     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0635    E9            2234     MOV A , R1 
0636    9408          2235     	SUBB	A, #HIGH(2200)
0638    5006          2236     	JNC	PCA_INT_RESTORE_EDGE
                      2237     
063A    E4            2238     	CLR	A
063B    D2E0          2239     SETB ACC . 0 
063D    FB            2240     MOV R3 , A 
063E    7A78          2241     MOV R2 , # 120 
                      2242     
                      2243     PCA_INT_RESTORE_EDGE: 
                      2244     	; Calculate difference between this period and previous period
0640    C3            2245     	CLR	C
0641    E8            2246     MOV A , R0 
0642    9556          2247     	SUBB	A, RCP_PREV_PERIOD_L
0644    FC            2248     MOV R4 , A 
0645    E9            2249     MOV A , R1 
0646    9557          2250     	SUBB	A, RCP_PREV_PERIOD_H
0648    FD            2251     MOV R5 , A 
                      2252     	; Make positive
0649    30E708        2253     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064C    EC            2254     MOV A , R4 
064D    F4            2255     	CPL	A
064E    2401          2256     	ADD	A, #1
0650    FC            2257     MOV R4 , A 
0651    ED            2258     MOV A , R5 
0652    F4            2259     	CPL	A
0653    FD            2260     MOV R5 , A 
                      2261     
                      2262     PCA_INT_CHECK_DIFF: 
                      2263     	; Check difference
0654    755800        2264     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0657    7008          2265     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2266     
0659    C3            2267     	CLR	C
065A    EC            2268     MOV A , R4 
065B    9A            2269     SUBB A , R2 
065C    5003          2270     	JNC	PCA_INT_STORE_DATA
                      2271     
065E    755801        2272     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2273     
                      2274     PCA_INT_STORE_DATA: 
                      2275     	; Store previous period
0661    8856          2276     MOV RCP_PREV_PERIOD_L , R0 
0663    8957          2277     MOV RCP_PREV_PERIOD_H , R1 
                      2278     	; Restore edge data from RAM
0665    A854          2279     MOV R0 , RCP_EDGE_L 
0667    A955          2280     MOV R1 , RCP_EDGE_H 
                      2281     	; Store pre previous edge
0669    8852          2282     MOV RCP_PREPREV_EDGE_L , R0 
066B    8953          2283     MOV RCP_PREPREV_EDGE_H , R1 
                      2284     
                      2285     PCA_INT_FALL: 
                      2286     	; RC pulse edge was second, calculate new pulse length
066D    C3            2287     	CLR	C
066E    E8            2288     MOV A , R0 
066F    9526          2289     	SUBB	A, RCP_PREV_EDGE_L	
0671    F8            2290     MOV R0 , A 
0672    E9            2291     MOV A , R1 
0673    9527          2292     	SUBB	A, RCP_PREV_EDGE_H
0675    F9            2293     MOV R1 , A 
0676    307402        2294     JNB FLAGS3 . 4 , ( $+5 ) 
0679    E16C          2295     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
067B    307302        2296     JNB FLAGS3 . 3 , ( $+5 ) 
067E    E16C          2297     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2298     
0680    307202        2299     JNB FLAGS3 . 2 , ( $+5 ) 
0683    E165          2300     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2301     
0685    E9            2302     MOV A , R1 
0686    C3            2303     	CLR	C
0687    13            2304     	RRC	A
0688    F9            2305     MOV R1 , A 
0689    E8            2306     MOV A , R0 
068A    13            2307     	RRC	A
068B    F8            2308     MOV R0 , A 
                      2309     
068C    307102        2310     JNB FLAGS3 . 1 , ( $+5 ) 
068F    E165          2311     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2312     
0691    E9            2313     MOV A , R1 
0692    C3            2314     	CLR	C
0693    13            2315     	RRC	A
0694    F9            2316     MOV R1 , A 
0695    E8            2317     MOV A , R0 
0696    13            2318     	RRC	A
0697    F8            2319     MOV R0 , A 
                      2320     
0698    307002        2321     JNB FLAGS3 . 0 , ( $+5 ) 
069B    E165          2322     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2323     
069D    E9            2324     MOV A , R1 
069E    C3            2325     	CLR	C
069F    13            2326     	RRC	A
06A0    FD            2327     MOV R5 , A 
06A1    E8            2328     MOV A , R0 
06A2    13            2329     	RRC	A
06A3    FC            2330     MOV R4 , A 
                      2331     	; Skip range limitation if pwm frequency measurement
06A4    205918        2332     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2333     
                      2334     	; Check if 2160us or above (in order to ignore false pulses)
06A7    C3            2335     	CLR	C
06A8    EC            2336     MOV A , R4 
06A9    941C          2337     	SUBB	A, #28
06AB    ED            2338     MOV A , R5 
06AC    9402          2339     	SUBB A, #2
06AE    4003          2340     	JC	($+5)						; No - proceed
                      2341     
06B0    02082C        2342     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2343     
                      2344     	; Check if below 800us (in order to ignore false pulses)
06B3    ED            2345     MOV A , R5 
06B4    7009          2346     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2347     
06B6    C3            2348     	CLR	C
06B7    EC            2349     MOV A , R4 
06B8    94C8          2350     	SUBB	A, #200
06BA    5003          2351     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2352     
06BC    02082C        2353     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2354     
                      2355     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2356     	; Calculate "1000us" plus throttle minimum
06BF    7400          2357     	MOV	A, #0						; Set 1000us as default minimum
06C1    20770B        2358     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2359     
                      2360     IF MODE >= 1	; Tail or multi
06C4    7888          2361     MOV R0 , # PGM_DIRECTION 
06C6    E6            2362     MOV A , @ R0 
                      2363     ENDIF
06C7    7896          2364     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2365     IF MODE >= 1	; Tail or multi
06C9    B40302        2366     	CJNE	A, #3, ($+5)
                      2367     
06CC    789E          2368     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2369     ENDIF
06CE    E6            2370     MOV A , @ R0 
                      2371     
                      2372     PCA_INT_PPM_CALCULATE: 
06CF    24FA          2373     	ADD	A, #250						; Add 1000us to minimum
06D1    FE            2374     MOV R6 , A 
06D2    E4            2375     	CLR	A
06D3    3400          2376     	ADDC	A, #0
06D5    FF            2377     MOV R7 , A 
                      2378     
06D6    C3            2379     	CLR	C
06D7    EC            2380     MOV A , R4 
06D8    9E            2381     SUBB A , R6 
06D9    FC            2382     MOV R4 , A 
06DA    ED            2383     MOV A , R5 
06DB    9F            2384     SUBB A , R7 
06DC    FD            2385     MOV R5 , A 
                      2386     IF MODE >= 1	; Tail or multi
06DD    9208          2387     	MOV	BIT_ACCESS_INT.0, C
06DF    7888          2388     MOV R0 , # PGM_DIRECTION 
06E1    E6            2389     MOV A , @ R0 
06E2    B40322        2390     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2391     
06E5    A208          2392     	MOV	C, BIT_ACCESS_INT.0
06E7    5009          2393     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2394     
                      2395     PCA_INT_PPM_BIDIR_REV: 
06E9    20751B        2396     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2397     
06EC    C2AF          2398     	CLR	EA							; Direction change, turn off all fets
06EE    D275          2399     SETB FLAGS3 . 5 
06F0    C1F9          2400     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2401     
                      2402     PCA_INT_PPM_BIDIR_FWD: 
06F2    307512        2403     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2404     
06F5    C2AF          2405     	CLR	EA							; Direction change, turn off all fets
06F7    C275          2406     CLR FLAGS3 . 5 
                      2407     
                      2408     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2409     	ALL_NFETS_OFF
06F9    C2B1          2409+1   CLR P3 . 1 
06FB    C287          2409+1   CLR P0 . 7 
06FD    C281          2409+1   CLR P0 . 1 
                      2410     	ALL_PFETS_OFF
06FF    C282          2410+1   CLR P0 . 2 
0701    C286          2410+1   CLR P0 . 6 
0703    C280          2410+1   CLR P0 . 0 
0705    D2AF          2411     	SETB	EA
                      2412     
                      2413     PCA_INT_PPM_BIDIR_DIR_SET: 
0707    A208          2414     	MOV	C, BIT_ACCESS_INT.0
                      2415     ENDIF
0709    5017          2416     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2417     
                      2418     IF MODE >= 1	; Tail or multi
070B    E6            2419     MOV A , @ R0 
070C    B4030D        2420     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2421     
070F    EC            2422     MOV A , R4 
0710    F4            2423     	CPL	A
0711    2401          2424     	ADD	A, #1
0713    FC            2425     MOV R4 , A 
0714    ED            2426     MOV A , R5 
0715    F4            2427     	CPL	A
0716    3400          2428     	ADDC	A, #0
0718    FD            2429     MOV R5 , A 
0719    020722        2430     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2431     
                      2432     PCA_INT_PPM_UNIDIR_NEG: 
                      2433     ENDIF
071C    7800          2434     MOV R0 , # 0 
071E    7900          2435     MOV R1 , # 0 
0720    E16C          2436     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2437     
                      2438     PCA_INT_PPM_NEG_CHECKED: 
                      2439     IF MODE >= 1	; Tail or multi
0722    7888          2440     MOV R0 , # PGM_DIRECTION 
0724    E6            2441     MOV A , @ R0 
0725    B40315        2442     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2443     
0728    EC            2444     MOV A , R4 
0729    33            2445     	RLC	A
072A    FC            2446     MOV R4 A 
072B    ED            2447     MOV A , R5 
072C    33            2448     	RLC	A
072D    FD            2449     MOV R5 A 
072E    C3            2450     	CLR	C							; Subtract deadband
072F    EC            2451     MOV A , R4 
0730    9405          2452     	SUBB	A, #5		
0732    FC            2453     MOV R4 , A 
0733    ED            2454     MOV A , R5 
0734    9400          2455     	SUBB	A, #0
0736    FD            2456     MOV R5 , A 
0737    5004          2457     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2458     
0739    7C00          2459     MOV R4 , # 0 
073B    7D00          2460     MOV R5 , # 0 
                      2461     
                      2462     PCA_INT_PPM_BIDIR_DONE: 
                      2463     ENDIF
073D    C3            2464     	CLR	C							; Check that RC pulse is within legal range (max 255)
073E    EC            2465     MOV A , R4 
073F    94FF          2466     SUBB A , # 255 
0741    ED            2467     MOV A , R5 
0742    9400          2468     	SUBB	A, #0
0744    4006          2469     	JC	PCA_INT_PPM_MAX_CHECKED
                      2470     
0746    78FF          2471     MOV R0 , # 255 
0748    7900          2472     MOV R1 , # 0 
074A    E16C          2473     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2474     
                      2475     PCA_INT_PPM_MAX_CHECKED: 
074C    EC            2476     MOV A , R4 
074D    856EF0        2477     	MOV	B, PPM_THROTTLE_GAIN
0750    A4            2478     	MUL	AB
0751    C5F0          2479     	XCH	A, B
0753    A2F7          2480     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0755    33            2481     	RLC	A
0756    F8            2482     MOV R0 , A 
0757    7900          2483     MOV R1 , # 0 
0759    4003          2484     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2485     	
075B    020788        2486     	JMP	PCA_INT_LIMITED			
                      2487     
                      2488     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075E    78FF          2489     MOV R0 , # 255 
0760    7900          2490     MOV R1 , # 0 
0762    020788        2491     	JMP	PCA_INT_LIMITED			
                      2492     
                      2493     PCA_INT_PWM_DIVIDE: 
0765    E9            2494     MOV A , R1 
0766    C3            2495     	CLR	C
0767    13            2496     	RRC	A
0768    F9            2497     MOV R1 , A 
0769    E8            2498     MOV A , R0 
076A    13            2499     	RRC	A
076B    F8            2500     MOV R0 , A 
                      2501     
                      2502     PCA_INT_PWM_DIVIDE_DONE: 
076C    30740E        2503     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076F    E9            2504     MOV A , R1 
0770    6002          2505     	JZ	($+4)
                      2506     
0772    78FF          2507     MOV R0 , # 255 
                      2508     
0774    C3            2509     	CLR	C
0775    E8            2510     MOV A , R0 
0776    13            2511     	RRC	A
0777    38            2512     ADDC A , R0 
0778    F8            2513     MOV R0 , A 
0779    E4            2514     	CLR	A
077A    3400          2515     	ADDC	A, #0
077C    F9            2516     MOV R1 , A 
                      2517     
                      2518     PCA_INT_CHECK_LEGAL_RANGE: 
                      2519     	; Check that RC pulse is within legal range
077D    C3            2520     	CLR	C
077E    E8            2521     MOV A , R0 
077F    94FF          2522     SUBB A , # 255 
0781    E9            2523     MOV A , R1 
0782    9400          2524     	SUBB	A, #0
0784    4002          2525     	JC	PCA_INT_LIMITED
                      2526     
0786    78FF          2527     MOV R0 , # 255 
                      2528     
                      2529     PCA_INT_LIMITED: 
                      2530     
                      2531     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2532     ; 
                      2533     ; GetPWM
                      2534     ; Skypup 2015.05.25
                      2535     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2536     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2537     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2538     ; 
                      2539     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2540     PROCEDURE_GETPWM: 
0788    C3            2541     	CLR	C
0789    E8            2542     MOV A , R0 
078A    94A0          2543     SUBB A , # 160 
078C    5005          2544     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
078E    7800          2545     MOV R0 , # 0 
0790    020795        2546     	JMP	SET_PWM_IN
                      2547     SET_PWM_IN_HIGH: 
0793    7801          2548     MOV R0 , # 1 
                      2549     SET_PWM_IN: 
0795    8875          2550     MOV NPWMIN , R0 
                      2551     END_PROCEDURE_GETPWM: 
                      2552     
                      2553     
                      2554     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2555     ;
                      2556     ; 是否解锁
                      2557     ; Skypup 2015.05.26
                      2558     ;
                      2559     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0797    A873          2560     MOV R0 , FLAG_BEFORE_ARM 
0799    B80107        2561     CJNE R0 , # 1 , ELSE_FLAG_BEFORE_ARM 
                      2562     IF_FLAG_BEFORE_ARM: 
079C    78FF          2563     MOV R0 , # 255 
079E    8859          2564     MOV NEW_RCP , R0 
07A0    020819        2565     	JMP SET_PREV_RCP				; 如果未解锁, 不做后续处理, 直接跳转
                      2566     ELSE_FLAG_BEFORE_ARM: 
                      2567     ; endif_Flag_Before_ARM:
                      2568     
                      2569     
                      2570     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2571     ;
                      2572     ; 例程: 判断是否 PWM_IN_HIGH
                      2573     ; Skypup 2015.05.26
                      2574     ;
                      2575     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2576     ;	mov	Temp1, nPWMIn
                      2577     ;	cjne	Temp1, #PWM_IN_HIGH, else_nPWMIn_pwm_in_high
                      2578     ;if_nPWMIn_pwm_in_high:
                      2579     ;	mov	Temp1, Initial_Arm
                      2580     ;	cjne	Temp1, #1, else_Initial_Arm
                      2581     ;  if_Initial_Arm:
                      2582     ;	mov Temp1, #PWM_FULL
                      2583     ;	mov	New_Rcp, Temp1	
                      2584     ;	jmp set_Prev_Rcp		; 如果未解锁, 不做后续处理, 直接跳转
                      2585     ;  else_Initial_Arm:
                      2586     ;	mov	Temp1,  #RCP_MIN
                      2587     ;  endif_INitial_Arm:
                      2588     ;	mov	New_Rcp, Temp1	
                      2589     ;	jmp	endif_nPWMIn_pwm_in_high
                      2590     ;else_nPWMIn_pwm_in_high:
                      2591     ;	; 最低油门
                      2592     ;	mov	Temp1, #RCP_MIN
                      2593     ;	mov	New_Rcp, Temp1	
                      2594     ;	; jmp	endif_nPWMIn_pwm_in_high
                      2595     ;endif_nPWMIn_pwm_in_high:
                      2596     
                      2597     
                      2598     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2599     ;
                      2600     ; 判断 cState 状态
                      2601     ; Skypup 2015.05.
                      2602     ;
                      2603     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2604     ;
07A3    A878          2605     MOV R0 , CSTATE 
07A5    B81029        2606     CJNE R0 , # 16 , ELES_STATE_FULL 
                      2607     IF_STATE_FULL: 
                      2608      	; STATE_FULL - 全油门
07A8    78FF          2609     MOV R0 , # 255 
07AA    8859          2610     MOV NEW_RCP , R0 
                      2611     	; 计数器 ++
07AC    0576          2612     	INC	NHOLD_L						; nHold_L 低位 ++
07AE    E576          2613     	MOV	A, NHOLD_L
07B0    7002          2614     	JNZ	IF_FULL_NHOLD_L_NOT_ZERO			; nHold_L 不是 0x00
07B2    0577          2615     	INC	NHOLD_H						; nHold_L 是 0x00, nHold_H 高位 ++
                      2616     	IF_FULL_NHOLD_L_NOT_ZERO: 
                      2617     
                      2618     	; 是否超时
07B4    C3            2619     	CLR	C
07B5    E577          2620     	MOV	A, NHOLD_H
07B7    9402          2621     SUBB A , # 2 
07B9    4013          2622     	JC	IF_FULL_NHOLD_NOT_TIMEOUT		; 发生借位, 则 nHold_H < #HOLD_FULL_H, 未超时
07BB    C3            2623     	CLR	C
07BC    E576          2624     	MOV	A, NHOLD_L
07BE    948A          2625     SUBB A , # 138 
07C0    400C          2626     	JC	IF_FULL_NHOLD_NOT_TIMEOUT		; 发生借位, 则 nHold_L < #HOLD_FULL_L, 未超时
                      2627     	IF_FULL_NHOLD_TIMEOUT: 				; 未发生借位, 超时切换至 STATE_CRUISE
                      2628     		; 状态切换为 STATE_CRUISE
07C2    7820          2629     MOV R0 , # 32 
07C4    8878          2630     MOV CSTATE , R0 
                      2631     		; 计数器清零
07C6    E4            2632     		CLR	A
07C7    F576          2633     		MOV	NHOLD_L, A
07C9    F577          2634     		MOV	NHOLD_H, A
07CB    020819        2635     		JMP	ENDIF_STATE_FULL
                      2636     	IF_FULL_NHOLD_NOT_TIMEOUT: 
07CE    020819        2637     	 	JMP ENDIF_STATE_FULL
                      2638      
                      2639     ELES_STATE_FULL: 
07D1    A878          2640     MOV R0 , CSTATE 
07D3    B82029        2641     CJNE R0 , # 32 , ELSE_STATE_CRUISE 
                      2642      
                      2643     	IF_STATE_CRUISE: 
                      2644     	 	; STATE_CRUISE - 巡航油门
07D6    787F          2645     MOV R0 , # 127 
07D8    8859          2646     MOV NEW_RCP , R0 
                      2647     		; 计数器 ++
07DA    0576          2648     		INC	NHOLD_L					; nHold_L 低位 ++
07DC    E576          2649     		MOV	A, NHOLD_L
07DE    7002          2650     		JNZ	IF_CRUISE_NHOLD_L_NOT_ZERO	; nHold_L 不是 0x00
07E0    0577          2651     		INC	NHOLD_H					; nHold_L 是 0x00, nHold_H 高位 ++
                      2652     		IF_CRUISE_NHOLD_L_NOT_ZERO: 
                      2653     
                      2654     		; 是否超时
07E2    C3            2655     		CLR	C
07E3    E577          2656     		MOV	A, NHOLD_H
07E5    9429          2657     SUBB A , # 41 
07E7    4013          2658     		JC	IF_CRUISE_NHOLD_NOT_TIMEOUT	; 发生借位, 则 nHold_H < #HOLD_CRUISE_H, 未超时
07E9    C3            2659     		CLR	C
07EA    E576          2660     		MOV	A, NHOLD_L
07EC    9404          2661     SUBB A , # 4 
07EE    400C          2662     		JC	IF_CRUISE_NHOLD_NOT_TIMEOUT	; 发生借位, 则 nHold_L < #HOLD_CRUISE_L, 未超时
                      2663     		IF_CRUISE_NHOLD_TIMEOUT: 			; 未发生借位, 超时切换至 STATE_WAIT
                      2664     			; 状态切换为 STATE_WAIT
07F0    7800          2665     MOV R0 , # 0 
07F2    8878          2666     MOV CSTATE , R0 
                      2667     			; 计数器清零
07F4    E4            2668     			CLR	A
07F5    F576          2669     			MOV	NHOLD_L, A
07F7    F577          2670     			MOV	NHOLD_H, A
07F9    020819        2671     			JMP	ENDIF_STATE_CRUISE
                      2672     		IF_CRUISE_NHOLD_NOT_TIMEOUT: 
07FC    020819        2673     		 	JMP ENDIF_STATE_CRUISE
                      2674       
                      2675     	ELSE_STATE_CRUISE: 
                      2676     	 	; STATE_WAIT
07FF    7800          2677     MOV R0 , # 0 
0801    8859          2678     MOV NEW_RCP , R0 
                      2679     		;
0803    A830          2680     MOV R0 , INITIAL_ARM 
0805    B80011        2681     CJNE R0 , # 0 , ELSE_INITIAL_ARM 
                      2682     		IF_INITIAL_ARM: 
                      2683     			; 判断是否 PWM_IN_HIGH
0808    A875          2684     MOV R0 , NPWMIN 
080A    B8010C        2685     CJNE R0 , # 1 , ENDIF_STATE_WAIT_PWM_IN_HIGH 
                      2686     			; 状态切换为 STATE_FULL
080D    7810          2687     MOV R0 , # 16 
080F    8878          2688     MOV CSTATE , R0 
                      2689     			; 计数器清零
0811    E4            2690     			CLR	A
0812    F576          2691     			MOV	NHOLD_L, A
0814    F577          2692     			MOV	NHOLD_H, A
0816    020819        2693     		 	JMP	ENDIF_INITIAL_ARM
                      2694     			ENDIF_STATE_WAIT_PWM_IN_HIGH: 
                      2695     		ELSE_INITIAL_ARM: 
                      2696     		ENDIF_INITIAL_ARM: 
                      2697     	ENDIF_STATE_CRUISE:  
                      2698     ENDIF_STATE_FULL: 
                      2699     
                      2700     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2701     ;
                      2702     ; 已经弃用的代码, 供参考.
                      2703     ;
                      2704     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2705     ; skypup_03:
                      2706     ; 
                      2707     ; 	clr C
                      2708     ; 	mov A, Temp1
                      2709     ; 	subb A, Prev_Rcp				; 上一个 Rcp > 当前 Rcp ?
                      2710     ; 	jc skypup_04					; No
                      2711     ; 
                      2712     ; 	subb A, #THR_DELTA				; 油门缓启动增量 > Rcp 增加值 ?
                      2713     ; 	jc skypup_04					; No
                      2714     ; 
                      2715     ; 	clr C						; 这一句能否去掉? Skypup 2015.05.25
                      2716     ; 	mov A, Prev_Rcp
                      2717     ; 	add A, #THR_DELTA
                      2718     ; 	mov Temp1, A
                      2719     ; 	jnc skypup_04					; 没有发生进位溢出
                      2720     ; 
                      2721     ; 	mov Temp1, #0FFh	
                      2722     ; 	
                      2723     ; skypup_04:
                      2724     
                      2725     
                      2726     SET_PREV_RCP: 
                      2727     	; 记录 New_Rcp 值
0819    E559          2728     	MOV A, NEW_RCP
081B    F574          2729     	MOV PREV_RCP, A
                      2730     
                      2731     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2732     	; RC pulse value accepted
                      2733     	; mov	New_Rcp, Temp1				; Store new pulse length
081D    D268          2734     SETB FLAGS2 . 0 
081F    205902        2735     JB FLAGS0 . 1 , ( $+5 ) 
0822    012C          2736     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2737     
0824    741F          2738     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0826    F4            2739     	CPL	A
0827    552E          2740     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0829    4B            2741     ORL A , R3 
082A    F52E          2742     	MOV	FLAGS3, A
                      2743     
                      2744     PCA_INT_SET_TIMEOUT: 
082C    752818        2745     MOV RCP_TIMEOUT_CNT , # 24 
082F    741F          2746     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0831    552E          2747     	ANL	A, FLAGS3					; Check pwm frequency flags
0833    7003          2748     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2749     
0835    75280A        2750     MOV RCP_TIMEOUT_CNT , # 10 
                      2751     
                      2752     PCA_INT_PPM_TIMEOUT_SET: 
0838    305902        2753     JNB FLAGS0 . 1 , ( $+5 ) 
083B    0146          2754     	AJMP PCA_INT_EXIT				; Yes - exit
                      2755     
083D    741F          2756     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
083F    552E          2757     	ANL	A, FLAGS3					; Check pwm frequency flags
0841    6003          2758     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2759     
                      2760     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
0843    53DAFE        2760+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2761     
                      2762     PCA_INT_EXIT: 	; Exit interrupt routine	
0846    752906        2763     MOV RCP_SKIP_CNT , # 6 
0849    741F          2764     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
084B    552E          2765     	ANL	A, FLAGS3					; Check pwm frequency flags
084D    7003          2766     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2767     
084F    75290A        2768     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2769     
0852    D0F0          2770     	POP	B			; Restore preserved registers
0854    D0E0          2771     	POP	ACC			
0856    D0D0          2772     	POP	PSW
0858    C2D3          2773     	CLR	PSW.3		; Select register bank 0 for main program routines	
085A    D2AD          2774     	SETB	ET2			; Enable timer2 interrupts
085C    43E610        2775     	ORL	EIE1, #10H	; Enable PCA0 interrupts
085F    32            2776     	RETI
                      2777     
                      2778     
                      2779     
                      2780     
                      2781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2782     ;
                      2783     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2784     ;
                      2785     ; No assumptions
                      2786     ;
                      2787     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2788     WAIT1MS: 	
0860    7901          2789     MOV R1 , # 1 
0862    02087E        2790     	JMP	WAITXMS_O
                      2791     
                      2792     WAIT3MS: 	
0865    7903          2793     MOV R1 , # 3 
0867    02087E        2794     	JMP	WAITXMS_O
                      2795     
                      2796     WAIT10MS: 	
086A    790A          2797     MOV R1 , # 10 
086C    02087E        2798     	JMP	WAITXMS_O
                      2799     
                      2800     WAIT30MS: 	
086F    791E          2801     MOV R1 , # 30 
0871    02087E        2802     	JMP	WAITXMS_O
                      2803     
                      2804     WAIT100MS: 	
0874    7964          2805     MOV R1 , # 100 
0876    02087E        2806     	JMP	WAITXMS_O
                      2807     
                      2808     WAIT200MS: 	
0879    79C8          2809     MOV R1 , # 200 
087B    02087E        2810     	JMP	WAITXMS_O
                      2811     
                      2812     WAITXMS_O: 	; Outer loop
087E    7817          2813     MOV R0 , # 23 
                      2814     WAITXMS_M: 	; Middle loop
0880    E4            2815     	CLR	A
0881    D5E0FD        2816      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0884    D8FA          2817     DJNZ R0 , WAITXMS_M 
0886    D9F6          2818     DJNZ R1 , WAITXMS_O 
0888    22            2819     	RET
                      2820     
                      2821     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2822     ;
                      2823     ; Wait 1 second routine
                      2824     ;
                      2825     ; No assumptions
                      2826     ;
                      2827     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2828     WAIT1S: 
0889    7C05          2829     MOV R4 , # 5 
                      2830     WAIT1S_LOOP: 
088B    1179          2831     	CALL WAIT200MS
088D    DCFC          2832     DJNZ R4 , WAIT1S_LOOP 
088F    22            2833     	RET
                      2834     
                      2835     
                      2836     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2837     ;
                      2838     ; Beeper routines (4 different entry points) 
                      2839     ;
                      2840     ; No assumptions
                      2841     ;
                      2842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2843     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0890    7A14          2844     MOV R2 , # 20 
0892    7B78          2845     MOV R3 , # 120 
0894    0208AC        2846     	JMP	BEEP
                      2847     
                      2848     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0897    7A10          2849     MOV R2 , # 16 
0899    7B8C          2850     MOV R3 , # 140 
089B    0208AC        2851     	JMP	BEEP
                      2852     
                      2853     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
089E    7A0D          2854     MOV R2 , # 13 
08A0    7BB4          2855     MOV R3 , # 180 
08A2    0208AC        2856     	JMP	BEEP
                      2857     
                      2858     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
08A5    7A0B          2859     MOV R2 , # 11 
08A7    7BC8          2860     MOV R3 , # 200 
08A9    0208AC        2861     	JMP	BEEP
                      2862     
                      2863     BEEP: 	; Beep loop start
08AC    AC25          2864     MOV R4 , CURRENT_PWM_LIMITED 
08AE    752501        2865     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
08B1    7902          2866     MOV R1 , # 2 
                      2867     BEEP_ONOFF: 
08B3    B275          2868     CPL FLAGS3 . 5 
08B5    E4            2869     	CLR	A
                      2870     	BPFET_OFF			; BpFET off
08B6    C286          2870+1   CLR P0 . 6 
08B8    D5E0FD        2871     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2872     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
08BB    E525          2872+1   MOV A , CURRENT_PWM_LIMITED 
08BD    6002          2872+1   JZ ( $+4 ) 
08BF    D287          2872+1   SETB P0 . 7 
08C1    D5E0FD        2873     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2874     	BNFET_OFF			; BnFET off again
08C4    C287          2874+1   CLR P0 . 7 
08C6    D5E0FD        2875     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2876     	BPFET_ON			; BpFET on
08C9    D286          2876+1   SETB P0 . 6 
08CB    D5E0FD        2877     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2878     	; Turn on nfet
                      2879     	ANFET_ON			; AnFET on
08CE    E525          2879+1   MOV A , CURRENT_PWM_LIMITED 
08D0    600A          2879+1   JZ ( $+12 ) 
08D2    207502        2879+1   JB FLAGS3 . 5 , ( $+5 ) 
08D5    D2B1          2879+1   SETB P3 . 1 
08D7    307502        2879+1   JNB FLAGS3 . 5 , ( $+5 ) 
08DA    D281          2879+1   SETB P0 . 1 
08DC    E56F          2880     	MOV	A, BEEP_STRENGTH
08DE    D5E0FD        2881     	DJNZ	ACC, $		
                      2882     	; Turn off nfet
                      2883     	ANFET_OFF			; AnFET off
08E1    207502        2883+1   JB FLAGS3 . 5 , ( $+5 ) 
08E4    C2B1          2883+1   CLR P3 . 1 
08E6    307502        2883+1   JNB FLAGS3 . 5 , ( $+5 ) 
08E9    C281          2883+1   CLR P0 . 1 
08EB    7496          2884     	MOV	A, #150		; 25s off
08ED    D5E0FD        2885     	DJNZ	ACC, $		
08F0    D9C1          2886     DJNZ R1 , BEEP_ONOFF 
                      2887     	; Copy variable
08F2    EA            2888     MOV A , R2 
08F3    F8            2889     MOV R0 , A 
                      2890     BEEP_OFF: 		; Fets off loop
08F4    D5E0FD        2891     	DJNZ	ACC, $
08F7    D8FB          2892     DJNZ R0 , BEEP_OFF 
08F9    DBB1          2893     DJNZ R3 , BEEP 
                      2894     	BPFET_OFF			; BpFET off
08FB    C286          2894+1   CLR P0 . 6 
08FD    8C25          2895     MOV CURRENT_PWM_LIMITED , R4 
08FF    22            2896     	RET
                      2897     
                      2898     
                      2899     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2900     ;
                      2901     ; Division 16bit unsigned by 16bit unsigned
                      2902     ;
                      2903     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2904     ; Result will be in Temp2/Temp1
                      2905     ;
                      2906     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2907     DIV_U16_BY_U16: 	
0900    C3            2908     	CLR	C       
0901    7C00          2909     MOV R4 , # 0 
0903    7D00          2910     MOV R5 , # 0 
0905    75F000        2911     	MOV	B, #0
                      2912     DIV_U16_BY_U16_DIV1: 
0908    05F0          2913     	INC	B      			; Increment counter for each left shift
090A    EA            2914     MOV A , R2 
090B    33            2915     	RLC	A      		
090C    FA            2916     MOV R2 , A 
090D    EB            2917     MOV A , R3 
090E    33            2918     	RLC	A      	  	
090F    FB            2919     MOV R3 , A 
0910    50F6          2920     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2921     DIV_U16_BY_U16_DIV2:         
0912    EB            2922     MOV A , R3 
0913    13            2923     	RRC	A      
0914    FB            2924     MOV R3 , A 
0915    EA            2925     MOV A , R2 
0916    13            2926     	RRC	A      
0917    FA            2927     MOV R2 , A 
0918    C3            2928     	CLR	C      
0919    E9            2929     MOV A , R1 
091A    FF            2930     MOV R7 , A 
091B    E8            2931     MOV A , R0 
091C    FE            2932     MOV R6 , A 
091D    E8            2933     MOV A , R0 
091E    9A            2934     SUBB A , R2 
091F    F8            2935     MOV R0 , A 
0920    E9            2936     MOV A , R1 
0921    9B            2937     SUBB A , R3 
0922    F9            2938     MOV R1 , A 
0923    5004          2939     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0925    EF            2940     MOV A , R7 
0926    F9            2941     MOV R1 , A 
0927    EE            2942     MOV A , R6 
0928    F8            2943     MOV R0 , A 
                      2944     DIV_U16_BY_U16_DIV3: 
0929    B3            2945     	CPL	C      			; Invert carry, so it can be directly copied into result
092A    EC            2946     MOV A , R4 
092B    33            2947     	RLC	A      			; Shift carry flag into temporary result
092C    FC            2948     MOV R4 , A 
092D    ED            2949     MOV A , R5 
092E    33            2950     	RLC	A
092F    FD            2951     MOV R5 , A 
0930    D5F0DF        2952     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0933    ED            2953     MOV A , R5 
0934    F9            2954     MOV R1 , A 
0935    EC            2955     MOV A , R4 
0936    F8            2956     MOV R0 , A 
0937    22            2957     	RET
                      2958     
                      2959     
                      2960     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2961     ;
                      2962     ; Multiplication 16bit signed by 8bit unsigned
                      2963     ;
                      2964     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2965     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2966     ;
                      2967     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2968     MULT_S16_BY_U8_DIV_16: 
0938    E8            2969     MOV A , R0 
0939    89F0          2970     MOV B , R1 
093B    8A20          2971     MOV BIT_ACCESS , R2 
093D    D2D4          2972     	SETB	PSW.4		; Select register bank 2 for math routines
093F    F8            2973     MOV R0 , A 
0940    A9F0          2974     MOV R1 , B 
0942    7B00          2975     MOV R3 , # 0 
0944    30F70B        2976     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2977     
0947    7BFF          2978     MOV R3 , # 0FFH 
0949    F4            2979     	CPL	A
094A    2401          2980     	ADD	A, #1
094C    F8            2981     MOV R0 , A 
094D    E9            2982     MOV A , R1 
094E    F4            2983     	CPL	A
094F    3400          2984     	ADDC	A, #0
0951    F9            2985     MOV R1 , A 
                      2986     MULT_S16_BY_U8_POSITIVE: 
0952    E8            2987     MOV A , R0 
0953    8520F0        2988     	MOV	B, BIT_ACCESS
0956    A4            2989     	MUL	AB
0957    ADF0          2990     MOV R5 , B 
0959    F8            2991     MOV R0 , A 
095A    E9            2992     MOV A , R1 
095B    8520F0        2993     	MOV	B, BIT_ACCESS
095E    A4            2994     	MUL	AB
095F    AFF0          2995     MOV R7 , B 
0961    FE            2996     MOV R6 , A 
0962    ED            2997     MOV A , R5 
0963    2E            2998     ADD A , R6 
0964    F9            2999     MOV R1 , A 
0965    7400          3000     	MOV	A, #0
0967    3F            3001     ADDC A , R7 
0968    FA            3002     MOV R2 , A 
0969    7C04          3003     MOV R4 , # 4 
                      3004     MULT_S16_BY_U8_DIV_LOOP: 
096B    C3            3005     	CLR	C			; Rotate right 
096C    EA            3006     MOV A , R2 
096D    13            3007     	RRC	A
096E    FA            3008     MOV R2 , A 
096F    E9            3009     MOV A , R1 
0970    13            3010     	RRC	A
0971    F9            3011     MOV R1 , A 
0972    E8            3012     MOV A , R0 
0973    13            3013     	RRC	A
0974    F8            3014     MOV R0 , A 
0975    DCF4          3015     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      3016     
0977    8BF0          3017     MOV B , R3 
0979    30F70A        3018     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      3019     
097C    E8            3020     MOV A , R0 
097D    F4            3021     	CPL	A
097E    2401          3022     	ADD	A, #1
0980    F8            3023     MOV R0 , A 
0981    E9            3024     MOV A , R1 
0982    F4            3025     	CPL	A
0983    3400          3026     	ADDC	A, #0
0985    F9            3027     MOV R1 , A 
                      3028     
                      3029     MULT_S16_BY_U8_EXIT: 
0986    E8            3030     MOV A , R0 
0987    89F0          3031     MOV B , R1 
0989    C2D4          3032     	CLR	PSW.4		; Select normal register bank
098B    F8            3033     MOV R0 , A 
098C    A9F0          3034     MOV R1 , B 
098E    22            3035     	RET
                      3036     
                      3037     
                      3038     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3039     ;
                      3040     ; Calculate governor routines
                      3041     ;
                      3042     ; No assumptions
                      3043     ;
                      3044     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      3045     ; The governor task is split into several routines in order to distribute processing time
                      3046     ;
                      3047     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3048     ; First governor routine - calculate governor target
                      3049     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3189     IF MODE == 2	; Multi
                      3190     CALC_GOVERNOR_TARGET: 
098F    7882          3191     MOV R0 , # PGM_GOV_MODE 
0991    B60403        3192     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0994    0209EB        3193     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3194     
                      3195     GOVERNOR_TARGET_CALC: 
                      3196     	; Stop governor for stop RC pulse	
0997    C3            3197     	CLR	C
0998    E559          3198     	MOV	A, NEW_RCP				; Check RC pulse against stop value
099A    9401          3199     SUBB A , # 1 
099C    4003          3200     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3201     
099E    0209B4        3202     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3203     
                      3204     GOVERNOR_DEACTIVATE: 
09A1    852224        3205     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
09A4    E4            3206     	CLR	A
09A5    F540          3207     	MOV	GOV_TARGET_L, A			; Set target to zero
09A7    F541          3208     	MOV	GOV_TARGET_H, A
09A9    F542          3209     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
09AB    F543          3210     	MOV	GOV_INTEGRAL_H, A
09AD    F544          3211     	MOV	GOV_INTEGRAL_X, A
09AF    F549          3212     	MOV	GOV_ACTIVE, A
09B1    0209EB        3213     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3214     
                      3215     GOVERNOR_ACTIVATE: 
09B4    7882          3216     MOV R0 , # PGM_GOV_MODE 
09B6    E6            3217     MOV A , @ R0 
09B7    FC            3218     MOV R4 , A 
09B8    754901        3219     	MOV	GOV_ACTIVE, #1
09BB    E522          3220     	MOV	A, REQUESTED_PWM			; Load requested pwm
09BD    F523          3221     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3222     	; Calculate comm period target 2*(51000/Requested_Pwm)
09BF    7838          3223     MOV R0 , # 38H 
09C1    79C7          3224     MOV R1 , # 0C7H 
09C3    AA3C          3225     MOV R2 , COMM_PERIOD4X_L 
09C5    AB3D          3226     MOV R3 , COMM_PERIOD4X_H 
                      3227     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
09C7    C3            3228     	CLR	C
09C8    EB            3229     MOV A , R3 
09C9    13            3230     	RRC	A
09CA    FB            3231     MOV R3 , A 
09CB    EA            3232     MOV A , R2 
09CC    13            3233     	RRC	A
09CD    FA            3234     MOV R2 , A 
                      3235     	; Check range
09CE    EC            3236     MOV A , R4 
09CF    14            3237     	DEC	A
09D0    6013          3238     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3239     GOVERNOR_ACTIVATE_100K: 
09D2    C3            3240     	CLR	C
09D3    EB            3241     MOV A , R3 
09D4    13            3242     	RRC	A
09D5    FB            3243     MOV R3 , A 
09D6    EA            3244     MOV A , R2 
09D7    13            3245     	RRC	A
09D8    FA            3246     MOV R2 , A 
09D9    EC            3247     MOV A , R4 
09DA    14            3248     	DEC	A
09DB    14            3249     	DEC	A
09DC    6007          3250     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3251     GOVERNOR_ACTIVATE_50K: 
09DE    C3            3252     	CLR	C
09DF    EB            3253     MOV A , R3 
09E0    13            3254     	RRC	A
09E1    FB            3255     MOV R3 , A 
09E2    EA            3256     MOV A , R2 
09E3    13            3257     	RRC	A
09E4    FA            3258     MOV R2 , A 
                      3259     GOVERNOR_ACTIVATE_RANGE_SET: 
09E5    3100          3260     	CALL	DIV_U16_BY_U16
                      3261     	; Store governor target
09E7    8840          3262     MOV GOV_TARGET_L , R0 
09E9    8941          3263     MOV GOV_TARGET_H , R1 
                      3264     CALC_GOVERNOR_TARGET_EXIT: 
09EB    22            3265     	RET						
                      3266     ENDIF
                      3267     
                      3268     
                      3269     ; Second governor routine - calculate governor proportional error
                      3270     CALC_GOVERNOR_PROP_ERROR: 
                      3271     	; Exit if governor is inactive
09EC    E549          3272     	MOV	A, GOV_ACTIVE
09EE    6034          3273     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3274     
                      3275     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3293     IF MODE == 2	; Multi
                      3294     	; Calculate error
09F0    C3            3295     	CLR	C
09F1    E540          3296     	MOV	A, GOV_TARGET_L
09F3    9523          3297     	SUBB	A, GOVERNOR_REQ_PWM
09F5    F8            3298     MOV R0 , A 
09F6    E541          3299     	MOV	A, GOV_TARGET_H
09F8    9400          3300     	SUBB	A, #0
09FA    F9            3301     MOV R1 , A 
                      3302     ENDIF
                      3303     	; Check error and limit
09FB    500C          3304     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3305     
09FD    C3            3306     	CLR	C
09FE    E8            3307     MOV A , R0 
09FF    9480          3308     	SUBB	A, #80H					; Is error too negative?
0A01    E9            3309     MOV A , R1 
0A02    94FF          3310     	SUBB	A, #0FFH
0A04    4016          3311     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0A06    020A20        3312     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3313     
                      3314     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0A09    C3            3315     	CLR	C
0A0A    E8            3316     MOV A , R0 
0A0B    947F          3317     	SUBB	A, #7FH					; Is error too positive?
0A0D    E9            3318     MOV A , R1 
0A0E    9400          3319     	SUBB	A, #00H
0A10    5003          3320     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0A12    020A20        3321     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3322     
                      3323     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0A15    787F          3324     MOV R0 , # 7FH 
0A17    7900          3325     MOV R1 , # 00H 
0A19    020A20        3326     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3327     
                      3328     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0A1C    7880          3329     MOV R0 , # 80H 
0A1E    79FF          3330     MOV R1 , # 0FFH 
                      3331     
                      3332     GOVERNOR_STORE_PROP_ERROR: 
                      3333     	; Store proportional
0A20    8845          3334     MOV GOV_PROPORTIONAL_L , R0 
0A22    8946          3335     MOV GOV_PROPORTIONAL_H , R1 
                      3336     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0A24    22            3337     	RET						
                      3338     
                      3339     
                      3340     ; Third governor routine - calculate governor integral error
                      3341     CALC_GOVERNOR_INT_ERROR: 
                      3342     	; Exit if governor is inactive
0A25    E549          3343     	MOV	A, GOV_ACTIVE
0A27    6058          3344     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3345     
                      3346     	; Add proportional to integral
0A29    E545          3347     	MOV	A, GOV_PROPORTIONAL_L
0A2B    2542          3348     	ADD	A, GOV_INTEGRAL_L
0A2D    F8            3349     MOV R0 , A 
0A2E    E546          3350     	MOV	A, GOV_PROPORTIONAL_H
0A30    3543          3351     	ADDC	A, GOV_INTEGRAL_H
0A32    F9            3352     MOV R1 , A 
0A33    854620        3353     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
0A36    E4            3354     	CLR	A
0A37    300701        3355     	JNB	BIT_ACCESS.7, ($+4)			
0A3A    F4            3356     	CPL	A
0A3B    3544          3357     	ADDC	A, GOV_INTEGRAL_X
0A3D    FA            3358     MOV R2 , A 
                      3359     	; Check integral and limit
0A3E    30E709        3360     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3361     
0A41    C3            3362     	CLR	C
0A42    EA            3363     MOV A , R2 
0A43    94F0          3364     	SUBB	A, #0F0H					; Is error too negative?
0A45    4015          3365     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0A47    020A62        3366     	JMP	GOVERNOR_CHECK_PWM
                      3367     
                      3368     GOVERNOR_CHECK_INT_LIMIT_POS: 
0A4A    C3            3369     	CLR	C
0A4B    EA            3370     MOV A , R2 
0A4C    940F          3371     	SUBB	A, #0FH					; Is error too positive?
0A4E    5003          3372     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0A50    020A62        3373     	JMP	GOVERNOR_CHECK_PWM
                      3374     
                      3375     GOVERNOR_LIMIT_INT_ERROR_POS: 
0A53    78FF          3376     MOV R0 , # 0FFH 
0A55    79FF          3377     MOV R1 , # 0FFH 
0A57    7A0F          3378     MOV R2 , # 0FH 
0A59    020A62        3379     	JMP	GOVERNOR_CHECK_PWM
                      3380     
                      3381     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0A5C    7800          3382     MOV R0 , # 00H 
0A5E    7900          3383     MOV R1 , # 00H 
0A60    7AF0          3384     MOV R2 , # 0F0H 
                      3385     
                      3386     GOVERNOR_CHECK_PWM: 
                      3387     	; Check current pwm
0A62    C3            3388     	CLR	C
0A63    E524          3389     	MOV	A, CURRENT_PWM
0A65    955E          3390     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0A67    5006          3391     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3392     
0A69    E524          3393     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0A6B    6009          3394     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3395     
0A6D    417B          3396     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3397     
                      3398     GOVERNOR_INT_MAX_PWM: 
0A6F    E546          3399     	MOV	A, GOV_PROPORTIONAL_H
0A71    20E70D        3400     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3401     
0A74    417B          3402     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3403     
                      3404     GOVERNOR_INT_MIN_PWM: 
0A76    E546          3405     	MOV	A, GOV_PROPORTIONAL_H
0A78    30E706        3406     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3407     
                      3408     GOVERNOR_STORE_INT_ERROR: 
                      3409     	; Store integral
0A7B    8842          3410     MOV GOV_INTEGRAL_L , R0 
0A7D    8943          3411     MOV GOV_INTEGRAL_H , R1 
0A7F    8A44          3412     MOV GOV_INTEGRAL_X , R2 
                      3413     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A81    22            3414     	RET						
                      3415     
                      3416     
                      3417     ; Fourth governor routine - calculate governor proportional correction
                      3418     CALC_GOVERNOR_PROP_CORRECTION: 
                      3419     	; Exit if governor is inactive
0A82    E549          3420     	MOV	A, GOV_ACTIVE
0A84    7003          3421     	JNZ	CALC_GOVERNOR_PROP_CORR
0A86    020AE5        3422     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3423     
                      3424     CALC_GOVERNOR_PROP_CORR: 
                      3425     	; Load proportional gain
0A89    789F          3426     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A8B    E6            3427     MOV A , @ R0 
0A8C    FA            3428     MOV R2 , A 
                      3429     	; Load proportional
0A8D    C3            3430     	CLR	C
0A8E    E545          3431     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A90    33            3432     	RLC	A
0A91    F8            3433     MOV R0 , A 
0A92    E546          3434     	MOV	A, GOV_PROPORTIONAL_H
0A94    33            3435     	RLC	A
0A95    F9            3436     MOV R1 , A 
                      3437     	; Apply gain
0A96    3138          3438     	CALL	MULT_S16_BY_U8_DIV_16
                      3439     	; Check error and limit (to low byte)
0A98    E9            3440     MOV A , R1 
0A99    30E70B        3441     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3442     
0A9C    C3            3443     	CLR	C
0A9D    E8            3444     MOV A , R0 
0A9E    9480          3445     	SUBB	A, #80H					; Is error too negative?
0AA0    E9            3446     MOV A , R1 
0AA1    94FF          3447     	SUBB	A, #0FFH
0AA3    4013          3448     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0AA5    41BC          3449     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3450     
                      3451     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0AA7    C3            3452     	CLR	C
0AA8    E8            3453     MOV A , R0 
0AA9    947F          3454     	SUBB	A, #7FH					; Is error too positive?
0AAB    E9            3455     MOV A , R1 
0AAC    9400          3456     	SUBB	A, #00H
0AAE    5002          3457     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0AB0    41BC          3458     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3459     
                      3460     GOVERNOR_LIMIT_PROP_CORR_POS: 
0AB2    787F          3461     MOV R0 , # 7FH 
0AB4    7900          3462     MOV R1 , # 00H 
0AB6    41BC          3463     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3464     
                      3465     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0AB8    7880          3466     MOV R0 , # 80H 
0ABA    79FF          3467     MOV R1 , # 0FFH 
                      3468     
                      3469     GOVERNOR_APPLY_PROP_CORR: 
                      3470     	; Test proportional sign
0ABC    E8            3471     MOV A , R0 
0ABD    20E715        3472     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3473     
                      3474     	; Subtract positive proportional
0AC0    C3            3475     	CLR	C
0AC1    E523          3476     	MOV	A, GOVERNOR_REQ_PWM
0AC3    98            3477     SUBB A , R0 
0AC4    F8            3478     MOV R0 , A 
                      3479     	; Check result
0AC5    4009          3480     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3481     
0AC7    C3            3482     	CLR	C
0AC8    E8            3483     MOV A , R0 
0AC9    9401          3484     	SUBB	A, #1
0ACB    4003          3485     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0ACD    020AE3        3486     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3487     
                      3488     GOVERNOR_CORR_PROP_MIN_PWM: 
0AD0    7801          3489     MOV R0 , # 1 
0AD2    020AE3        3490     	JMP	GOVERNOR_STORE_PROP_CORR
                      3491     
                      3492     GOVERNOR_CORR_NEG_PROP: 
                      3493     	; Add negative proportional
0AD5    E8            3494     MOV A , R0 
0AD6    F4            3495     	CPL	A
0AD7    2401          3496     	ADD	A, #1
0AD9    2523          3497     	ADD	A, GOVERNOR_REQ_PWM
0ADB    F8            3498     MOV R0 , A 
                      3499     	; Check result
0ADC    4003          3500     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0ADE    020AE3        3501     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3502     
                      3503     GOVERNOR_CORR_PROP_MAX_PWM: 
0AE1    78FF          3504     MOV R0 , # 255 
                      3505     GOVERNOR_STORE_PROP_CORR: 
                      3506     	; Store proportional pwm
0AE3    8847          3507     MOV GOV_PROP_PWM , R0 
                      3508     CALC_GOVERNOR_PROP_CORR_EXIT: 
0AE5    22            3509     	RET
                      3510     
                      3511     
                      3512     ; Fifth governor routine - calculate governor integral correction
                      3513     CALC_GOVERNOR_INT_CORRECTION: 
                      3514     	; Exit if governor is inactive
0AE6    E549          3515     	MOV	A, GOV_ACTIVE
0AE8    7003          3516     	JNZ	CALC_GOVERNOR_INT_CORR
0AEA    020B47        3517     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3518     
                      3519     CALC_GOVERNOR_INT_CORR: 
                      3520     	; Load integral gain
0AED    78A0          3521     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0AEF    E6            3522     MOV A , @ R0 
0AF0    FA            3523     MOV R2 , A 
                      3524     	; Load integral
0AF1    A843          3525     MOV R0 , GOV_INTEGRAL_H 
0AF3    A944          3526     MOV R1 , GOV_INTEGRAL_X 
                      3527     	; Apply gain
0AF5    3138          3528     	CALL	MULT_S16_BY_U8_DIV_16
                      3529     	; Check integral and limit
0AF7    E9            3530     MOV A , R1 
0AF8    30E70C        3531     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3532     
0AFB    C3            3533     	CLR	C
0AFC    E8            3534     MOV A , R0 
0AFD    9401          3535     	SUBB	A, #01H					; Is integral too negative?
0AFF    E9            3536     MOV A , R1 
0B00    94FF          3537     	SUBB	A, #0FFH
0B02    4016          3538     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0B04    020B1E        3539     	JMP	GOVERNOR_APPLY_INT_CORR
                      3540     
                      3541     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0B07    C3            3542     	CLR	C
0B08    E8            3543     MOV A , R0 
0B09    94FF          3544     	SUBB	A, #0FFH					; Is integral too positive?
0B0B    E9            3545     MOV A , R1 
0B0C    9400          3546     	SUBB	A, #00H
0B0E    5003          3547     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0B10    020B1E        3548     	JMP	GOVERNOR_APPLY_INT_CORR
                      3549     
                      3550     GOVERNOR_LIMIT_INT_CORR_POS: 
0B13    78FF          3551     MOV R0 , # 0FFH 
0B15    7900          3552     MOV R1 , # 00H 
0B17    020B1E        3553     	JMP	GOVERNOR_APPLY_INT_CORR
                      3554     
                      3555     GOVERNOR_LIMIT_INT_CORR_NEG: 
0B1A    7801          3556     MOV R0 , # 01H 
0B1C    79FF          3557     MOV R1 , # 0FFH 
                      3558     
                      3559     GOVERNOR_APPLY_INT_CORR: 
                      3560     	; Test integral sign
0B1E    E9            3561     MOV A , R1 
0B1F    20E715        3562     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3563     
                      3564     	; Subtract positive integral
0B22    C3            3565     	CLR	C
0B23    E547          3566     	MOV	A, GOV_PROP_PWM
0B25    98            3567     SUBB A , R0 
0B26    F8            3568     MOV R0 , A 
                      3569     	; Check result
0B27    4009          3570     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3571     
0B29    C3            3572     	CLR	C
0B2A    E8            3573     MOV A , R0 
0B2B    9401          3574     	SUBB	A, #1
0B2D    4003          3575     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0B2F    020B45        3576     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3577     
                      3578     GOVERNOR_CORR_INT_MIN_PWM: 
0B32    7800          3579     MOV R0 , # 0 
0B34    020B45        3580     	JMP	GOVERNOR_STORE_INT_CORR
                      3581     
                      3582     GOVERNOR_CORR_NEG_INT: 
                      3583     	; Add negative integral
0B37    E8            3584     MOV A , R0 
0B38    F4            3585     	CPL	A
0B39    2401          3586     	ADD	A, #1
0B3B    2547          3587     	ADD	A, GOV_PROP_PWM
0B3D    F8            3588     MOV R0 , A 
                      3589     	; Check result
0B3E    4003          3590     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0B40    020B45        3591     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3592     
                      3593     GOVERNOR_CORR_INT_MAX_PWM: 
0B43    78FF          3594     MOV R0 , # 255 
                      3595     GOVERNOR_STORE_INT_CORR: 
                      3596     	; Store current pwm
0B45    8824          3597     MOV CURRENT_PWM , R0 
                      3598     CALC_GOVERNOR_INT_CORR_EXIT: 
0B47    22            3599     	RET
                      3600     
                      3601     
                      3602     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3603     ;
                      3604     ; Measure lipo cells
                      3605     ;
                      3606     ; No assumptions
                      3607     ;
                      3608     ; Measure voltage and calculate lipo cells
                      3609     ;
                      3610     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3611     MEASURE_LIPO_CELLS: 
                      3612     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3616     MEASURE_LIPO_START: 
                      3617     	; Load programmed low voltage limit
0B48    7883          3618     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B4A    E6            3619     MOV A , @ R0 
0B4B    F520          3620     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3621     	; Set commutation to BpFET on
0B4D    121065        3622     	CALL	COMM5COMM6			
                      3623     	; Start adc
                      3624     	START_ADC 
0B50    75E890        3624+1   MOV ADC0CN , # 90H  ; ADC START
                      3625     	; Wait for ADC reference to settle, and then start again
0B53    1160          3626     	CALL	WAIT1MS
                      3627     	START_ADC
0B55    75E890        3627+1   MOV ADC0CN , # 90H  ; ADC START
                      3628     	; Wait for ADC conversion to complete
                      3629     MEASURE_LIPO_WAIT_ADC: 
                      3630     	GET_ADC_STATUS 
0B58    E5E8          3630+1   MOV A , ADC0CN 
0B5A    20ECFB        3631     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3632     	; Read ADC result
                      3633     	READ_ADC_RESULT
0B5D    A8BD          3633+1   MOV R0 , ADC0L 
0B5F    A9BE          3633+1   MOV R1 , ADC0H 
                      3634     	; Stop ADC
                      3635     	STOP_ADC
                      3636     	; Switch power off
0B61    12110B        3637     	CALL	SWITCH_POWER_OFF		
                      3638     	; Set limit step
0B64    756A55        3639     MOV LIPO_ADC_LIMIT_L , # 85 
0B67    756B00        3640     MOV LIPO_ADC_LIMIT_H , # 0 
0B6A    C3            3641     	CLR	C
0B6B    7400          3642     MOV A , # 0 
0B6D    13            3643     	RRC	A
0B6E    FD            3644     MOV R5 , A 
0B6F    7455          3645     MOV A , # 85 
0B71    13            3646     	RRC	A
0B72    FC            3647     MOV R4 , A 
0B73    7455          3648     MOV A , # 85 
0B75    2C            3649     ADD A , R4 
0B76    FC            3650     MOV R4 , A 
0B77    7400          3651     MOV A , # 0 
0B79    3D            3652     ADDC A , R5 
0B7A    FD            3653     MOV R5 , A 
0B7B    EC            3654     MOV A , R4 
0B7C    FA            3655     MOV R2 , A 
0B7D    ED            3656     MOV A , R5 
0B7E    FB            3657     MOV R3 , A 
                      3658     MEASURE_LIPO_CELL_LOOP: 
                      3659     	; Check voltage against xS lower limit
0B7F    C3            3660     	CLR	C
0B80    E8            3661     MOV A , R0 
0B81    9A            3662     SUBB A , R2 
0B82    E9            3663     MOV A , R1 
0B83    9B            3664     SUBB A , R3 
0B84    4014          3665     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3666     
                      3667     	; Set xS voltage limit
0B86    E56A          3668     	MOV	A, LIPO_ADC_LIMIT_L		
0B88    2455          3669     ADD A , # 85 
0B8A    F56A          3670     	MOV	LIPO_ADC_LIMIT_L, A
0B8C    E56B          3671     	MOV	A, LIPO_ADC_LIMIT_H		
0B8E    3400          3672     ADDC A , # 0 
0B90    F56B          3673     	MOV	LIPO_ADC_LIMIT_H, A
                      3674     	; Set (x+1)S lower limit
0B92    EA            3675     MOV A , R2 
0B93    2C            3676     ADD A , R4 
0B94    FA            3677     MOV R2 , A 
0B95    EB            3678     MOV A , R3 
0B96    3D            3679     ADDC A , R5 
0B97    FB            3680     MOV R3 , A 
0B98    80E5          3681     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3682     
                      3683     MEASURE_LIPO_ADJUST: 
0B9A    AE6A          3684     MOV R6 , LIPO_ADC_LIMIT_L 
0B9C    AF6B          3685     MOV R7 , LIPO_ADC_LIMIT_H 
                      3686     	; Calculate 3.125%
0B9E    C3            3687     	CLR	C
0B9F    E56B          3688     	MOV	A, LIPO_ADC_LIMIT_H
0BA1    13            3689     	RRC	A
0BA2    F9            3690     MOV R1 , A 
0BA3    E56A          3691     	MOV	A, LIPO_ADC_LIMIT_L	
0BA5    13            3692     	RRC	A
0BA6    F8            3693     MOV R0 , A 
0BA7    C3            3694     	CLR	C
0BA8    E9            3695     MOV A , R1 
0BA9    13            3696     	RRC	A
0BAA    F9            3697     MOV R1 , A 
0BAB    E8            3698     MOV A , R0 
0BAC    13            3699     	RRC	A
0BAD    F8            3700     MOV R0 , A 
0BAE    E56A          3701     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0BB0    28            3702     ADD A , R0 
0BB1    F568          3703     	MOV	LIPO_ADC_REFERENCE_L, A
0BB3    E56B          3704     	MOV	A, LIPO_ADC_LIMIT_H
0BB5    39            3705     ADDC A , R1 
0BB6    F569          3706     	MOV	LIPO_ADC_REFERENCE_H, A
                      3707     	; Divide three times to get to 3.125%
0BB8    7A03          3708     MOV R2 , # 3 
                      3709     MEASURE_LIPO_DIVIDE_LOOP: 
0BBA    C3            3710     	CLR	C
0BBB    E9            3711     MOV A , R1 
0BBC    13            3712     	RRC	A
0BBD    F9            3713     MOV R1 , A 
0BBE    E8            3714     MOV A , R0 
0BBF    13            3715     	RRC	A
0BC0    F8            3716     MOV R0 , A 
0BC1    DAF7          3717     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3718     
                      3719     	; Add the programmed number of 0.1V (or 3.125% increments)
0BC3    AA20          3720     MOV R2 , BIT_ACCESS 
0BC5    1A            3721     DEC R2 
0BC6    7009          3722     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3723     
0BC8    756A00        3724     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0BCB    756B00        3725     	MOV	LIPO_ADC_LIMIT_H, #0
0BCE    020BE1        3726     	JMP	MEASURE_LIPO_EXIT	
                      3727     
                      3728     MEASURE_LIPO_LIMIT_ON: 
0BD1    1A            3729     DEC R2 
0BD2    EA            3730     MOV A , R2 
0BD3    6008          3731     	JZ	MEASURE_LIPO_UPDATE
                      3732     
                      3733     MEASURE_LIPO_ADD_LOOP: 
0BD5    EE            3734     MOV A , R6 
0BD6    28            3735     ADD A , R0 
0BD7    FE            3736     MOV R6 , A 
0BD8    EF            3737     MOV A , R7 
0BD9    39            3738     ADDC A , R1 
0BDA    FF            3739     MOV R7 , A 
0BDB    DAF8          3740     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3741     
                      3742     MEASURE_LIPO_UPDATE: 
                      3743     	; Set ADC limit
0BDD    8E6A          3744     MOV LIPO_ADC_LIMIT_L , R6 
0BDF    8F6B          3745     MOV LIPO_ADC_LIMIT_H , R7 
                      3746     MEASURE_LIPO_EXIT: 
0BE1    22            3747     	RET
                      3748     
                      3749     
                      3750     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3751     ;
                      3752     ; Start ADC conversion
                      3753     ;
                      3754     ; No assumptions
                      3755     ;
                      3756     ; Start conversion used for measuring power supply voltage
                      3757     ;
                      3758     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3759     START_ADC_CONVERSION: 
                      3760     	; Start adc
                      3761     	START_ADC 
0BE2    75E890        3761+1   MOV ADC0CN , # 90H  ; ADC START
0BE5    22            3762     	RET
                      3763     
                      3764     
                      3765     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3766     ;
                      3767     ; Check temperature, power supply voltage and limit power
                      3768     ;
                      3769     ; No assumptions
                      3770     ;
                      3771     ; Used to limit main motor power in order to maintain the required voltage
                      3772     ;
                      3773     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3774     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3775     	; Load programmed low voltage limit
0BE6    7883          3776     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0BE8    E6            3777     MOV A , @ R0 
0BE9    FF            3778     MOV R7 , A 
                      3779     	; Wait for ADC conversion to complete
                      3780     	GET_ADC_STATUS 
0BEA    E5E8          3780+1   MOV A , ADC0CN 
0BEC    20ECF7        3781     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3782     	; Read ADC result
                      3783     	READ_ADC_RESULT
0BEF    A8BD          3783+1   MOV R0 , ADC0L 
0BF1    A9BE          3783+1   MOV R1 , ADC0H 
                      3784     	; Stop ADC
                      3785     	STOP_ADC
                      3786     
0BF3    056C          3787     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0BF5    C3            3788     	CLR	C
0BF6    E56C          3789     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0BF8    9408          3790     SUBB A , # 8 
0BFA    404B          3791     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3792     
0BFC    756C00        3793     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0BFF    E9            3794     MOV A , R1 
0C00    7007          3795     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3796     
0C02    E56D          3797     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0C04    601B          3798     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0C06    020C15        3799     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3800     
                      3801     TEMP_AVERAGE_INC_DEC: 
0C09    C3            3802     	CLR	C
0C0A    E8            3803     MOV A , R0 
0C0B    956D          3804     	SUBB	A, CURRENT_AVERAGE_TEMP
0C0D    6010          3805     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3806     
0C0F    E56D          3807     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0C11    5006          3808     	JNC	TEMP_AVERAGE_INC				
                      3809     
0C13    600C          3810     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3811     TEMP_AVERAGE_DEC: 
0C15    14            3812     	DEC	A						; Decrement average
0C16    020C21        3813     	JMP	TEMP_AVERAGE_UPDATED
                      3814     
                      3815     TEMP_AVERAGE_INC: 
0C19    04            3816     	INC	A						; Increment average
0C1A    60F9          3817     	JZ	TEMP_AVERAGE_DEC
0C1C    020C21        3818     	JMP	TEMP_AVERAGE_UPDATED
                      3819     
                      3820     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0C1F    E56D          3821     	MOV	A, CURRENT_AVERAGE_TEMP
                      3822     TEMP_AVERAGE_UPDATED: 
0C21    F56D          3823     	MOV	CURRENT_AVERAGE_TEMP, A
0C23    C3            3824     	CLR	C
0C24    94A8          3825     SUBB A , # 168 
0C26    401B          3826     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3827     
0C28    755EC0        3828     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3829     
0C2B    C3            3830     	CLR	C
0C2C    9405          3831     SUBB A , # 5 
0C2E    4013          3832     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3833     
0C30    755E80        3834     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3835     
0C33    C3            3836     	CLR	C
0C34    9405          3837     SUBB A , # 5 
0C36    400B          3838     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3839     
0C38    755E40        3840     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3841     
0C3B    C3            3842     	CLR	C
0C3C    9405          3843     SUBB A , # 5 
0C3E    4003          3844     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3845     
0C40    755E00        3846     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3847     
                      3848     TEMP_CHECK_EXIT: 
                      3849     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0C43    75BB06        3849+1   MOV AMX0P , # 6  ; SELECT POSITIVE INPUT
0C46    22            3850     	RET
                      3851     
                      3852     CHECK_VOLTAGE_START: 
                      3853     IF MODE == 0 OR MODE == 2	; Main or multi
                      3854     	; Check if low voltage limiting is enabled
0C47    EF            3855     MOV A , R7 
0C48    C3            3856     	CLR	C
0C49    9401          3857     	SUBB	A, #1					; Is low voltage limit disabled?
0C4B    601B          3858     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3859     
                      3860     	; Check if ADC is saturated
0C4D    C3            3861     	CLR	C
0C4E    E8            3862     MOV A , R0 
0C4F    94FF          3863     	SUBB	A, #0FFH
0C51    E9            3864     MOV A , R1 
0C52    9403          3865     	SUBB	A, #03H
0C54    5012          3866     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3867     
                      3868     	; Check voltage against limit
0C56    C3            3869     	CLR	C
0C57    E8            3870     MOV A , R0 
0C58    956A          3871     	SUBB	A, LIPO_ADC_LIMIT_L
0C5A    E9            3872     MOV A , R1 
0C5B    956B          3873     	SUBB	A, LIPO_ADC_LIMIT_H
0C5D    5009          3874     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3875     
                      3876     	; Decrease pwm limit
0C5F    E55E          3877     	MOV  A, PWM_LIMIT
0C61    600C          3878     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3879     
0C63    155E          3880     	DEC	PWM_LIMIT					; Decrement limit
0C65    020C6F        3881     	JMP	CHECK_VOLTAGE_LIM
                      3882     
                      3883     CHECK_VOLTAGE_GOOD: 
                      3884     	; Increase pwm limit
0C68    E55E          3885     	MOV  A, PWM_LIMIT
0C6A    F4            3886     	CPL	A			
0C6B    6002          3887     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3888     
0C6D    055E          3889     	INC	PWM_LIMIT					; Increment limit
                      3890     
                      3891     CHECK_VOLTAGE_LIM: 
0C6F    A85E          3892     MOV R0 , PWM_LIMIT 
0C71    C3            3893     	CLR	C
0C72    E524          3894     	MOV	A, CURRENT_PWM
0C74    98            3895     SUBB A , R0 
0C75    5002          3896     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3897     
0C77    A824          3898     MOV R0 , CURRENT_PWM 
                      3899     
                      3900     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3901     	; Slow spoolup
0C79    C3            3902     	CLR	C
0C7A    E8            3903     MOV A , R0 
0C7B    955F          3904     	SUBB	A, PWM_LIMIT_SPOOLUP
0C7D    400A          3905     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3906     
0C7F    A85F          3907     MOV R0 , PWM_LIMIT_SPOOLUP 
0C81    E55F          3908     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C83    F4            3909     	CPL	A
0C84    6003          3910     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3911      
0C86    855F5E        3912     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3913     
                      3914     CHECK_VOLTAGE_EXIT: 
0C89    8825          3915     MOV CURRENT_PWM_LIMITED , R0 
                      3916     ENDIF
                      3917     	; Set adc mux for next conversion
0C8B    C3            3918     	CLR	C
0C8C    E56C          3919     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C8E    B40703        3920     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3921     
                      3922     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C91    75BB1E        3922+1   MOV AMX0P , # 1EH  ; SELECT TEMP SENSOR INPUT
                      3923     
                      3924     CHECK_VOLTAGE_RET: 
0C94    22            3925     	RET
                      3926     
                      3927     
                      3928     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3929     ;
                      3930     ; Set startup PWM routine
                      3931     ;
                      3932     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3933     ;
                      3934     ; Used for pwm control during startup
                      3935     ;
                      3936     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3937     SET_STARTUP_PWM: 	
                      3938     	; Set pwm values according to startup phase flags
0C95    306102        3939     JNB FLAGS1 . 1 , ( $+5 ) 
0C98    7832          3940     MOV R0 , # 50 
0C9A    306202        3941     JNB FLAGS1 . 2 , ( $+5 ) 
0C9D    7878          3942     MOV R0 , # 120 
                      3943     
                      3944     	; Update pwm variables if any startup phase flag is set
0C9F    E52C          3945     	MOV	A, FLAGS1
0CA1    5406          3946     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0CA3    601F          3947     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3948     
                      3949     	; Adjust startup power
0CA5    E8            3950     MOV A , R0 
0CA6    79A2          3951     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0CA8    87F0          3952     MOV B , @ R1 
0CAA    A4            3953     	MUL	AB
0CAB    C5F0          3954     	XCH	A, B
0CAD    A2F7          3955     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0CAF    33            3956     	RLC	A
0CB0    F8            3957     MOV R0 , A 
0CB1    C3            3958     	CLR	C
0CB2    E8            3959     MOV A , R0 
0CB3    955E          3960     	SUBB	A, PWM_LIMIT	
0CB5    4002          3961     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3962     
0CB7    A85E          3963     MOV R0 , PWM_LIMIT 
                      3964     
                      3965     STARTUP_PWM_SET_PWM: 
                      3966     	; Set pwm variables
0CB9    8822          3967     MOV REQUESTED_PWM , R0 
0CBB    8824          3968     MOV CURRENT_PWM , R0 
0CBD    8825          3969     MOV CURRENT_PWM_LIMITED , R0 
0CBF    306102        3970     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3971     
0CC2    8860          3972     MOV PWM_SPOOLUP_BEG , R0 
                      3973     
                      3974     STARTUP_PWM_EXIT: 
0CC4    22            3975     	RET
                      3976     
                      3977     
                      3978     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3979     ;
                      3980     ; Initialize all timings routine
                      3981     ;
                      3982     ; No assumptions
                      3983     ;
                      3984     ; Part of initialization before motor start
                      3985     ;
                      3986     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3987     INITIALIZE_ALL_TIMINGS:  
                      3988     	; Load programmed startup rpm
0CC5    788F          3989     MOV R0 , # PGM_STARTUP_RPM 
0CC7    E6            3990     MOV A , @ R0 
0CC8    FF            3991     MOV R7 , A 
                      3992     	; Check startup rpm setting and set step accordingly
0CC9    C3            3993     	CLR	C
0CCA    EF            3994     MOV A , R7 
0CCB    9405          3995     	SUBB	A, #5
0CCD    5018          3996     	JNC	STEPPER_STEP_HIGH
0CCF    C3            3997     	CLR	C
0CD0    EF            3998     MOV A , R7 
0CD1    9404          3999     	SUBB	A, #4
0CD3    5020          4000     	JNC	STEPPER_STEP_MED_HIGH
0CD5    C3            4001     	CLR	C
0CD6    EF            4002     MOV A , R7 
0CD7    9403          4003     	SUBB	A, #3
0CD9    5028          4004     	JNC	STEPPER_STEP_MED
0CDB    C3            4005     	CLR	C
0CDC    EF            4006     MOV A , R7 
0CDD    9402          4007     	SUBB	A, #2
0CDF    5030          4008     	JNC	STEPPER_STEP_MED_LOW
0CE1    C3            4009     	CLR	C
0CE2    EF            4010     MOV A , R7 
0CE3    9401          4011     	SUBB	A, #1
0CE5    5038          4012     	JNC	STEPPER_STEP_LOW
                      4013     
                      4014     STEPPER_STEP_HIGH: 
0CE7    7533A0        4015     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0CEA    75340F        4016     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0CED    75353C        4017     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0CF0    753605        4018     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0CF3    A12B          4019     	AJMP	STEPPER_STEP_SET
                      4020     STEPPER_STEP_MED_HIGH: 
0CF5    7533C0        4021     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0CF8    753412        4022     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0CFB    753540        4023     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0CFE    753606        4024     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0D01    A12B          4025     	AJMP	STEPPER_STEP_SET
                      4026     STEPPER_STEP_MED: 
0D03    753370        4027     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0D06    753417        4028     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0D09    7535D0        4029     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0D0C    753607        4030     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0D0F    A12B          4031     	AJMP	STEPPER_STEP_SET
                      4032     STEPPER_STEP_MED_LOW: 
0D11    75334C        4033     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0D14    75341D        4034     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0D17    7535C4        4035     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0D1A    753609        4036     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0D1D    A12B          4037     	AJMP	STEPPER_STEP_SET
                      4038     STEPPER_STEP_LOW: 
0D1F    753328        4039     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0D22    753423        4040     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0D25    7535B8        4041     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0D28    75360B        4042     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      4043     
                      4044     STEPPER_STEP_SET: 
0D2B    853350        4045     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0D2E    853451        4046     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0D31    753C00        4047     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0D34    753D08        4048     	MOV	COMM_PERIOD4X_H, #08H
0D37    22            4049     	RET
                      4050     
                      4051     
                      4052     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4053     ;
                      4054     ; Calculate next commutation timing routine
                      4055     ;
                      4056     ; No assumptions
                      4057     ;
                      4058     ; Called immediately after each commutation
                      4059     ; Also sets up timer 3 to wait advance timing
                      4060     ; Two entry points are used
                      4061     ;
                      4062     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4063     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0D38    A850          4064     MOV R0 , WT_STEPPER_STEP_L 
0D3A    A951          4065     MOV R1 , WT_STEPPER_STEP_H 
0D3C    020D43        4066     	JMP	READ_TIMER
                      4067     
                      4068     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0D3F    A84A          4069     MOV R0 , WT_ADVANCE_L 
0D41    A94B          4070     MOV R1 , WT_ADVANCE_H 
                      4071     READ_TIMER: 
                      4072     	; Set up next wait
0D43    759100        4073     	MOV	TMR3CN, #00H		; Timer3 disabled
0D46    C3            4074     	CLR	C
0D47    E4            4075     	CLR	A
0D48    98            4076     SUBB A , R0 
0D49    F594          4077     	MOV	TMR3L, A
0D4B    E4            4078     	CLR	A
0D4C    99            4079     SUBB A , R1 
0D4D    F595          4080     	MOV	TMR3H, A
0D4F    759104        4081     	MOV	TMR3CN, #04H		; Timer3 enabled
0D52    D258          4082     SETB FLAGS0 . 0 
                      4083     	; Read commutation time
0D54    75C820        4084     	MOV	TMR2CN, #20H		; Timer2 disabled
0D57    A8CC          4085     MOV R0 , TMR2L 
0D59    A9CD          4086     MOV R1 , TMR2H 
0D5B    75C824        4087     	MOV	TMR2CN, #24H		; Timer2 enabled
                      4088     	; Calculate this commutation time
0D5E    AA3A          4089     MOV R2 , PREV_COMM_L 
0D60    AB3B          4090     MOV R3 , PREV_COMM_H 
0D62    883A          4091     MOV PREV_COMM_L , R0 
0D64    893B          4092     MOV PREV_COMM_H , R1 
0D66    C3            4093     	CLR	C
0D67    E8            4094     MOV A , R0 
0D68    9A            4095     SUBB A , R2 
0D69    F8            4096     MOV R0 , A 
0D6A    E9            4097     MOV A , R1 
0D6B    9B            4098     SUBB A , R3 
0D6C    F9            4099     MOV R1 , A 
                      4100     	; Calculate next zero cross scan timeout 
0D6D    AA3C          4101     MOV R2 , COMM_PERIOD4X_L 
0D6F    AB3D          4102     MOV R3 , COMM_PERIOD4X_H 
0D71    C3            4103     	CLR	C
0D72    EB            4104     MOV A , R3 
0D73    13            4105     	RRC	A					; Divide by 2
0D74    FD            4106     MOV R5 , A 
0D75    EA            4107     MOV A , R2 
0D76    13            4108     	RRC	A
0D77    FC            4109     MOV R4 , A 
0D78    C3            4110     	CLR	C
0D79    ED            4111     MOV A , R5 
0D7A    13            4112     	RRC	A					; Divide by 2 again
0D7B    FD            4113     MOV R5 , A 
0D7C    EC            4114     MOV A , R4 
0D7D    13            4115     	RRC	A
0D7E    FC            4116     MOV R4 , A 
0D7F    C3            4117     	CLR	C
0D80    EA            4118     MOV A , R2 
0D81    9C            4119     SUBB A , R4 
0D82    FA            4120     MOV R2 , A 
0D83    EB            4121     MOV A , R3 
0D84    9D            4122     SUBB A , R5 
0D85    FB            4123     MOV R3 , A 
                      4124     
0D86    EA            4125     MOV A , R2 
0D87    28            4126     ADD A , R0 
0D88    FA            4127     MOV R2 , A 
0D89    EB            4128     MOV A , R3 
0D8A    39            4129     ADDC A , R1 
0D8B    FB            4130     MOV R3 , A 
0D8C    8A3C          4131     MOV COMM_PERIOD4X_L , R2 
0D8E    8B3D          4132     MOV COMM_PERIOD4X_H , R3 
0D90    4001          4133     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4134     
0D92    22            4135     	RET
                      4136     
                      4137     CALC_NEXT_COMM_SLOW: 
0D93    753CFF        4138     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D96    753DFF        4139     	MOV	COMM_PERIOD4X_H, #0FFH
0D99    22            4140     	RET
                      4141     
                      4142     
                      4143     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4144     ;
                      4145     ; Setup zero cross scan wait
                      4146     ;
                      4147     ; No assumptions
                      4148     ;
                      4149     ; Sets up timer 3 to wait the zero cross scan wait time
                      4150     ;
                      4151     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4152     SETUP_ZC_SCAN_WAIT: 
0D9A    759100        4153     	MOV	TMR3CN, #00H		; Timer3 disabled
0D9D    C3            4154     	CLR	C
0D9E    E4            4155     	CLR	A
0D9F    954C          4156     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0DA1    F594          4157     	MOV	TMR3L, A
0DA3    E4            4158     	CLR	A
0DA4    954D          4159     	SUBB	A, WT_ZC_SCAN_H		
0DA6    F595          4160     	MOV	TMR3H, A
0DA8    759104        4161     	MOV	TMR3CN, #04H		; Timer3 enabled
0DAB    D258          4162     SETB FLAGS0 . 0 
0DAD    22            4163     	RET
                      4164     
                      4165     
                      4166     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4167     ;
                      4168     ; Wait advance timing routine
                      4169     ;
                      4170     ; No assumptions
                      4171     ;
                      4172     ; Waits for the advance timing to elapse, waits one zero cross
                      4173     ; wait and sets up the next zero cross wait
                      4174     ;
                      4175     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4176     WAIT_ADVANCE_TIMING: 	
0DAE    7F01          4177     MOV R7 , # 1 
0DB0    789C          4178     MOV R0 , # PGM_DEMAG_COMP 
0DB2    E6            4179     MOV A , @ R0 
0DB3    14            4180     	DEC	A
0DB4    6002          4181     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4182     
0DB6    7F02          4183     MOV R7 , # 2 
                      4184     
                      4185     WAIT_ADVANCE_TIMING_WAIT: 
0DB8    305802        4186     JNB FLAGS0 . 0 , ( $+5 ) 
0DBB    A1B8          4187     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4188     
0DBD    B19A          4189     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0DBF    DFF7          4190     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4191     
0DC1    22            4192     	RET
                      4193     
                      4194     
                      4195     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4196     ;
                      4197     ; Calculate new wait times routine
                      4198     ;
                      4199     ; No assumptions
                      4200     ;
                      4201     ; Calculates new wait times
                      4202     ;
                      4203     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4204     CALC_NEW_WAIT_TIMES: 	
                      4205     	; Load programmed commutation timing
0DC2    7892          4206     MOV R0 , # PGM_COMM_TIMING 
0DC4    E6            4207     MOV A , @ R0 
0DC5    FF            4208     MOV R7 , A 
0DC6    7E14          4209     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4210     IF MODE == 2
0DC8    A83D          4211     MOV R0 , COMM_PERIOD4X_H 
0DCA    C3            4212     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0DCB    E8            4213     MOV A , R0 
0DCC    9404          4214     	SUBB	A, #4
0DCE    4002          4215     	JC	CALC_NEW_WAIT_RED_SET
                      4216     
0DD0    7804          4217     MOV R0 , # 4 
                      4218     
                      4219     CALC_NEW_WAIT_RED_SET: 
0DD2    C3            4220     	CLR	C
0DD3    E8            4221     MOV A , R0 
0DD4    33            4222     	RLC	A
0DD5    F8            4223     MOV R0 , A 
0DD6    C3            4224     	CLR	C
0DD7    EE            4225     MOV A , R6 
0DD8    98            4226     SUBB A , R0 
0DD9    FE            4227     MOV R6 , A 
                      4228     ENDIF
0DDA    306304        4229     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4230     
0DDD    7F03          4231     MOV R7 , # 3 
0DDF    7E00          4232     MOV R6 , # 0 
                      4233     
                      4234     CALC_NEW_WAIT_DIR_START_SET: 
                      4235     	; Load current commutation timing
0DE1    A93D          4236     MOV R1 , COMM_PERIOD4X_H 
0DE3    A83C          4237     MOV R0 , COMM_PERIOD4X_L 
0DE5    7A04          4238     MOV R2 , # 4 
                      4239     DIVIDE_WAIT_TIMES: 
0DE7    C3            4240     	CLR	C
0DE8    E9            4241     MOV A , R1 
0DE9    13            4242     	RRC	A					; Divide by 2
0DEA    F9            4243     MOV R1 , A 
0DEB    E8            4244     MOV A , R0 
0DEC    13            4245     	RRC	A
0DED    F8            4246     MOV R0 , A 
0DEE    DAF7          4247     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4248     
0DF0    C3            4249     	CLR	C
0DF1    E8            4250     MOV A , R0 
0DF2    9E            4251     SUBB A , R6 
0DF3    F8            4252     MOV R0 , A 
0DF4    E9            4253     MOV A , R1 
0DF5    9400          4254     	SUBB	A, #0
0DF7    F9            4255     MOV R1 , A 
0DF8    4009          4256     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4257     
0DFA    C3            4258     	CLR	C
0DFB    E8            4259     MOV A , R0 
0DFC    9402          4260     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0DFE    E9            4261     MOV A , R1 
0DFF    9400          4262     	SUBB	A, #0
0E01    5004          4263     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4264     
                      4265     LOAD_MIN_TIME: 
0E03    7802          4266     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0E05    E4            4267     	CLR	A
0E06    F9            4268     MOV R1 , A 
                      4269     
                      4270     ADJUST_TIMING: 
0E07    E9            4271     MOV A , R1 
0E08    FB            4272     MOV R3 , A 
0E09    E8            4273     MOV A , R0 
0E0A    FA            4274     MOV R2 , A 
0E0B    C3            4275     	CLR	C
0E0C    E9            4276     MOV A , R1 
0E0D    13            4277     	RRC	A					; Divide by 2
0E0E    FD            4278     MOV R5 , A 
0E0F    E8            4279     MOV A , R0 
0E10    13            4280     	RRC	A
0E11    FC            4281     MOV R4 , A 
0E12    C3            4282     	CLR	C
0E13    EF            4283     MOV A , R7 
0E14    9403          4284     	SUBB	A, #3				; Is timing normal?
0E16    602E          4285     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4286     
0E18    EF            4287     MOV A , R7 
0E19    20E00D        4288     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4289     
0E1C    E8            4290     MOV A , R0 
0E1D    2C            4291     ADD A , R4 
0E1E    F8            4292     MOV R0 , A 
0E1F    E9            4293     MOV A , R1 
0E20    3D            4294     ADDC A , R5 
0E21    F9            4295     MOV R1 , A 
0E22    EC            4296     MOV A , R4 
0E23    FA            4297     MOV R2 , A 
0E24    ED            4298     MOV A , R5 
0E25    FB            4299     MOV R3 , A 
0E26    020E33        4300     	JMP	STORE_TIMES_UP_OR_DOWN
                      4301     
                      4302     ADJUST_TIMING_TWO_STEPS: 
0E29    E8            4303     MOV A , R0 
0E2A    28            4304     ADD A , R0 
0E2B    F8            4305     MOV R0 , A 
0E2C    E9            4306     MOV A , R1 
0E2D    39            4307     ADDC A , R1 
0E2E    F9            4308     MOV R1 , A 
0E2F    7A02          4309     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0E31    E4            4310     	CLR	A
0E32    FB            4311     MOV R3 , A 
                      4312     
                      4313     STORE_TIMES_UP_OR_DOWN: 
0E33    C3            4314     	CLR	C
0E34    EF            4315     MOV A , R7 
0E35    9403          4316     	SUBB	A, #3				; Is timing higher than normal?
0E37    400D          4317     	JC	STORE_TIMES_DECREASE	; No - branch
                      4318     
                      4319     STORE_TIMES_INCREASE: 
0E39    8A4E          4320     MOV WT_COMM_L , R2 
0E3B    8B4F          4321     MOV WT_COMM_H , R3 
0E3D    884A          4322     MOV WT_ADVANCE_L , R0 
0E3F    894B          4323     MOV WT_ADVANCE_H , R1 
0E41    8C4C          4324     MOV WT_ZC_SCAN_L , R4 
0E43    8D4D          4325     MOV WT_ZC_SCAN_H , R5 
0E45    22            4326     	RET
                      4327     
                      4328     STORE_TIMES_DECREASE: 
0E46    884E          4329     MOV WT_COMM_L , R0 
0E48    894F          4330     MOV WT_COMM_H , R1 
0E4A    8A4A          4331     MOV WT_ADVANCE_L , R2 
0E4C    8B4B          4332     MOV WT_ADVANCE_H , R3 
0E4E    8C4C          4333     MOV WT_ZC_SCAN_L , R4 
0E50    8D4D          4334     MOV WT_ZC_SCAN_H , R5 
0E52    22            4335     	RET
                      4336     
                      4337     
                      4338     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4339     ;
                      4340     ; Wait before zero cross scan routine
                      4341     ;
                      4342     ; No assumptions
                      4343     ;
                      4344     ; Waits for the zero cross scan wait time to elapse
                      4345     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4346     ;
                      4347     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4348     WAIT_BEFORE_ZC_SCAN: 	
0E53    305802        4349     JNB FLAGS0 . 0 , ( $+5 ) 
0E56    C153          4350     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4351     
0E58    759100        4352     	MOV	TMR3CN, #00H		; Timer3 disabled
0E5B    C3            4353     	CLR	C
0E5C    E4            4354     	CLR	A
0E5D    953C          4355     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0E5F    F594          4356     	MOV	TMR3L, A
0E61    E4            4357     	CLR	A
0E62    953D          4358     	SUBB	A, COMM_PERIOD4X_H		
0E64    F595          4359     	MOV	TMR3H, A
0E66    759104        4360     	MOV	TMR3CN, #04H		; Timer3 enabled
0E69    D258          4361     SETB FLAGS0 . 0 
0E6B    22            4362     	RET
                      4363     
                      4364     
                      4365     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4366     ;
                      4367     ; Wait for comparator to go low/high routines
                      4368     ;
                      4369     ; No assumptions
                      4370     ;
                      4371     ; Waits for the zero cross scan wait time to elapse
                      4372     ; Then scans for comparator going low/high
                      4373     ;
                      4374     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4375     WAIT_FOR_COMP_OUT_LOW: 
0E6C    753F00        4376     	MOV	COMP_WAIT_READS, #0
0E6F    752000        4377     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E72    020E7B        4378     	JMP	WAIT_FOR_COMP_OUT_START
                      4379     
                      4380     WAIT_FOR_COMP_OUT_HIGH: 
0E75    753F00        4381     	MOV	COMP_WAIT_READS, #0
0E78    752040        4382     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4383     
                      4384     WAIT_FOR_COMP_OUT_START: 
0E7B    D2AF          4385     	SETB	EA						; Enable interrupts
0E7D    053F          4386     	INC	COMP_WAIT_READS
0E7F    205801        4387     JB FLAGS0 . 0 , ( $+4 ) 
0E82    22            4388     	RET							; Yes - return
                      4389     
                      4390     	; Set default comparator response times
0E83    759D00        4391     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4392     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4395     	; Select number of comparator readings based upon current rotation speed
0E86    E53D          4396     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E88    C3            4397     	CLR	C
0E89    13            4398     	RRC	A						; Divide by 4
0E8A    C3            4399     	CLR	C
0E8B    13            4400     	RRC	A
0E8C    F8            4401     MOV R0 , A 
0E8D    08            4402     INC R0 
0E8E    6030          4403     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4404     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E90    306A06        4405     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4406     
0E93    C3            4407     	CLR	C
0E94    13            4408     	RRC	A						; Divide by 4 again
0E95    C3            4409     	CLR	C
0E96    13            4410     	RRC	A
0E97    F8            4411     MOV R0 , A 
0E98    08            4412     INC R0 
                      4413     
                      4414     COMP_WAIT_SET_MAX_READINGS: 
0E99    C3            4415     	CLR	C
0E9A    E8            4416     MOV A , R0 
0E9B    940A          4417     	SUBB	A, #10
0E9D    4002          4418     	JC	($+4)
                      4419     
0E9F    780A          4420     MOV R0 , # 10 
                      4421     
0EA1    306D08        4422     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4423     
0EA4    C3            4424     	CLR	C
0EA5    E8            4425     MOV A , R0 
0EA6    9404          4426     	SUBB	A, #4
0EA8    4002          4427     	JC	($+4)
                      4428     
0EAA    7804          4429     MOV R0 , # 4 
                      4430     
                      4431     COMP_WAIT_SET_RESPONSE_TIME: 
0EAC    C3            4432     	CLR	C
0EAD    E53D          4433     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0EAF    9408          4434     	SUBB	A, #8
0EB1    400D          4435     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4436     
0EB3    759D02        4437     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4438     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0EB6    C3            4441     	CLR	C
0EB7    E53D          4442     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0EB9    9410          4443     	SUBB	A, #16
0EBB    4003          4444     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4445     
0EBD    759D03        4446     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4447     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4450     
                      4451     COMP_WAIT_ON_COMP_ABLE: 
0EC0    205803        4452     JB FLAGS0 . 0 , ( $+6 ) 
0EC3    D2AF          4453     	SETB	EA							; Enable interrupts
0EC5    22            4454     	RET								; Yes - return
                      4455     
0EC6    791E          4456     MOV R1 , # 30 
0EC8    206D02        4457     JB FLAGS2 . 5 , ( $+5 ) 
0ECB    790A          4458     MOV R1 , # 10 
0ECD    D2AF          4459     	SETB	EA							; Enable interrupts
0ECF    00            4460     	NOP								; Allocate only just enough time to capture interrupt
0ED0    00            4461     	NOP
0ED1    C2AF          4462     	CLR	EA							; Disable interrupts
0ED3    205A0A        4463     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4464     
0ED6    791E          4465     MOV R1 , # 30 
0ED8    206D02        4466     JB FLAGS2 . 5 , ( $+5 ) 
0EDB    790A          4467     MOV R1 , # 10 
0EDD    3066E0        4468     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4469     
                      4470     PWM_WAIT_STARTUP: 						
0EE0    306302        4471     JNB FLAGS1 . 3 , PWM_WAIT 
                      4472     
0EE3    7978          4473     MOV R1 , # 120 
                      4474     PWM_WAIT: 						
0EE5    C3            4475     	CLR	C
0EE6    E58B          4476     	MOV	A, TL1
0EE8    99            4477     SUBB A , R1 
                      4478     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0EE9    40D5          4483     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4484     ENDIF
                      4485     
                      4486     COMP_READ: 
                      4487     	READ_COMP_OUT 					; Read comparator output
0EEB    E59B          4487+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0EED    F4            4488     	CPL	A
0EEE    5440          4489     	ANL	A, #40H
0EF0    B52002        4490     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4491     
0EF3    C17B          4492     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4493     
0EF5    D8C9          4494     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4495     
0EF7    D2AF          4496     	SETB	EA						; Enable interrupts
0EF9    22            4497     	RET							
                      4498     
                      4499     
                      4500     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4501     ;
                      4502     ; Evaluate comparator integrity
                      4503     ;
                      4504     ; No assumptions
                      4505     ;
                      4506     ; Checks comparator signal behaviour versus expected behaviour
                      4507     ;
                      4508     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4509     EVALUATE_COMPARATOR_INTEGRITY: 
0EFA    C25B          4510     CLR FLAGS0 . 3 
                      4511     	; Check if demag compensation is enabled
0EFC    789C          4512     MOV R0 , # PGM_DEMAG_COMP 
0EFE    E6            4513     MOV A , @ R0 
0EFF    14            4514     	DEC	A
0F00    600A          4515     	JZ	EVAL_COMP_NO_DEMAG
                      4516     
                      4517     	; Check if a demag situation has occurred
0F02    E53F          4518     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0F04    14            4519     	DEC	A
0F05    7005          4520     	JNZ	EVAL_COMP_NO_DEMAG
                      4521     
0F07    206302        4522     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4523     
0F0A    D25B          4524     SETB FLAGS0 . 3 
                      4525     
                      4526     EVAL_COMP_NO_DEMAG: 
0F0C    30630B        4527     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4528     
0F0F    0538          4529     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0F11    205810        4530     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4531     
0F14    753800        4532     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0F17    020F24        4533     	JMP	EVAL_COMP_EXIT
                      4534     
                      4535     EVAL_COMP_CHECK_TIMEOUT: 
0F1A    205807        4536     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0F1D    1581          4537     	DEC	SP							; Routine exit without "ret" command
0F1F    1581          4538     	DEC	SP
0F21    0217E8        4539     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4540     
                      4541     EVAL_COMP_EXIT: 
0F24    22            4542     	RET
                      4543     
                      4544     
                      4545     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4546     ;
                      4547     ; Setup commutation timing routine
                      4548     ;
                      4549     ; No assumptions
                      4550     ;
                      4551     ; Sets up and starts wait from commutation to zero cross
                      4552     ;
                      4553     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4554     SETUP_COMM_WAIT:  
0F25    759100        4555     	MOV	TMR3CN, #00H		; Timer3 disabled
0F28    C3            4556     	CLR	C
0F29    E4            4557     	CLR	A
0F2A    954E          4558     	SUBB	A, WT_COMM_L		; Set wait commutation value
0F2C    F594          4559     	MOV	TMR3L, A
0F2E    E4            4560     	CLR	A
0F2F    954F          4561     	SUBB	A, WT_COMM_H		
0F31    F595          4562     	MOV	TMR3H, A
0F33    759104        4563     	MOV	TMR3CN, #04H		; Timer3 enabled
0F36    D258          4564     SETB FLAGS0 . 0 
0F38    22            4565     	RET
                      4566     
                      4567     
                      4568     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4569     ;
                      4570     ; Wait for commutation routine
                      4571     ;
                      4572     ; No assumptions
                      4573     ;
                      4574     ; Waits from zero cross to commutation 
                      4575     ;
                      4576     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4577     WAIT_FOR_COMM:  
                      4578     	; Increment or reset consecutive count
0F39    0539          4579     	INC	DEMAG_CONSECUTIVE_CNT
0F3B    205B03        4580     JB FLAGS0 . 3 , ( $+6 ) 
                      4581     
0F3E    753900        4582     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4583     
                      4584     	; Check if a demag situation has occurred
0F41    305B23        4585     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4586     
                      4587     	; Load programmed demag compensation
0F44    78A3          4588     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0F46    E6            4589     MOV A , @ R0 
0F47    FF            4590     MOV R7 , A 
                      4591     
                      4592     	; Check for power off
0F48    BF0108        4593     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4594     
0F4B    D25C          4595     SETB FLAGS0 . 4 
                      4596     	ALL_NFETS_OFF
0F4D    C2B1          4596+1   CLR P3 . 1 
0F4F    C287          4596+1   CLR P0 . 7 
0F51    C281          4596+1   CLR P0 . 1 
                      4597     
                      4598     	; Wait a blind wait
                      4599     WAIT_FOR_COMM_BLIND: 
0F53    B19A          4600     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4601     WAIT_DEMAG_DEFAULT_ZC: 	
0F55    305802        4602     JNB FLAGS0 . 0 , ( $+5 ) 
0F58    E155          4603     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4604     
                      4605     	; Check for power off
0F5A    BF0208        4606     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4607     
0F5D    D25C          4608     SETB FLAGS0 . 4 
                      4609     	ALL_NFETS_OFF
0F5F    C2B1          4609+1   CLR P3 . 1 
0F61    C287          4609+1   CLR P0 . 7 
0F63    C281          4609+1   CLR P0 . 1 
                      4610     
                      4611     WAIT_FOR_COMM_SETUP: 
0F65    F125          4612     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4613     WAIT_FOR_COMM_WAIT: 
0F67    305802        4614     JNB FLAGS0 . 0 , ( $+5 ) 
0F6A    E167          4615     	AJMP	WAIT_FOR_COMM_WAIT					
                      4616     
0F6C    22            4617     	RET
                      4618     
                      4619     
                      4620     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4621     ;
                      4622     ; Commutation routines
                      4623     ;
                      4624     ; No assumptions
                      4625     ;
                      4626     ; Performs commutation switching 
                      4627     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4628     ;
                      4629     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4630     COMM1COMM2: 	
0F6D    C2AF          4631     	CLR 	EA					; Disable all interrupts
                      4632     	BPFET_OFF					; Bp off
0F6F    C286          4632+1   CLR P0 . 6 
0F71    206A03        4633     JB FLAGS2 . 2 , COMM12_DAMP 
0F74    020F8C        4634     	JMP	COMM12_NONDAMP
                      4635     COMM12_DAMP: 
                      4636     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4640     IF DAMPED_MODE_ENABLE == 1
0F77    900347        4641     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4642     ENDIF
0F7A    30650F        4643     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4644     	CPFET_OFF				
0F7D    207502        4644+1   JB FLAGS3 . 5 , ( $+5 ) 
0F80    C280          4644+1   CLR P0 . 0 
0F82    307502        4644+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F85    C282          4644+1   CLR P0 . 2 
0F87    7406          4645     MOV A , # 6 
0F89    D5E0FD        4646     	DJNZ ACC,	$
                      4647     COMM12_NONDAMP: 
                      4648     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4656     	APFET_ON					; Ap on
0F8C    207502        4656+1   JB FLAGS3 . 5 , ( $+5 ) 
0F8F    D282          4656+1   SETB P0 . 2 
0F91    307502        4656+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F94    D280          4656+1   SETB P0 . 0 
                      4657     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F96    759F02        4657+1   MOV CPT0MX , # 02H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F99    753E02        4658     	MOV	COMM_PHASE, #2
0F9C    0210F7        4659     	JMP	COMM_EXIT
                      4660     
                      4661     COMM2COMM3: 	
0F9F    C2AF          4662     	CLR 	EA					; Disable all interrupts
0FA1    206A03        4663     JB FLAGS2 . 2 , COMM23_DAMP 
0FA4    020FC1        4664     	JMP	COMM23_NONDAMP
                      4665     COMM23_DAMP: 
                      4666     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4669     IF DAMPED_MODE_ENABLE == 1
0FA7    9002FE        4670     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4671     ENDIF
0FAA    306517        4672     JNB FLAGS1 . 5 , COMM23_NFET 
                      4673     	BPFET_OFF				
0FAD    C286          4673+1   CLR P0 . 6 
                      4674     	CPFET_OFF				
0FAF    207502        4674+1   JB FLAGS3 . 5 , ( $+5 ) 
0FB2    C280          4674+1   CLR P0 . 0 
0FB4    307502        4674+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FB7    C282          4674+1   CLR P0 . 2 
0FB9    7406          4675     MOV A , # 6 
0FBB    D5E0FD        4676     	DJNZ ACC,	$
0FBE    020FC4        4677     	JMP	COMM23_NFET
                      4678     COMM23_NONDAMP: 
0FC1    9001E1        4679     	MOV	DPTR, #PWM_BFET_ON	
                      4680     COMM23_NFET: 
                      4681     	CNFET_OFF					; Cn off
0FC4    207502        4681+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC7    C281          4681+1   CLR P0 . 1 
0FC9    307502        4681+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FCC    C2B1          4681+1   CLR P3 . 1 
0FCE    305A06        4682     JNB FLAGS0 . 2 , COMM23_CP 
                      4683     	BNFET_ON					; Yes - Bn on
0FD1    E525          4683+1   MOV A , CURRENT_PWM_LIMITED 
0FD3    6002          4683+1   JZ ( $+4 ) 
0FD5    D287          4683+1   SETB P0 . 7 
                      4684     COMM23_CP: 
                      4685     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FD7    207503        4685+1   JB FLAGS3 . 5 , ( $+6 ) 
0FDA    759F03        4685+1   MOV CPT0MX , # 03H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FDD    307503        4685+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FE0    759F01        4685+1   MOV CPT0MX , # 01H 
0FE3    753E03        4686     	MOV	COMM_PHASE, #3
0FE6    0210F7        4687     	JMP	COMM_EXIT
                      4688     
                      4689     COMM3COMM4: 	
0FE9    C2AF          4690     	CLR 	EA					; Disable all interrupts
                      4691     	APFET_OFF					; Ap off
0FEB    207502        4691+1   JB FLAGS3 . 5 , ( $+5 ) 
0FEE    C282          4691+1   CLR P0 . 2 
0FF0    307502        4691+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF3    C280          4691+1   CLR P0 . 0 
0FF5    206A03        4692     JB FLAGS2 . 2 , COMM34_DAMP 
0FF8    021008        4693     	JMP	COMM34_NONDAMP
                      4694     COMM34_DAMP: 
                      4695     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4699     IF DAMPED_MODE_ENABLE == 1
0FFB    9002BD        4700     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4701     ENDIF
0FFE    306507        4702     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4703     	BPFET_OFF				
1001    C286          4703+1   CLR P0 . 6 
1003    7406          4704     MOV A , # 6 
1005    D5E0FD        4705     	DJNZ ACC,	$
                      4706     COMM34_NONDAMP: 
                      4707     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4715     	CPFET_ON					; Cp on
1008    207502        4715+1   JB FLAGS3 . 5 , ( $+5 ) 
100B    D280          4715+1   SETB P0 . 0 
100D    307502        4715+1   JNB FLAGS3 . 5 , ( $+5 ) 
1010    D282          4715+1   SETB P0 . 2 
                      4716     	SET_COMP_PHASE_A 			; Set comparator to phase A
1012    207503        4716+1   JB FLAGS3 . 5 , ( $+6 ) 
1015    759F01        4716+1   MOV CPT0MX , # 01H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1018    307503        4716+1   JNB FLAGS3 . 5 , ( $+6 ) 
101B    759F03        4716+1   MOV CPT0MX , # 03H 
101E    753E04        4717     	MOV	COMM_PHASE, #4
1021    0210F7        4718     	JMP	COMM_EXIT
                      4719     
                      4720     COMM4COMM5: 	
1024    C2AF          4721     	CLR 	EA					; Disable all interrupts
1026    206A03        4722     JB FLAGS2 . 2 , COMM45_DAMP 
1029    021046        4723     	JMP	COMM45_NONDAMP
                      4724     COMM45_DAMP: 
                      4725     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4728     IF DAMPED_MODE_ENABLE == 1
102C    90027C        4729     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4730     ENDIF
102F    306517        4731     JNB FLAGS1 . 5 , COMM45_NFET 
                      4732     	APFET_OFF				
1032    207502        4732+1   JB FLAGS3 . 5 , ( $+5 ) 
1035    C282          4732+1   CLR P0 . 2 
1037    307502        4732+1   JNB FLAGS3 . 5 , ( $+5 ) 
103A    C280          4732+1   CLR P0 . 0 
                      4733     	BPFET_OFF				
103C    C286          4733+1   CLR P0 . 6 
103E    7406          4734     MOV A , # 6 
1040    D5E0FD        4735     	DJNZ ACC,	$
1043    021049        4736     	JMP	COMM45_NFET
                      4737     COMM45_NONDAMP: 
1046    9001CF        4738     	MOV	DPTR, #PWM_AFET_ON
                      4739     COMM45_NFET: 
                      4740     	BNFET_OFF					; Bn off
1049    C287          4740+1   CLR P0 . 7 
104B    305A0E        4741     JNB FLAGS0 . 2 , COMM45_CP 
                      4742     	ANFET_ON					; Yes - An on
104E    E525          4742+1   MOV A , CURRENT_PWM_LIMITED 
1050    600A          4742+1   JZ ( $+12 ) 
1052    207502        4742+1   JB FLAGS3 . 5 , ( $+5 ) 
1055    D2B1          4742+1   SETB P3 . 1 
1057    307502        4742+1   JNB FLAGS3 . 5 , ( $+5 ) 
105A    D281          4742+1   SETB P0 . 1 
                      4743     COMM45_CP: 
                      4744     	SET_COMP_PHASE_B 			; Set comparator to phase B
105C    759F02        4744+1   MOV CPT0MX , # 02H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
105F    753E05        4745     	MOV	COMM_PHASE, #5
1062    0210F7        4746     	JMP	COMM_EXIT
                      4747     
                      4748     COMM5COMM6: 	
1065    C2AF          4749     	CLR 	EA					; Disable all interrupts
                      4750     	CPFET_OFF					; Cp off
1067    207502        4750+1   JB FLAGS3 . 5 , ( $+5 ) 
106A    C280          4750+1   CLR P0 . 0 
106C    307502        4750+1   JNB FLAGS3 . 5 , ( $+5 ) 
106F    C282          4750+1   CLR P0 . 2 
1071    206A03        4751     JB FLAGS2 . 2 , COMM56_DAMP 
1074    02108C        4752     	JMP	COMM56_NONDAMP
                      4753     COMM56_DAMP: 
                      4754     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4758     IF DAMPED_MODE_ENABLE == 1
1077    900233        4759     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4760     ENDIF
107A    30650F        4761     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4762     	APFET_OFF				
107D    207502        4762+1   JB FLAGS3 . 5 , ( $+5 ) 
1080    C282          4762+1   CLR P0 . 2 
1082    307502        4762+1   JNB FLAGS3 . 5 , ( $+5 ) 
1085    C280          4762+1   CLR P0 . 0 
1087    7406          4763     MOV A , # 6 
1089    D5E0FD        4764     	DJNZ ACC,	$
                      4765     COMM56_NONDAMP: 
                      4766     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4774     	BPFET_ON					; Bp on
108C    D286          4774+1   SETB P0 . 6 
                      4775     	SET_COMP_PHASE_C 			; Set comparator to phase C
108E    207503        4775+1   JB FLAGS3 . 5 , ( $+6 ) 
1091    759F03        4775+1   MOV CPT0MX , # 03H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1094    307503        4775+1   JNB FLAGS3 . 5 , ( $+6 ) 
1097    759F01        4775+1   MOV CPT0MX , # 01H 
109A    753E06        4776     	MOV	COMM_PHASE, #6
109D    0210F7        4777     	JMP	COMM_EXIT
                      4778     
                      4779     COMM6COMM1: 	
10A0    C2AF          4780     	CLR 	EA					; Disable all interrupts
10A2    206A03        4781     JB FLAGS2 . 2 , COMM61_DAMP 
10A5    0210CA        4782     	JMP	COMM61_NONDAMP
                      4783     COMM61_DAMP: 
                      4784     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4787     IF DAMPED_MODE_ENABLE == 1
10A8    9003A0        4788     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4789     ENDIF
10AB    30651F        4790     JNB FLAGS1 . 5 , COMM61_NFET 
                      4791     	APFET_OFF				
10AE    207502        4791+1   JB FLAGS3 . 5 , ( $+5 ) 
10B1    C282          4791+1   CLR P0 . 2 
10B3    307502        4791+1   JNB FLAGS3 . 5 , ( $+5 ) 
10B6    C280          4791+1   CLR P0 . 0 
                      4792     	CPFET_OFF				
10B8    207502        4792+1   JB FLAGS3 . 5 , ( $+5 ) 
10BB    C280          4792+1   CLR P0 . 0 
10BD    307502        4792+1   JNB FLAGS3 . 5 , ( $+5 ) 
10C0    C282          4792+1   CLR P0 . 2 
10C2    7406          4793     MOV A , # 6 
10C4    D5E0FD        4794     	DJNZ ACC,	$
10C7    0210CD        4795     	JMP	COMM61_NFET
                      4796     COMM61_NONDAMP: 
10CA    9001F3        4797     	MOV	DPTR, #PWM_CFET_ON
                      4798     COMM61_NFET: 
                      4799     	ANFET_OFF					; An off
10CD    207502        4799+1   JB FLAGS3 . 5 , ( $+5 ) 
10D0    C2B1          4799+1   CLR P3 . 1 
10D2    307502        4799+1   JNB FLAGS3 . 5 , ( $+5 ) 
10D5    C281          4799+1   CLR P0 . 1 
10D7    305A0E        4800     JNB FLAGS0 . 2 , COMM61_CP 
                      4801     	CNFET_ON					; Yes - Cn on
10DA    E525          4801+1   MOV A , CURRENT_PWM_LIMITED 
10DC    600A          4801+1   JZ ( $+12 ) 
10DE    207502        4801+1   JB FLAGS3 . 5 , ( $+5 ) 
10E1    D281          4801+1   SETB P0 . 1 
10E3    307502        4801+1   JNB FLAGS3 . 5 , ( $+5 ) 
10E6    D2B1          4801+1   SETB P3 . 1 
                      4802     COMM61_CP: 
                      4803     	SET_COMP_PHASE_A 			; Set comparator to phase A
10E8    207503        4803+1   JB FLAGS3 . 5 , ( $+6 ) 
10EB    759F01        4803+1   MOV CPT0MX , # 01H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
10EE    307503        4803+1   JNB FLAGS3 . 5 , ( $+6 ) 
10F1    759F03        4803+1   MOV CPT0MX , # 03H 
10F4    753E01        4804     	MOV	COMM_PHASE, #1
                      4805     
                      4806     COMM_EXIT: 
10F7    D2AF          4807     	SETB	EA					; Enable all interrupts
10F9    789C          4808     MOV R0 , # PGM_DEMAG_COMP 
10FB    E6            4809     MOV A , @ R0 
10FC    C3            4810     	CLR	C
10FD    9402          4811     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
10FF    4007          4812     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4813     
1101    C3            4814     	CLR	C
1102    E539          4815     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1104    9403          4816     	SUBB	A, #3
1106    5002          4817     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4818     
                      4819     COMM_RESTORE_POWER: 
1108    C25C          4820     CLR FLAGS0 . 4 
                      4821     
                      4822     COMM_RETURN: 
110A    22            4823     	RET
                      4824     
                      4825     
                      4826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4827     ;
                      4828     ; Switch power off routine
                      4829     ;
                      4830     ; No assumptions
                      4831     ;
                      4832     ; Switches all fets off 
                      4833     ;
                      4834     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4835     SWITCH_POWER_OFF: 
110B    9001CD        4836     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4837     	ALL_NFETS_OFF			; Turn off all nfets
110E    C2B1          4837+1   CLR P3 . 1 
1110    C287          4837+1   CLR P0 . 7 
1112    C281          4837+1   CLR P0 . 1 
                      4838     	ALL_PFETS_OFF			; Turn off all pfets
1114    C282          4838+1   CLR P0 . 2 
1116    C286          4838+1   CLR P0 . 6 
1118    C280          4838+1   CLR P0 . 0 
111A    C25A          4839     CLR FLAGS0 . 2 
111C    22            4840     	RET			
                      4841     
                      4842     
                      4843     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4844     ;
                      4845     ; Decrement stepper step routine
                      4846     ;
                      4847     ; No assumptions
                      4848     ;
                      4849     ; Decrements the stepper step 
                      4850     ;
                      4851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4852     DECREMENT_STEPPER_STEP: 
111D    C3            4853     	CLR	C
111E    E550          4854     	MOV	A, WT_STEPPER_STEP_L
1120    9535          4855     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1122    E551          4856     	MOV	A, WT_STEPPER_STEP_H
1124    9536          4857     	SUBB	A, STEPPER_STEP_END_H	
1126    5001          4858     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
1128    22            4859     	RET
                      4860     
                      4861     DECREMENT_STEP: 
                      4862     	; Load programmed startup acceleration
1129    7890          4863     MOV R0 , # PGM_STARTUP_ACCEL 
112B    E6            4864     MOV A , @ R0 
112C    FF            4865     MOV R7 , A 
                      4866     	; Check acceleration setting and set step size accordingly
112D    C3            4867     	CLR	C
112E    EF            4868     MOV A , R7 
112F    9405          4869     	SUBB	A, #5
1131    5018          4870     	JNC	DEC_STEP_HIGH
1133    C3            4871     	CLR	C
1134    EF            4872     MOV A , R7 
1135    9404          4873     	SUBB	A, #4
1137    501B          4874     	JNC	DEC_STEP_MED_HIGH
1139    C3            4875     	CLR	C
113A    EF            4876     MOV A , R7 
113B    9403          4877     	SUBB	A, #3
113D    501E          4878     	JNC	DEC_STEP_MED
113F    C3            4879     	CLR	C
1140    EF            4880     MOV A , R7 
1141    9402          4881     	SUBB	A, #2
1143    5021          4882     	JNC	DEC_STEP_MED_LOW
1145    C3            4883     	CLR	C
1146    EF            4884     MOV A , R7 
1147    9401          4885     	SUBB	A, #1
1149    5024          4886     	JNC	DEC_STEP_LOW
                      4887     
                      4888     DEC_STEP_HIGH: 
114B    C3            4889     	CLR	C
114C    E550          4890     	MOV	A, WT_STEPPER_STEP_L
114E    943C          4891     	SUBB	A, #LOW(30 SHL 1)		
1150    F8            4892     MOV R0 , A 
1151    021178        4893     	JMP	DECREMENT_STEP_EXIT
                      4894     DEC_STEP_MED_HIGH: 
1154    C3            4895     	CLR	C
1155    E550          4896     	MOV	A, WT_STEPPER_STEP_L
1157    9428          4897     	SUBB	A, #LOW(20 SHL 1)		
1159    F8            4898     MOV R0 , A 
115A    021178        4899     	JMP	DECREMENT_STEP_EXIT
                      4900     DEC_STEP_MED: 
115D    C3            4901     	CLR	C
115E    E550          4902     	MOV	A, WT_STEPPER_STEP_L
1160    941A          4903     	SUBB	A, #LOW(13 SHL 1)		
1162    F8            4904     MOV R0 , A 
1163    021178        4905     	JMP	DECREMENT_STEP_EXIT
                      4906     DEC_STEP_MED_LOW: 
1166    C3            4907     	CLR	C
1167    E550          4908     	MOV	A, WT_STEPPER_STEP_L
1169    9412          4909     	SUBB	A, #LOW(9 SHL 1)		
116B    F8            4910     MOV R0 , A 
116C    021178        4911     	JMP	DECREMENT_STEP_EXIT
                      4912     DEC_STEP_LOW: 
116F    C3            4913     	CLR	C
1170    E550          4914     	MOV	A, WT_STEPPER_STEP_L
1172    940A          4915     	SUBB	A, #LOW(5 SHL 1)		
1174    F8            4916     MOV R0 , A 
1175    021178        4917     	JMP	DECREMENT_STEP_EXIT
                      4918     
                      4919     DECREMENT_STEP_EXIT: 
1178    E551          4920     	MOV	A, WT_STEPPER_STEP_H
117A    9400          4921     	SUBB	A, #0		
117C    F9            4922     MOV R1 , A 
117D    8850          4923     MOV WT_STEPPER_STEP_L , R0 
117F    8951          4924     MOV WT_STEPPER_STEP_H , R1 
1181    22            4925     	RET
                      4926     
                      4927     
                      4928     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4929     ;
                      4930     ; Stepper timer wait
                      4931     ;
                      4932     ; No assumptions
                      4933     ;
                      4934     ; Waits for the stepper step timer to elapse
                      4935     ;
                      4936     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4937     STEPPER_TIMER_WAIT: 
1182    305802        4938     JNB FLAGS0 . 0 , ( $+5 ) 
1185    2182          4939     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
1187    22            4940     	RET
                      4941     
                      4942     
                      4943     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4944     ;
                      4945     ; Set default parameters
                      4946     ;
                      4947     ; No assumptions
                      4948     ;
                      4949     ; Sets default programming parameters
                      4950     ;
                      4951     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4952     SET_DEFAULT_PARAMETERS: 
                      4953     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      5014     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      5075     IF MODE == 2	; Multi
1188    7880          5076     MOV R0 , # PGM_GOV_P_GAIN 
118A    7609          5077     MOV @ R0 , # 9 
118C    08            5078     INC R0 
118D    7609          5079     MOV @ R0 , # 9 
118F    08            5080     INC R0 
1190    7604          5081     MOV @ R0 , # 4 
1192    08            5082     INC R0 
1193    7601          5083     MOV @ R0 , # 1 
1195    08            5084     INC R0 
1196    7603          5085     MOV @ R0 , # 3 
1198    08            5086     INC R0 
1199    76FF          5087     MOV @ R0 , # 0XFF 
119B    08            5088     INC R0 
119C    7609          5089     MOV @ R0 , # 9 
119E    08            5090     INC R0 
119F    7601          5091     MOV @ R0 , # 1 
11A1    08            5092     INC R0 
11A2    7601          5093     MOV @ R0 , # 1 
11A4    08            5094     INC R0 
11A5    7601          5095     MOV @ R0 , # 1 
                      5096     
11A7    788C          5097     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
11A9    7600          5098     MOV @ R0 , # 0 
11AB    08            5099     INC R0 
11AC    76FF          5100     MOV @ R0 , # 0XFF 
11AE    08            5101     INC R0 
11AF    76FF          5102     MOV @ R0 , # 0XFF 
11B1    08            5103     INC R0 
11B2    7601          5104     MOV @ R0 , # 1 
11B4    08            5105     INC R0 
11B5    7605          5106     MOV @ R0 , # 5 
11B7    08            5107     INC R0 
11B8    76FF          5108     MOV @ R0 , # 0XFF 
11BA    08            5109     INC R0 
11BB    7603          5110     MOV @ R0 , # 3 
11BD    08            5111     INC R0 
11BE    7606          5112     MOV @ R0 , # 6 
11C0    08            5113     INC R0 
11C1    76FF          5114     MOV @ R0 , # 0XFF 
11C3    08            5115     INC R0 
11C4    7602          5116     MOV @ R0 , # 2 
11C6    08            5117     INC R0 
11C7    7603          5118     MOV @ R0 , # 3 
11C9    08            5119     INC R0 
11CA    76FA          5120     MOV @ R0 , # 250 
11CC    08            5121     INC R0 
11CD    7614          5122     MOV @ R0 , # 20 
11CF    08            5123     INC R0 
11D0    7614          5124     MOV @ R0 , # 20 
11D2    08            5125     INC R0 
11D3    7605          5126     MOV @ R0 , # 5 
11D5    08            5127     INC R0 
11D6    7601          5128     MOV @ R0 , # 1 
11D8    08            5129     INC R0 
11D9    7602          5130     MOV @ R0 , # 2 
11DB    08            5131     INC R0 
11DC    7600          5132     MOV @ R0 , # 0 
11DE    08            5133     INC R0 
11DF    767D          5134     MOV @ R0 , # 125 
                      5135     ENDIF
                      5136     
                      5137     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5138     ;
                      5139     ; 初始化变量 
                      5140     ; Skypup 2015.05.25
11E1    757400        5141     	MOV	PREV_RCP,	#0
11E4    757600        5142     	MOV	NHOLD_L,	#0
11E7    757700        5143     	MOV	NHOLD_H,	#0
11EA    757800        5144     MOV CSTATE , # 0 
                      5145     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
11ED    22            5146     	RET
                      5147     
                      5148     
                      5149     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5150     ;
                      5151     ; Decode parameters
                      5152     ;
                      5153     ; No assumptions
                      5154     ;
                      5155     ; Decodes programming parameters
                      5156     ;
                      5157     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5158     DECODE_PARAMETERS: 
                      5159     	; Load programmed damping force
11EE    7893          5160     MOV R0 , # PGM_DAMPING_FORCE 
11F0    E6            5161     MOV A , @ R0 
11F1    FF            5162     MOV R7 , A 
                      5163     	; Decode damping
11F2    756609        5164     	MOV	DAMPING_PERIOD, #9		; Set default
11F5    756701        5165     	MOV	DAMPING_ON, #1
11F8    C3            5166     	CLR	C
11F9    BF0206        5167     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5168     
11FC    756605        5169     	MOV	DAMPING_PERIOD, #5
11FF    756701        5170     	MOV	DAMPING_ON, #1
                      5171     
                      5172     DECODE_DAMPING_3: 
1202    C3            5173     	CLR	C
1203    BF0306        5174     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5175     
1206    756605        5176     	MOV	DAMPING_PERIOD, #5
1209    756702        5177     	MOV	DAMPING_ON, #2
                      5178     
                      5179     DECODE_DAMPING_4: 
120C    C3            5180     	CLR	C
120D    BF0406        5181     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5182     
1210    756605        5183     	MOV	DAMPING_PERIOD, #5
1213    756703        5184     	MOV	DAMPING_ON, #3
                      5185     
                      5186     DECODE_DAMPING_5: 
1216    C3            5187     	CLR	C
1217    BF0506        5188     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5189     
121A    756609        5190     	MOV	DAMPING_PERIOD, #9
121D    756707        5191     	MOV	DAMPING_ON, #7
                      5192     
                      5193     DECODE_DAMPING_6: 
1220    C3            5194     	CLR	C
1221    BF0606        5195     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5196     
1224    756600        5197     	MOV	DAMPING_PERIOD, #0
1227    756700        5198     	MOV	DAMPING_ON, #0
                      5199     
                      5200     DECODE_DAMPING_DONE: 
                      5201     	; Load programmed pwm frequency
122A    7887          5202     MOV R0 , # PGM_PWM_FREQ 
122C    E6            5203     MOV A , @ R0 
122D    FF            5204     MOV R7 , A 
                      5205     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5212     IF MODE >= 1	; Tail or multi
122E    C26C          5213     CLR FLAGS2 . 4 
1230    C3            5214     	CLR	C
1231    BF0302        5215     CJNE R7 , # 3 , ( $+5 ) 
1234    D26C          5216     SETB FLAGS2 . 4 
1236    C26B          5217     CLR FLAGS2 . 3 
1238    C3            5218     	CLR	C
1239    BF0402        5219     CJNE R7 , # 4 , ( $+5 ) 
123C    D26B          5220     SETB FLAGS2 . 3 
                      5221     ENDIF
123E    C26A          5222     CLR FLAGS2 . 2 
1240    7418          5223     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
1242    552D          5224     	ANL	A, FLAGS2					; Check if any damped mode is set
1244    6002          5225     	JZ	($+4)
1246    D26A          5226     SETB FLAGS2 . 2 
1248    C265          5227     CLR FLAGS1 . 5 
124A    6002          5228     	JZ	($+4)
124C    D265          5229     SETB FLAGS1 . 5 
124E    D266          5230     SETB FLAGS1 . 6 
1250    6002          5231     	JZ	($+4)
1252    C266          5232     CLR FLAGS1 . 6 
                      5233     	; Load programmed direction
1254    7888          5234     MOV R0 , # PGM_DIRECTION 
                      5235     IF MODE >= 1	; Tail or multi
1256    E6            5236     MOV A , @ R0 
1257    C3            5237     	CLR	C
1258    9403          5238     	SUBB	A, #3
125A    6008          5239     	JZ	DECODE_PARAMS_DIR_SET
                      5240     ENDIF
                      5241     
125C    C275          5242     CLR FLAGS3 . 5 
125E    E6            5243     MOV A , @ R0 
125F    30E102        5244     	JNB	ACC.1, ($+5)
1262    D275          5245     SETB FLAGS3 . 5 
                      5246     DECODE_PARAMS_DIR_SET: 
1264    C276          5247     CLR FLAGS3 . 6 
1266    7889          5248     MOV R0 , # PGM_INPUT_POL 
1268    E6            5249     MOV A , @ R0 
1269    30E102        5250     	JNB	ACC.1, ($+5)
126C    D276          5251     SETB FLAGS3 . 6 
126E    C3            5252     	CLR	C
126F    EF            5253     MOV A , R7 
1270    9402          5254     	SUBB	A, #2
1272    6008          5255     	JZ	DECODE_PWM_FREQ_LOW
                      5256     
1274    758E01        5257     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1277    D26D          5258     SETB FLAGS2 . 5 
1279    021281        5259     	JMP	DECODE_PWM_FREQ_END
                      5260     
                      5261     DECODE_PWM_FREQ_LOW: 
127C    758E00        5262     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
127F    C26D          5263     CLR FLAGS2 . 5 
                      5264     
                      5265     DECODE_PWM_FREQ_END: 
1281    22            5266     	RET
                      5267     
                      5268     
                      5269     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5270     ;
                      5271     ; Decode governor gain
                      5272     ;
                      5273     ; No assumptions
                      5274     ;
                      5275     ; Decodes governor gains
                      5276     ;
                      5277     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5278     DECODE_GOVERNOR_GAINS: 
                      5279     	; Decode governor gains
1282    7880          5280     MOV R0 , # PGM_GOV_P_GAIN 
1284    E6            5281     MOV A , @ R0 
1285    14            5282     	DEC	A	
1286    900080        5283     	MOV	DPTR, #GOV_GAIN_TABLE
1289    93            5284     	MOVC A, @A+DPTR	
128A    789F          5285     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
128C    F6            5286     MOV @ R0 , A 
128D    7881          5287     MOV R0 , # PGM_GOV_I_GAIN 
128F    E6            5288     MOV A , @ R0 
1290    14            5289     	DEC	A	
1291    900080        5290     	MOV	DPTR, #GOV_GAIN_TABLE
1294    93            5291     	MOVC A, @A+DPTR	
1295    78A0          5292     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1297    F6            5293     MOV @ R0 , A 
1298    310B          5294     	CALL	SWITCH_POWER_OFF		; Reset DPTR
129A    22            5295     	RET
                      5296     
                      5297     
                      5298     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5299     ;
                      5300     ; Decode throttle rate
                      5301     ;
                      5302     ; No assumptions
                      5303     ;
                      5304     ; Decodes throttle rate
                      5305     ;
                      5306     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5307     DECODE_THROTTLE_RATE: 
                      5308     	; Decode throttle rate
129B    789B          5309     MOV R0 , # PGM_THROTTLE_RATE 
129D    E6            5310     MOV A , @ R0 
129E    14            5311     	DEC	A	
129F    90008D        5312     	MOV	DPTR, #THROTTLE_RATE_TABLE
12A2    93            5313     	MOVC A, @A+DPTR	
12A3    78A1          5314     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
12A5    F6            5315     MOV @ R0 , A 
12A6    310B          5316     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12A8    22            5317     	RET
                      5318     
                      5319     
                      5320     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5321     ;
                      5322     ; Decode startup power
                      5323     ;
                      5324     ; No assumptions
                      5325     ;
                      5326     ; Decodes startup power
                      5327     ;
                      5328     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5329     DECODE_STARTUP_POWER: 
                      5330     	; Decode startup power
12A9    7886          5331     MOV R0 , # PGM_STARTUP_PWR 
12AB    E6            5332     MOV A , @ R0 
12AC    14            5333     	DEC	A	
12AD    90009A        5334     	MOV	DPTR, #STARTUP_POWER_TABLE
12B0    93            5335     	MOVC A, @A+DPTR	
12B1    78A2          5336     MOV R0 , # PGM_STARTUP_PWR_DECODED 
12B3    F6            5337     MOV @ R0 , A 
12B4    310B          5338     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12B6    22            5339     	RET
                      5340     
                      5341     
                      5342     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5343     ;
                      5344     ; Decode demag compensation
                      5345     ;
                      5346     ; No assumptions
                      5347     ;
                      5348     ; Decodes throttle rate
                      5349     ;
                      5350     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5351     DECODE_DEMAG_COMP: 
                      5352     	; Decode demag compensation
12B7    789C          5353     MOV R0 , # PGM_DEMAG_COMP 
12B9    E6            5354     MOV A , @ R0 
12BA    14            5355     	DEC	A	
12BB    9000A7        5356     	MOV	DPTR, #DEMAG_POWER_TABLE
12BE    93            5357     	MOVC A, @A+DPTR	
12BF    78A3          5358     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
12C1    F6            5359     MOV @ R0 , A 
12C2    310B          5360     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12C4    22            5361     	RET
                      5362     
                      5363     
                      5364     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5365     ;
                      5366     ; Set BEC voltage
                      5367     ;
                      5368     ; No assumptions
                      5369     ;
                      5370     ; Sets the BEC output voltage low or high
                      5371     ;
                      5372     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5373     SET_BEC_VOLTAGE: 
                      5374     	; Set bec voltage
                      5375     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
12C5    22            5385     	RET
                      5386     
                      5387     
                      5388     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5389     ;
                      5390     ; Find throttle gain
                      5391     ;
                      5392     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5393     ;
                      5394     ; Finds throttle gain from throttle calibration values
                      5395     ;
                      5396     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5397     FIND_THROTTLE_GAIN: 
                      5398     	; Load programmed minimum and maximum throttle
12C6    7896          5399     MOV R0 , # PGM_PPM_MIN_THROTTLE 
12C8    E6            5400     MOV A , @ R0 
12C9    FA            5401     MOV R2 , A 
12CA    7897          5402     MOV R0 , # PGM_PPM_MAX_THROTTLE 
12CC    E6            5403     MOV A , @ R0 
12CD    FB            5404     MOV R3 , A 
                      5405     	; Check if full range is chosen
12CE    307704        5406     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5407     
12D1    7A00          5408     MOV R2 , # 0 
12D3    7BFF          5409     MOV R3 , # 255 
                      5410     
                      5411     FIND_THROTTLE_GAIN_CALCULATE: 
                      5412     	; Calculate difference
12D5    C3            5413     	CLR	C
12D6    EB            5414     MOV A , R3 
12D7    9A            5415     SUBB A , R2 
12D8    FC            5416     MOV R4 , A 
                      5417     	; Check that difference is minimum 130
12D9    C3            5418     	CLR	C
12DA    9482          5419     	SUBB	A, #130
12DC    5002          5420     	JNC	($+4)
                      5421     
12DE    7C82          5422     MOV R4 , # 130 
                      5423     
                      5424     	; Find gain
12E0    756E00        5425     	MOV	PPM_THROTTLE_GAIN, #0
                      5426     TEST_THROTTLE_GAIN: 
12E3    056E          5427     	INC	PPM_THROTTLE_GAIN
12E5    EC            5428     MOV A , R4 
12E6    856EF0        5429     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
12E9    A4            5430     	MUL	AB
12EA    C3            5431     	CLR	C
12EB    E5F0          5432     	MOV	A, B
12ED    9480          5433     	SUBB	A, #128
12EF    40F2          5434     	JC	TEST_THROTTLE_GAIN
12F1    22            5435     	RET
                      5436     
                      5437     
                      5438     
                      5439     
                      5440     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5441     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5442     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5443     ;
                      5444     ; Main program start
                      5445     ;
                      5446     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5447     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5448     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5449     
                      5450     RESET: 
                      5451     	; Check flash lock byte
12F2    E5EF          5452     	MOV	A, RSTSRC			
12F4    20E603        5453     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5454     
12F7    752000        5455     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5456     
12FA    0520          5457     	INC	BIT_ACCESS
12FC    903DFF        5458     MOV DPTR , # 15871 
12FF    E520          5459     	MOV	A, BIT_ACCESS
1301    14            5460     	DEC	A
1302    6006          5461     	JZ	LOCK_BYTE_TEST
                      5462     
1304    901FFF        5463     MOV DPTR , # 8191 
1307    14            5464     	DEC	A
1308    6000          5465     	JZ	LOCK_BYTE_TEST
                      5466     
                      5467     LOCK_BYTE_TEST: 
130A    93            5468     	MOVC A, @A+DPTR		; Read lock byte
130B    04            5469     	INC	A				
130C    6003          5470     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5471     
                      5472     IF ONE_S_CAPABLE == 0		
130E    75EF12        5473     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5474     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5477     
                      5478     LOCK_BYTE_OK: 
                      5479     	; Select register bank 0 for main program routines
1311    C2D3          5480     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5481     	; Disable the WDT.
1313    53D9BF        5482     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5483     	; Initialize stack
1316    7581C0        5484     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5485     	; Initialize VDD monitor
1319    43FF80        5486     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
131C    120860        5487     	CALL	WAIT1MS			; Wait at least 100us
                      5488     IF ONE_S_CAPABLE == 0		
131F    75EF02        5489     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5490     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5493     	; Set clock frequency
1322    43B203        5494     	ORL	OSCICN, #03H		; Set clock divider to 1
1325    E5B3          5495     	MOV	A, OSCICL				
1327    2404          5496     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1329    4002          5497     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5498     
132B    F5B3          5499     	MOV	OSCICL, A
                      5500     
                      5501     RESET_CAL_DONE: 
                      5502     	; Switch power off
132D    310B          5503     	CALL	SWITCH_POWER_OFF
                      5504     	; Ports initialization
132F    758038        5505     MOV P0 , # 56 
1332    75A4C7        5506     MOV P0MDOUT , # 199 
1335    75F1FF        5507     MOV P0MDIN , # 255 
1338    75D4DF        5508     MOV P0SKIP , # -33 
133B    7590FF        5509     MOV P1 , # 255 
133E    75A500        5510     MOV P1MDOUT , # 0 
1341    75F200        5511     MOV P1MDIN , # 0 
1344    75D500        5512     MOV P1SKIP , # 0 
                      5513     IF PORT3_EXIST == 1
1347    75A0FF        5514     MOV P2 , # 255 
                      5515     ENDIF
134A    75A600        5516     MOV P2MDOUT , # 0 
                      5517     IF PORT3_EXIST == 1
134D    75F300        5518     MOV P2MDIN , # 0 
1350    75D600        5519     MOV P2SKIP , # 0 
1353    75B0E4        5520     MOV P3 , # -28 
1356    75A71B        5521     MOV P3MDOUT , # 27 
1359    75F4FF        5522     MOV P3MDIN , # 255 
                      5523     ENDIF
                      5524     	; Initialize the XBAR and related functionality
                      5525     	INITIALIZE_XBAR		
135C    75E241        5525+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5526     	; Clear RAM
135F    E4            5527     	CLR	A				; Clear accumulator
1360    F8            5528     MOV R0 , A 
                      5529     CLEAR_RAM: 	
1361    F6            5530     MOV @ R0 , A 
1362    D8FD          5531     DJNZ R0 , CLEAR_RAM 
                      5532     	; Set default programmed parameters
1364    3188          5533     	CALL	SET_DEFAULT_PARAMETERS
                      5534     	; Decode parameters
1366    31EE          5535     	CALL	DECODE_PARAMETERS
                      5536     	; Decode governor gains
1368    5182          5537     	CALL	DECODE_GOVERNOR_GAINS
                      5538     	; Decode throttle rate
136A    519B          5539     	CALL	DECODE_THROTTLE_RATE
                      5540     	; Decode startup power
136C    51A9          5541     	CALL	DECODE_STARTUP_POWER
                      5542     	; Decode demag compensation
136E    51B7          5543     	CALL	DECODE_DEMAG_COMP
                      5544     	; Set BEC voltage
1370    51C5          5545     	CALL	SET_BEC_VOLTAGE
                      5546     	; Find throttle gain from stored min and max settings
1372    51C6          5547     	CALL	FIND_THROTTLE_GAIN
                      5548     	; Set beep strength
1374    7898          5549     MOV R0 , # PGM_BEEP_STRENGTH 
1376    866F          5550     MOV BEEP_STRENGTH , @ R0 
                      5551     	; Switch power off
1378    310B          5552     	CALL	SWITCH_POWER_OFF
                      5553     	; Timer control
137A    758850        5554     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5555     	; Timer mode
137D    758902        5556     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5557     	; Timer2: clk/12 for 128us and 32ms interrupts
1380    75C824        5558     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5559     	; Timer3: clk/12 for commutation timing
1383    759104        5560     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5561     	; PCA
1386    75D840        5562     	MOV	PCA0CN, #40H		; PCA enabled
                      5563     	; Initializing beep
1389    C2AF          5564     	CLR	EA				; Disable interrupts explicitly
138B    120879        5565     	CALL WAIT200MS	
138E    120890        5566     	CALL BEEP_F1
1391    12086A        5567     	CALL WAIT10MS
1394    120897        5568     	CALL BEEP_F2
1397    12086A        5569     	CALL WAIT10MS
139A    12089E        5570     	CALL BEEP_F3
139D    12086A        5571     	CALL WAIT10MS
13A0    1208A5        5572     	CALL BEEP_F4
13A3    12086A        5573     	CALL WAIT10MS
                      5574     
                      5575     	; Wait for receiver to initialize
13A6    120889        5576     	CALL	WAIT1S
13A9    120879        5577     	CALL	WAIT200MS
13AC    120879        5578     	CALL	WAIT200MS
13AF    120874        5579     	CALL	WAIT100MS
                      5580     
                      5581     
                      5582     	; Enable interrupts
13B2    75A822        5583     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
13B5    75B802        5584     	MOV	IP, #02H			; High priority to timer0 interrupts
13B8    75E690        5585     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5586     	; Initialize comparator
13BB    759B80        5587     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
13BE    759D03        5588     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5589     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5593     	; Initialize ADC
                      5594     	INITIALIZE_ADC			; Initialize ADC operation
13C1    75D10E        5594+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
13C4    75BC58        5594+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
13C7    75BB06        5594+1   MOV AMX0P , # 6  ; SELECT POSITIVE INPUT
13CA    75BA1F        5594+1   MOV AMX0N , # 1FH  ; SELECT NEGATIVE INPUT AS GROUND
13CD    75E880        5594+1   MOV ADC0CN , # 80H  ; ADC ENABLED
13D0    120860        5595     	CALL	WAIT1MS
13D3    D2AF          5596     	SETB	EA				; Enable all interrupts
                      5597     
                      5598     	; Measure number of lipo cells
13D5    120B48        5599     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5600     	; Initialize rc pulse
                      5601     	RCP_INT_ENABLE		 			; Enable interrupt
13D8    43DA01        5601+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5602     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
13DB    C2D8          5602+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
13DD    C269          5603     CLR FLAGS2 . 1 
13DF    120879        5604     	CALL WAIT200MS
                      5605     	; Set initial arm variable
13E2    753001        5606     	MOV	INITIAL_ARM, #1
13E5    757301        5607     	MOV	FLAG_BEFORE_ARM, #1
                      5608     
                      5609     	; Measure PWM frequency
                      5610     MEASURE_PWM_FREQ_INIT: 	
13E8    D259          5611     SETB FLAGS0 . 1 
                      5612     MEASURE_PWM_FREQ_START: 	
13EA    7A05          5613     MOV R2 , # 5 
                      5614     MEASURE_PWM_FREQ_LOOP: 	
                      5615     	; Check if period diff was accepted
13EC    E558          5616     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
13EE    7002          5617     	JNZ	($+4)
                      5618     
13F0    7A05          5619     MOV R2 , # 5 
                      5620     
13F2    120865        5621     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
13F5    E559          5622     	MOV	A, NEW_RCP					; Load value
13F7    C3            5623     	CLR	C
13F8    9402          5624     SUBB A , # 2 
13FA    40EE          5625     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5626     
13FC    E52E          5627     	MOV	A, FLAGS3						; Check pwm frequency flags
13FE    541F          5628     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1400    855B5A        5629     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1403    F55B          5630     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1405    B55AE2        5631     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5632     
1408    DAE2          5633     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5634     
                      5635     	; Clear measure pwm frequency flag
140A    C259          5636     CLR FLAGS0 . 1 
                      5637     	; Set up RC pulse interrupts after pwm frequency measurement
                      5638     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
140C    53DACF        5638+1   ANL PCA0CPM0 , # 0CFH 
140F    207603        5638+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1412    43DA20        5638+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1415    307603        5638+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1418    43DA10        5638+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5639     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
141B    C2D8          5639+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
141D    C269          5640     CLR FLAGS2 . 1 
141F    120874        5641     	CALL WAIT100MS						; Wait for new RC pulse
                      5642     
                      5643     	; Validate RC pulse
                      5644     VALIDATE_RCP_START: 	
1422    120865        5645     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1425    7802          5646     MOV R0 , # 2 
1427    741F          5647     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1429    552E          5648     	ANL	A, FLAGS3						; Check pwm frequency flags
142B    7002          5649     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5650     
142D    7800          5651     MOV R0 , # 0 
                      5652     
142F    C3            5653     	CLR	C
1430    E559          5654     	MOV	A, NEW_RCP					; Load value
1432    98            5655     SUBB A , R0 
1433    40ED          5656     	JC	VALIDATE_RCP_START				; No - start over
                      5657     
                      5658     	; Beep arm sequence start signal
1435    C2AF          5659     	CLR 	EA							; Disable all interrupts
1437    120890        5660     	CALL BEEP_F1
143A    12086A        5661     	CALL WAIT10MS
143D    120890        5662     	CALL BEEP_F1
1440    12086A        5663     	CALL WAIT10MS
1443    120897        5664     	CALL BEEP_F2
1446    12086A        5665     	CALL WAIT10MS
1449    120897        5666     	CALL BEEP_F2
144C    12086A        5667     	CALL WAIT10MS
144F    D2AF          5668     	SETB	EA							; Enable all interrupts
1451    120879        5669     	CALL WAIT200MS	
                      5670     
1454    757300        5671     	MOV	FLAG_BEFORE_ARM, #0		; 为了让定制的程序输出最低油门. Skypup 2015.05.26
                      5672     
                      5673     	; Arming sequence start
1457    754800        5674     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5675     ARMING_START: 
145A    C3            5676     	CLR	C
145B    E559          5677     	MOV	A, NEW_RCP			; Load new RC pulse value
145D    9548          5678     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
145F    4003          5679     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5680     
1461    855948        5681     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5682     
                      5683     ARM_TARGET_UPDATED: 
1464    120874        5684     	CALL WAIT100MS				; Wait for new throttle value
1467    C3            5685     	CLR	C
1468    E559          5686     	MOV	A, NEW_RCP			; Load new RC pulse value
146A    9401          5687     SUBB A , # 1 
146C    4002          5688     	JC	ARM_END_BEEP			; Yes - proceed
                      5689     
146E    80EA          5690     	JMP	ARMING_START			; No - start over
                      5691     
                      5692     ARM_END_BEEP: 
                      5693     	; Beep arm sequence end signal
1470    C2AF          5694     	CLR 	EA					; Disable all interrupts
1472    1208A5        5695     	CALL BEEP_F4
1475    12086A        5696     	CALL WAIT10MS
1478    1208A5        5697     	CALL BEEP_F4
147B    12086A        5698     	CALL WAIT10MS
147E    12089E        5699     	CALL BEEP_F3
1481    12086A        5700     	CALL WAIT10MS
1484    12089E        5701     	CALL BEEP_F3
1487    12086A        5702     	CALL WAIT10MS
148A    D2AF          5703     	SETB	EA					; Enable all interrupts
148C    120879        5704     	CALL WAIT200MS
                      5705     
                      5706     	; Clear initial arm variable
148F    753000        5707     	MOV	INITIAL_ARM, #0
                      5708     
                      5709     	; Armed and waiting for power on
                      5710     WAIT_FOR_POWER_ON: 
1492    E4            5711     	CLR	A
1493    F531          5712     	MOV	POWER_ON_WAIT_CNT_L, A	; 清零
1495    F532          5713     	MOV	POWER_ON_WAIT_CNT_H, A	; 清零
                      5714     WAIT_FOR_POWER_ON_LOOP: 
1497    0531          5715     	INC	POWER_ON_WAIT_CNT_L		; 低位 ++
1499    E531          5716     	MOV	A, POWER_ON_WAIT_CNT_L
149B    F4            5717     	CPL	A					; 取反
149C    7039          5718     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Power_On_Wait_Cnt_L 不是 0xFF 则跳转, 进入下一个循环, Counter wrapping (about 1 sec)?
                      5719     
149E    0532          5720     	INC	POWER_ON_WAIT_CNT_H		; Power_On_Wait_Cnt_L == 0xFF, 高位 ++
14A0    789A          5721     MOV R0 , # PGM_BEACON_DELAY 
14A2    E6            5722     MOV A , @ R0 
14A3    7819          5723     MOV R0 , # 25 
14A5    14            5724     	DEC	A
14A6    6012          5725     	JZ	BEEP_DELAY_SET
                      5726     
14A8    7832          5727     MOV R0 , # 50 
14AA    14            5728     	DEC	A
14AB    600D          5729     	JZ	BEEP_DELAY_SET
                      5730     
14AD    787D          5731     MOV R0 , # 125 
14AF    14            5732     	DEC	A
14B0    6008          5733     	JZ	BEEP_DELAY_SET
                      5734     
14B2    78FA          5735     MOV R0 , # 250 
14B4    14            5736     	DEC	A
14B5    6003          5737     	JZ	BEEP_DELAY_SET
                      5738     
14B7    753200        5739     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5740     
                      5741     BEEP_DELAY_SET: 
14BA    C3            5742     	CLR	C
14BB    E532          5743     	MOV	A, POWER_ON_WAIT_CNT_H
14BD    98            5744     SUBB A , R0 
14BE    4017          5745     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5746     
14C0    1532          5747     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14C2    7531B4        5748     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14C5    7899          5749     MOV R0 , # PGM_BEACON_STRENGTH 
14C7    866F          5750     MOV BEEP_STRENGTH , @ R0 
14C9    C2AF          5751     	CLR 	EA					; Disable all interrupts
14CB    1208A5        5752     	CALL BEEP_F4				; Signal that there is no signal
14CE    D2AF          5753     	SETB	EA					; Enable all interrupts
14D0    7898          5754     MOV R0 , # PGM_BEEP_STRENGTH 
14D2    866F          5755     MOV BEEP_STRENGTH , @ R0 
14D4    120874        5756     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5757     
                      5758     WAIT_FOR_POWER_ON_NO_BEEP: 
14D7    12086A        5759     	CALL WAIT10MS
14DA    E528          5760     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14DC    7008          5761     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5762     
14DE    741F          5763     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
14E0    552E          5764     	ANL	A, FLAGS3						; Check pwm frequency flags
14E2    7002          5765     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5766     
14E4    61E8          5767     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5768     
                      5769     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14E6    C3            5770     	CLR	C
14E7    E559          5771     	MOV	A, NEW_RCP			; Load new RC pulse value
14E9    9406          5772     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
14EB    40AA          5773     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5774     
                      5775     IF MODE >= 1	; Tail or multi
14ED    7888          5776     MOV R0 , # PGM_DIRECTION 
14EF    E6            5777     MOV A , @ R0 
14F0    C3            5778     	CLR	C
14F1    9403          5779     	SUBB	A, #3
14F3    6003          5780     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5781     ENDIF
                      5782     
14F5    120874        5783     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5784     
14F8    E528          5785     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14FA    7003          5786     	JNZ	($+5)				; If it is not zero - proceed
                      5787     
14FC    0213E8        5788     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5789     
                      5790     
                      5791     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5792     ;
                      5793     ; Start entry point
                      5794     ;
                      5795     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5796     INIT_START: 
14FF    C2AF          5797     	CLR	EA
1501    310B          5798     	CALL SWITCH_POWER_OFF
1503    E4            5799     	CLR	A
1504    F522          5800     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1506    F523          5801     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1508    F524          5802     	MOV	CURRENT_PWM, A			; Set current pwm to zero
150A    F525          5803     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
150C    D2AF          5804     	SETB	EA
150E    7885          5805     MOV R0 , # PGM_MOTOR_IDLE 
1510    8661          5806     MOV PWM_MOTOR_IDLE , @ R0 
1512    F540          5807     	MOV	GOV_TARGET_L, A		; Set target to zero
1514    F541          5808     	MOV	GOV_TARGET_H, A
1516    F542          5809     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1518    F543          5810     	MOV	GOV_INTEGRAL_H, A
151A    F544          5811     	MOV	GOV_INTEGRAL_X, A
151C    F56C          5812     	MOV	ADC_CONVERSION_CNT, A
151E    F549          5813     	MOV	GOV_ACTIVE, A
1520    F52B          5814     	MOV	FLAGS0, A				; Clear flags0
1522    F52C          5815     	MOV	FLAGS1, A				; Clear flags1
1524    F539          5816     	MOV	DEMAG_CONSECUTIVE_CNT, A
1526    120CC5        5817     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5818     	;**** **** **** **** ****
                      5819     	; Motor start beginning
                      5820     	;**** **** **** **** **** 
1529    756C08        5821     MOV ADC_CONVERSION_CNT , # 8 
                      5822     	SET_ADC_IP_TEMP
152C    75BB1E        5822+1   MOV AMX0P , # 1EH  ; SELECT TEMP SENSOR INPUT
152F    120860        5823     	CALL WAIT1MS
1532    120BE2        5824     	CALL START_ADC_CONVERSION
                      5825     READ_INITIAL_TEMP: 
                      5826     	GET_ADC_STATUS 
1535    E5E8          5826+1   MOV A , ADC0CN 
1537    20ECFB        5827     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5828     	READ_ADC_RESULT						; Read initial temperature
153A    A8BD          5828+1   MOV R0 , ADC0L 
153C    A9BE          5828+1   MOV R1 , ADC0H 
153E    E9            5829     MOV A , R1 
153F    7001          5830     	JNZ	($+3)							; Is reading below 256?
                      5831     
1541    F8            5832     MOV R0 , A 
                      5833     
1542    886D          5834     MOV CURRENT_AVERAGE_TEMP , R0 
1544    120BE6        5835     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1547    756C08        5836     MOV ADC_CONVERSION_CNT , # 8 
                      5837     	SET_ADC_IP_TEMP
154A    75BB1E        5837+1   MOV AMX0P , # 1EH  ; SELECT TEMP SENSOR INPUT
                      5838     
                      5839     	; Go to the desired startup mode
154D    7895          5840     MOV R0 , # PGM_STARTUP_METHOD 
154F    E6            5841     MOV A , @ R0 
1550    30E003        5842     	JNB	ACC.0, DIRECT_METHOD_START
                      5843     
1553    021596        5844     	JMP	STEPPER_METHOD_START
                      5845     
                      5846     DIRECT_METHOD_START: 
                      5847     	; Set up start operating conditions
1556    7887          5848     MOV R0 , # PGM_PWM_FREQ 
1558    E6            5849     MOV A , @ R0 
1559    FE            5850     MOV R6 , A 
155A    7602          5851     MOV @ R0 , # 2 
155C    31EE          5852     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
155E    7887          5853     MOV R0 , # PGM_PWM_FREQ 
1560    EE            5854     MOV A , R6 
1561    F6            5855     MOV @ R0 , A 
                      5856     	; Set max allowed power
1562    D261          5857     SETB FLAGS1 . 1 
1564    C2AF          5858     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1566    755EFF        5859     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1569    120C95        5860     	CALL SET_STARTUP_PWM
156C    85225E        5861     	MOV	PWM_LIMIT, REQUESTED_PWM
156F    85225F        5862     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1572    D2AF          5863     	SETB	EA
1574    C261          5864     CLR FLAGS1 . 1 
1576    752501        5865     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
1579    855D64        5866     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
157C    756501        5867     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5868     	; Begin startup sequence
157F    D260          5869     SETB FLAGS1 . 0 
1581    D263          5870     SETB FLAGS1 . 3 
1583    753800        5871     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1586    1165          5872     	CALL COMM5COMM6				; Initialize commutation
1588    11A0          5873     	CALL COMM6COMM1				
158A    120D3F        5874     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
158D    120CC5        5875     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
1590    120DC2        5876     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
1593    0216B9        5877     	JMP	RUN1
                      5878     
                      5879     
                      5880     STEPPER_METHOD_START: 
                      5881     	; Set up start operating conditions
1596    7887          5882     MOV R0 , # PGM_PWM_FREQ 
1598    E6            5883     MOV A , @ R0 
1599    FE            5884     MOV R6 , A 
159A    7603          5885     MOV @ R0 , # 3 
159C    7893          5886     MOV R0 , # PGM_DAMPING_FORCE 
159E    E6            5887     MOV A , @ R0 
159F    FD            5888     MOV R5 , A 
15A0    7605          5889     MOV @ R0 , # 5 
15A2    31EE          5890     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15A4    7887          5891     MOV R0 , # PGM_PWM_FREQ 
15A6    EE            5892     MOV A , R6 
15A7    F6            5893     MOV @ R0 , A 
15A8    7893          5894     MOV R0 , # PGM_DAMPING_FORCE 
15AA    ED            5895     MOV A , R5 
15AB    F6            5896     MOV @ R0 , A 
                      5897     	; Begin startup sequence
15AC    D260          5898     SETB FLAGS1 . 0 
15AE    D261          5899     SETB FLAGS1 . 1 
15B0    D265          5900     SETB FLAGS1 . 5 
15B2    1165          5901     	CALL COMM5COMM6			; Initialize commutation
15B4    11A0          5902     	CALL COMM6COMM1			
15B6    755EFF        5903     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15B9    120C95        5904     	CALL SET_STARTUP_PWM
15BC    120860        5905     	CALL WAIT1MS
15BF    120F6D        5906     	CALL COMM1COMM2
15C2    120860        5907     	CALL WAIT1MS
15C5    120860        5908     	CALL WAIT1MS
15C8    120F9F        5909     	CALL COMM2COMM3
15CB    120865        5910     	CALL WAIT3MS			
15CE    120FE9        5911     	CALL COMM3COMM4
15D1    120865        5912     	CALL WAIT3MS			
15D4    120865        5913     	CALL WAIT3MS			
15D7    1124          5914     	CALL COMM4COMM5
15D9    12086A        5915     	CALL WAIT10MS				; Settle rotor
15DC    1165          5916     	CALL COMM5COMM6
15DE    120865        5917     	CALL WAIT3MS				
15E1    120860        5918     	CALL WAIT1MS			
15E4    C261          5919     CLR FLAGS1 . 1 
15E6    D262          5920     SETB FLAGS1 . 2 
                      5921     
                      5922     	;**** **** **** **** ****
                      5923     	; Stepper phase beginning
                      5924     	;**** **** **** **** **** 
                      5925     STEPPER_ROT_BEG: 
15E8    120BE2        5926     	CALL START_ADC_CONVERSION
15EB    120BE6        5927     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15EE    120C95        5928     	CALL SET_STARTUP_PWM
15F1    756C08        5929     MOV ADC_CONVERSION_CNT , # 8 
                      5930     	SET_ADC_IP_TEMP
15F4    75BB1E        5930+1   MOV AMX0P , # 1EH  ; SELECT TEMP SENSOR INPUT
                      5931     
15F7    11A0          5932     	CALL COMM6COMM1				; Commutate
15F9    120D38        5933     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
15FC    120DC2        5934     	CALL CALC_NEW_WAIT_TIMES
15FF    311D          5935     	CALL DECREMENT_STEPPER_STEP
1601    3182          5936     	CALL STEPPER_TIMER_WAIT
                      5937     
1603    120F6D        5938     	CALL COMM1COMM2			
1606    120D38        5939     	CALL CALC_NEXT_COMM_TIMING_START	
1609    120DC2        5940     	CALL CALC_NEW_WAIT_TIMES
160C    311D          5941     	CALL DECREMENT_STEPPER_STEP
160E    3182          5942     	CALL STEPPER_TIMER_WAIT
                      5943     
1610    120F9F        5944     	CALL COMM2COMM3			
1613    120D38        5945     	CALL CALC_NEXT_COMM_TIMING_START	
1616    120DC2        5946     	CALL CALC_NEW_WAIT_TIMES
1619    311D          5947     	CALL DECREMENT_STEPPER_STEP
161B    3182          5948     	CALL STEPPER_TIMER_WAIT
                      5949     
161D    120FE9        5950     	CALL COMM3COMM4			
1620    120D38        5951     	CALL CALC_NEXT_COMM_TIMING_START	
1623    120DC2        5952     	CALL CALC_NEW_WAIT_TIMES
1626    311D          5953     	CALL DECREMENT_STEPPER_STEP
1628    3182          5954     	CALL STEPPER_TIMER_WAIT
                      5955     
162A    1124          5956     	CALL COMM4COMM5			
162C    120D38        5957     	CALL CALC_NEXT_COMM_TIMING_START	
162F    120DC2        5958     	CALL CALC_NEW_WAIT_TIMES
1632    311D          5959     	CALL DECREMENT_STEPPER_STEP
1634    3182          5960     	CALL STEPPER_TIMER_WAIT
                      5961     
1636    1165          5962     	CALL COMM5COMM6			
1638    120D38        5963     	CALL CALC_NEXT_COMM_TIMING_START	
163B    120DC2        5964     	CALL CALC_NEW_WAIT_TIMES
163E    311D          5965     	CALL DECREMENT_STEPPER_STEP	
                      5966     	; Check stepper step versus end criteria
1640    C3            5967     	CLR	C
1641    E550          5968     	MOV	A, WT_STEPPER_STEP_L
1643    9535          5969     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1645    E551          5970     	MOV	A, WT_STEPPER_STEP_H
1647    9536          5971     	SUBB	A, STEPPER_STEP_END_H
1649    400C          5972     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5973     
                      5974     	; Wait for step
164B    3182          5975     	CALL STEPPER_TIMER_WAIT
164D    C3            5976     	CLR	C
164E    E559          5977     	MOV	A, NEW_RCP				; Load new pulse value
1650    9401          5978     SUBB A , # 1 
1652    5094          5979     	JNC	STEPPER_ROT_BEG
                      5980     
1654    0217E8        5981     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5982     
                      5983     STEPPER_ROT_EXIT: 
                      5984     	; Wait for step
1657    3182          5985     	CALL STEPPER_TIMER_WAIT
                      5986     	; Clear stepper phase
1659    C262          5987     CLR FLAGS1 . 2 
                      5988     	; Set dondamped low pwm frequency
165B    7887          5989     MOV R0 , # PGM_PWM_FREQ 
165D    E6            5990     MOV A , @ R0 
165E    FE            5991     MOV R6 , A 
165F    7602          5992     MOV @ R0 , # 2 
1661    31EE          5993     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1663    7887          5994     MOV R0 , # PGM_PWM_FREQ 
1665    EE            5995     MOV A , R6 
1666    F6            5996     MOV @ R0 , A 
                      5997     	; Set spoolup power variables (power is now controlled from RCP)
1667    85225E        5998     	MOV	PWM_LIMIT, REQUESTED_PWM
166A    85605F        5999     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
166D    856025        6000     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
1670    855D64        6001     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1673    756501        6002     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6003     	; Set direct startup phase to acquire sync quickly
1676    D263          6004     SETB FLAGS1 . 3 
1678    753800        6005     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
167B    C2AF          6006     	CLR	EA						; Disable interrupts
                      6007     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
167D    207502        6007+1   JB FLAGS3 . 5 , ( $+5 ) 
1680    C282          6007+1   CLR P0 . 2 
1682    307502        6007+1   JNB FLAGS3 . 5 , ( $+5 ) 
1685    C280          6007+1   CLR P0 . 0 
                      6008     	CPFET_OFF						; Cp off
1687    207502        6008+1   JB FLAGS3 . 5 , ( $+5 ) 
168A    C280          6008+1   CLR P0 . 0 
168C    307502        6008+1   JNB FLAGS3 . 5 , ( $+5 ) 
168F    C282          6008+1   CLR P0 . 2 
1691    742D          6009     	MOV	A, #45					; 8us delay for pfets to go off
1693    D5E0FD        6010     	DJNZ	ACC, $
1696    D2AF          6011     	SETB	EA						; Enable interrupts
1698    11A0          6012     	CALL COMM6COMM1				
169A    120D3F        6013     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
169D    120DAE        6014     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16A0    120DC2        6015     	CALL CALC_NEW_WAIT_TIMES
16A3    120E53        6016     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16A6    756C00        6017     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      6018     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16A9    75BB06        6018+1   MOV AMX0P , # 6  ; SELECT POSITIVE INPUT
16AC    0216B9        6019     	JMP	RUN1
                      6020     
                      6021     
                      6022     
                      6023     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6024     ;
                      6025     ; Run entry point
                      6026     ;
                      6027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6028     DAMPED_TRANSITION: 
                      6029     	; Transition from nondamped to damped if applicable
16AF    31EE          6030     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16B1    11A0          6031     	CALL	COMM6COMM1
16B3    756C00        6032     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      6033     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16B6    75BB06        6033+1   MOV AMX0P , # 6  ; SELECT POSITIVE INPUT
                      6034     
                      6035     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      6036     ; Out_cA changes from low to high
                      6037     RUN1: 
16B9    120E75        6038     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16BC    120EFA        6039     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16BF    120F25        6040     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16C2    12098F        6041     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16C5    120F39        6042     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16C8    120F6D        6043     	CALL COMM1COMM2			; Commutate
16CB    120D3F        6044     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
16CE    120DAE        6045     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
16D1    120DC2        6046     	CALL CALC_NEW_WAIT_TIMES
16D4    120E53        6047     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      6048     
                      6049     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      6050     ; Out_cB changes from high to low
                      6051     RUN2: 
16D7    120E6C        6052     	CALL WAIT_FOR_COMP_OUT_LOW
16DA    120EFA        6053     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16DD    120F25        6054     	CALL SETUP_COMM_WAIT	
16E0    1209EC        6055     	CALL CALC_GOVERNOR_PROP_ERROR
16E3    120F39        6056     	CALL WAIT_FOR_COMM
16E6    120F9F        6057     	CALL COMM2COMM3
16E9    120D3F        6058     	CALL CALC_NEXT_COMM_TIMING
16EC    120DAE        6059     	CALL WAIT_ADVANCE_TIMING
16EF    120DC2        6060     	CALL CALC_NEW_WAIT_TIMES
16F2    120E53        6061     	CALL WAIT_BEFORE_ZC_SCAN	
                      6062     
                      6063     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6064     ; Out_cC changes from low to high
                      6065     RUN3: 
16F5    120E75        6066     	CALL WAIT_FOR_COMP_OUT_HIGH
16F8    120EFA        6067     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16FB    120F25        6068     	CALL SETUP_COMM_WAIT	
16FE    120A25        6069     	CALL CALC_GOVERNOR_INT_ERROR
1701    120F39        6070     	CALL WAIT_FOR_COMM
1704    120FE9        6071     	CALL COMM3COMM4
1707    120D3F        6072     	CALL CALC_NEXT_COMM_TIMING
170A    120DAE        6073     	CALL WAIT_ADVANCE_TIMING
170D    120DC2        6074     	CALL CALC_NEW_WAIT_TIMES
1710    120E53        6075     	CALL WAIT_BEFORE_ZC_SCAN	
                      6076     
                      6077     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6078     ; Out_cA changes from high to low
                      6079     RUN4: 
1713    120E6C        6080     	CALL WAIT_FOR_COMP_OUT_LOW
1716    120EFA        6081     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1719    120F25        6082     	CALL SETUP_COMM_WAIT	
171C    120A82        6083     	CALL CALC_GOVERNOR_PROP_CORRECTION
171F    120F39        6084     	CALL WAIT_FOR_COMM
1722    1124          6085     	CALL COMM4COMM5
1724    120D3F        6086     	CALL CALC_NEXT_COMM_TIMING
1727    120DAE        6087     	CALL WAIT_ADVANCE_TIMING
172A    120DC2        6088     	CALL CALC_NEW_WAIT_TIMES
172D    120E53        6089     	CALL WAIT_BEFORE_ZC_SCAN	
                      6090     
                      6091     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6092     ; Out_cB changes from low to high
                      6093     RUN5: 
1730    120E75        6094     	CALL WAIT_FOR_COMP_OUT_HIGH
1733    120EFA        6095     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1736    120F25        6096     	CALL SETUP_COMM_WAIT	
1739    120AE6        6097     	CALL CALC_GOVERNOR_INT_CORRECTION
173C    120F39        6098     	CALL WAIT_FOR_COMM
173F    1165          6099     	CALL COMM5COMM6
1741    120D3F        6100     	CALL CALC_NEXT_COMM_TIMING
1744    120DAE        6101     	CALL WAIT_ADVANCE_TIMING
1747    120DC2        6102     	CALL CALC_NEW_WAIT_TIMES
174A    120E53        6103     	CALL WAIT_BEFORE_ZC_SCAN	
                      6104     
                      6105     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6106     ; Out_cC changes from high to low
                      6107     RUN6: 
174D    120E6C        6108     	CALL WAIT_FOR_COMP_OUT_LOW
1750    120BE2        6109     	CALL START_ADC_CONVERSION
1753    120EFA        6110     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1756    120F25        6111     	CALL SETUP_COMM_WAIT	
1759    120BE6        6112     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
175C    120F39        6113     	CALL WAIT_FOR_COMM
175F    11A0          6114     	CALL COMM6COMM1
1761    120D3F        6115     	CALL CALC_NEXT_COMM_TIMING
1764    120DAE        6116     	CALL WAIT_ADVANCE_TIMING
1767    120DC2        6117     	CALL CALC_NEW_WAIT_TIMES
176A    120E53        6118     	CALL WAIT_BEFORE_ZC_SCAN	
                      6119     
                      6120     	; Check if it is direct startup
176D    306342        6121     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6122     
                      6123     	; Set spoolup power variables
1770    85605E        6124     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1773    85605F        6125     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1776    855D64        6126     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1779    756501        6127     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6128     	; Check startup ok counter
177C    7964          6129     MOV R1 , # 100 
177E    7A14          6130     MOV R2 , # 20 
                      6131     IF MODE >= 1	; Tail or multi
1780    7888          6132     MOV R0 , # PGM_DIRECTION 
1782    E6            6133     MOV A , @ R0 
1783    B40304        6134     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6135     
1786    791E          6136     MOV R1 , # 30 
1788    7A05          6137     MOV R2 , # 5 
                      6138     
                      6139     DIRECT_START_PARAMS_SET: 
                      6140     ENDIF
178A    C3            6141     	CLR	C
178B    E538          6142     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
178D    99            6143     SUBB A , R1 
178E    4015          6144     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6145     
1790    C263          6146     CLR FLAGS1 . 3 
1792    D264          6147     SETB FLAGS1 . 4 
1794    8A37          6148     MOV STARTUP_ROT_CNT , R2 
                      6149     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6153     IF MODE == 2	; Multi
1796    7888          6154     MOV R0 , # PGM_DIRECTION 
1798    E6            6155     MOV A , @ R0 
1799    B40306        6156     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6157     
179C    755EFF        6158     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
179F    755FFF        6159     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6160     
                      6161     DIRECT_START_PWM_LIM_SET: 
                      6162     ENDIF
17A2    0217B2        6163     	JMP	NORMAL_RUN_CHECKS
                      6164     
                      6165     DIRECT_START_CHECK_RCP: 
17A5    C3            6166     	CLR	C
17A6    E559          6167     	MOV	A, NEW_RCP				; Load new pulse value
17A8    9401          6168     SUBB A , # 1 
17AA    4003          6169     	JC	($+5)
                      6170     
17AC    0216B9        6171     	LJMP	RUN1						; Continue to run 
                      6172     
17AF    0217E8        6173     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6174     
                      6175     
                      6176     NORMAL_RUN_CHECKS: 
                      6177     	; Check if it is initial run phase
17B2    306419        6178     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6179     
                      6180     	; Decrement startup rotaton count
17B5    E537          6181     	MOV	A, STARTUP_ROT_CNT
17B7    14            6182     	DEC	A
                      6183     	; Check number of nondamped rotations
17B8    7005          6184     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6185     
17BA    C264          6186     CLR FLAGS1 . 4 
17BC    0216AF        6187     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6188     
                      6189     NORMAL_RUN_CHECK_STARTUP_ROT: 
17BF    F537          6190     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6191     
17C1    C3            6192     	CLR	C
17C2    E559          6193     	MOV	A, NEW_RCP				; Load new pulse value
17C4    9401          6194     SUBB A , # 1 
17C6    4003          6195     	JC	($+5)
                      6196     
17C8    0216B9        6197     	LJMP	RUN1						; Continue to run 
                      6198     
17CB    0217E8        6199     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6200     
                      6201     
                      6202     INITIAL_RUN_PHASE_DONE: 
                      6203     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6216     	; Exit run loop after a given time
17CE    C3            6217     	CLR	C
17CF    E55C          6218     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
17D1    94FA          6219     SUBB A , # 250 
17D3    5013          6220     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6221     
                      6222     RUN6_CHECK_RCP_TIMEOUT: 
17D5    741F          6223     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
17D7    552E          6224     	ANL	A, FLAGS3					; Check pwm frequency flags
17D9    7004          6225     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6226     
17DB    E528          6227     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17DD    6009          6228     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6229     
                      6230     RUN6_CHECK_SPEED: 
17DF    C3            6231     	CLR	C
17E0    E53D          6232     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
17E2    94F0          6233     	SUBB	A, #0F0H
17E4    5002          6234     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
17E6    C1B9          6235     	JMP	RUN1						; Go back to run 1
                      6236     
                      6237     
                      6238     RUN_TO_WAIT_FOR_POWER_ON: 	
17E8    C2AF          6239     	CLR	EA
17EA    310B          6240     	CALL SWITCH_POWER_OFF
17EC    7887          6241     MOV R0 , # PGM_PWM_FREQ 
17EE    E6            6242     MOV A , @ R0 
17EF    FE            6243     MOV R6 , A 
17F0    7602          6244     MOV @ R0 , # 2 
17F2    31EE          6245     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
17F4    7887          6246     MOV R0 , # PGM_PWM_FREQ 
17F6    EE            6247     MOV A , R6 
17F7    F6            6248     MOV @ R0 , A 
17F8    E4            6249     	CLR	A
17F9    F522          6250     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
17FB    F523          6251     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
17FD    F524          6252     	MOV	CURRENT_PWM, A				; Set current pwm to zero
17FF    F525          6253     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1801    F561          6254     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1803    C260          6255     CLR FLAGS1 . 0 
1805    D2AF          6256     	SETB	EA
1807    120860        6257     	CALL	WAIT1MS					; Wait for pwm to be stopped
180A    12110B        6258     	CALL SWITCH_POWER_OFF
                      6259     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6290     IF MODE >= 1	; Tail or multi
180D    741F          6291     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
180F    552E          6292     	ANL	A, FLAGS3					; Check pwm frequency flags
1811    7007          6293     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6294     
1813    E528          6295     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1815    7003          6296     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6297     
1817    0213E8        6298     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6299     
                      6300     JMP_WAIT_FOR_POWER_ON: 
181A    021492        6301     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6302     ENDIF
                      6303     
                      6304     
                      6305     END
MACRO ASSEMBLER BLHELI                                      05/28/15 15:39:24 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17BFH   A 
COMP_WAIT_ON_COMP~  C ADDR   0EC0H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D93H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0BE6H   A 
MEASURE_LIPO_WAIT~  C ADDR   0B58H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0B13H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AD5H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0076H   A 
HOLD_FULL_H. . . .  N NUMB   0002h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
P3_DIGITAL . . . .  N NUMB   00FFh            
ADC_IP . . . . . .  N NUMB   0006h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
CCF4 . . . . . . .  B ADDR   00D8H.4 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
INIT_START . . . .  C ADDR   14FFH   A 
FIND_THROTTLE_GAI~  C ADDR   12D5H   A 
COMM45_NFET. . . .  C ADDR   1049H   A 
COMM45_NONDAMP . .  C ADDR   1046H   A 
COMM4COMM5 . . . .  C ADDR   1024H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0DB8H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C79H   A 
IF_STATE_FULL. . .  C ADDR   07A8H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0074H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   12A9H   A 
GOVERNOR_CHECK_PWM  C ADDR   0A62H   A 
GOVERNOR_ACTIVATE.  C ADDR   09B4H   A 
ENDIF_STATE_WAIT_~  C ADDR   0819H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
B. . . . . . . . .  D ADDR   00F0H   A 
FLACL. . . . . . .  D ADDR   00B5H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
WAIT_FOR_POWER_ON.  C ADDR   1492H   A 
SET_DEFAULT_PARAM~  C ADDR   1188H   A 
COMM56_NONDAMP . .  C ADDR   108CH   A 
COMM23_CP. . . . .  C ADDR   0FD7H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D3FH   A 
COMM5COMM6 . . . .  C ADDR   1065H   A 
CALC_GOVERNOR_INT~  C ADDR   0AEDH   A 
CALC_GOVERNOR_TAR~  C ADDR   09EBH   A 
IF_CRUISE_NHOLD_N~  C ADDR   07FCH   A 
PCA_INT_STORE_DATA  C ADDR   0661H   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   12F2H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
P3 . . . . . . . .  D ADDR   00B0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   15E8H   A 
DECODE_THROTTLE_R~  C ADDR   129BH   A 
STEPPER_STEP_MED_~  C ADDR   0D11H   A 
INITIALIZE_ALL_TI~  C ADDR   0CC5H   A 
STARTUP_PWM_SET_P~  C ADDR   0CB9H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0078H   A 
HOLD_FULL_L. . . .  N NUMB   008Ah            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0001h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   13E8H   A 
COMM61_CP. . . . .  C ADDR   10E8H   A 
COMM_EXIT. . . . .  C ADDR   10F7H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D9AH   A 
CALC_GOVERNOR_INT~  C ADDR   0AE6H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BFH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0765H   A 
PCA_INT_LIMITED. .  C ADDR   0788H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
TURNIGY_PLUSH_40A~  N NUMB   002Eh            
RUN1 . . . . . . .  C ADDR   16B9H   A 
CLEAR_RAM. . . . .  C ADDR   1361H   A 
SET_BEC_VOLTAGE. .  C ADDR   12C5H   A 
DECODE_GOVERNOR_G~  C ADDR   1282H   A 
DEC_STEP_HIGH. . .  C ADDR   114BH   A 
WAIT_FOR_COMM. . .  C ADDR   0F39H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0DE1H   A 
MEASURE_LIPO_ADD_~  C ADDR   0BD5H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A24H   A 
DIV_U16_BY_U16_DI~  C ADDR   0908H   A 
WAIT100MS. . . . .  C ADDR   0874H   A 
WAIT1MS. . . . . .  C ADDR   0860H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   17A2H   A 
RUN2 . . . . . . .  C ADDR   16D7H   A 
COMM45_CP. . . . .  C ADDR   105CH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0E53H   A 
MEASURE_LIPO_UPDA~  C ADDR   0BDDH   A 
GOVERNOR_CORR_INT~  C ADDR   0B32H   A 
GOVERNOR_STORE_PR~  C ADDR   0A20H   A 
DIV_U16_BY_U16_DI~  C ADDR   0912H   A 
WAIT200MS. . . . .  C ADDR   0879H   A 
IF_CRUISE_NHOLD_L~  C ADDR   07E2H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   16F5H   A 
DIRECT_METHOD_STA~  C ADDR   1556H   A 
DECODE_DAMPING_DO~  C ADDR   122AH   A 
PWM_WAIT . . . . .  C ADDR   0EE5H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C89H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0B1AH   A 
GOVERNOR_CHECK_IN~  C ADDR   0A4AH   A 
DIV_U16_BY_U16_DI~  C ADDR   0929H   A 
WAIT3MS. . . . . .  C ADDR   0865H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   181AH   A 
DIRECT_START_CHEC~  C ADDR   17A5H   A 
RUN4 . . . . . . .  C ADDR   1713H   A 
STORE_TIMES_UP_OR~  C ADDR   0E33H   A 
STORE_TIMES_DECRE~  C ADDR   0E46H   A 
STEPPER_STEP_SET .  C ADDR   0D2BH   A 
TEMP_AVERAGE_INC .  C ADDR   0C19H   A 
GOVERNOR_CORR_INT~  C ADDR   0B43H   A 
MULT_S16_BY_U8_DI~  C ADDR   0938H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0722H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   001Eh            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
CPT1MD . . . . . .  D ADDR   009CH   A 
CPT1CN . . . . . .  D ADDR   009AH   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   1730H   A 
COMP_READ. . . . .  C ADDR   0EEBH   A 
COMP_WAIT_SET_RES~  C ADDR   0EACH   A 
DIVIDE_WAIT_TIMES.  C ADDR   0DE7H   A 
GOVERNOR_CORR_NEG~  C ADDR   0B37H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A15H   A 
GOVERNOR_TARGET_C~  C ADDR   0997H   A 
CALC_GOVERNOR_TAR~  C ADDR   098FH   A 
PCA_INT_PWM_DIVID~  C ADDR   076CH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_40A~  N NUMB   002Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   174DH   A 
ARMING_START . . .  C ADDR   145AH   A 
MEASURE_PWM_FREQ_~  C ADDR   13ECH   A 
DECREMENT_STEP_EX~  C ADDR   1178H   A 
COMM_RETURN. . . .  C ADDR   110AH   A 
GOVERNOR_DEACTIVA~  C ADDR   09A1H   A 
IF_FULL_NHOLD_NOT~  C ADDR   07CEH   A 
PCA_INT_CHECK_LEG~  C ADDR   077DH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
FLAG_BEFORE_ARM. .  D ADDR   0073H   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0003h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
P3MDIN . . . . . .  D ADDR   00F4H   A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
TURNIGY_PLUSH_40A~  N NUMB   0030h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   1464H   A 
EVALUATE_COMPARAT~  C ADDR   0EFAH   A 
TEMP_CHECK_EXIT. .  C ADDR   0C43H   A 
GOVERNOR_APPLY_PR~  C ADDR   0ABCH   A 
SET_PREV_RCP . . .  C ADDR   0819H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MUX_A2 . . . . . .  N NUMB   0004h            
MUX_B1 . . . . . .  N NUMB   0007h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P3MDOUT. . . . . .  D ADDR   00A7H   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
NORMAL_RUN_CHECKS.  C ADDR   17B2H   A 
DEC_STEP_MED_LOW .  C ADDR   1166H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E7BH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0DAEH   A 
CALC_GOVERNOR_PRO~  C ADDR   09ECH   A 
PCA_INT_PPM_UNIDI~  C ADDR   071CH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_B2 . . . . . .  N NUMB   0000h            
MUX_C1 . . . . . .  N NUMB   0003h            
MUX_A3 . . . . . .  N NUMB   0005h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0F53H   A 
ENDIF_INITIAL_ARM.  C ADDR   0819H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0001h            
MUX_B3 . . . . . .  N NUMB   0001h            
MUX_C2 . . . . . .  N NUMB   0004h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   12B7H   A 
EVAL_COMP_EXIT . .  C ADDR   0F24H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0F0CH   A 
STEPPER_STEP_LOW .  C ADDR   0D1FH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B9AH   A 
IF_FULL_NHOLD_L_N~  C ADDR   07B4H   A 
PCA_INT_SET_TIMEO~  C ADDR   082CH   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
MUX_C3 . . . . . .  N NUMB   0005h            
BNFET. . . . . . .  N NUMB   0007h            
TEMP_LIMIT_STEP. .  N NUMB   0005h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
STEPPER_ROT_EXIT .  C ADDR   1657H   A 
STEPPER_METHOD_ST~  C ADDR   1596H   A 
DECODE_PARAMS_DIR~  C ADDR   1264H   A 
COMM12_DAMP. . . .  C ADDR   0F77H   A 
SETUP_COMM_WAIT. .  C ADDR   0F25H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D38H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0C6FH   A 
CALC_GOVERNOR_INT~  C ADDR   0A81H   A 
ENDIF_STATE_CRUISE  C ADDR   0819H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0001h            
APFET. . . . . . .  N NUMB   0002h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   1470H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E6CH   A 
LOAD_MIN_TIME. . .  C ADDR   0E03H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0DC2H   A 
SET_STARTUP_PWM. .  C ADDR   0C95H   A 
GOVERNOR_STORE_IN~  C ADDR   0A7BH   A 
GOVERNOR_ACTIVATE~  C ADDR   09DEH   A 
ELSE_INITIAL_ARM .  C ADDR   0819H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0006h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   17D5H   A 
DECREMENT_STEP . .  C ADDR   1129H   A 
COMM23_DAMP. . . .  C ADDR   0FA7H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0F55H   A 
ADJUST_TIMING. . .  C ADDR   0E07H   A 
STEPPER_STEP_MED_~  C ADDR   0CF5H   A 
MEASURE_LIPO_DIVI~  C ADDR   0BBAH   A 
MEASURE_LIPO_START  C ADDR   0B48H   A 
CALC_GOVERNOR_PRO~  C ADDR   0AE5H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A76H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A1CH   A 
BEEP_F1. . . . . .  C ADDR   0890H   A 
WAIT1S_LOOP. . . .  C ADDR   088BH   A 
END_PROCEDURE_GET~  C ADDR   0797H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0000h            
LOCK_BYTE_ADDRESS~  N NUMB   3DFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
PCA0CPH3 . . . . .  D ADDR   00EEH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
INITIAL_RUN_PHASE~  C ADDR   17CEH   A 
TEST_THROTTLE_GAIN  C ADDR   12E3H   A 
STEPPER_STEP_MED .  C ADDR   0D03H   A 
GOVERNOR_STORE_PR~  C ADDR   0AE3H   A 
GOVERNOR_CHECK_PR~  C ADDR   0AA7H   A 
MULT_S16_BY_U8_PO~  C ADDR   0952H   A 
DIV_U16_BY_U16 . .  C ADDR   0900H   A 
BEEP_ONOFF . . . .  C ADDR   08B3H   A 
BEEP_F2. . . . . .  C ADDR   0897H   A 
IF_CRUISE_NHOLD_T~  C ADDR   07F0H   A 
ELSE_STATE_CRUISE.  C ADDR   07FFH   A 
ELSE_FLAG_BEFORE_~  C ADDR   07A3H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F2H   A 
PCA_INT_CHECK_DIFF  C ADDR   0654H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   0038h            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPH4 . . . . .  D ADDR   00FEH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   12C6H   A 
DECREMENT_STEPPER~  C ADDR   111DH   A 
COMM61_DAMP. . . .  C ADDR   10A8H   A 
COMM34_DAMP. . . .  C ADDR   0FFBH   A 
TEMP_AVERAGE_INC_~  C ADDR   0C09H   A 
GOVERNOR_INT_MAX_~  C ADDR   0A6FH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A53H   A 
BEEP_F3. . . . . .  C ADDR   089EH   A 
SET_PWM_IN_HIGH. .  C ADDR   0793H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   00FFh            
TEMP_LIMIT . . . .  N NUMB   00A8h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
DAMPED_TRANSITION.  C ADDR   16AFH   A 
BEEP_DELAY_SET . .  C ADDR   14BAH   A 
LOCK_BYTE_OK . . .  C ADDR   1311H   A 
DECODE_PWM_FREQ_L~  C ADDR   127CH   A 
DECODE_DAMPING_3 .  C ADDR   1202H   A 
CALC_NEW_WAIT_RED~  C ADDR   0DD2H   A 
BEEP_F4. . . . . .  C ADDR   08A5H   A 
SET_PWM_IN . . . .  C ADDR   0795H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074CH   A 
PCA_INT_RESTORE_E~  C ADDR   0640H   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
BEC_6V . . . . . .  N NUMB   0003h            
LED. . . . . . . .  N NUMB   0004h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
DIRECT_START_PARA~  C ADDR   178AH   A 
DECODE_DAMPING_4 .  C ADDR   120CH   A 
COMM45_DAMP. . . .  C ADDR   102CH   A 
WAIT_FOR_COMM_SET~  C ADDR   0F65H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0C21H   A 
GOVERNOR_APPLY_IN~  C ADDR   0B1EH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0AB2H   A 
BEEP_OFF . . . . .  C ADDR   08F4H   A 
WAIT10MS . . . . .  C ADDR   086AH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F9H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P3_INIT. . . . . .  N NUMB   FFFFFFE4h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPL3 . . . . .  D ADDR   00EDH   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
RESET_CAL_DONE . .  C ADDR   132DH   A 
DECODE_DAMPING_5 .  C ADDR   1216H   A 
DECODE_PARAMETERS.  C ADDR   11EEH   A 
STEPPER_TIMER_WAIT  C ADDR   1182H   A 
STORE_TIMES_INCRE~  C ADDR   0E39H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0C68H   A 
MEASURE_LIPO_CELLS  C ADDR   0B48H   A 
CALC_GOVERNOR_INT~  C ADDR   0A25H   A 
IF_INITIAL_ARM . .  C ADDR   0808H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CFH   A 
PCA_INT_EXIT . . .  C ADDR   0846H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0000h            
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
PCA0CPL4 . . . . .  D ADDR   00FDH   A 
PCA0CPM3 . . . . .  D ADDR   00DDH   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
RUN6_CHECK_SPEED .  C ADDR   17DFH   A 
WAIT_FOR_POWER_ON~  C ADDR   14E6H   A 
DECODE_DAMPING_6 .  C ADDR   1220H   A 
DEC_STEP_LOW . . .  C ADDR   116FH   A 
COMM56_DAMP. . . .  C ADDR   1077H   A 
SWITCH_POWER_OFF .  C ADDR   110BH   A 
WAIT30MS . . . . .  C ADDR   086FH   A 
ENDIF_STATE_FULL .  C ADDR   0819H   A 
PCA_INT_PPM_BIDIR~  C ADDR   073DH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0631H   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0029h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_SKIP. . . . . .  N NUMB   0000h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
PCA0CPM4 . . . . .  D ADDR   00DEH   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   17E8H   A 
EVAL_COMP_CHECK_T~  C ADDR   0F1AH   A 
ADJUST_TIMING_TWO~  C ADDR   0E29H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C94H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A89H   A 
GOVERNOR_ACTIVATE~  C ADDR   09E5H   A 
WAIT1S . . . . . .  C ADDR   0889H   A 
WAITXMS_M. . . . .  C ADDR   0880H   A 
IF_STATE_CRUISE. .  C ADDR   07D6H   A 
IF_FLAG_BEFORE_ARM  C ADDR   079CH   A 
PCA_INT_CHECK_2KHZ  C ADDR   0620H   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0075H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   1535H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D7H   A 
DECODE_PWM_FREQ_E~  C ADDR   1281H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0F67H   A 
PWM_WAIT_STARTUP .  C ADDR   0EE0H   A 
START_ADC_CONVERS~  C ADDR   0BE2H   A 
MULT_S16_BY_U8_EX~  C ADDR   0986H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075EH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   1422H   A 
LOCK_BYTE_TEST . .  C ADDR   130AH   A 
DEC_STEP_MED_HIGH.  C ADDR   1154H   A 
COMM_RESTORE_POWER  C ADDR   1108H   A 
COMM12_NONDAMP . .  C ADDR   0F8CH   A 
COMM1COMM2 . . . .  C ADDR   0F6DH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0C1FH   A 
TEMP_AVERAGE_DEC .  C ADDR   0C15H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A82H   A 
WAITXMS_O. . . . .  C ADDR   087EH   A 
PCA_INT_PPM_TIMEO~  C ADDR   0838H   A 
IF_FULL_NHOLD_TIM~  C ADDR   07C2H   A 
ELES_STATE_FULL. .  C ADDR   07D1H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060FH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   000Ah            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
WAIT_FOR_POWER_ON~  C ADDR   1497H   A 
DEC_STEP_MED . . .  C ADDR   115DH   A 
READ_TIMER . . . .  C ADDR   0D43H   A 
CHECK_VOLTAGE_STA~  C ADDR   0C47H   A 
CALC_GOVERNOR_INT~  C ADDR   0B47H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A5CH   A 
MULT_S16_BY_U8_DI~  C ADDR   096BH   A 
BEEP . . . . . . .  C ADDR   08ACH   A 
PROCEDURE_GETPWM .  C ADDR   0788H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0707H   A 
PCA_INT_FALL . . .  C ADDR   066DH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0077H   A 
HOLD_CRUISE_L. . .  N NUMB   0004h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   00C7h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
COMM23_NFET. . . .  C ADDR   0FC4H   A 
COMM23_NONDAMP . .  C ADDR   0FC1H   A 
COMM2COMM3 . . . .  C ADDR   0F9FH   A 
STEPPER_STEP_HIGH.  C ADDR   0CE7H   A 
MEASURE_LIPO_CELL~  C ADDR   0B7FH   A 
GOVERNOR_STORE_IN~  C ADDR   0B45H   A 
GOVERNOR_CHECK_IN~  C ADDR   0B07H   A 
GOVERNOR_CORR_PRO~  C ADDR   0AD0H   A 
GOVERNOR_ACTIVATE~  C ADDR   09D2H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   0000h            
P0_DIGITAL . . . .  N NUMB   00FFh            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
CPT1MX . . . . . .  D ADDR   009EH   A 
MEASURE_LIPO_EXIT.  C ADDR   0BE1H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0AB8H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A09H   A 
LINE_TEMP01. . . .  C ADDR   05A1H   A 
PCA_INT_SECOND_ME~  C ADDR   05B3H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0000h            
P1_DIGITAL . . . .  N NUMB   0000h            
COMP_COM1. . . . .  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   13EAH   A 
COMM61_NFET. . . .  C ADDR   10CDH   A 
COMM61_NONDAMP . .  C ADDR   10CAH   A 
COMM6COMM1 . . . .  C ADDR   10A0H   A 
COMM34_NONDAMP . .  C ADDR   1008H   A 
COMM3COMM4 . . . .  C ADDR   0FE9H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E99H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E75H   A 
STARTUP_PWM_EXIT .  C ADDR   0CC4H   A 
MEASURE_LIPO_LIMI~  C ADDR   0BD1H   A 
GOVERNOR_CORR_PRO~  C ADDR   0AE1H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E9H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FEH   A 
LINE_TEMP02. . . .  C ADDR   05AFH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P3_PUSHPULL. . . .  N NUMB   001Bh            
P2_DIGITAL . . . .  N NUMB   0000h            
COMP_COM2. . . . .  N NUMB   0001h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
CCF3 . . . . . . .  B ADDR   00D8H.3 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6143    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     88    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
