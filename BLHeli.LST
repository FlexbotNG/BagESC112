MACRO ASSEMBLER BLHELI                                      05/26/15 11:12:51 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=96) OBJECT(OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
  0002                 142     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       143     $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                       650     ENDIF
                       651     
                       652     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       656     
                       657     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       661     
                       662     IF BESC == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       666     
                       667     
                       668     ;**** **** **** **** ****
                       669     ; TX programming defaults
                       670     ;
                       671     ; Parameter dependencies:
                       672     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       673     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       674     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       675     ; - Damping force is only used if DampedLight or Damped is selected
                       676     ;
                       677     ; Main
  0007                 678     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 679     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 680     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 681     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 682     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 683     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 684     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 685     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 686     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 687     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 688     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 689     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 690     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 691     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 692     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 693     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 694     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 695     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 696     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       697     ; Tail
  0003                 698     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 699     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 700     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 701     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 702     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 703     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 704     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       705     IF DAMPED_MODE_ENABLE == 1
  0004                 706     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       707     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 710     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 711     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 712     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 713     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 714     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 715     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       716     ; Multi
  0009                 717     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 718     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 719     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 720     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 721     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 722     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 723     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 724     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 725     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 726     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       727     IF DAMPED_MODE_ENABLE == 1
  0001                 728     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       729     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 732     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 733     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 734     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0014                 735     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 20	; Beep strength
  0014                 736     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 20	; Beacon strength
  0005                 737     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       738     ; Common
  0000                 739     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 740     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 741     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 742     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 743     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       744     
                       745     ;**** **** **** **** ****
                       746     ; Constant definitions for main
                       747     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       769     ; Constant definitions for tail
                       770     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       791     ; Constant definitions for multi
                       792     IF MODE == 2
                       793     
  0001                 794     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       795     
  000A                 796     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 797     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 798     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 799     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 800     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 801     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 802     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 803     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       804     
  0032                 805     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 806     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       807     
  000A                 808     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 809     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       810     
  0008                 811     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       812     
                       813     ENDIF
                       814     
                       815     ;**** **** **** **** ****
                       816     ; Temporary register definitions
  REG                  817     TEMP1		EQU	R0
  REG                  818     TEMP2		EQU	R1
  REG                  819     TEMP3		EQU	R2
  REG                  820     TEMP4		EQU	R3
  REG                  821     TEMP5		EQU	R4
  REG                  822     TEMP6		EQU	R5
  REG                  823     TEMP7		EQU	R6
  REG                  824     TEMP8		EQU	R7
                       825     
                       826     ;**** **** **** **** ****
                       827     ; Register definitions
------                 828     DSEG AT 20H					; Variables segment 
                       829     
0020                   830     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   831     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       832     
0022                   833     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   834     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   835     CURRENT_PWM: 				DS	1		; Current pwm
0025                   836     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   837     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   838     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   839     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   840     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   841     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       842     
002B                   843     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 844     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 845     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 846     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 847     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 848     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       849     ;						EQU 	5
                       850     ;						EQU 	6
                       851     ;						EQU 	7
                       852     
002C                   853     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 854     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 855     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 856     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 857     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 858     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 859     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 860     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       861     ;						EQU 	7
                       862     
002D                   863     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 864     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 865     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 866     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 867     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 868     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 869     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       870     ;						EQU 	6	
                       871     ;						EQU 	7	
                       872     
002E                   873     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 874     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 875     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 876     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 877     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 878     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 879     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 880     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 881     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       882     
                       883     ;**** **** **** **** ****
                       884     ; RAM definitions
------                 885     DSEG AT 30H						; Ram data segment, direct addressing
                       886     
0030                   887     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       888     
0031                   889     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   890     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       891     
0033                   892     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   893     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   894     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   895     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   896     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   897     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   898     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       899     
003A                   900     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   901     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   902     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   903     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   904     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   905     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       906     
0040                   907     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   908     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   909     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   910     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   911     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   912     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   913     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   914     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   915     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   916     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       917     
004A                   918     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   919     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   920     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   921     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   922     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   923     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   924     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   925     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       926     
0052                   927     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   928     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   929     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   930     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   931     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   932     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   933     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   934     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   935     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   936     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   937     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   938     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       939     
005E                   940     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   941     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   942     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   943     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   944     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   945     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       946     
0064                   947     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   948     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       949     
0066                   950     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   951     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       952     
0068                   953     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   954     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   955     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   956     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   957     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       958     
006D                   959     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       960     
006E                   961     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   962     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       963     
0070                   964     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   965     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   966     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       967     
                       968     
                       969     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       970     ;
                       971     ; Skypup 2015.05.25
                       972     ; 宏定义
                       973     ;
                       974     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       975     ;
  0002                 976     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 977     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       978     ;
  00FF                 979     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                 980     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                       981     ;
  00EE                 982     HOLD_FULL_L		EQU	0EEH	; 750 0x02EE 低位
  0002                 983     HOLD_FULL_H		EQU	02H	; 750 0x02EE 高位
  0030                 984     HOLD_CRUISE_L		EQU	30H	; 30000 0x7530 低位
  0075                 985     HOLD_CRUISE_H		EQU	75H	; 30000 0x7530 高位
                       986     
                       987     
                       988     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       989     ;
                       990     ; Skypup 2015.05.25
                       991     ; 变量定义
                       992     ;
                       993     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       994     ;
0073                   995     FLAG_BEFORE_ARM: 			DS	1		; 标记在解锁前需要 New_Rcp 为一个较大的值
0074                   996     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                       997     ;
0075                   998     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                 999     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1000     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1001     ;
0076                  1002     NHOLD_L: 					DS	1		; nHold 低位
0077                  1003     NHOLD_H: 					DS	1		; nHold 高位
                      1004     ;
0078                  1005     CSTATE: 					DS	1		; 状态
                      1006     ;
                      1007     ;	State 状态矩阵
                      1008     ; 
                      1009     ;	00   ->   10   ->   20   ->   00
                      1010     ; 
                      1011     ;	00:Wait          -> 10
                      1012     ;	10:Full          -> 20
                      1013     ;	20:Cruise        -> 00
  0000                1014     STATE_WAIT		EQU	00H
  0010                1015     STATE_FULL		EQU	10H
  0020                1016     STATE_CRUISE		EQU	20H
                      1017     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1018     
                      1019     ; Indirect addressing data segment. The variables below must be in this sequence
------                1020     ISEG AT 080H					
0080                  1021     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1022     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1023     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1024     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1025     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1026     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1027     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1028     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1029     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1030     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1031     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1032     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1033     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1034     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1035     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1036     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1037     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1038     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1039     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1040     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1041     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1042     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1043     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1044     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1045     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1046     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1047     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1048     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1049     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1050     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1051     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1052     
                      1053     ; The sequence of the variables below is no longer of importance
009F                  1054     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1055     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1056     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1057     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1058     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1059     
                      1060     
                      1061     ; Indirect addressing data segment
------                1062     ISEG AT 0D0H					
00D0                  1063     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1064     
                      1065     
                      1066     ;**** **** **** **** ****
------                1067     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1068     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1069     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1070     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1071     
1A00    0B            1072     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1073     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1074     EEP_LAYOUT_REVISION:  DB 17 
                      1075     
                      1076     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1109     
                      1110     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1143     
                      1144     IF MODE == 2
1A03    09            1145     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1146     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1147     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1148     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1149     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1150     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1151     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1152     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1153     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1154     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1155     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1156     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1157     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1158     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1159     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1160     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1161     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1162     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1163     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1164     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1165     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1166     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1167     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1168     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    14            1169     EEP_PGM_BEEP_STRENGTH:  DB 20 
1A1C    14            1170     EEP_PGM_BEACON_STRENGTH:  DB 20 
1A1D    05            1171     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1172     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1173     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1174     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1175     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1176     ENDIF
                      1177     
                      1178     
1A22    FF            1179     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1180     
------                1181     CSEG AT 1A60H
1A60    6F72672E      1182     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1183     
                      1184     ;**** **** **** **** ****
                      1185             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1185+1   CSEG AT 0  ; CODE SEGMENT START
0000    0212FD        1185+1   JMP RESET 
------                1185+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1185+1   JMP T0_INT 
------                1185+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1185+1   JMP T2_INT 
------                1185+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1185+1   JMP PCA_INT 
------                1185+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1185+1   JMP T3_INT 
------                1186     CSEG AT 80H			; Code segment after interrupt vectors 
                      1187     
                      1188     ;**** **** **** **** ****
                      1189     
                      1190     ; Table definitions
0080    02030406      1191     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1192     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1193     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1194     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1195     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1198     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1206     IF MODE == 2
                      1207       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1208     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1209       ENDIF
                      1210       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1213     ENDIF
                      1214     
                      1215     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1216     ;
                      1217     ; Timer0 interrupt routine
                      1218     ;
                      1219     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1220     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1221     ;
                      1222     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1223     T0_INT: 	; Used for pwm control
00BA    C2AF          1224     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1225     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1226     	PUSH	ACC		
                      1227     	; Check if pwm is on
00C0    205A10        1228     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1229     
                      1230     	; Do not execute pwm when stopped
00C3    30600A        1231     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1232     	; Do not execute pwm on during demag recovery
00C6    205C07        1233     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1234     	; Pwm on cycle. 
00C9    302F02        1235     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1236     
                      1237     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1238     	CLR	A					
00CD    73            1239     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1240     
                      1241     T0_INT_PWM_ON_LOW_PWM: 
                      1242     
                      1243     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1244     	JMP	T0_INT_PWM_ON_EXECUTE
                      1245     ENDIF
                      1246     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1263     
                      1264     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1265     	JMP	T0_INT_PWM_ON_EXIT
                      1266     
                      1267     
                      1268     T0_INT_PWM_OFF: 
00D3    306306        1269     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1270     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    D297          1270+1   SETB P1 . 7 
00D8    D295          1270+1   SETB P1 . 5 
00DA    D293          1270+1   SETB P1 . 3 
                      1271     T0_INT_PWM_OFF_START_CHECKED: 
                      1272     	; Pwm off cycle
00DC    85258A        1273     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1274     	; Clear pwm on flag
00DF    C25A          1275     CLR FLAGS0 . 2 
                      1276     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1277     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1278     	CPL	A						; Full pwm?
00E4    7002          1279     	JNZ	($+4)					; No - branch
00E6    21C6          1280     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1281     
00E8    0563          1282     	INC	PWM_OFF_CNT				; Increment event counter
                      1283     	; Do not execute pwm when stopped
00EA    306013        1284     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1285     
                      1286     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1287     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1288     
                      1289     	; Separate exit commands here for minimum delay
00F0    758B00        1290     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1291     	POP	ACC			; Restore preserved registers
00F5    D0D0          1292     	POP	PSW
                      1293     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    D297          1293+1   SETB P1 . 7 
00F9    D295          1293+1   SETB P1 . 5 
00FB    D293          1293+1   SETB P1 . 3 
00FD    D2AF          1294     	SETB	EA			; Enable all interrupts
00FF    32            1295     	RETI
                      1296     
                      1297     T0_INT_PWM_OFF_STOPPED: 
                      1298     	ALL_NFETS_OFF 					; Switch off all nfets
0100    D297          1298+1   SETB P1 . 7 
0102    D295          1298+1   SETB P1 . 5 
0104    D293          1298+1   SETB P1 . 3 
0106    0201B6        1299     	JMP	T0_INT_PWM_OFF_EXIT
                      1300     
                      1301     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1302     SETB FLAGS1 . 5 
010B    C266          1303     CLR FLAGS1 . 6 
010D    E567          1304     	MOV	A, DAMPING_ON
010F    601C          1305     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1306     
0111    C3            1307     	CLR	C
0112    E563          1308     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1309     	DEC	A
0115    9567          1310     	SUBB	A, DAMPING_ON
0117    4014          1311     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1312     
0119    C265          1313     CLR FLAGS1 . 5 
011B    D266          1314     SETB FLAGS1 . 6 
011D    C3            1315     	CLR	C
011E    E563          1316     	MOV	A, PWM_OFF_CNT					
0120    9566          1317     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1318     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1319     
0124    0201B6        1320     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1321     
                      1322     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1323     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1324     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1325     
                      1326     T0_INT_PWM_OFF_DO_DAMPED: 
                      1327     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1328     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1329     
                      1330     	ALL_NFETS_OFF 					; Switch off all nfets
0130    D297          1330+1   SETB P1 . 7 
0132    D295          1330+1   SETB P1 . 5 
0134    D293          1330+1   SETB P1 . 3 
0136    7406          1331     MOV A , # 6 
0138    D5E0FD        1332     	DJNZ	ACC, $	
                      1333     	ALL_PFETS_ON 					; Switch on all pfets
013B    D296          1333+1   SETB P1 . 6 
013D    D294          1333+1   SETB P1 . 4 
013F    D292          1333+1   SETB P1 . 2 
0141    0201B6        1334     	JMP	T0_INT_PWM_OFF_EXIT
                      1335     
                      1336     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1337     IF DAMPED_MODE_ENABLE == 1
0144    D266          1338     SETB FLAGS1 . 6 
                      1339     ENDIF
                      1340     	ALL_NFETS_OFF 					; Switch off all nfets
0146    D297          1340+1   SETB P1 . 7 
0148    D295          1340+1   SETB P1 . 5 
014A    D293          1340+1   SETB P1 . 3 
014C    E53E          1341     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1342     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1343     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1344     
                      1345     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1348     MOV A , # 6 
0156    D5E0FD        1349     	DJNZ	ACC, $	
                      1350     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1350+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D292          1350+1   SETB P1 . 2 
015E    307502        1350+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D296          1350+1   SETB P1 . 6 
                      1351     ENDIF
0163    0201B6        1352     	JMP	T0_INT_PWM_OFF_EXIT
                      1353     
                      1354     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1355     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1356     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1359     MOV A , # 6 
016B    D5E0FD        1360     	DJNZ	ACC, $	
                      1361     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1361+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D292          1361+1   SETB P1 . 2 
0173    307502        1361+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D296          1361+1   SETB P1 . 6 
                      1362     ENDIF
0178    0201B6        1363     	JMP	T0_INT_PWM_OFF_EXIT
                      1364     
                      1365     T0_INT_PWM_OFF_COMM_3: 
                      1366     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1369     MOV A , # 6 
017D    D5E0FD        1370     	DJNZ	ACC, $	
                      1371     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1371+1   SETB P1 . 4 
                      1372     ENDIF
0182    0201B6        1373     	JMP	T0_INT_PWM_OFF_EXIT
                      1374     
                      1375     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1376     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1377     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1378     
                      1379     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1382     MOV A , # 6 
018D    D5E0FD        1383     	DJNZ	ACC, $	
                      1384     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1384+1   SETB P1 . 4 
                      1385     ENDIF
0192    0201B6        1386     	JMP	T0_INT_PWM_OFF_EXIT
                      1387     
                      1388     T0_INT_PWM_OFF_COMM_5: 
                      1389     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1392     MOV A , # 6 
0197    D5E0FD        1393     	DJNZ	ACC, $	
                      1394     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1394+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D296          1394+1   SETB P1 . 6 
019F    307502        1394+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D292          1394+1   SETB P1 . 2 
                      1395     ENDIF
01A4    0201B6        1396     	JMP	T0_INT_PWM_OFF_EXIT
                      1397     
                      1398     T0_INT_PWM_OFF_COMM_6: 
                      1399     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1402     MOV A , # 6 
01A9    D5E0FD        1403     	DJNZ	ACC, $	
                      1404     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1404+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D296          1404+1   SETB P1 . 6 
01B1    307502        1404+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D292          1404+1   SETB P1 . 2 
                      1405     ENDIF
                      1406     
                      1407     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1408     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1409     	POP	ACC			; Restore preserved registers
01BB    D0D0          1410     	POP	PSW
                      1411     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    D297          1411+1   SETB P1 . 7 
01BF    D295          1411+1   SETB P1 . 5 
01C1    D293          1411+1   SETB P1 . 3 
01C3    D2AF          1412     	SETB	EA			; Enable all interrupts
01C5    32            1413     	RETI
                      1414     
                      1415     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1416     	POP	ACC			; Restore preserved registers
01C8    D0D0          1417     	POP	PSW
01CA    D2AF          1418     	SETB	EA			; Enable all interrupts
01CC    32            1419     	RETI
                      1420     
                      1421     
                      1422     
                      1423     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1424     	AJMP	T0_INT_PWM_ON_EXIT
                      1425     
                      1426     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1427     	ANFET_ON	
01CF    E525          1427+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1427+1   JZ ( $+12 ) 
01D3    207502        1427+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    C297          1427+1   CLR P1 . 7 
01D8    307502        1427+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    C293          1427+1   CLR P1 . 3 
                      1428     	BNFET_OFF
01DD    D295          1428+1   SETB P1 . 5 
01DF    61D3          1429     	AJMP	T0_INT_PWM_ON_EXIT
                      1430     
                      1431     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1432     	BNFET_ON
01E1    E525          1432+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1432+1   JZ ( $+4 ) 
01E5    C295          1432+1   CLR P1 . 5 
                      1433     	CNFET_OFF
01E7    207502        1433+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    D293          1433+1   SETB P1 . 3 
01EC    307502        1433+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    D297          1433+1   SETB P1 . 7 
01F1    61D3          1434     	AJMP	T0_INT_PWM_ON_EXIT
                      1435     
                      1436     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1437     	CNFET_ON
01F3    E525          1437+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1437+1   JZ ( $+12 ) 
01F7    207502        1437+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    C293          1437+1   CLR P1 . 3 
01FC    307502        1437+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    C297          1437+1   CLR P1 . 7 
                      1438     	ANFET_OFF
0201    207502        1438+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    D297          1438+1   SETB P1 . 7 
0206    307502        1438+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    D293          1438+1   SETB P1 . 3 
020B    61D3          1439     	AJMP	T0_INT_PWM_ON_EXIT
                      1440     
                      1441     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1442     	APFET_OFF
020D    207502        1442+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C296          1442+1   CLR P1 . 6 
0212    307502        1442+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C292          1442+1   CLR P1 . 2 
                      1443     	ANFET_ON								; Switch nFETs
0217    E525          1443+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1443+1   JZ ( $+12 ) 
021B    207502        1443+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    C297          1443+1   CLR P1 . 7 
0220    307502        1443+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    C293          1443+1   CLR P1 . 3 
                      1444     	CPFET_OFF
0225    207502        1444+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C292          1444+1   CLR P1 . 2 
022A    307502        1444+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C296          1444+1   CLR P1 . 6 
                      1445     	BNFET_OFF 							
022F    D295          1445+1   SETB P1 . 5 
0231    61D3          1446     	AJMP	T0_INT_PWM_ON_EXIT
                      1447     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1448     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1449     	APFET_OFF
0233    207502        1449+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C296          1449+1   CLR P1 . 6 
0238    307502        1449+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C292          1449+1   CLR P1 . 2 
                      1450     	CPFET_OFF
023D    207502        1450+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C292          1450+1   CLR P1 . 2 
0242    307502        1450+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C296          1450+1   CLR P1 . 6 
0247    7406          1451     MOV A , # 6 
0249    D5E0FD        1452     	DJNZ ACC,	$
                      1453     	ANFET_ON								; Switch nFETs
024C    E525          1453+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1453+1   JZ ( $+12 ) 
0250    207502        1453+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    C297          1453+1   CLR P1 . 7 
0255    307502        1453+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    C293          1453+1   CLR P1 . 3 
                      1454     	BNFET_OFF 							
025A    D295          1454+1   SETB P1 . 5 
025C    61D3          1455     	AJMP	T0_INT_PWM_ON_EXIT
                      1456     
                      1457     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1458     	APFET_OFF
025E    207502        1458+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C296          1458+1   CLR P1 . 6 
0263    307502        1458+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C292          1458+1   CLR P1 . 2 
                      1459     	ANFET_ON								; Switch nFETs
0268    E525          1459+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1459+1   JZ ( $+12 ) 
026C    207502        1459+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    C297          1459+1   CLR P1 . 7 
0271    307502        1459+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    C293          1459+1   CLR P1 . 3 
                      1460     	BPFET_OFF
0276    C294          1460+1   CLR P1 . 4 
                      1461     	BNFET_OFF								
0278    D295          1461+1   SETB P1 . 5 
027A    61D3          1462     	AJMP	T0_INT_PWM_ON_EXIT
                      1463     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1464     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1465     	APFET_OFF
027C    207502        1465+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C296          1465+1   CLR P1 . 6 
0281    307502        1465+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C292          1465+1   CLR P1 . 2 
                      1466     	BPFET_OFF
0286    C294          1466+1   CLR P1 . 4 
0288    7406          1467     MOV A , # 6 
028A    D5E0FD        1468     	DJNZ ACC,	$
                      1469     	ANFET_ON								; Switch nFETs
028D    E525          1469+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1469+1   JZ ( $+12 ) 
0291    207502        1469+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    C297          1469+1   CLR P1 . 7 
0296    307502        1469+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    C293          1469+1   CLR P1 . 3 
                      1470     	BNFET_OFF								
029B    D295          1470+1   SETB P1 . 5 
029D    61D3          1471     	AJMP	T0_INT_PWM_ON_EXIT
                      1472     
                      1473     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1474     	BPFET_OFF
029F    C294          1474+1   CLR P1 . 4 
                      1475     	BNFET_ON								; Switch nFETs
02A1    E525          1475+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1475+1   JZ ( $+4 ) 
02A5    C295          1475+1   CLR P1 . 5 
                      1476     	APFET_OFF
02A7    207502        1476+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C296          1476+1   CLR P1 . 6 
02AC    307502        1476+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C292          1476+1   CLR P1 . 2 
                      1477     	CNFET_OFF								
02B1    207502        1477+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    D293          1477+1   SETB P1 . 3 
02B6    307502        1477+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    D297          1477+1   SETB P1 . 7 
02BB    61D3          1478     	AJMP	T0_INT_PWM_ON_EXIT
                      1479     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1480     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1481     	BPFET_OFF
02BD    C294          1481+1   CLR P1 . 4 
                      1482     	APFET_OFF
02BF    207502        1482+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C296          1482+1   CLR P1 . 6 
02C4    307502        1482+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C292          1482+1   CLR P1 . 2 
02C9    7406          1483     MOV A , # 6 
02CB    D5E0FD        1484     	DJNZ ACC,	$
                      1485     	BNFET_ON								; Switch nFETs
02CE    E525          1485+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1485+1   JZ ( $+4 ) 
02D2    C295          1485+1   CLR P1 . 5 
                      1486     	CNFET_OFF								
02D4    207502        1486+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    D293          1486+1   SETB P1 . 3 
02D9    307502        1486+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    D297          1486+1   SETB P1 . 7 
02DE    61D3          1487     	AJMP	T0_INT_PWM_ON_EXIT
                      1488     
                      1489     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1490     	BPFET_OFF
02E0    C294          1490+1   CLR P1 . 4 
                      1491     	BNFET_ON								; Switch nFETs
02E2    E525          1491+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1491+1   JZ ( $+4 ) 
02E6    C295          1491+1   CLR P1 . 5 
                      1492     	CPFET_OFF
02E8    207502        1492+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C292          1492+1   CLR P1 . 2 
02ED    307502        1492+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C296          1492+1   CLR P1 . 6 
                      1493     	CNFET_OFF								
02F2    207502        1493+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    D293          1493+1   SETB P1 . 3 
02F7    307502        1493+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    D297          1493+1   SETB P1 . 7 
02FC    61D3          1494     	AJMP	T0_INT_PWM_ON_EXIT
                      1495     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1496     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1497     	BPFET_OFF
02FE    C294          1497+1   CLR P1 . 4 
                      1498     	CPFET_OFF
0300    207502        1498+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C292          1498+1   CLR P1 . 2 
0305    307502        1498+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C296          1498+1   CLR P1 . 6 
030A    7406          1499     MOV A , # 6 
030C    D5E0FD        1500     	DJNZ ACC,	$
                      1501     	BNFET_ON								; Switch nFETs
030F    E525          1501+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1501+1   JZ ( $+4 ) 
0313    C295          1501+1   CLR P1 . 5 
                      1502     	CNFET_OFF								
0315    207502        1502+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    D293          1502+1   SETB P1 . 3 
031A    307502        1502+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    D297          1502+1   SETB P1 . 7 
031F    61D3          1503     	AJMP	T0_INT_PWM_ON_EXIT
                      1504     
                      1505     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1506     	CPFET_OFF
0321    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C292          1506+1   CLR P1 . 2 
0326    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C296          1506+1   CLR P1 . 6 
                      1507     	CNFET_ON								; Switch nFETs
032B    E525          1507+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1507+1   JZ ( $+12 ) 
032F    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    C293          1507+1   CLR P1 . 3 
0334    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    C297          1507+1   CLR P1 . 7 
                      1508     	BPFET_OFF
0339    C294          1508+1   CLR P1 . 4 
                      1509     	ANFET_OFF								
033B    207502        1509+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    D297          1509+1   SETB P1 . 7 
0340    307502        1509+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    D293          1509+1   SETB P1 . 3 
0345    61D3          1510     	AJMP	T0_INT_PWM_ON_EXIT
                      1511     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1512     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1513     	CPFET_OFF
0347    207502        1513+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C292          1513+1   CLR P1 . 2 
034C    307502        1513+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C296          1513+1   CLR P1 . 6 
                      1514     	BPFET_OFF
0351    C294          1514+1   CLR P1 . 4 
0353    7406          1515     MOV A , # 6 
0355    D5E0FD        1516     	DJNZ ACC,	$
                      1517     	CNFET_ON								; Switch nFETs
0358    E525          1517+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1517+1   JZ ( $+12 ) 
035C    207502        1517+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    C293          1517+1   CLR P1 . 3 
0361    307502        1517+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    C297          1517+1   CLR P1 . 7 
                      1518     	ANFET_OFF								
0366    207502        1518+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    D297          1518+1   SETB P1 . 7 
036B    307502        1518+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    D293          1518+1   SETB P1 . 3 
0370    61D3          1519     	AJMP	T0_INT_PWM_ON_EXIT
                      1520     
                      1521     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1522     	CPFET_OFF
0372    207502        1522+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C292          1522+1   CLR P1 . 2 
0377    307502        1522+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C296          1522+1   CLR P1 . 6 
                      1523     	CNFET_ON								; Switch nFETs
037C    E525          1523+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1523+1   JZ ( $+12 ) 
0380    207502        1523+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    C293          1523+1   CLR P1 . 3 
0385    307502        1523+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    C297          1523+1   CLR P1 . 7 
                      1524     	APFET_OFF
038A    207502        1524+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C296          1524+1   CLR P1 . 6 
038F    307502        1524+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C292          1524+1   CLR P1 . 2 
                      1525     	ANFET_OFF								
0394    207502        1525+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    D297          1525+1   SETB P1 . 7 
0399    307502        1525+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    D293          1525+1   SETB P1 . 3 
039E    61D3          1526     	AJMP	T0_INT_PWM_ON_EXIT
                      1527     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1528     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1529     	CPFET_OFF
03A0    207502        1529+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C292          1529+1   CLR P1 . 2 
03A5    307502        1529+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C296          1529+1   CLR P1 . 6 
                      1530     	APFET_OFF
03AA    207502        1530+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C296          1530+1   CLR P1 . 6 
03AF    307502        1530+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C292          1530+1   CLR P1 . 2 
03B4    7406          1531     MOV A , # 6 
03B6    D5E0FD        1532     	DJNZ ACC,	$
                      1533     	CNFET_ON								; Switch nFETs
03B9    E525          1533+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1533+1   JZ ( $+12 ) 
03BD    207502        1533+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    C293          1533+1   CLR P1 . 3 
03C2    307502        1533+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    C297          1533+1   CLR P1 . 7 
                      1534     	ANFET_OFF								
03C7    207502        1534+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    D297          1534+1   SETB P1 . 7 
03CC    307502        1534+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    D293          1534+1   SETB P1 . 3 
03D1    61D3          1535     	AJMP	T0_INT_PWM_ON_EXIT
                      1536     
                      1537     T0_INT_PWM_ON_EXIT: 
                      1538     	; Set timer for coming on cycle length
03D3    E525          1539     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1540     	CPL	A						; cpl is 255-x
03D6    F58A          1541     	MOV	TL0, A					; Write start point for timer
                      1542     	; Set other variables
03D8    758B00        1543     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1544     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1545     SETB FLAGS0 . 2 
                      1546     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1547     	; Exit interrupt
03E0    D0E0          1548     	POP	ACC			; Restore preserved registers
03E2    D0D0          1549     	POP	PSW
03E4    D2AF          1550     	SETB	EA			; Enable all interrupts
03E6    32            1551     	RETI
                      1552     
                      1553     
                      1554     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1555     ;
                      1556     ; Timer2 interrupt routine
                      1557     ;
                      1558     ; No assumptions
                      1559     ;
                      1560     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1561     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1562     	CLR	EA
03E9    C2AD          1563     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1564     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1565     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1566     	PUSH	ACC
03F2    D2D3          1567     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1568     	SETB	EA
                      1569     	; Clear low byte interrupt flag
03F6    C2CE          1570     	CLR	TF2L						; Clear interrupt flag
                      1571     	; Check RC pulse timeout counter
03F8    E528          1572     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1573     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1574     
                      1575     	; Decrement timeout counter (if PWM)
03FC    741F          1576     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1577     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1578     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1579     
0402    1528          1580     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1581     	AJMP	T2_INT_SKIP_START
                      1582     
                      1583     T2_INT_PULSES_ABSENT: 
                      1584     	; Timeout counter has reached zero, pulses are absent
0406    7800          1585     MOV R0 , # 0 
0408    7900          1586     MOV R1 , # 0 
                      1587     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1587+1   MOV A , P0 
040C    307601        1587+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1587+1   CPL A  ; YES - INVERT
0410    30E502        1588     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1589     MOV R0 , # 255 
                      1590     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1590+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1590+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1590+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1590+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1590+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1591     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1591+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1592     CLR FLAGS2 . 1 
                      1593     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1593+1   MOV A , P0 
042A    307601        1593+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1593+1   CPL A  ; YES - INVERT
042E    30E502        1594     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1595     MOV R1 , # 255 
0433    C3            1596     	CLR	C
0434    E8            1597     MOV A , R0 
0435    99            1598     SUBB A , R1 
0436    70CE          1599     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1600     
0438    305903        1601     JNB FLAGS0 . 1 , ( $+6 ) 
                      1602     
043B    752818        1603     MOV RCP_TIMEOUT_CNT , # 24 
                      1604     
043E    741F          1605     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1606     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1607     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1608     
0444    752818        1609     MOV RCP_TIMEOUT_CNT , # 24 
                      1610     
                      1611     
                      1612     T2_INT_PPM_TIMEOUT_SET: 
                      1613     
                      1614     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1615     ; 
                      1616     ; 对 RCP 信号处理
                      1617     ; 1 小于 1500us 最低油门
                      1618     ; 2 大于 1500us 正常处理
                      1619     ; 
                      1620     ;	clr C
                      1621     ;	mov A, Temp1
                      1622     ;	subb A, #80h
                      1623     ;	jnc skypup_01
                      1624     ;	mov	Temp1, #RCP_MIN
                      1625     ; skypup_01:
                      1626     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1627     MOV NEW_RCP , R0 
0449    D268          1628     SETB FLAGS2 . 0 
                      1629     
                      1630     T2_INT_SKIP_START: 
                      1631     	; Check RC pulse skip counter
044B    E529          1632     	MOV	A, RCP_SKIP_CNT			
044D    6004          1633     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1634     	
                      1635     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1636     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1637     	AJMP	T2_INT_RCP_UPDATE_START
                      1638     
                      1639     T2_INT_SKIP_END: 
0453    741F          1640     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1641     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1642     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1643     
                      1644     	; Skip counter has reached zero, start looking for RC pulses again
                      1645     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1645+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1646     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1646+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1647     	
                      1648     T2_INT_RCP_UPDATE_START: 
                      1649     	; Process updated RC pulse
045E    206802        1650     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1651     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1652     
0463    E559          1653     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1654     MOV R0 , A 
0466    C268          1655     CLR FLAGS2 . 0 
                      1656     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1657     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1658     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1659     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1660     
                      1661     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1664     
                      1665     IF MODE == 2	; Multi
046E    7982          1666     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1667     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1668     ENDIF
                      1669     
                      1670     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1671     	CLR	C
0474    E8            1672     MOV A , R0 
0475    94F0          1673     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1674     	JC	T2_INT_RCP_UPDATE_MULT
                      1675     
0479    74F0          1676     	MOV	A, #240			; Set requested pwm to max
047B    F8            1677     MOV R0 , A 
                      1678     
                      1679     T2_INT_RCP_UPDATE_MULT: 	
                      1680     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1681     MOV A , R0 
047D    C4            1682     	SWAP	A			; After this "0.0625"
047E    540F          1683     	ANL	A, #0FH
0480    28            1684     ADD A , R0 
0481    F8            1685     MOV R0 , A 
                      1686     	; Adjust tail gain
0482    7984          1687     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1688     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1689     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1690     
0489    C3            1691     	CLR	C
048A    13            1692     	RRC	A			; After this "0.5"
048B    C3            1693     	CLR	C
048C    13            1694     	RRC	A			; After this "0.25"
048D    8721          1695     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1696     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1697     
0492    C3            1698     	CLR	C
0493    13            1699     	RRC	A			; After this "0.125"
                      1700     
                      1701     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1702     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1703     
0497    C3            1704     	CLR	C
0498    C8            1705     XCH A , R0 
0499    98            1706     SUBB A , R0 
049A    F8            1707     MOV R0 , A 
049B    81A4          1708     	AJMP	T2_INT_PWM_MIN_RUN
                      1709     
                      1710     T2_INT_RCP_GAIN_POS: 
049D    28            1711     ADD A , R0 
049E    F8            1712     MOV R0 , A 
049F    5003          1713     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1714     
04A1    74FF          1715     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1716     MOV R0 , A 
                      1717     
                      1718     T2_INT_PWM_MIN_RUN:  
                      1719     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1729     
                      1730     T2_INT_PWM_UPDATE:  
                      1731     	; Check if any startup phase flags are set
04A4    E52C          1732     	MOV	A, FLAGS1
04A6    5406          1733     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1734     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1735     
                      1736     	; Update requested_pwm
04AA    8822          1737     MOV REQUESTED_PWM , R0 
                      1738     	; Limit pwm during direct start
04AC    30630A        1739     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1740     
04AF    C3            1741     	CLR	C
04B0    E522          1742     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1743     	SUBB	A, PWM_LIMIT
04B4    4003          1744     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1745     
04B6    855E22        1746     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1747     
                      1748     T2_INT_CURRENT_PWM_UPDATE:  
                      1749     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1750     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1751     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1752     ENDIF
                      1753     
                      1754     	; Update current pwm, with limited throttle change rate
04BE    C3            1755     	CLR	C
04BF    E522          1756     	MOV	A, REQUESTED_PWM	 
04C1    9524          1757     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1758     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1759     
                      1760     	; 缓启动
04C5    78A1          1761     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1762     	;mov	Temp1, #1
04C7    96            1763     SUBB A , @ R0 
                      1764     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1765     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1766     
04CA    E524          1767     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1768     ADD A , @ R0 
                      1769     	; add	A, Temp1
04CD    F524          1770     	MOV	CURRENT_PWM, A
04CF    5009          1771     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1772     
04D1    7524FF        1773     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1774     	JMP	T2_INT_CURRENT_PWM_DONE
                      1775     
                      1776     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1777     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1778     T2_INT_CURRENT_PWM_DONE: 
                      1779     IF MODE >= 1	; Tail or multi
                      1780     	; Set current_pwm_limited
04DA    A824          1781     MOV R0 , CURRENT_PWM 
04DC    C3            1782     	CLR	C
04DD    E524          1783     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1784     	SUBB	A, PWM_LIMIT
04E1    4002          1785     	JC	($+4)					; If current pwm below limit - branch
                      1786     
04E3    A85E          1787     MOV R0 , PWM_LIMIT 
                      1788     
04E5    8825          1789     MOV CURRENT_PWM_LIMITED , R0 
                      1790     ENDIF
                      1791     T2_INT_PWM_EXIT: 	
                      1792     	; Check if high byte flag is set
04E7    20CF0C        1793     	JB	TF2H, T2H_INT		
04EA    D0E0          1794     	POP	ACC			; Restore preserved registers
04EC    D0D0          1795     	POP	PSW
04EE    C2D3          1796     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1797     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1798     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1799     	RETI
                      1800     
                      1801     T2H_INT: 
                      1802     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1803     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1804     MOV R0 , # 1 
                      1805     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1806     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1807     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1808     
                      1809     	; Decrement timeout counter (if PPM)
04FE    741F          1810     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1811     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1812     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1813     
0504    1528          1814     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1815     
                      1816     T2H_INT_RCP_STOP_CHECK: 
                      1817     	; Check RC pulse against stop value
0506    C3            1818     	CLR	C
0507    E559          1819     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1820     SUBB A , # 1 
050B    4005          1821     	JC	T2H_INT_RCP_STOP
                      1822     
                      1823     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1824     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1825     	AJMP	T2H_INT_RCP_GOV_PWM
                      1826     
                      1827     T2H_INT_RCP_STOP: 	
                      1828     	; RC pulse less than stop value
0512    755D00        1829     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1830     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1831     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1832     	ADD	A, #1
051C    F55C          1833     	MOV	RCP_STOP_CNT, A
051E    5003          1834     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1835     
0520    755CFF        1836     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1837     
                      1838     T2H_INT_RCP_GOV_PWM: 
                      1839     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1968     IF MODE == 2	; Multi
0523    E55F          1969     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1970     	ADD	A, #10
0527    5005          1971     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1972     
0529    755FFF        1973     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1974     	AJMP	T2H_INT_RCP_EXIT
                      1975     
                      1976     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1977     	MOV	PWM_LIMIT_SPOOLUP, A
                      1978     ENDIF
                      1979     
                      1980     T2H_INT_RCP_EXIT: 
0530    D0E0          1981     	POP	ACC			; Restore preserved registers
0532    D0D0          1982     	POP	PSW
0534    C2D3          1983     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1984     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1985     	SETB	ET2			; Enable timer2 interrupts
053B    32            1986     	RETI
                      1987     
                      1988     
                      1989     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1990     ;
                      1991     ; Timer3 interrupt routine
                      1992     ;
                      1993     ; No assumptions
                      1994     ;
                      1995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1996     T3_INT: 	; Used for commutation timing
053C    C2AF          1997     	CLR 	EA			; Disable all interrupts
053E    53917F        1998     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1999     CLR FLAGS0 . 0 
0543    D2AF          2000     	SETB	EA			; Enable all interrupts
0545    32            2001     	RETI
                      2002     
                      2003     
                      2004     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2005     ;
                      2006     ; PCA interrupt routine
                      2007     ;
                      2008     ; No assumptions
                      2009     ;
                      2010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2011     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2012     	CLR	EA
0548    53E6EF        2013     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2014     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2015     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2016     	PUSH	ACC
0551    C0F0          2017     	PUSH	B
0553    D2D3          2018     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2019     	SETB	EA
                      2020     	; Get the PCA counter values
                      2021     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2021+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2021+1   MOV R1 , PCA0CPH0 
                      2022     	; Clear interrupt flag
                      2023     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2023+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2024     	; Check which edge it is
055D    306902        2025     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          2026     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2027     
                      2028     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2028+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2028+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2028+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2028+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2028+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2029     SETB FLAGS2 . 1 
                      2030     	; Read RC signal level
                      2031     	READ_RCP_INT			
0573    E580          2031+1   MOV A , P0 
0575    307601        2031+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2031+1   CPL A  ; YES - INVERT
                      2032     	; Test RC signal level
0579    20E502        2033     JB ACC . 5 , ( $+5 ) 
057C    A185          2034     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2035     
                      2036     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2037     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2038     MOV RCP_PREV_EDGE_H , R1 
0582    0207FB        2039     	LJMP	PCA_INT_EXIT				; Exit
                      2040     
                      2041     PCA_INT_FAIL_MINIMUM: 
                      2042     	; Prepare for next interrupt
                      2043     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2043+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2043+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2043+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2043+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2043+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2044     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2044+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2045     CLR FLAGS2 . 1 
0598    741F          2046     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2047     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          2048     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      2049     
059E    E1E1          2050     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      2051     
05A0    7800          2052     MOV R0 , # 0 
                      2053     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          2053+1   MOV A , P0 
05A4    307601        2053+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            2053+1   CPL A  ; YES - INVERT
05A8    30E502        2054     JNB ACC . 5 , ( $+5 ) 
05AB    E1E1          2055     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      2056     
                      2057     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2058     ; 
                      2059     ; 对 RCP 信号处理
                      2060     ; 1 小于 1500us 最低油门
                      2061     ; 2 大于 1500us 正常处理
                      2062     ; 
                      2063     ;	clr C
                      2064     ;	mov A, Temp1
                      2065     ;	subb A, #80h
                      2066     ;	jnc skypup_02
                      2067     ;	mov	Temp1, #RCP_MIN
                      2068     ; skypup_02:
                      2069     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2070     
05AD    8859          2071     MOV NEW_RCP , R0 
05AF    E186          2072     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2073     
                      2074     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2075     	; Prepare for next interrupt
                      2076     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        2076+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        2076+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        2076+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        2076+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        2076+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          2077     CLR FLAGS2 . 1 
                      2078     	; Check if pwm frequency shall be measured
05C2    205902        2079     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          2080     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2081     
                      2082     	; Set second edge trig only during pwm frequency measurement
                      2083     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        2083+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        2083+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        2083+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        2083+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        2083+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2084     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          2084+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          2085     SETB FLAGS2 . 1 
                      2086     	; Store edge data to RAM
05DA    8854          2087     MOV RCP_EDGE_L , R0 
05DC    8955          2088     MOV RCP_EDGE_H , R1 
                      2089     	; Calculate pwm frequency
05DE    C3            2090     	CLR	C
05DF    E8            2091     MOV A , R0 
05E0    9552          2092     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            2093     MOV R0 , A 
05E3    E9            2094     MOV A , R1 
05E4    9553          2095     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            2096     MOV R1 , A 
05E7    E4            2097     	CLR	A
05E8    FB            2098     MOV R3 , A 
05E9    7AFA          2099     MOV R2 , # 250 
                      2100     	; Check if pwm frequency is 12kHz
05EB    C3            2101     	CLR	C
05EC    E8            2102     MOV A , R0 
05ED    94C8          2103     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            2104     MOV A , R1 
05F0    9400          2105     	SUBB	A, #HIGH(200)
05F2    5008          2106     	JNC	PCA_INT_CHECK_8KHZ
                      2107     
05F4    E4            2108     	CLR	A
05F5    D2E4          2109     SETB ACC . 4 
05F7    FB            2110     MOV R3 , A 
05F8    7A0A          2111     MOV R2 , # 10 
05FA    C13E          2112     	AJMP	PCA_INT_RESTORE_EDGE
                      2113     
                      2114     PCA_INT_CHECK_8KHZ: 
                      2115     	; Check if pwm frequency is 8kHz
05FC    C3            2116     	CLR	C
05FD    E8            2117     MOV A , R0 
05FE    9468          2118     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            2119     MOV A , R1 
0601    9401          2120     	SUBB	A, #HIGH(360)
0603    5008          2121     	JNC	PCA_INT_CHECK_4KHZ
                      2122     
0605    E4            2123     	CLR	A
0606    D2E3          2124     SETB ACC . 3 
0608    FB            2125     MOV R3 , A 
0609    7A0F          2126     MOV R2 , # 15 
060B    C13E          2127     	AJMP	PCA_INT_RESTORE_EDGE
                      2128     
                      2129     PCA_INT_CHECK_4KHZ: 
                      2130     	; Check if pwm frequency is 4kHz
060D    C3            2131     	CLR	C
060E    E8            2132     MOV A , R0 
060F    94D0          2133     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2134     MOV A , R1 
0612    9402          2135     	SUBB	A, #HIGH(720)
0614    5008          2136     	JNC	PCA_INT_CHECK_2KHZ
                      2137     
0616    E4            2138     	CLR	A
0617    D2E2          2139     SETB ACC . 2 
0619    FB            2140     MOV R3 , A 
061A    7A1E          2141     MOV R2 , # 30 
061C    C13E          2142     	AJMP	PCA_INT_RESTORE_EDGE
                      2143     
                      2144     PCA_INT_CHECK_2KHZ: 
                      2145     	; Check if pwm frequency is 2kHz
061E    C3            2146     	CLR	C
061F    E8            2147     MOV A , R0 
0620    94A0          2148     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2149     MOV A , R1 
0623    9405          2150     	SUBB	A, #HIGH(1440)
0625    5008          2151     	JNC	PCA_INT_CHECK_1KHZ
                      2152     
0627    E4            2153     	CLR	A
0628    D2E1          2154     SETB ACC . 1 
062A    FB            2155     MOV R3 , A 
062B    7A3C          2156     MOV R2 , # 60 
062D    C13E          2157     	AJMP	PCA_INT_RESTORE_EDGE
                      2158     
                      2159     PCA_INT_CHECK_1KHZ: 
                      2160     	; Check if pwm frequency is 1kHz
062F    C3            2161     	CLR	C
0630    E8            2162     MOV A , R0 
0631    9498          2163     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2164     MOV A , R1 
0634    9408          2165     	SUBB	A, #HIGH(2200)
0636    5006          2166     	JNC	PCA_INT_RESTORE_EDGE
                      2167     
0638    E4            2168     	CLR	A
0639    D2E0          2169     SETB ACC . 0 
063B    FB            2170     MOV R3 , A 
063C    7A78          2171     MOV R2 , # 120 
                      2172     
                      2173     PCA_INT_RESTORE_EDGE: 
                      2174     	; Calculate difference between this period and previous period
063E    C3            2175     	CLR	C
063F    E8            2176     MOV A , R0 
0640    9556          2177     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2178     MOV R4 , A 
0643    E9            2179     MOV A , R1 
0644    9557          2180     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2181     MOV R5 , A 
                      2182     	; Make positive
0647    30E708        2183     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2184     MOV A , R4 
064B    F4            2185     	CPL	A
064C    2401          2186     	ADD	A, #1
064E    FC            2187     MOV R4 , A 
064F    ED            2188     MOV A , R5 
0650    F4            2189     	CPL	A
0651    FD            2190     MOV R5 , A 
                      2191     
                      2192     PCA_INT_CHECK_DIFF: 
                      2193     	; Check difference
0652    755800        2194     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2195     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2196     
0657    C3            2197     	CLR	C
0658    EC            2198     MOV A , R4 
0659    9A            2199     SUBB A , R2 
065A    5003          2200     	JNC	PCA_INT_STORE_DATA
                      2201     
065C    755801        2202     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2203     
                      2204     PCA_INT_STORE_DATA: 
                      2205     	; Store previous period
065F    8856          2206     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2207     MOV RCP_PREV_PERIOD_H , R1 
                      2208     	; Restore edge data from RAM
0663    A854          2209     MOV R0 , RCP_EDGE_L 
0665    A955          2210     MOV R1 , RCP_EDGE_H 
                      2211     	; Store pre previous edge
0667    8852          2212     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2213     MOV RCP_PREPREV_EDGE_H , R1 
                      2214     
                      2215     PCA_INT_FALL: 
                      2216     	; RC pulse edge was second, calculate new pulse length
066B    C3            2217     	CLR	C
066C    E8            2218     MOV A , R0 
066D    9526          2219     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2220     MOV R0 , A 
0670    E9            2221     MOV A , R1 
0671    9527          2222     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2223     MOV R1 , A 
0674    307402        2224     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2225     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2226     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2227     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2228     
067E    307202        2229     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2230     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2231     
0683    E9            2232     MOV A , R1 
0684    C3            2233     	CLR	C
0685    13            2234     	RRC	A
0686    F9            2235     MOV R1 , A 
0687    E8            2236     MOV A , R0 
0688    13            2237     	RRC	A
0689    F8            2238     MOV R0 , A 
                      2239     
068A    307102        2240     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2241     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2242     
068F    E9            2243     MOV A , R1 
0690    C3            2244     	CLR	C
0691    13            2245     	RRC	A
0692    F9            2246     MOV R1 , A 
0693    E8            2247     MOV A , R0 
0694    13            2248     	RRC	A
0695    F8            2249     MOV R0 , A 
                      2250     
0696    307002        2251     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2252     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2253     
069B    E9            2254     MOV A , R1 
069C    C3            2255     	CLR	C
069D    13            2256     	RRC	A
069E    FD            2257     MOV R5 , A 
069F    E8            2258     MOV A , R0 
06A0    13            2259     	RRC	A
06A1    FC            2260     MOV R4 , A 
                      2261     	; Skip range limitation if pwm frequency measurement
06A2    205918        2262     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2263     
                      2264     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2265     	CLR	C
06A6    EC            2266     MOV A , R4 
06A7    941C          2267     	SUBB	A, #28
06A9    ED            2268     MOV A , R5 
06AA    9402          2269     	SUBB A, #2
06AC    4003          2270     	JC	($+5)						; No - proceed
                      2271     
06AE    0207E1        2272     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2273     
                      2274     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2275     MOV A , R5 
06B2    7009          2276     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2277     
06B4    C3            2278     	CLR	C
06B5    EC            2279     MOV A , R4 
06B6    94C8          2280     	SUBB	A, #200
06B8    5003          2281     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2282     
06BA    0207E1        2283     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2284     
                      2285     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2286     	; Calculate "1000us" plus throttle minimum
06BD    7400          2287     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2288     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2289     
                      2290     IF MODE >= 1	; Tail or multi
06C2    7888          2291     MOV R0 , # PGM_DIRECTION 
06C4    E6            2292     MOV A , @ R0 
                      2293     ENDIF
06C5    7896          2294     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2295     IF MODE >= 1	; Tail or multi
06C7    B40302        2296     	CJNE	A, #3, ($+5)
                      2297     
06CA    789E          2298     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2299     ENDIF
06CC    E6            2300     MOV A , @ R0 
                      2301     
                      2302     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2303     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2304     MOV R6 , A 
06D0    E4            2305     	CLR	A
06D1    3400          2306     	ADDC	A, #0
06D3    FF            2307     MOV R7 , A 
                      2308     
06D4    C3            2309     	CLR	C
06D5    EC            2310     MOV A , R4 
06D6    9E            2311     SUBB A , R6 
06D7    FC            2312     MOV R4 , A 
06D8    ED            2313     MOV A , R5 
06D9    9F            2314     SUBB A , R7 
06DA    FD            2315     MOV R5 , A 
                      2316     IF MODE >= 1	; Tail or multi
06DB    9208          2317     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2318     MOV R0 , # PGM_DIRECTION 
06DF    E6            2319     MOV A , @ R0 
06E0    B40322        2320     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2321     
06E3    A208          2322     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2323     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2324     
                      2325     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2326     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2327     
06EA    C2AF          2328     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2329     SETB FLAGS3 . 5 
06EE    C1F7          2330     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2331     
                      2332     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2333     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2334     
06F3    C2AF          2335     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2336     CLR FLAGS3 . 5 
                      2337     
                      2338     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2339     	ALL_NFETS_OFF
06F7    D297          2339+1   SETB P1 . 7 
06F9    D295          2339+1   SETB P1 . 5 
06FB    D293          2339+1   SETB P1 . 3 
                      2340     	ALL_PFETS_OFF
06FD    C296          2340+1   CLR P1 . 6 
06FF    C294          2340+1   CLR P1 . 4 
0701    C292          2340+1   CLR P1 . 2 
0703    D2AF          2341     	SETB	EA
                      2342     
                      2343     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2344     	MOV	C, BIT_ACCESS_INT.0
                      2345     ENDIF
0707    5017          2346     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2347     
                      2348     IF MODE >= 1	; Tail or multi
0709    E6            2349     MOV A , @ R0 
070A    B4030D        2350     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2351     
070D    EC            2352     MOV A , R4 
070E    F4            2353     	CPL	A
070F    2401          2354     	ADD	A, #1
0711    FC            2355     MOV R4 , A 
0712    ED            2356     MOV A , R5 
0713    F4            2357     	CPL	A
0714    3400          2358     	ADDC	A, #0
0716    FD            2359     MOV R5 , A 
0717    020720        2360     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2361     
                      2362     PCA_INT_PPM_UNIDIR_NEG: 
                      2363     ENDIF
071A    7800          2364     MOV R0 , # 0 
071C    7900          2365     MOV R1 , # 0 
071E    E16A          2366     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2367     
                      2368     PCA_INT_PPM_NEG_CHECKED: 
                      2369     IF MODE >= 1	; Tail or multi
0720    7888          2370     MOV R0 , # PGM_DIRECTION 
0722    E6            2371     MOV A , @ R0 
0723    B40315        2372     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2373     
0726    EC            2374     MOV A , R4 
0727    33            2375     	RLC	A
0728    FC            2376     MOV R4 A 
0729    ED            2377     MOV A , R5 
072A    33            2378     	RLC	A
072B    FD            2379     MOV R5 A 
072C    C3            2380     	CLR	C							; Subtract deadband
072D    EC            2381     MOV A , R4 
072E    9405          2382     	SUBB	A, #5		
0730    FC            2383     MOV R4 , A 
0731    ED            2384     MOV A , R5 
0732    9400          2385     	SUBB	A, #0
0734    FD            2386     MOV R5 , A 
0735    5004          2387     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2388     
0737    7C00          2389     MOV R4 , # 0 
0739    7D00          2390     MOV R5 , # 0 
                      2391     
                      2392     PCA_INT_PPM_BIDIR_DONE: 
                      2393     ENDIF
073B    C3            2394     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2395     MOV A , R4 
073D    94FF          2396     SUBB A , # 255 
073F    ED            2397     MOV A , R5 
0740    9400          2398     	SUBB	A, #0
0742    4006          2399     	JC	PCA_INT_PPM_MAX_CHECKED
                      2400     
0744    78FF          2401     MOV R0 , # 255 
0746    7900          2402     MOV R1 , # 0 
0748    E16A          2403     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2404     
                      2405     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2406     MOV A , R4 
074B    856EF0        2407     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2408     	MUL	AB
074F    C5F0          2409     	XCH	A, B
0751    A2F7          2410     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2411     	RLC	A
0754    F8            2412     MOV R0 , A 
0755    7900          2413     MOV R1 , # 0 
0757    4003          2414     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2415     	
0759    020786        2416     	JMP	PCA_INT_LIMITED			
                      2417     
                      2418     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2419     MOV R0 , # 255 
075E    7900          2420     MOV R1 , # 0 
0760    020786        2421     	JMP	PCA_INT_LIMITED			
                      2422     
                      2423     PCA_INT_PWM_DIVIDE: 
0763    E9            2424     MOV A , R1 
0764    C3            2425     	CLR	C
0765    13            2426     	RRC	A
0766    F9            2427     MOV R1 , A 
0767    E8            2428     MOV A , R0 
0768    13            2429     	RRC	A
0769    F8            2430     MOV R0 , A 
                      2431     
                      2432     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2433     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2434     MOV A , R1 
076E    6002          2435     	JZ	($+4)
                      2436     
0770    78FF          2437     MOV R0 , # 255 
                      2438     
0772    C3            2439     	CLR	C
0773    E8            2440     MOV A , R0 
0774    13            2441     	RRC	A
0775    38            2442     ADDC A , R0 
0776    F8            2443     MOV R0 , A 
0777    E4            2444     	CLR	A
0778    3400          2445     	ADDC	A, #0
077A    F9            2446     MOV R1 , A 
                      2447     
                      2448     PCA_INT_CHECK_LEGAL_RANGE: 
                      2449     	; Check that RC pulse is within legal range
077B    C3            2450     	CLR	C
077C    E8            2451     MOV A , R0 
077D    94FF          2452     SUBB A , # 255 
077F    E9            2453     MOV A , R1 
0780    9400          2454     	SUBB	A, #0
0782    4002          2455     	JC	PCA_INT_LIMITED
                      2456     
0784    78FF          2457     MOV R0 , # 255 
                      2458     
                      2459     PCA_INT_LIMITED: 
                      2460     
                      2461     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2462     ; 
                      2463     ; GetPWM
                      2464     ; Skypup 2015.05.25
                      2465     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2466     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2467     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2468     ; 
                      2469     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2470     PROCEDURE_GETPWM: 
0786    C3            2471     	CLR	C
0787    E8            2472     MOV A , R0 
0788    94A0          2473     SUBB A , # 160 
078A    5005          2474     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
078C    7800          2475     MOV R0 , # 0 
078E    020793        2476     	JMP	SET_PWM_IN
                      2477     SET_PWM_IN_HIGH: 
0791    7801          2478     MOV R0 , # 1 
                      2479     SET_PWM_IN: 
0793    8875          2480     MOV NPWMIN , R0 
                      2481     END_PROCEDURE_GETPWM: 
                      2482     
                      2483     
                      2484     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2485     ;
                      2486     ; 是否解锁
                      2487     ; Skypup 2015.05.26
                      2488     ;
                      2489     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0795    A873          2490     MOV R0 , FLAG_BEFORE_ARM 
0797    B80107        2491     CJNE R0 , # 1 , ELSE_FLAG_BEFORE_ARM 
                      2492     IF_FLAG_BEFORE_ARM: 
079A    78FF          2493     MOV R0 , # 255 
079C    8859          2494     MOV NEW_RCP , R0 
079E    0207CE        2495     	JMP SET_PREV_RCP				; 如果未解锁, 不做后续处理, 直接跳转
                      2496     ELSE_FLAG_BEFORE_ARM: 
                      2497     ; endif_Flag_Before_ARM:
                      2498     
                      2499     
                      2500     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2501     ;
                      2502     ; 例程: 判断是否 PWM_IN_HIGH
                      2503     ;
                      2504     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2505     ;	mov	Temp1, nPWMIn
                      2506     ;	cjne	Temp1, #PWM_IN_HIGH, else_nPWMIn_pwm_in_high
                      2507     ;if_nPWMIn_pwm_in_high:
                      2508     ;	mov	Temp1, Initial_Arm
                      2509     ;	cjne	Temp1, #1, else_Initial_Arm
                      2510     ;  if_Initial_Arm:
                      2511     ;	mov Temp1, #PWM_FULL
                      2512     ;	mov	New_Rcp, Temp1	
                      2513     ;	jmp set_Prev_Rcp		; 如果未解锁, 不做后续处理, 直接跳转
                      2514     ;  else_Initial_Arm:
                      2515     ;	mov	Temp1,  #RCP_MIN
                      2516     ;  endif_INitial_Arm:
                      2517     ;	mov	New_Rcp, Temp1	
                      2518     ;	jmp	endif_nPWMIn_pwm_in_high
                      2519     ;else_nPWMIn_pwm_in_high:
                      2520     ;	; 最低油门
                      2521     ;	mov	Temp1, #RCP_MIN
                      2522     ;	mov	New_Rcp, Temp1	
                      2523     ;	; jmp	endif_nPWMIn_pwm_in_high
                      2524     ;endif_nPWMIn_pwm_in_high:
                      2525     
                      2526     
                      2527     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2528     ;
                      2529     ; 判断 cState 状态
                      2530     ;
                      2531     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2532     ;
07A1    A878          2533     MOV R0 , CSTATE 
07A3    B81007        2534     CJNE R0 , # 16 , ELES_STATE_FULL 
                      2535      IF_STATE_FULL: 
                      2536      	; STATE_FULL
                      2537      	;
                      2538      	; 全油门
07A6    78FF          2539     MOV R0 , # 255 
07A8    8859          2540     MOV NEW_RCP , R0 
                      2541      	; 
07AA    0207CE        2542      	JMP ENDIF_STATE_FULL
                      2543      
                      2544      ELES_STATE_FULL: 
07AD    A878          2545     MOV R0 , CSTATE 
07AF    B82007        2546     CJNE R0 , # 32 , ELSE_STATE_CRUISE 
                      2547      
                      2548     	IF_STATE_CRUISE: 
                      2549     	 	; STATE_FULL
                      2550     	 	;
                      2551     	 	; 巡航油门
07B2    787F          2552     MOV R0 , # 127 
07B4    8859          2553     MOV NEW_RCP , R0 
                      2554     	 	; 
07B6    0207CE        2555     	 	JMP ENDIF_STATE_CRUISE
                      2556      
                      2557     	ELSE_STATE_CRUISE: 
                      2558     	 	; STATE_WAIT
07B9    7800          2559     MOV R0 , # 0 
07BB    8859          2560     MOV NEW_RCP , R0 
                      2561     		;
07BD    A830          2562     MOV R0 , INITIAL_ARM 
07BF    B8000C        2563     CJNE R0 , # 0 , ELSE_INITIAL_ARM 
                      2564     		IF_INITIAL_ARM: 
                      2565     			; 判断是否 PWM_IN_HIGH
07C2    A875          2566     MOV R0 , NPWMIN 
07C4    B80107        2567     CJNE R0 , # 1 , ENDIF_STATE_WAIT_PWM_IN_HIGH 
07C7    7810          2568     MOV R0 , # 16 
07C9    8878          2569     MOV CSTATE , R0 
07CB    0207CE        2570     		 	JMP	ENDIF_INITIAL_ARM
                      2571     			ENDIF_STATE_WAIT_PWM_IN_HIGH: 
                      2572     		ELSE_INITIAL_ARM: 
                      2573     		ENDIF_INITIAL_ARM: 
                      2574     	ENDIF_STATE_CRUISE:  
                      2575     ENDIF_STATE_FULL: 
                      2576     
                      2577     
                      2578     SET_PREV_RCP: 
                      2579     	; 记录 New_Rcp 值
07CE    E559          2580     	MOV A, NEW_RCP
07D0    F574          2581     	MOV PREV_RCP, A
                      2582     
                      2583     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2584     	; RC pulse value accepted
                      2585     	; mov	New_Rcp, Temp1				; Store new pulse length
07D2    D268          2586     SETB FLAGS2 . 0 
07D4    205902        2587     JB FLAGS0 . 1 , ( $+5 ) 
07D7    E1E1          2588     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2589     
07D9    741F          2590     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07DB    F4            2591     	CPL	A
07DC    552E          2592     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07DE    4B            2593     ORL A , R3 
07DF    F52E          2594     	MOV	FLAGS3, A
                      2595     
                      2596     PCA_INT_SET_TIMEOUT: 
07E1    752818        2597     MOV RCP_TIMEOUT_CNT , # 24 
07E4    741F          2598     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07E6    552E          2599     	ANL	A, FLAGS3					; Check pwm frequency flags
07E8    7003          2600     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2601     
07EA    75280A        2602     MOV RCP_TIMEOUT_CNT , # 10 
                      2603     
                      2604     PCA_INT_PPM_TIMEOUT_SET: 
07ED    305902        2605     JNB FLAGS0 . 1 , ( $+5 ) 
07F0    E1FB          2606     	AJMP PCA_INT_EXIT				; Yes - exit
                      2607     
07F2    741F          2608     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07F4    552E          2609     	ANL	A, FLAGS3					; Check pwm frequency flags
07F6    6003          2610     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2611     
                      2612     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07F8    53DAFE        2612+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2613     
                      2614     PCA_INT_EXIT: 	; Exit interrupt routine	
07FB    752906        2615     MOV RCP_SKIP_CNT , # 6 
07FE    741F          2616     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0800    552E          2617     	ANL	A, FLAGS3					; Check pwm frequency flags
0802    7003          2618     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2619     
0804    75290A        2620     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2621     
0807    D0F0          2622     	POP	B			; Restore preserved registers
0809    D0E0          2623     	POP	ACC			
080B    D0D0          2624     	POP	PSW
080D    C2D3          2625     	CLR	PSW.3		; Select register bank 0 for main program routines	
080F    D2AD          2626     	SETB	ET2			; Enable timer2 interrupts
0811    43E610        2627     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0814    32            2628     	RETI
                      2629     
                      2630     
                      2631     
                      2632     
                      2633     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2634     ;
                      2635     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2636     ;
                      2637     ; No assumptions
                      2638     ;
                      2639     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2640     WAIT1MS: 	
0815    7901          2641     MOV R1 , # 1 
0817    020833        2642     	JMP	WAITXMS_O
                      2643     
                      2644     WAIT3MS: 	
081A    7903          2645     MOV R1 , # 3 
081C    020833        2646     	JMP	WAITXMS_O
                      2647     
                      2648     WAIT10MS: 	
081F    790A          2649     MOV R1 , # 10 
0821    020833        2650     	JMP	WAITXMS_O
                      2651     
                      2652     WAIT30MS: 	
0824    791E          2653     MOV R1 , # 30 
0826    020833        2654     	JMP	WAITXMS_O
                      2655     
                      2656     WAIT100MS: 	
0829    7964          2657     MOV R1 , # 100 
082B    020833        2658     	JMP	WAITXMS_O
                      2659     
                      2660     WAIT200MS: 	
082E    79C8          2661     MOV R1 , # 200 
0830    020833        2662     	JMP	WAITXMS_O
                      2663     
                      2664     WAITXMS_O: 	; Outer loop
0833    7817          2665     MOV R0 , # 23 
                      2666     WAITXMS_M: 	; Middle loop
0835    E4            2667     	CLR	A
0836    D5E0FD        2668      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0839    D8FA          2669     DJNZ R0 , WAITXMS_M 
083B    D9F6          2670     DJNZ R1 , WAITXMS_O 
083D    22            2671     	RET
                      2672     
                      2673     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2674     ;
                      2675     ; Wait 1 second routine
                      2676     ;
                      2677     ; No assumptions
                      2678     ;
                      2679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2680     WAIT1S: 
083E    7C05          2681     MOV R4 , # 5 
                      2682     WAIT1S_LOOP: 
0840    112E          2683     	CALL WAIT200MS
0842    DCFC          2684     DJNZ R4 , WAIT1S_LOOP 
0844    22            2685     	RET
                      2686     
                      2687     
                      2688     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2689     ;
                      2690     ; Beeper routines (4 different entry points) 
                      2691     ;
                      2692     ; No assumptions
                      2693     ;
                      2694     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2695     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0845    7A14          2696     MOV R2 , # 20 
0847    7B78          2697     MOV R3 , # 120 
0849    020861        2698     	JMP	BEEP
                      2699     
                      2700     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
084C    7A10          2701     MOV R2 , # 16 
084E    7B8C          2702     MOV R3 , # 140 
0850    020861        2703     	JMP	BEEP
                      2704     
                      2705     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0853    7A0D          2706     MOV R2 , # 13 
0855    7BB4          2707     MOV R3 , # 180 
0857    020861        2708     	JMP	BEEP
                      2709     
                      2710     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
085A    7A0B          2711     MOV R2 , # 11 
085C    7BC8          2712     MOV R3 , # 200 
085E    020861        2713     	JMP	BEEP
                      2714     
                      2715     BEEP: 	; Beep loop start
0861    AC25          2716     MOV R4 , CURRENT_PWM_LIMITED 
0863    752501        2717     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0866    7902          2718     MOV R1 , # 2 
                      2719     BEEP_ONOFF: 
0868    B275          2720     CPL FLAGS3 . 5 
086A    E4            2721     	CLR	A
                      2722     	BPFET_OFF			; BpFET off
086B    C294          2722+1   CLR P1 . 4 
086D    D5E0FD        2723     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2724     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0870    E525          2724+1   MOV A , CURRENT_PWM_LIMITED 
0872    6002          2724+1   JZ ( $+4 ) 
0874    C295          2724+1   CLR P1 . 5 
0876    D5E0FD        2725     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2726     	BNFET_OFF			; BnFET off again
0879    D295          2726+1   SETB P1 . 5 
087B    D5E0FD        2727     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2728     	BPFET_ON			; BpFET on
087E    D294          2728+1   SETB P1 . 4 
0880    D5E0FD        2729     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2730     	; Turn on nfet
                      2731     	ANFET_ON			; AnFET on
0883    E525          2731+1   MOV A , CURRENT_PWM_LIMITED 
0885    600A          2731+1   JZ ( $+12 ) 
0887    207502        2731+1   JB FLAGS3 . 5 , ( $+5 ) 
088A    C297          2731+1   CLR P1 . 7 
088C    307502        2731+1   JNB FLAGS3 . 5 , ( $+5 ) 
088F    C293          2731+1   CLR P1 . 3 
0891    E56F          2732     	MOV	A, BEEP_STRENGTH
0893    D5E0FD        2733     	DJNZ	ACC, $		
                      2734     	; Turn off nfet
                      2735     	ANFET_OFF			; AnFET off
0896    207502        2735+1   JB FLAGS3 . 5 , ( $+5 ) 
0899    D297          2735+1   SETB P1 . 7 
089B    307502        2735+1   JNB FLAGS3 . 5 , ( $+5 ) 
089E    D293          2735+1   SETB P1 . 3 
08A0    7496          2736     	MOV	A, #150		; 25s off
08A2    D5E0FD        2737     	DJNZ	ACC, $		
08A5    D9C1          2738     DJNZ R1 , BEEP_ONOFF 
                      2739     	; Copy variable
08A7    EA            2740     MOV A , R2 
08A8    F8            2741     MOV R0 , A 
                      2742     BEEP_OFF: 		; Fets off loop
08A9    D5E0FD        2743     	DJNZ	ACC, $
08AC    D8FB          2744     DJNZ R0 , BEEP_OFF 
08AE    DBB1          2745     DJNZ R3 , BEEP 
                      2746     	BPFET_OFF			; BpFET off
08B0    C294          2746+1   CLR P1 . 4 
08B2    8C25          2747     MOV CURRENT_PWM_LIMITED , R4 
08B4    22            2748     	RET
                      2749     
                      2750     
                      2751     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2752     ;
                      2753     ; Division 16bit unsigned by 16bit unsigned
                      2754     ;
                      2755     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2756     ; Result will be in Temp2/Temp1
                      2757     ;
                      2758     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2759     DIV_U16_BY_U16: 	
08B5    C3            2760     	CLR	C       
08B6    7C00          2761     MOV R4 , # 0 
08B8    7D00          2762     MOV R5 , # 0 
08BA    75F000        2763     	MOV	B, #0
                      2764     DIV_U16_BY_U16_DIV1: 
08BD    05F0          2765     	INC	B      			; Increment counter for each left shift
08BF    EA            2766     MOV A , R2 
08C0    33            2767     	RLC	A      		
08C1    FA            2768     MOV R2 , A 
08C2    EB            2769     MOV A , R3 
08C3    33            2770     	RLC	A      	  	
08C4    FB            2771     MOV R3 , A 
08C5    50F6          2772     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2773     DIV_U16_BY_U16_DIV2:         
08C7    EB            2774     MOV A , R3 
08C8    13            2775     	RRC	A      
08C9    FB            2776     MOV R3 , A 
08CA    EA            2777     MOV A , R2 
08CB    13            2778     	RRC	A      
08CC    FA            2779     MOV R2 , A 
08CD    C3            2780     	CLR	C      
08CE    E9            2781     MOV A , R1 
08CF    FF            2782     MOV R7 , A 
08D0    E8            2783     MOV A , R0 
08D1    FE            2784     MOV R6 , A 
08D2    E8            2785     MOV A , R0 
08D3    9A            2786     SUBB A , R2 
08D4    F8            2787     MOV R0 , A 
08D5    E9            2788     MOV A , R1 
08D6    9B            2789     SUBB A , R3 
08D7    F9            2790     MOV R1 , A 
08D8    5004          2791     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08DA    EF            2792     MOV A , R7 
08DB    F9            2793     MOV R1 , A 
08DC    EE            2794     MOV A , R6 
08DD    F8            2795     MOV R0 , A 
                      2796     DIV_U16_BY_U16_DIV3: 
08DE    B3            2797     	CPL	C      			; Invert carry, so it can be directly copied into result
08DF    EC            2798     MOV A , R4 
08E0    33            2799     	RLC	A      			; Shift carry flag into temporary result
08E1    FC            2800     MOV R4 , A 
08E2    ED            2801     MOV A , R5 
08E3    33            2802     	RLC	A
08E4    FD            2803     MOV R5 , A 
08E5    D5F0DF        2804     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08E8    ED            2805     MOV A , R5 
08E9    F9            2806     MOV R1 , A 
08EA    EC            2807     MOV A , R4 
08EB    F8            2808     MOV R0 , A 
08EC    22            2809     	RET
                      2810     
                      2811     
                      2812     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2813     ;
                      2814     ; Multiplication 16bit signed by 8bit unsigned
                      2815     ;
                      2816     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2817     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2818     ;
                      2819     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2820     MULT_S16_BY_U8_DIV_16: 
08ED    E8            2821     MOV A , R0 
08EE    89F0          2822     MOV B , R1 
08F0    8A20          2823     MOV BIT_ACCESS , R2 
08F2    D2D4          2824     	SETB	PSW.4		; Select register bank 2 for math routines
08F4    F8            2825     MOV R0 , A 
08F5    A9F0          2826     MOV R1 , B 
08F7    7B00          2827     MOV R3 , # 0 
08F9    30F70B        2828     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2829     
08FC    7BFF          2830     MOV R3 , # 0FFH 
08FE    F4            2831     	CPL	A
08FF    2401          2832     	ADD	A, #1
0901    F8            2833     MOV R0 , A 
0902    E9            2834     MOV A , R1 
0903    F4            2835     	CPL	A
0904    3400          2836     	ADDC	A, #0
0906    F9            2837     MOV R1 , A 
                      2838     MULT_S16_BY_U8_POSITIVE: 
0907    E8            2839     MOV A , R0 
0908    8520F0        2840     	MOV	B, BIT_ACCESS
090B    A4            2841     	MUL	AB
090C    ADF0          2842     MOV R5 , B 
090E    F8            2843     MOV R0 , A 
090F    E9            2844     MOV A , R1 
0910    8520F0        2845     	MOV	B, BIT_ACCESS
0913    A4            2846     	MUL	AB
0914    AFF0          2847     MOV R7 , B 
0916    FE            2848     MOV R6 , A 
0917    ED            2849     MOV A , R5 
0918    2E            2850     ADD A , R6 
0919    F9            2851     MOV R1 , A 
091A    7400          2852     	MOV	A, #0
091C    3F            2853     ADDC A , R7 
091D    FA            2854     MOV R2 , A 
091E    7C04          2855     MOV R4 , # 4 
                      2856     MULT_S16_BY_U8_DIV_LOOP: 
0920    C3            2857     	CLR	C			; Rotate right 
0921    EA            2858     MOV A , R2 
0922    13            2859     	RRC	A
0923    FA            2860     MOV R2 , A 
0924    E9            2861     MOV A , R1 
0925    13            2862     	RRC	A
0926    F9            2863     MOV R1 , A 
0927    E8            2864     MOV A , R0 
0928    13            2865     	RRC	A
0929    F8            2866     MOV R0 , A 
092A    DCF4          2867     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2868     
092C    8BF0          2869     MOV B , R3 
092E    30F70A        2870     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2871     
0931    E8            2872     MOV A , R0 
0932    F4            2873     	CPL	A
0933    2401          2874     	ADD	A, #1
0935    F8            2875     MOV R0 , A 
0936    E9            2876     MOV A , R1 
0937    F4            2877     	CPL	A
0938    3400          2878     	ADDC	A, #0
093A    F9            2879     MOV R1 , A 
                      2880     
                      2881     MULT_S16_BY_U8_EXIT: 
093B    E8            2882     MOV A , R0 
093C    89F0          2883     MOV B , R1 
093E    C2D4          2884     	CLR	PSW.4		; Select normal register bank
0940    F8            2885     MOV R0 , A 
0941    A9F0          2886     MOV R1 , B 
0943    22            2887     	RET
                      2888     
                      2889     
                      2890     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2891     ;
                      2892     ; Calculate governor routines
                      2893     ;
                      2894     ; No assumptions
                      2895     ;
                      2896     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2897     ; The governor task is split into several routines in order to distribute processing time
                      2898     ;
                      2899     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2900     ; First governor routine - calculate governor target
                      2901     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3041     IF MODE == 2	; Multi
                      3042     CALC_GOVERNOR_TARGET: 
0944    7882          3043     MOV R0 , # PGM_GOV_MODE 
0946    B60403        3044     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0949    0209A0        3045     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3046     
                      3047     GOVERNOR_TARGET_CALC: 
                      3048     	; Stop governor for stop RC pulse	
094C    C3            3049     	CLR	C
094D    E559          3050     	MOV	A, NEW_RCP				; Check RC pulse against stop value
094F    9401          3051     SUBB A , # 1 
0951    4003          3052     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3053     
0953    020969        3054     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3055     
                      3056     GOVERNOR_DEACTIVATE: 
0956    852224        3057     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0959    E4            3058     	CLR	A
095A    F540          3059     	MOV	GOV_TARGET_L, A			; Set target to zero
095C    F541          3060     	MOV	GOV_TARGET_H, A
095E    F542          3061     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0960    F543          3062     	MOV	GOV_INTEGRAL_H, A
0962    F544          3063     	MOV	GOV_INTEGRAL_X, A
0964    F549          3064     	MOV	GOV_ACTIVE, A
0966    0209A0        3065     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3066     
                      3067     GOVERNOR_ACTIVATE: 
0969    7882          3068     MOV R0 , # PGM_GOV_MODE 
096B    E6            3069     MOV A , @ R0 
096C    FC            3070     MOV R4 , A 
096D    754901        3071     	MOV	GOV_ACTIVE, #1
0970    E522          3072     	MOV	A, REQUESTED_PWM			; Load requested pwm
0972    F523          3073     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3074     	; Calculate comm period target 2*(51000/Requested_Pwm)
0974    7838          3075     MOV R0 , # 38H 
0976    79C7          3076     MOV R1 , # 0C7H 
0978    AA3C          3077     MOV R2 , COMM_PERIOD4X_L 
097A    AB3D          3078     MOV R3 , COMM_PERIOD4X_H 
                      3079     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
097C    C3            3080     	CLR	C
097D    EB            3081     MOV A , R3 
097E    13            3082     	RRC	A
097F    FB            3083     MOV R3 , A 
0980    EA            3084     MOV A , R2 
0981    13            3085     	RRC	A
0982    FA            3086     MOV R2 , A 
                      3087     	; Check range
0983    EC            3088     MOV A , R4 
0984    14            3089     	DEC	A
0985    6013          3090     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3091     GOVERNOR_ACTIVATE_100K: 
0987    C3            3092     	CLR	C
0988    EB            3093     MOV A , R3 
0989    13            3094     	RRC	A
098A    FB            3095     MOV R3 , A 
098B    EA            3096     MOV A , R2 
098C    13            3097     	RRC	A
098D    FA            3098     MOV R2 , A 
098E    EC            3099     MOV A , R4 
098F    14            3100     	DEC	A
0990    14            3101     	DEC	A
0991    6007          3102     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3103     GOVERNOR_ACTIVATE_50K: 
0993    C3            3104     	CLR	C
0994    EB            3105     MOV A , R3 
0995    13            3106     	RRC	A
0996    FB            3107     MOV R3 , A 
0997    EA            3108     MOV A , R2 
0998    13            3109     	RRC	A
0999    FA            3110     MOV R2 , A 
                      3111     GOVERNOR_ACTIVATE_RANGE_SET: 
099A    11B5          3112     	CALL	DIV_U16_BY_U16
                      3113     	; Store governor target
099C    8840          3114     MOV GOV_TARGET_L , R0 
099E    8941          3115     MOV GOV_TARGET_H , R1 
                      3116     CALC_GOVERNOR_TARGET_EXIT: 
09A0    22            3117     	RET						
                      3118     ENDIF
                      3119     
                      3120     
                      3121     ; Second governor routine - calculate governor proportional error
                      3122     CALC_GOVERNOR_PROP_ERROR: 
                      3123     	; Exit if governor is inactive
09A1    E549          3124     	MOV	A, GOV_ACTIVE
09A3    6034          3125     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3126     
                      3127     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3145     IF MODE == 2	; Multi
                      3146     	; Calculate error
09A5    C3            3147     	CLR	C
09A6    E540          3148     	MOV	A, GOV_TARGET_L
09A8    9523          3149     	SUBB	A, GOVERNOR_REQ_PWM
09AA    F8            3150     MOV R0 , A 
09AB    E541          3151     	MOV	A, GOV_TARGET_H
09AD    9400          3152     	SUBB	A, #0
09AF    F9            3153     MOV R1 , A 
                      3154     ENDIF
                      3155     	; Check error and limit
09B0    500C          3156     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3157     
09B2    C3            3158     	CLR	C
09B3    E8            3159     MOV A , R0 
09B4    9480          3160     	SUBB	A, #80H					; Is error too negative?
09B6    E9            3161     MOV A , R1 
09B7    94FF          3162     	SUBB	A, #0FFH
09B9    4016          3163     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
09BB    0209D5        3164     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3165     
                      3166     GOVERNOR_CHECK_PROP_LIMIT_POS: 
09BE    C3            3167     	CLR	C
09BF    E8            3168     MOV A , R0 
09C0    947F          3169     	SUBB	A, #7FH					; Is error too positive?
09C2    E9            3170     MOV A , R1 
09C3    9400          3171     	SUBB	A, #00H
09C5    5003          3172     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
09C7    0209D5        3173     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3174     
                      3175     GOVERNOR_LIMIT_PROP_ERROR_POS: 
09CA    787F          3176     MOV R0 , # 7FH 
09CC    7900          3177     MOV R1 , # 00H 
09CE    0209D5        3178     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3179     
                      3180     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09D1    7880          3181     MOV R0 , # 80H 
09D3    79FF          3182     MOV R1 , # 0FFH 
                      3183     
                      3184     GOVERNOR_STORE_PROP_ERROR: 
                      3185     	; Store proportional
09D5    8845          3186     MOV GOV_PROPORTIONAL_L , R0 
09D7    8946          3187     MOV GOV_PROPORTIONAL_H , R1 
                      3188     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09D9    22            3189     	RET						
                      3190     
                      3191     
                      3192     ; Third governor routine - calculate governor integral error
                      3193     CALC_GOVERNOR_INT_ERROR: 
                      3194     	; Exit if governor is inactive
09DA    E549          3195     	MOV	A, GOV_ACTIVE
09DC    6058          3196     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3197     
                      3198     	; Add proportional to integral
09DE    E545          3199     	MOV	A, GOV_PROPORTIONAL_L
09E0    2542          3200     	ADD	A, GOV_INTEGRAL_L
09E2    F8            3201     MOV R0 , A 
09E3    E546          3202     	MOV	A, GOV_PROPORTIONAL_H
09E5    3543          3203     	ADDC	A, GOV_INTEGRAL_H
09E7    F9            3204     MOV R1 , A 
09E8    854620        3205     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09EB    E4            3206     	CLR	A
09EC    300701        3207     	JNB	BIT_ACCESS.7, ($+4)			
09EF    F4            3208     	CPL	A
09F0    3544          3209     	ADDC	A, GOV_INTEGRAL_X
09F2    FA            3210     MOV R2 , A 
                      3211     	; Check integral and limit
09F3    30E709        3212     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3213     
09F6    C3            3214     	CLR	C
09F7    EA            3215     MOV A , R2 
09F8    94F0          3216     	SUBB	A, #0F0H					; Is error too negative?
09FA    4015          3217     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09FC    020A17        3218     	JMP	GOVERNOR_CHECK_PWM
                      3219     
                      3220     GOVERNOR_CHECK_INT_LIMIT_POS: 
09FF    C3            3221     	CLR	C
0A00    EA            3222     MOV A , R2 
0A01    940F          3223     	SUBB	A, #0FH					; Is error too positive?
0A03    5003          3224     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0A05    020A17        3225     	JMP	GOVERNOR_CHECK_PWM
                      3226     
                      3227     GOVERNOR_LIMIT_INT_ERROR_POS: 
0A08    78FF          3228     MOV R0 , # 0FFH 
0A0A    79FF          3229     MOV R1 , # 0FFH 
0A0C    7A0F          3230     MOV R2 , # 0FH 
0A0E    020A17        3231     	JMP	GOVERNOR_CHECK_PWM
                      3232     
                      3233     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0A11    7800          3234     MOV R0 , # 00H 
0A13    7900          3235     MOV R1 , # 00H 
0A15    7AF0          3236     MOV R2 , # 0F0H 
                      3237     
                      3238     GOVERNOR_CHECK_PWM: 
                      3239     	; Check current pwm
0A17    C3            3240     	CLR	C
0A18    E524          3241     	MOV	A, CURRENT_PWM
0A1A    955E          3242     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0A1C    5006          3243     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3244     
0A1E    E524          3245     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0A20    6009          3246     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3247     
0A22    4130          3248     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3249     
                      3250     GOVERNOR_INT_MAX_PWM: 
0A24    E546          3251     	MOV	A, GOV_PROPORTIONAL_H
0A26    20E70D        3252     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3253     
0A29    4130          3254     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3255     
                      3256     GOVERNOR_INT_MIN_PWM: 
0A2B    E546          3257     	MOV	A, GOV_PROPORTIONAL_H
0A2D    30E706        3258     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3259     
                      3260     GOVERNOR_STORE_INT_ERROR: 
                      3261     	; Store integral
0A30    8842          3262     MOV GOV_INTEGRAL_L , R0 
0A32    8943          3263     MOV GOV_INTEGRAL_H , R1 
0A34    8A44          3264     MOV GOV_INTEGRAL_X , R2 
                      3265     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A36    22            3266     	RET						
                      3267     
                      3268     
                      3269     ; Fourth governor routine - calculate governor proportional correction
                      3270     CALC_GOVERNOR_PROP_CORRECTION: 
                      3271     	; Exit if governor is inactive
0A37    E549          3272     	MOV	A, GOV_ACTIVE
0A39    7003          3273     	JNZ	CALC_GOVERNOR_PROP_CORR
0A3B    020A9A        3274     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3275     
                      3276     CALC_GOVERNOR_PROP_CORR: 
                      3277     	; Load proportional gain
0A3E    789F          3278     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A40    E6            3279     MOV A , @ R0 
0A41    FA            3280     MOV R2 , A 
                      3281     	; Load proportional
0A42    C3            3282     	CLR	C
0A43    E545          3283     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A45    33            3284     	RLC	A
0A46    F8            3285     MOV R0 , A 
0A47    E546          3286     	MOV	A, GOV_PROPORTIONAL_H
0A49    33            3287     	RLC	A
0A4A    F9            3288     MOV R1 , A 
                      3289     	; Apply gain
0A4B    11ED          3290     	CALL	MULT_S16_BY_U8_DIV_16
                      3291     	; Check error and limit (to low byte)
0A4D    E9            3292     MOV A , R1 
0A4E    30E70B        3293     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3294     
0A51    C3            3295     	CLR	C
0A52    E8            3296     MOV A , R0 
0A53    9480          3297     	SUBB	A, #80H					; Is error too negative?
0A55    E9            3298     MOV A , R1 
0A56    94FF          3299     	SUBB	A, #0FFH
0A58    4013          3300     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A5A    4171          3301     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3302     
                      3303     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A5C    C3            3304     	CLR	C
0A5D    E8            3305     MOV A , R0 
0A5E    947F          3306     	SUBB	A, #7FH					; Is error too positive?
0A60    E9            3307     MOV A , R1 
0A61    9400          3308     	SUBB	A, #00H
0A63    5002          3309     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A65    4171          3310     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3311     
                      3312     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A67    787F          3313     MOV R0 , # 7FH 
0A69    7900          3314     MOV R1 , # 00H 
0A6B    4171          3315     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3316     
                      3317     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A6D    7880          3318     MOV R0 , # 80H 
0A6F    79FF          3319     MOV R1 , # 0FFH 
                      3320     
                      3321     GOVERNOR_APPLY_PROP_CORR: 
                      3322     	; Test proportional sign
0A71    E8            3323     MOV A , R0 
0A72    20E715        3324     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3325     
                      3326     	; Subtract positive proportional
0A75    C3            3327     	CLR	C
0A76    E523          3328     	MOV	A, GOVERNOR_REQ_PWM
0A78    98            3329     SUBB A , R0 
0A79    F8            3330     MOV R0 , A 
                      3331     	; Check result
0A7A    4009          3332     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3333     
0A7C    C3            3334     	CLR	C
0A7D    E8            3335     MOV A , R0 
0A7E    9401          3336     	SUBB	A, #1
0A80    4003          3337     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A82    020A98        3338     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3339     
                      3340     GOVERNOR_CORR_PROP_MIN_PWM: 
0A85    7801          3341     MOV R0 , # 1 
0A87    020A98        3342     	JMP	GOVERNOR_STORE_PROP_CORR
                      3343     
                      3344     GOVERNOR_CORR_NEG_PROP: 
                      3345     	; Add negative proportional
0A8A    E8            3346     MOV A , R0 
0A8B    F4            3347     	CPL	A
0A8C    2401          3348     	ADD	A, #1
0A8E    2523          3349     	ADD	A, GOVERNOR_REQ_PWM
0A90    F8            3350     MOV R0 , A 
                      3351     	; Check result
0A91    4003          3352     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A93    020A98        3353     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3354     
                      3355     GOVERNOR_CORR_PROP_MAX_PWM: 
0A96    78FF          3356     MOV R0 , # 255 
                      3357     GOVERNOR_STORE_PROP_CORR: 
                      3358     	; Store proportional pwm
0A98    8847          3359     MOV GOV_PROP_PWM , R0 
                      3360     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A9A    22            3361     	RET
                      3362     
                      3363     
                      3364     ; Fifth governor routine - calculate governor integral correction
                      3365     CALC_GOVERNOR_INT_CORRECTION: 
                      3366     	; Exit if governor is inactive
0A9B    E549          3367     	MOV	A, GOV_ACTIVE
0A9D    7003          3368     	JNZ	CALC_GOVERNOR_INT_CORR
0A9F    020AFC        3369     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3370     
                      3371     CALC_GOVERNOR_INT_CORR: 
                      3372     	; Load integral gain
0AA2    78A0          3373     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0AA4    E6            3374     MOV A , @ R0 
0AA5    FA            3375     MOV R2 , A 
                      3376     	; Load integral
0AA6    A843          3377     MOV R0 , GOV_INTEGRAL_H 
0AA8    A944          3378     MOV R1 , GOV_INTEGRAL_X 
                      3379     	; Apply gain
0AAA    11ED          3380     	CALL	MULT_S16_BY_U8_DIV_16
                      3381     	; Check integral and limit
0AAC    E9            3382     MOV A , R1 
0AAD    30E70C        3383     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3384     
0AB0    C3            3385     	CLR	C
0AB1    E8            3386     MOV A , R0 
0AB2    9401          3387     	SUBB	A, #01H					; Is integral too negative?
0AB4    E9            3388     MOV A , R1 
0AB5    94FF          3389     	SUBB	A, #0FFH
0AB7    4016          3390     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0AB9    020AD3        3391     	JMP	GOVERNOR_APPLY_INT_CORR
                      3392     
                      3393     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0ABC    C3            3394     	CLR	C
0ABD    E8            3395     MOV A , R0 
0ABE    94FF          3396     	SUBB	A, #0FFH					; Is integral too positive?
0AC0    E9            3397     MOV A , R1 
0AC1    9400          3398     	SUBB	A, #00H
0AC3    5003          3399     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0AC5    020AD3        3400     	JMP	GOVERNOR_APPLY_INT_CORR
                      3401     
                      3402     GOVERNOR_LIMIT_INT_CORR_POS: 
0AC8    78FF          3403     MOV R0 , # 0FFH 
0ACA    7900          3404     MOV R1 , # 00H 
0ACC    020AD3        3405     	JMP	GOVERNOR_APPLY_INT_CORR
                      3406     
                      3407     GOVERNOR_LIMIT_INT_CORR_NEG: 
0ACF    7801          3408     MOV R0 , # 01H 
0AD1    79FF          3409     MOV R1 , # 0FFH 
                      3410     
                      3411     GOVERNOR_APPLY_INT_CORR: 
                      3412     	; Test integral sign
0AD3    E9            3413     MOV A , R1 
0AD4    20E715        3414     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3415     
                      3416     	; Subtract positive integral
0AD7    C3            3417     	CLR	C
0AD8    E547          3418     	MOV	A, GOV_PROP_PWM
0ADA    98            3419     SUBB A , R0 
0ADB    F8            3420     MOV R0 , A 
                      3421     	; Check result
0ADC    4009          3422     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3423     
0ADE    C3            3424     	CLR	C
0ADF    E8            3425     MOV A , R0 
0AE0    9401          3426     	SUBB	A, #1
0AE2    4003          3427     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0AE4    020AFA        3428     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3429     
                      3430     GOVERNOR_CORR_INT_MIN_PWM: 
0AE7    7800          3431     MOV R0 , # 0 
0AE9    020AFA        3432     	JMP	GOVERNOR_STORE_INT_CORR
                      3433     
                      3434     GOVERNOR_CORR_NEG_INT: 
                      3435     	; Add negative integral
0AEC    E8            3436     MOV A , R0 
0AED    F4            3437     	CPL	A
0AEE    2401          3438     	ADD	A, #1
0AF0    2547          3439     	ADD	A, GOV_PROP_PWM
0AF2    F8            3440     MOV R0 , A 
                      3441     	; Check result
0AF3    4003          3442     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AF5    020AFA        3443     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3444     
                      3445     GOVERNOR_CORR_INT_MAX_PWM: 
0AF8    78FF          3446     MOV R0 , # 255 
                      3447     GOVERNOR_STORE_INT_CORR: 
                      3448     	; Store current pwm
0AFA    8824          3449     MOV CURRENT_PWM , R0 
                      3450     CALC_GOVERNOR_INT_CORR_EXIT: 
0AFC    22            3451     	RET
                      3452     
                      3453     
                      3454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3455     ;
                      3456     ; Measure lipo cells
                      3457     ;
                      3458     ; No assumptions
                      3459     ;
                      3460     ; Measure voltage and calculate lipo cells
                      3461     ;
                      3462     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3463     MEASURE_LIPO_CELLS: 
                      3464     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3468     MEASURE_LIPO_START: 
                      3469     	; Load programmed low voltage limit
0AFD    7883          3470     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AFF    E6            3471     MOV A , @ R0 
0B00    F520          3472     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3473     	; Set commutation to BpFET on
0B02    12105E        3474     	CALL	COMM5COMM6			
                      3475     	; Start adc
                      3476     	START_ADC 
0B05    75E890        3476+1   MOV ADC0CN , # 90H  ; ADC START
                      3477     	; Wait for ADC reference to settle, and then start again
0B08    1115          3478     	CALL	WAIT1MS
                      3479     	START_ADC
0B0A    75E890        3479+1   MOV ADC0CN , # 90H  ; ADC START
                      3480     	; Wait for ADC conversion to complete
                      3481     MEASURE_LIPO_WAIT_ADC: 
                      3482     	GET_ADC_STATUS 
0B0D    E5E8          3482+1   MOV A , ADC0CN 
0B0F    20ECFB        3483     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3484     	; Read ADC result
                      3485     	READ_ADC_RESULT
0B12    A8BD          3485+1   MOV R0 , ADC0L 
0B14    A9BE          3485+1   MOV R1 , ADC0H 
                      3486     	; Stop ADC
                      3487     	STOP_ADC
                      3488     	; Switch power off
0B16    121116        3489     	CALL	SWITCH_POWER_OFF		
                      3490     	; Set limit step
0B19    756A55        3491     MOV LIPO_ADC_LIMIT_L , # 85 
0B1C    756B00        3492     MOV LIPO_ADC_LIMIT_H , # 0 
0B1F    C3            3493     	CLR	C
0B20    7400          3494     MOV A , # 0 
0B22    13            3495     	RRC	A
0B23    FD            3496     MOV R5 , A 
0B24    7455          3497     MOV A , # 85 
0B26    13            3498     	RRC	A
0B27    FC            3499     MOV R4 , A 
0B28    7455          3500     MOV A , # 85 
0B2A    2C            3501     ADD A , R4 
0B2B    FC            3502     MOV R4 , A 
0B2C    7400          3503     MOV A , # 0 
0B2E    3D            3504     ADDC A , R5 
0B2F    FD            3505     MOV R5 , A 
0B30    EC            3506     MOV A , R4 
0B31    FA            3507     MOV R2 , A 
0B32    ED            3508     MOV A , R5 
0B33    FB            3509     MOV R3 , A 
                      3510     MEASURE_LIPO_CELL_LOOP: 
                      3511     	; Check voltage against xS lower limit
0B34    C3            3512     	CLR	C
0B35    E8            3513     MOV A , R0 
0B36    9A            3514     SUBB A , R2 
0B37    E9            3515     MOV A , R1 
0B38    9B            3516     SUBB A , R3 
0B39    4014          3517     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3518     
                      3519     	; Set xS voltage limit
0B3B    E56A          3520     	MOV	A, LIPO_ADC_LIMIT_L		
0B3D    2455          3521     ADD A , # 85 
0B3F    F56A          3522     	MOV	LIPO_ADC_LIMIT_L, A
0B41    E56B          3523     	MOV	A, LIPO_ADC_LIMIT_H		
0B43    3400          3524     ADDC A , # 0 
0B45    F56B          3525     	MOV	LIPO_ADC_LIMIT_H, A
                      3526     	; Set (x+1)S lower limit
0B47    EA            3527     MOV A , R2 
0B48    2C            3528     ADD A , R4 
0B49    FA            3529     MOV R2 , A 
0B4A    EB            3530     MOV A , R3 
0B4B    3D            3531     ADDC A , R5 
0B4C    FB            3532     MOV R3 , A 
0B4D    80E5          3533     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3534     
                      3535     MEASURE_LIPO_ADJUST: 
0B4F    AE6A          3536     MOV R6 , LIPO_ADC_LIMIT_L 
0B51    AF6B          3537     MOV R7 , LIPO_ADC_LIMIT_H 
                      3538     	; Calculate 3.125%
0B53    C3            3539     	CLR	C
0B54    E56B          3540     	MOV	A, LIPO_ADC_LIMIT_H
0B56    13            3541     	RRC	A
0B57    F9            3542     MOV R1 , A 
0B58    E56A          3543     	MOV	A, LIPO_ADC_LIMIT_L	
0B5A    13            3544     	RRC	A
0B5B    F8            3545     MOV R0 , A 
0B5C    C3            3546     	CLR	C
0B5D    E9            3547     MOV A , R1 
0B5E    13            3548     	RRC	A
0B5F    F9            3549     MOV R1 , A 
0B60    E8            3550     MOV A , R0 
0B61    13            3551     	RRC	A
0B62    F8            3552     MOV R0 , A 
0B63    E56A          3553     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B65    28            3554     ADD A , R0 
0B66    F568          3555     	MOV	LIPO_ADC_REFERENCE_L, A
0B68    E56B          3556     	MOV	A, LIPO_ADC_LIMIT_H
0B6A    39            3557     ADDC A , R1 
0B6B    F569          3558     	MOV	LIPO_ADC_REFERENCE_H, A
                      3559     	; Divide three times to get to 3.125%
0B6D    7A03          3560     MOV R2 , # 3 
                      3561     MEASURE_LIPO_DIVIDE_LOOP: 
0B6F    C3            3562     	CLR	C
0B70    E9            3563     MOV A , R1 
0B71    13            3564     	RRC	A
0B72    F9            3565     MOV R1 , A 
0B73    E8            3566     MOV A , R0 
0B74    13            3567     	RRC	A
0B75    F8            3568     MOV R0 , A 
0B76    DAF7          3569     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3570     
                      3571     	; Add the programmed number of 0.1V (or 3.125% increments)
0B78    AA20          3572     MOV R2 , BIT_ACCESS 
0B7A    1A            3573     DEC R2 
0B7B    7009          3574     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3575     
0B7D    756A00        3576     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B80    756B00        3577     	MOV	LIPO_ADC_LIMIT_H, #0
0B83    020B96        3578     	JMP	MEASURE_LIPO_EXIT	
                      3579     
                      3580     MEASURE_LIPO_LIMIT_ON: 
0B86    1A            3581     DEC R2 
0B87    EA            3582     MOV A , R2 
0B88    6008          3583     	JZ	MEASURE_LIPO_UPDATE
                      3584     
                      3585     MEASURE_LIPO_ADD_LOOP: 
0B8A    EE            3586     MOV A , R6 
0B8B    28            3587     ADD A , R0 
0B8C    FE            3588     MOV R6 , A 
0B8D    EF            3589     MOV A , R7 
0B8E    39            3590     ADDC A , R1 
0B8F    FF            3591     MOV R7 , A 
0B90    DAF8          3592     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3593     
                      3594     MEASURE_LIPO_UPDATE: 
                      3595     	; Set ADC limit
0B92    8E6A          3596     MOV LIPO_ADC_LIMIT_L , R6 
0B94    8F6B          3597     MOV LIPO_ADC_LIMIT_H , R7 
                      3598     MEASURE_LIPO_EXIT: 
0B96    22            3599     	RET
                      3600     
                      3601     
                      3602     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3603     ;
                      3604     ; Start ADC conversion
                      3605     ;
                      3606     ; No assumptions
                      3607     ;
                      3608     ; Start conversion used for measuring power supply voltage
                      3609     ;
                      3610     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3611     START_ADC_CONVERSION: 
                      3612     	; Start adc
                      3613     	START_ADC 
0B97    75E890        3613+1   MOV ADC0CN , # 90H  ; ADC START
0B9A    22            3614     	RET
                      3615     
                      3616     
                      3617     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3618     ;
                      3619     ; Check temperature, power supply voltage and limit power
                      3620     ;
                      3621     ; No assumptions
                      3622     ;
                      3623     ; Used to limit main motor power in order to maintain the required voltage
                      3624     ;
                      3625     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3626     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3627     	; Load programmed low voltage limit
0B9B    7883          3628     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B9D    E6            3629     MOV A , @ R0 
0B9E    FF            3630     MOV R7 , A 
                      3631     	; Wait for ADC conversion to complete
                      3632     	GET_ADC_STATUS 
0B9F    E5E8          3632+1   MOV A , ADC0CN 
0BA1    20ECF7        3633     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3634     	; Read ADC result
                      3635     	READ_ADC_RESULT
0BA4    A8BD          3635+1   MOV R0 , ADC0L 
0BA6    A9BE          3635+1   MOV R1 , ADC0H 
                      3636     	; Stop ADC
                      3637     	STOP_ADC
                      3638     
0BA8    056C          3639     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0BAA    C3            3640     	CLR	C
0BAB    E56C          3641     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0BAD    9408          3642     SUBB A , # 8 
0BAF    404B          3643     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3644     
0BB1    756C00        3645     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0BB4    E9            3646     MOV A , R1 
0BB5    7007          3647     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3648     
0BB7    E56D          3649     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0BB9    601B          3650     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0BBB    020BCA        3651     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3652     
                      3653     TEMP_AVERAGE_INC_DEC: 
0BBE    C3            3654     	CLR	C
0BBF    E8            3655     MOV A , R0 
0BC0    956D          3656     	SUBB	A, CURRENT_AVERAGE_TEMP
0BC2    6010          3657     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3658     
0BC4    E56D          3659     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0BC6    5006          3660     	JNC	TEMP_AVERAGE_INC				
                      3661     
0BC8    600C          3662     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3663     TEMP_AVERAGE_DEC: 
0BCA    14            3664     	DEC	A						; Decrement average
0BCB    020BD6        3665     	JMP	TEMP_AVERAGE_UPDATED
                      3666     
                      3667     TEMP_AVERAGE_INC: 
0BCE    04            3668     	INC	A						; Increment average
0BCF    60F9          3669     	JZ	TEMP_AVERAGE_DEC
0BD1    020BD6        3670     	JMP	TEMP_AVERAGE_UPDATED
                      3671     
                      3672     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BD4    E56D          3673     	MOV	A, CURRENT_AVERAGE_TEMP
                      3674     TEMP_AVERAGE_UPDATED: 
0BD6    F56D          3675     	MOV	CURRENT_AVERAGE_TEMP, A
0BD8    C3            3676     	CLR	C
0BD9    946D          3677     SUBB A , # 109 
0BDB    401B          3678     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3679     
0BDD    755EC0        3680     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3681     
0BE0    C3            3682     	CLR	C
0BE1    9404          3683     SUBB A , # 4 
0BE3    4013          3684     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3685     
0BE5    755E80        3686     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3687     
0BE8    C3            3688     	CLR	C
0BE9    9404          3689     SUBB A , # 4 
0BEB    400B          3690     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3691     
0BED    755E40        3692     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3693     
0BF0    C3            3694     	CLR	C
0BF1    9404          3695     SUBB A , # 4 
0BF3    4003          3696     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3697     
0BF5    755E00        3698     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3699     
                      3700     TEMP_CHECK_EXIT: 
                      3701     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BF8    75BB08        3701+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BFB    22            3702     	RET
                      3703     
                      3704     CHECK_VOLTAGE_START: 
                      3705     IF MODE == 0 OR MODE == 2	; Main or multi
                      3706     	; Check if low voltage limiting is enabled
0BFC    EF            3707     MOV A , R7 
0BFD    C3            3708     	CLR	C
0BFE    9401          3709     	SUBB	A, #1					; Is low voltage limit disabled?
0C00    601B          3710     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3711     
                      3712     	; Check if ADC is saturated
0C02    C3            3713     	CLR	C
0C03    E8            3714     MOV A , R0 
0C04    94FF          3715     	SUBB	A, #0FFH
0C06    E9            3716     MOV A , R1 
0C07    9403          3717     	SUBB	A, #03H
0C09    5012          3718     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3719     
                      3720     	; Check voltage against limit
0C0B    C3            3721     	CLR	C
0C0C    E8            3722     MOV A , R0 
0C0D    956A          3723     	SUBB	A, LIPO_ADC_LIMIT_L
0C0F    E9            3724     MOV A , R1 
0C10    956B          3725     	SUBB	A, LIPO_ADC_LIMIT_H
0C12    5009          3726     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3727     
                      3728     	; Decrease pwm limit
0C14    E55E          3729     	MOV  A, PWM_LIMIT
0C16    600C          3730     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3731     
0C18    155E          3732     	DEC	PWM_LIMIT					; Decrement limit
0C1A    020C24        3733     	JMP	CHECK_VOLTAGE_LIM
                      3734     
                      3735     CHECK_VOLTAGE_GOOD: 
                      3736     	; Increase pwm limit
0C1D    E55E          3737     	MOV  A, PWM_LIMIT
0C1F    F4            3738     	CPL	A			
0C20    6002          3739     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3740     
0C22    055E          3741     	INC	PWM_LIMIT					; Increment limit
                      3742     
                      3743     CHECK_VOLTAGE_LIM: 
0C24    A85E          3744     MOV R0 , PWM_LIMIT 
0C26    C3            3745     	CLR	C
0C27    E524          3746     	MOV	A, CURRENT_PWM
0C29    98            3747     SUBB A , R0 
0C2A    5002          3748     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3749     
0C2C    A824          3750     MOV R0 , CURRENT_PWM 
                      3751     
                      3752     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3753     	; Slow spoolup
0C2E    C3            3754     	CLR	C
0C2F    E8            3755     MOV A , R0 
0C30    955F          3756     	SUBB	A, PWM_LIMIT_SPOOLUP
0C32    400A          3757     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3758     
0C34    A85F          3759     MOV R0 , PWM_LIMIT_SPOOLUP 
0C36    E55F          3760     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C38    F4            3761     	CPL	A
0C39    6003          3762     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3763      
0C3B    855F5E        3764     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3765     
                      3766     CHECK_VOLTAGE_EXIT: 
0C3E    8825          3767     MOV CURRENT_PWM_LIMITED , R0 
                      3768     ENDIF
                      3769     	; Set adc mux for next conversion
0C40    C3            3770     	CLR	C
0C41    E56C          3771     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C43    B40703        3772     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3773     
                      3774     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C46    75BB10        3774+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3775     
                      3776     CHECK_VOLTAGE_RET: 
0C49    22            3777     	RET
                      3778     
                      3779     
                      3780     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3781     ;
                      3782     ; Set startup PWM routine
                      3783     ;
                      3784     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3785     ;
                      3786     ; Used for pwm control during startup
                      3787     ;
                      3788     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3789     SET_STARTUP_PWM: 	
                      3790     	; Set pwm values according to startup phase flags
0C4A    306102        3791     JNB FLAGS1 . 1 , ( $+5 ) 
0C4D    7832          3792     MOV R0 , # 50 
0C4F    306202        3793     JNB FLAGS1 . 2 , ( $+5 ) 
0C52    7878          3794     MOV R0 , # 120 
                      3795     
                      3796     	; Update pwm variables if any startup phase flag is set
0C54    E52C          3797     	MOV	A, FLAGS1
0C56    5406          3798     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C58    601F          3799     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3800     
                      3801     	; Adjust startup power
0C5A    E8            3802     MOV A , R0 
0C5B    79A2          3803     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C5D    87F0          3804     MOV B , @ R1 
0C5F    A4            3805     	MUL	AB
0C60    C5F0          3806     	XCH	A, B
0C62    A2F7          3807     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C64    33            3808     	RLC	A
0C65    F8            3809     MOV R0 , A 
0C66    C3            3810     	CLR	C
0C67    E8            3811     MOV A , R0 
0C68    955E          3812     	SUBB	A, PWM_LIMIT	
0C6A    4002          3813     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3814     
0C6C    A85E          3815     MOV R0 , PWM_LIMIT 
                      3816     
                      3817     STARTUP_PWM_SET_PWM: 
                      3818     	; Set pwm variables
0C6E    8822          3819     MOV REQUESTED_PWM , R0 
0C70    8824          3820     MOV CURRENT_PWM , R0 
0C72    8825          3821     MOV CURRENT_PWM_LIMITED , R0 
0C74    306102        3822     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3823     
0C77    8860          3824     MOV PWM_SPOOLUP_BEG , R0 
                      3825     
                      3826     STARTUP_PWM_EXIT: 
0C79    22            3827     	RET
                      3828     
                      3829     
                      3830     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3831     ;
                      3832     ; Initialize all timings routine
                      3833     ;
                      3834     ; No assumptions
                      3835     ;
                      3836     ; Part of initialization before motor start
                      3837     ;
                      3838     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3839     INITIALIZE_ALL_TIMINGS:  
                      3840     	; Load programmed startup rpm
0C7A    788F          3841     MOV R0 , # PGM_STARTUP_RPM 
0C7C    E6            3842     MOV A , @ R0 
0C7D    FF            3843     MOV R7 , A 
                      3844     	; Check startup rpm setting and set step accordingly
0C7E    C3            3845     	CLR	C
0C7F    EF            3846     MOV A , R7 
0C80    9405          3847     	SUBB	A, #5
0C82    5018          3848     	JNC	STEPPER_STEP_HIGH
0C84    C3            3849     	CLR	C
0C85    EF            3850     MOV A , R7 
0C86    9404          3851     	SUBB	A, #4
0C88    5020          3852     	JNC	STEPPER_STEP_MED_HIGH
0C8A    C3            3853     	CLR	C
0C8B    EF            3854     MOV A , R7 
0C8C    9403          3855     	SUBB	A, #3
0C8E    5028          3856     	JNC	STEPPER_STEP_MED
0C90    C3            3857     	CLR	C
0C91    EF            3858     MOV A , R7 
0C92    9402          3859     	SUBB	A, #2
0C94    5030          3860     	JNC	STEPPER_STEP_MED_LOW
0C96    C3            3861     	CLR	C
0C97    EF            3862     MOV A , R7 
0C98    9401          3863     	SUBB	A, #1
0C9A    5038          3864     	JNC	STEPPER_STEP_LOW
                      3865     
                      3866     STEPPER_STEP_HIGH: 
0C9C    7533A0        3867     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C9F    75340F        3868     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0CA2    75353C        3869     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0CA5    753605        3870     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0CA8    81E0          3871     	AJMP	STEPPER_STEP_SET
                      3872     STEPPER_STEP_MED_HIGH: 
0CAA    7533C0        3873     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0CAD    753412        3874     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0CB0    753540        3875     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0CB3    753606        3876     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0CB6    81E0          3877     	AJMP	STEPPER_STEP_SET
                      3878     STEPPER_STEP_MED: 
0CB8    753370        3879     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0CBB    753417        3880     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0CBE    7535D0        3881     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0CC1    753607        3882     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0CC4    81E0          3883     	AJMP	STEPPER_STEP_SET
                      3884     STEPPER_STEP_MED_LOW: 
0CC6    75334C        3885     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0CC9    75341D        3886     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0CCC    7535C4        3887     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0CCF    753609        3888     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CD2    81E0          3889     	AJMP	STEPPER_STEP_SET
                      3890     STEPPER_STEP_LOW: 
0CD4    753328        3891     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CD7    753423        3892     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CDA    7535B8        3893     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CDD    75360B        3894     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3895     
                      3896     STEPPER_STEP_SET: 
0CE0    853350        3897     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CE3    853451        3898     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CE6    753C00        3899     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CE9    753D08        3900     	MOV	COMM_PERIOD4X_H, #08H
0CEC    22            3901     	RET
                      3902     
                      3903     
                      3904     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3905     ;
                      3906     ; Calculate next commutation timing routine
                      3907     ;
                      3908     ; No assumptions
                      3909     ;
                      3910     ; Called immediately after each commutation
                      3911     ; Also sets up timer 3 to wait advance timing
                      3912     ; Two entry points are used
                      3913     ;
                      3914     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3915     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CED    A850          3916     MOV R0 , WT_STEPPER_STEP_L 
0CEF    A951          3917     MOV R1 , WT_STEPPER_STEP_H 
0CF1    020CF8        3918     	JMP	READ_TIMER
                      3919     
                      3920     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CF4    A84A          3921     MOV R0 , WT_ADVANCE_L 
0CF6    A94B          3922     MOV R1 , WT_ADVANCE_H 
                      3923     READ_TIMER: 
                      3924     	; Set up next wait
0CF8    759100        3925     	MOV	TMR3CN, #00H		; Timer3 disabled
0CFB    C3            3926     	CLR	C
0CFC    E4            3927     	CLR	A
0CFD    98            3928     SUBB A , R0 
0CFE    F594          3929     	MOV	TMR3L, A
0D00    E4            3930     	CLR	A
0D01    99            3931     SUBB A , R1 
0D02    F595          3932     	MOV	TMR3H, A
0D04    759104        3933     	MOV	TMR3CN, #04H		; Timer3 enabled
0D07    D258          3934     SETB FLAGS0 . 0 
                      3935     	; Read commutation time
0D09    75C820        3936     	MOV	TMR2CN, #20H		; Timer2 disabled
0D0C    A8CC          3937     MOV R0 , TMR2L 
0D0E    A9CD          3938     MOV R1 , TMR2H 
0D10    75C824        3939     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3940     	; Calculate this commutation time
0D13    AA3A          3941     MOV R2 , PREV_COMM_L 
0D15    AB3B          3942     MOV R3 , PREV_COMM_H 
0D17    883A          3943     MOV PREV_COMM_L , R0 
0D19    893B          3944     MOV PREV_COMM_H , R1 
0D1B    C3            3945     	CLR	C
0D1C    E8            3946     MOV A , R0 
0D1D    9A            3947     SUBB A , R2 
0D1E    F8            3948     MOV R0 , A 
0D1F    E9            3949     MOV A , R1 
0D20    9B            3950     SUBB A , R3 
0D21    F9            3951     MOV R1 , A 
                      3952     	; Calculate next zero cross scan timeout 
0D22    AA3C          3953     MOV R2 , COMM_PERIOD4X_L 
0D24    AB3D          3954     MOV R3 , COMM_PERIOD4X_H 
0D26    C3            3955     	CLR	C
0D27    EB            3956     MOV A , R3 
0D28    13            3957     	RRC	A					; Divide by 2
0D29    FD            3958     MOV R5 , A 
0D2A    EA            3959     MOV A , R2 
0D2B    13            3960     	RRC	A
0D2C    FC            3961     MOV R4 , A 
0D2D    C3            3962     	CLR	C
0D2E    ED            3963     MOV A , R5 
0D2F    13            3964     	RRC	A					; Divide by 2 again
0D30    FD            3965     MOV R5 , A 
0D31    EC            3966     MOV A , R4 
0D32    13            3967     	RRC	A
0D33    FC            3968     MOV R4 , A 
0D34    C3            3969     	CLR	C
0D35    EA            3970     MOV A , R2 
0D36    9C            3971     SUBB A , R4 
0D37    FA            3972     MOV R2 , A 
0D38    EB            3973     MOV A , R3 
0D39    9D            3974     SUBB A , R5 
0D3A    FB            3975     MOV R3 , A 
                      3976     
0D3B    EA            3977     MOV A , R2 
0D3C    28            3978     ADD A , R0 
0D3D    FA            3979     MOV R2 , A 
0D3E    EB            3980     MOV A , R3 
0D3F    39            3981     ADDC A , R1 
0D40    FB            3982     MOV R3 , A 
0D41    8A3C          3983     MOV COMM_PERIOD4X_L , R2 
0D43    8B3D          3984     MOV COMM_PERIOD4X_H , R3 
0D45    4001          3985     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3986     
0D47    22            3987     	RET
                      3988     
                      3989     CALC_NEXT_COMM_SLOW: 
0D48    753CFF        3990     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D4B    753DFF        3991     	MOV	COMM_PERIOD4X_H, #0FFH
0D4E    22            3992     	RET
                      3993     
                      3994     
                      3995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3996     ;
                      3997     ; Setup zero cross scan wait
                      3998     ;
                      3999     ; No assumptions
                      4000     ;
                      4001     ; Sets up timer 3 to wait the zero cross scan wait time
                      4002     ;
                      4003     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4004     SETUP_ZC_SCAN_WAIT: 
0D4F    759100        4005     	MOV	TMR3CN, #00H		; Timer3 disabled
0D52    C3            4006     	CLR	C
0D53    E4            4007     	CLR	A
0D54    954C          4008     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D56    F594          4009     	MOV	TMR3L, A
0D58    E4            4010     	CLR	A
0D59    954D          4011     	SUBB	A, WT_ZC_SCAN_H		
0D5B    F595          4012     	MOV	TMR3H, A
0D5D    759104        4013     	MOV	TMR3CN, #04H		; Timer3 enabled
0D60    D258          4014     SETB FLAGS0 . 0 
0D62    22            4015     	RET
                      4016     
                      4017     
                      4018     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4019     ;
                      4020     ; Wait advance timing routine
                      4021     ;
                      4022     ; No assumptions
                      4023     ;
                      4024     ; Waits for the advance timing to elapse, waits one zero cross
                      4025     ; wait and sets up the next zero cross wait
                      4026     ;
                      4027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4028     WAIT_ADVANCE_TIMING: 	
0D63    7F01          4029     MOV R7 , # 1 
0D65    789C          4030     MOV R0 , # PGM_DEMAG_COMP 
0D67    E6            4031     MOV A , @ R0 
0D68    14            4032     	DEC	A
0D69    6002          4033     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4034     
0D6B    7F02          4035     MOV R7 , # 2 
                      4036     
                      4037     WAIT_ADVANCE_TIMING_WAIT: 
0D6D    305802        4038     JNB FLAGS0 . 0 , ( $+5 ) 
0D70    A16D          4039     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4040     
0D72    B14F          4041     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D74    DFF7          4042     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4043     
0D76    22            4044     	RET
                      4045     
                      4046     
                      4047     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4048     ;
                      4049     ; Calculate new wait times routine
                      4050     ;
                      4051     ; No assumptions
                      4052     ;
                      4053     ; Calculates new wait times
                      4054     ;
                      4055     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4056     CALC_NEW_WAIT_TIMES: 	
                      4057     	; Load programmed commutation timing
0D77    7892          4058     MOV R0 , # PGM_COMM_TIMING 
0D79    E6            4059     MOV A , @ R0 
0D7A    FF            4060     MOV R7 , A 
0D7B    7E14          4061     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4062     IF MODE == 2
0D7D    A83D          4063     MOV R0 , COMM_PERIOD4X_H 
0D7F    C3            4064     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D80    E8            4065     MOV A , R0 
0D81    9404          4066     	SUBB	A, #4
0D83    4002          4067     	JC	CALC_NEW_WAIT_RED_SET
                      4068     
0D85    7804          4069     MOV R0 , # 4 
                      4070     
                      4071     CALC_NEW_WAIT_RED_SET: 
0D87    C3            4072     	CLR	C
0D88    E8            4073     MOV A , R0 
0D89    33            4074     	RLC	A
0D8A    F8            4075     MOV R0 , A 
0D8B    C3            4076     	CLR	C
0D8C    EE            4077     MOV A , R6 
0D8D    98            4078     SUBB A , R0 
0D8E    FE            4079     MOV R6 , A 
                      4080     ENDIF
0D8F    306304        4081     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4082     
0D92    7F03          4083     MOV R7 , # 3 
0D94    7E00          4084     MOV R6 , # 0 
                      4085     
                      4086     CALC_NEW_WAIT_DIR_START_SET: 
                      4087     	; Load current commutation timing
0D96    A93D          4088     MOV R1 , COMM_PERIOD4X_H 
0D98    A83C          4089     MOV R0 , COMM_PERIOD4X_L 
0D9A    7A04          4090     MOV R2 , # 4 
                      4091     DIVIDE_WAIT_TIMES: 
0D9C    C3            4092     	CLR	C
0D9D    E9            4093     MOV A , R1 
0D9E    13            4094     	RRC	A					; Divide by 2
0D9F    F9            4095     MOV R1 , A 
0DA0    E8            4096     MOV A , R0 
0DA1    13            4097     	RRC	A
0DA2    F8            4098     MOV R0 , A 
0DA3    DAF7          4099     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4100     
0DA5    C3            4101     	CLR	C
0DA6    E8            4102     MOV A , R0 
0DA7    9E            4103     SUBB A , R6 
0DA8    F8            4104     MOV R0 , A 
0DA9    E9            4105     MOV A , R1 
0DAA    9400          4106     	SUBB	A, #0
0DAC    F9            4107     MOV R1 , A 
0DAD    4009          4108     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4109     
0DAF    C3            4110     	CLR	C
0DB0    E8            4111     MOV A , R0 
0DB1    9402          4112     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0DB3    E9            4113     MOV A , R1 
0DB4    9400          4114     	SUBB	A, #0
0DB6    5004          4115     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4116     
                      4117     LOAD_MIN_TIME: 
0DB8    7802          4118     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0DBA    E4            4119     	CLR	A
0DBB    F9            4120     MOV R1 , A 
                      4121     
                      4122     ADJUST_TIMING: 
0DBC    E9            4123     MOV A , R1 
0DBD    FB            4124     MOV R3 , A 
0DBE    E8            4125     MOV A , R0 
0DBF    FA            4126     MOV R2 , A 
0DC0    C3            4127     	CLR	C
0DC1    E9            4128     MOV A , R1 
0DC2    13            4129     	RRC	A					; Divide by 2
0DC3    FD            4130     MOV R5 , A 
0DC4    E8            4131     MOV A , R0 
0DC5    13            4132     	RRC	A
0DC6    FC            4133     MOV R4 , A 
0DC7    C3            4134     	CLR	C
0DC8    EF            4135     MOV A , R7 
0DC9    9403          4136     	SUBB	A, #3				; Is timing normal?
0DCB    602E          4137     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4138     
0DCD    EF            4139     MOV A , R7 
0DCE    20E00D        4140     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4141     
0DD1    E8            4142     MOV A , R0 
0DD2    2C            4143     ADD A , R4 
0DD3    F8            4144     MOV R0 , A 
0DD4    E9            4145     MOV A , R1 
0DD5    3D            4146     ADDC A , R5 
0DD6    F9            4147     MOV R1 , A 
0DD7    EC            4148     MOV A , R4 
0DD8    FA            4149     MOV R2 , A 
0DD9    ED            4150     MOV A , R5 
0DDA    FB            4151     MOV R3 , A 
0DDB    020DE8        4152     	JMP	STORE_TIMES_UP_OR_DOWN
                      4153     
                      4154     ADJUST_TIMING_TWO_STEPS: 
0DDE    E8            4155     MOV A , R0 
0DDF    28            4156     ADD A , R0 
0DE0    F8            4157     MOV R0 , A 
0DE1    E9            4158     MOV A , R1 
0DE2    39            4159     ADDC A , R1 
0DE3    F9            4160     MOV R1 , A 
0DE4    7A02          4161     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DE6    E4            4162     	CLR	A
0DE7    FB            4163     MOV R3 , A 
                      4164     
                      4165     STORE_TIMES_UP_OR_DOWN: 
0DE8    C3            4166     	CLR	C
0DE9    EF            4167     MOV A , R7 
0DEA    9403          4168     	SUBB	A, #3				; Is timing higher than normal?
0DEC    400D          4169     	JC	STORE_TIMES_DECREASE	; No - branch
                      4170     
                      4171     STORE_TIMES_INCREASE: 
0DEE    8A4E          4172     MOV WT_COMM_L , R2 
0DF0    8B4F          4173     MOV WT_COMM_H , R3 
0DF2    884A          4174     MOV WT_ADVANCE_L , R0 
0DF4    894B          4175     MOV WT_ADVANCE_H , R1 
0DF6    8C4C          4176     MOV WT_ZC_SCAN_L , R4 
0DF8    8D4D          4177     MOV WT_ZC_SCAN_H , R5 
0DFA    22            4178     	RET
                      4179     
                      4180     STORE_TIMES_DECREASE: 
0DFB    884E          4181     MOV WT_COMM_L , R0 
0DFD    894F          4182     MOV WT_COMM_H , R1 
0DFF    8A4A          4183     MOV WT_ADVANCE_L , R2 
0E01    8B4B          4184     MOV WT_ADVANCE_H , R3 
0E03    8C4C          4185     MOV WT_ZC_SCAN_L , R4 
0E05    8D4D          4186     MOV WT_ZC_SCAN_H , R5 
0E07    22            4187     	RET
                      4188     
                      4189     
                      4190     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4191     ;
                      4192     ; Wait before zero cross scan routine
                      4193     ;
                      4194     ; No assumptions
                      4195     ;
                      4196     ; Waits for the zero cross scan wait time to elapse
                      4197     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4198     ;
                      4199     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4200     WAIT_BEFORE_ZC_SCAN: 	
0E08    305802        4201     JNB FLAGS0 . 0 , ( $+5 ) 
0E0B    C108          4202     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4203     
0E0D    759100        4204     	MOV	TMR3CN, #00H		; Timer3 disabled
0E10    C3            4205     	CLR	C
0E11    E4            4206     	CLR	A
0E12    953C          4207     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0E14    F594          4208     	MOV	TMR3L, A
0E16    E4            4209     	CLR	A
0E17    953D          4210     	SUBB	A, COMM_PERIOD4X_H		
0E19    F595          4211     	MOV	TMR3H, A
0E1B    759104        4212     	MOV	TMR3CN, #04H		; Timer3 enabled
0E1E    D258          4213     SETB FLAGS0 . 0 
0E20    22            4214     	RET
                      4215     
                      4216     
                      4217     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4218     ;
                      4219     ; Wait for comparator to go low/high routines
                      4220     ;
                      4221     ; No assumptions
                      4222     ;
                      4223     ; Waits for the zero cross scan wait time to elapse
                      4224     ; Then scans for comparator going low/high
                      4225     ;
                      4226     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4227     WAIT_FOR_COMP_OUT_LOW: 
0E21    753F00        4228     	MOV	COMP_WAIT_READS, #0
0E24    752000        4229     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E27    020E30        4230     	JMP	WAIT_FOR_COMP_OUT_START
                      4231     
                      4232     WAIT_FOR_COMP_OUT_HIGH: 
0E2A    753F00        4233     	MOV	COMP_WAIT_READS, #0
0E2D    752040        4234     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4235     
                      4236     WAIT_FOR_COMP_OUT_START: 
0E30    D2AF          4237     	SETB	EA						; Enable interrupts
0E32    053F          4238     	INC	COMP_WAIT_READS
0E34    205801        4239     JB FLAGS0 . 0 , ( $+4 ) 
0E37    22            4240     	RET							; Yes - return
                      4241     
                      4242     	; Set default comparator response times
0E38    759D00        4243     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4244     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4247     	; Select number of comparator readings based upon current rotation speed
0E3B    E53D          4248     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E3D    C3            4249     	CLR	C
0E3E    13            4250     	RRC	A						; Divide by 4
0E3F    C3            4251     	CLR	C
0E40    13            4252     	RRC	A
0E41    F8            4253     MOV R0 , A 
0E42    08            4254     INC R0 
0E43    6030          4255     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4256     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E45    306A06        4257     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4258     
0E48    C3            4259     	CLR	C
0E49    13            4260     	RRC	A						; Divide by 4 again
0E4A    C3            4261     	CLR	C
0E4B    13            4262     	RRC	A
0E4C    F8            4263     MOV R0 , A 
0E4D    08            4264     INC R0 
                      4265     
                      4266     COMP_WAIT_SET_MAX_READINGS: 
0E4E    C3            4267     	CLR	C
0E4F    E8            4268     MOV A , R0 
0E50    940A          4269     	SUBB	A, #10
0E52    4002          4270     	JC	($+4)
                      4271     
0E54    780A          4272     MOV R0 , # 10 
                      4273     
0E56    306D08        4274     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4275     
0E59    C3            4276     	CLR	C
0E5A    E8            4277     MOV A , R0 
0E5B    9404          4278     	SUBB	A, #4
0E5D    4002          4279     	JC	($+4)
                      4280     
0E5F    7804          4281     MOV R0 , # 4 
                      4282     
                      4283     COMP_WAIT_SET_RESPONSE_TIME: 
0E61    C3            4284     	CLR	C
0E62    E53D          4285     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E64    9408          4286     	SUBB	A, #8
0E66    400D          4287     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4288     
0E68    759D02        4289     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4290     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E6B    C3            4293     	CLR	C
0E6C    E53D          4294     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E6E    9410          4295     	SUBB	A, #16
0E70    4003          4296     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4297     
0E72    759D03        4298     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4299     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4302     
                      4303     COMP_WAIT_ON_COMP_ABLE: 
0E75    205803        4304     JB FLAGS0 . 0 , ( $+6 ) 
0E78    D2AF          4305     	SETB	EA							; Enable interrupts
0E7A    22            4306     	RET								; Yes - return
                      4307     
0E7B    7918          4308     MOV R1 , # 24 
0E7D    206D02        4309     JB FLAGS2 . 5 , ( $+5 ) 
0E80    7908          4310     MOV R1 , # 8 
0E82    D2AF          4311     	SETB	EA							; Enable interrupts
0E84    00            4312     	NOP								; Allocate only just enough time to capture interrupt
0E85    00            4313     	NOP
0E86    C2AF          4314     	CLR	EA							; Disable interrupts
0E88    205A0A        4315     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4316     
0E8B    7914          4317     MOV R1 , # 20 
0E8D    206D02        4318     JB FLAGS2 . 5 , ( $+5 ) 
0E90    7907          4319     MOV R1 , # 7 
0E92    3066E0        4320     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4321     
                      4322     PWM_WAIT_STARTUP: 						
0E95    306302        4323     JNB FLAGS1 . 3 , PWM_WAIT 
                      4324     
0E98    7978          4325     MOV R1 , # 120 
                      4326     PWM_WAIT: 						
0E9A    C3            4327     	CLR	C
0E9B    E58B          4328     	MOV	A, TL1
0E9D    99            4329     SUBB A , R1 
                      4330     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E9E    40D5          4335     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4336     ENDIF
                      4337     
                      4338     COMP_READ: 
                      4339     	READ_COMP_OUT 					; Read comparator output
0EA0    E59B          4339+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0EA2    F4            4340     	CPL	A
0EA3    5440          4341     	ANL	A, #40H
0EA5    B52002        4342     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4343     
0EA8    C130          4344     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4345     
0EAA    D8C9          4346     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4347     
0EAC    D2AF          4348     	SETB	EA						; Enable interrupts
0EAE    22            4349     	RET							
                      4350     
                      4351     
                      4352     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4353     ;
                      4354     ; Evaluate comparator integrity
                      4355     ;
                      4356     ; No assumptions
                      4357     ;
                      4358     ; Checks comparator signal behaviour versus expected behaviour
                      4359     ;
                      4360     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4361     EVALUATE_COMPARATOR_INTEGRITY: 
0EAF    C25B          4362     CLR FLAGS0 . 3 
                      4363     	; Check if demag compensation is enabled
0EB1    789C          4364     MOV R0 , # PGM_DEMAG_COMP 
0EB3    E6            4365     MOV A , @ R0 
0EB4    14            4366     	DEC	A
0EB5    600A          4367     	JZ	EVAL_COMP_NO_DEMAG
                      4368     
                      4369     	; Check if a demag situation has occurred
0EB7    E53F          4370     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0EB9    14            4371     	DEC	A
0EBA    7005          4372     	JNZ	EVAL_COMP_NO_DEMAG
                      4373     
0EBC    206302        4374     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4375     
0EBF    D25B          4376     SETB FLAGS0 . 3 
                      4377     
                      4378     EVAL_COMP_NO_DEMAG: 
0EC1    30630B        4379     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4380     
0EC4    0538          4381     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0EC6    205810        4382     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4383     
0EC9    753800        4384     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0ECC    020ED9        4385     	JMP	EVAL_COMP_EXIT
                      4386     
                      4387     EVAL_COMP_CHECK_TIMEOUT: 
0ECF    205807        4388     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0ED2    1581          4389     	DEC	SP							; Routine exit without "ret" command
0ED4    1581          4390     	DEC	SP
0ED6    0217E1        4391     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4392     
                      4393     EVAL_COMP_EXIT: 
0ED9    22            4394     	RET
                      4395     
                      4396     
                      4397     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4398     ;
                      4399     ; Setup commutation timing routine
                      4400     ;
                      4401     ; No assumptions
                      4402     ;
                      4403     ; Sets up and starts wait from commutation to zero cross
                      4404     ;
                      4405     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4406     SETUP_COMM_WAIT:  
0EDA    759100        4407     	MOV	TMR3CN, #00H		; Timer3 disabled
0EDD    C3            4408     	CLR	C
0EDE    E4            4409     	CLR	A
0EDF    954E          4410     	SUBB	A, WT_COMM_L		; Set wait commutation value
0EE1    F594          4411     	MOV	TMR3L, A
0EE3    E4            4412     	CLR	A
0EE4    954F          4413     	SUBB	A, WT_COMM_H		
0EE6    F595          4414     	MOV	TMR3H, A
0EE8    759104        4415     	MOV	TMR3CN, #04H		; Timer3 enabled
0EEB    D258          4416     SETB FLAGS0 . 0 
0EED    22            4417     	RET
                      4418     
                      4419     
                      4420     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4421     ;
                      4422     ; Wait for commutation routine
                      4423     ;
                      4424     ; No assumptions
                      4425     ;
                      4426     ; Waits from zero cross to commutation 
                      4427     ;
                      4428     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4429     WAIT_FOR_COMM:  
                      4430     	; Increment or reset consecutive count
0EEE    0539          4431     	INC	DEMAG_CONSECUTIVE_CNT
0EF0    205B03        4432     JB FLAGS0 . 3 , ( $+6 ) 
                      4433     
0EF3    753900        4434     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4435     
                      4436     	; Check if a demag situation has occurred
0EF6    305B23        4437     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4438     
                      4439     	; Load programmed demag compensation
0EF9    78A3          4440     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0EFB    E6            4441     MOV A , @ R0 
0EFC    FF            4442     MOV R7 , A 
                      4443     
                      4444     	; Check for power off
0EFD    BF0108        4445     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4446     
0F00    D25C          4447     SETB FLAGS0 . 4 
                      4448     	ALL_NFETS_OFF
0F02    D297          4448+1   SETB P1 . 7 
0F04    D295          4448+1   SETB P1 . 5 
0F06    D293          4448+1   SETB P1 . 3 
                      4449     
                      4450     	; Wait a blind wait
                      4451     WAIT_FOR_COMM_BLIND: 
0F08    B14F          4452     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4453     WAIT_DEMAG_DEFAULT_ZC: 	
0F0A    305802        4454     JNB FLAGS0 . 0 , ( $+5 ) 
0F0D    E10A          4455     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4456     
                      4457     	; Check for power off
0F0F    BF0208        4458     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4459     
0F12    D25C          4460     SETB FLAGS0 . 4 
                      4461     	ALL_NFETS_OFF
0F14    D297          4461+1   SETB P1 . 7 
0F16    D295          4461+1   SETB P1 . 5 
0F18    D293          4461+1   SETB P1 . 3 
                      4462     
                      4463     WAIT_FOR_COMM_SETUP: 
0F1A    D1DA          4464     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4465     WAIT_FOR_COMM_WAIT: 
0F1C    305802        4466     JNB FLAGS0 . 0 , ( $+5 ) 
0F1F    E11C          4467     	AJMP	WAIT_FOR_COMM_WAIT					
                      4468     
0F21    22            4469     	RET
                      4470     
                      4471     
                      4472     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4473     ;
                      4474     ; Commutation routines
                      4475     ;
                      4476     ; No assumptions
                      4477     ;
                      4478     ; Performs commutation switching 
                      4479     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4480     ;
                      4481     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4482     COMM1COMM2: 	
0F22    C2AF          4483     	CLR 	EA					; Disable all interrupts
                      4484     	BPFET_OFF					; Bp off
0F24    C294          4484+1   CLR P1 . 4 
0F26    206A03        4485     JB FLAGS2 . 2 , COMM12_DAMP 
0F29    020F41        4486     	JMP	COMM12_NONDAMP
                      4487     COMM12_DAMP: 
                      4488     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4492     IF DAMPED_MODE_ENABLE == 1
0F2C    900347        4493     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4494     ENDIF
0F2F    30650F        4495     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4496     	CPFET_OFF				
0F32    207502        4496+1   JB FLAGS3 . 5 , ( $+5 ) 
0F35    C292          4496+1   CLR P1 . 2 
0F37    307502        4496+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F3A    C296          4496+1   CLR P1 . 6 
0F3C    7406          4497     MOV A , # 6 
0F3E    D5E0FD        4498     	DJNZ ACC,	$
                      4499     COMM12_NONDAMP: 
                      4500     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4501     	ANFET_ON				
0F41    E525          4501+1   MOV A , CURRENT_PWM_LIMITED 
0F43    600A          4501+1   JZ ( $+12 ) 
0F45    207502        4501+1   JB FLAGS3 . 5 , ( $+5 ) 
0F48    C297          4501+1   CLR P1 . 7 
0F4A    307502        4501+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F4D    C293          4501+1   CLR P1 . 3 
0F4F    740F          4502     MOV A , # 15 
0F51    D5E0FD        4503     	DJNZ ACC,	$
                      4504     	ANFET_OFF				
0F54    207502        4504+1   JB FLAGS3 . 5 , ( $+5 ) 
0F57    D297          4504+1   SETB P1 . 7 
0F59    307502        4504+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F5C    D293          4504+1   SETB P1 . 3 
0F5E    7406          4505     MOV A , # 6 
0F60    D5E0FD        4506     	DJNZ ACC,	$
                      4507     ENDIF
                      4508     	APFET_ON					; Ap on
0F63    207502        4508+1   JB FLAGS3 . 5 , ( $+5 ) 
0F66    D296          4508+1   SETB P1 . 6 
0F68    307502        4508+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F6B    D292          4508+1   SETB P1 . 2 
                      4509     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F6D    759F10        4509+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F70    753E02        4510     	MOV	COMM_PHASE, #2
0F73    021102        4511     	JMP	COMM_EXIT
                      4512     
                      4513     COMM2COMM3: 	
0F76    C2AF          4514     	CLR 	EA					; Disable all interrupts
0F78    206A03        4515     JB FLAGS2 . 2 , COMM23_DAMP 
0F7B    020F98        4516     	JMP	COMM23_NONDAMP
                      4517     COMM23_DAMP: 
                      4518     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4521     IF DAMPED_MODE_ENABLE == 1
0F7E    9002FE        4522     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4523     ENDIF
0F81    306517        4524     JNB FLAGS1 . 5 , COMM23_NFET 
                      4525     	BPFET_OFF				
0F84    C294          4525+1   CLR P1 . 4 
                      4526     	CPFET_OFF				
0F86    207502        4526+1   JB FLAGS3 . 5 , ( $+5 ) 
0F89    C292          4526+1   CLR P1 . 2 
0F8B    307502        4526+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F8E    C296          4526+1   CLR P1 . 6 
0F90    7406          4527     MOV A , # 6 
0F92    D5E0FD        4528     	DJNZ ACC,	$
0F95    020F9B        4529     	JMP	COMM23_NFET
                      4530     COMM23_NONDAMP: 
0F98    9001E1        4531     	MOV	DPTR, #PWM_BFET_ON	
                      4532     COMM23_NFET: 
                      4533     	CNFET_OFF					; Cn off
0F9B    207502        4533+1   JB FLAGS3 . 5 , ( $+5 ) 
0F9E    D293          4533+1   SETB P1 . 3 
0FA0    307502        4533+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FA3    D297          4533+1   SETB P1 . 7 
0FA5    305A06        4534     JNB FLAGS0 . 2 , COMM23_CP 
                      4535     	BNFET_ON					; Yes - Bn on
0FA8    E525          4535+1   MOV A , CURRENT_PWM_LIMITED 
0FAA    6002          4535+1   JZ ( $+4 ) 
0FAC    C295          4535+1   CLR P1 . 5 
                      4536     COMM23_CP: 
                      4537     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FAE    207503        4537+1   JB FLAGS3 . 5 , ( $+6 ) 
0FB1    759F13        4537+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FB4    307503        4537+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FB7    759F11        4537+1   MOV CPT0MX , # 11H 
0FBA    753E03        4538     	MOV	COMM_PHASE, #3
0FBD    021102        4539     	JMP	COMM_EXIT
                      4540     
                      4541     COMM3COMM4: 	
0FC0    C2AF          4542     	CLR 	EA					; Disable all interrupts
                      4543     	APFET_OFF					; Ap off
0FC2    207502        4543+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC5    C296          4543+1   CLR P1 . 6 
0FC7    307502        4543+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FCA    C292          4543+1   CLR P1 . 2 
0FCC    206A03        4544     JB FLAGS2 . 2 , COMM34_DAMP 
0FCF    020FDF        4545     	JMP	COMM34_NONDAMP
                      4546     COMM34_DAMP: 
                      4547     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4551     IF DAMPED_MODE_ENABLE == 1
0FD2    9002BD        4552     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4553     ENDIF
0FD5    306507        4554     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4555     	BPFET_OFF				
0FD8    C294          4555+1   CLR P1 . 4 
0FDA    7406          4556     MOV A , # 6 
0FDC    D5E0FD        4557     	DJNZ ACC,	$
                      4558     COMM34_NONDAMP: 
                      4559     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4560     	CNFET_ON				
0FDF    E525          4560+1   MOV A , CURRENT_PWM_LIMITED 
0FE1    600A          4560+1   JZ ( $+12 ) 
0FE3    207502        4560+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE6    C293          4560+1   CLR P1 . 3 
0FE8    307502        4560+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FEB    C297          4560+1   CLR P1 . 7 
0FED    740F          4561     MOV A , # 15 
0FEF    D5E0FD        4562     	DJNZ ACC,	$
                      4563     	CNFET_OFF				
0FF2    207502        4563+1   JB FLAGS3 . 5 , ( $+5 ) 
0FF5    D293          4563+1   SETB P1 . 3 
0FF7    307502        4563+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FFA    D297          4563+1   SETB P1 . 7 
0FFC    7406          4564     MOV A , # 6 
0FFE    D5E0FD        4565     	DJNZ ACC,	$
                      4566     ENDIF
                      4567     	CPFET_ON					; Cp on
1001    207502        4567+1   JB FLAGS3 . 5 , ( $+5 ) 
1004    D292          4567+1   SETB P1 . 2 
1006    307502        4567+1   JNB FLAGS3 . 5 , ( $+5 ) 
1009    D296          4567+1   SETB P1 . 6 
                      4568     	SET_COMP_PHASE_A 			; Set comparator to phase A
100B    207503        4568+1   JB FLAGS3 . 5 , ( $+6 ) 
100E    759F11        4568+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1011    307503        4568+1   JNB FLAGS3 . 5 , ( $+6 ) 
1014    759F13        4568+1   MOV CPT0MX , # 13H 
1017    753E04        4569     	MOV	COMM_PHASE, #4
101A    021102        4570     	JMP	COMM_EXIT
                      4571     
                      4572     COMM4COMM5: 	
101D    C2AF          4573     	CLR 	EA					; Disable all interrupts
101F    206A03        4574     JB FLAGS2 . 2 , COMM45_DAMP 
1022    02103F        4575     	JMP	COMM45_NONDAMP
                      4576     COMM45_DAMP: 
                      4577     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4580     IF DAMPED_MODE_ENABLE == 1
1025    90027C        4581     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4582     ENDIF
1028    306517        4583     JNB FLAGS1 . 5 , COMM45_NFET 
                      4584     	APFET_OFF				
102B    207502        4584+1   JB FLAGS3 . 5 , ( $+5 ) 
102E    C296          4584+1   CLR P1 . 6 
1030    307502        4584+1   JNB FLAGS3 . 5 , ( $+5 ) 
1033    C292          4584+1   CLR P1 . 2 
                      4585     	BPFET_OFF				
1035    C294          4585+1   CLR P1 . 4 
1037    7406          4586     MOV A , # 6 
1039    D5E0FD        4587     	DJNZ ACC,	$
103C    021042        4588     	JMP	COMM45_NFET
                      4589     COMM45_NONDAMP: 
103F    9001CF        4590     	MOV	DPTR, #PWM_AFET_ON
                      4591     COMM45_NFET: 
                      4592     	BNFET_OFF					; Bn off
1042    D295          4592+1   SETB P1 . 5 
1044    305A0E        4593     JNB FLAGS0 . 2 , COMM45_CP 
                      4594     	ANFET_ON					; Yes - An on
1047    E525          4594+1   MOV A , CURRENT_PWM_LIMITED 
1049    600A          4594+1   JZ ( $+12 ) 
104B    207502        4594+1   JB FLAGS3 . 5 , ( $+5 ) 
104E    C297          4594+1   CLR P1 . 7 
1050    307502        4594+1   JNB FLAGS3 . 5 , ( $+5 ) 
1053    C293          4594+1   CLR P1 . 3 
                      4595     COMM45_CP: 
                      4596     	SET_COMP_PHASE_B 			; Set comparator to phase B
1055    759F10        4596+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
1058    753E05        4597     	MOV	COMM_PHASE, #5
105B    021102        4598     	JMP	COMM_EXIT
                      4599     
                      4600     COMM5COMM6: 	
105E    C2AF          4601     	CLR 	EA					; Disable all interrupts
                      4602     	CPFET_OFF					; Cp off
1060    207502        4602+1   JB FLAGS3 . 5 , ( $+5 ) 
1063    C292          4602+1   CLR P1 . 2 
1065    307502        4602+1   JNB FLAGS3 . 5 , ( $+5 ) 
1068    C296          4602+1   CLR P1 . 6 
106A    206A03        4603     JB FLAGS2 . 2 , COMM56_DAMP 
106D    021085        4604     	JMP	COMM56_NONDAMP
                      4605     COMM56_DAMP: 
                      4606     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4610     IF DAMPED_MODE_ENABLE == 1
1070    900233        4611     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4612     ENDIF
1073    30650F        4613     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4614     	APFET_OFF				
1076    207502        4614+1   JB FLAGS3 . 5 , ( $+5 ) 
1079    C296          4614+1   CLR P1 . 6 
107B    307502        4614+1   JNB FLAGS3 . 5 , ( $+5 ) 
107E    C292          4614+1   CLR P1 . 2 
1080    7406          4615     MOV A , # 6 
1082    D5E0FD        4616     	DJNZ ACC,	$
                      4617     COMM56_NONDAMP: 
                      4618     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4619     	BNFET_ON				
1085    E525          4619+1   MOV A , CURRENT_PWM_LIMITED 
1087    6002          4619+1   JZ ( $+4 ) 
1089    C295          4619+1   CLR P1 . 5 
108B    740F          4620     MOV A , # 15 
108D    D5E0FD        4621     	DJNZ ACC,	$
                      4622     	BNFET_OFF				
1090    D295          4622+1   SETB P1 . 5 
1092    7406          4623     MOV A , # 6 
1094    D5E0FD        4624     	DJNZ ACC,	$
                      4625     ENDIF
                      4626     	BPFET_ON					; Bp on
1097    D294          4626+1   SETB P1 . 4 
                      4627     	SET_COMP_PHASE_C 			; Set comparator to phase C
1099    207503        4627+1   JB FLAGS3 . 5 , ( $+6 ) 
109C    759F13        4627+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
109F    307503        4627+1   JNB FLAGS3 . 5 , ( $+6 ) 
10A2    759F11        4627+1   MOV CPT0MX , # 11H 
10A5    753E06        4628     	MOV	COMM_PHASE, #6
10A8    021102        4629     	JMP	COMM_EXIT
                      4630     
                      4631     COMM6COMM1: 	
10AB    C2AF          4632     	CLR 	EA					; Disable all interrupts
10AD    206A03        4633     JB FLAGS2 . 2 , COMM61_DAMP 
10B0    0210D5        4634     	JMP	COMM61_NONDAMP
                      4635     COMM61_DAMP: 
                      4636     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4639     IF DAMPED_MODE_ENABLE == 1
10B3    9003A0        4640     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4641     ENDIF
10B6    30651F        4642     JNB FLAGS1 . 5 , COMM61_NFET 
                      4643     	APFET_OFF				
10B9    207502        4643+1   JB FLAGS3 . 5 , ( $+5 ) 
10BC    C296          4643+1   CLR P1 . 6 
10BE    307502        4643+1   JNB FLAGS3 . 5 , ( $+5 ) 
10C1    C292          4643+1   CLR P1 . 2 
                      4644     	CPFET_OFF				
10C3    207502        4644+1   JB FLAGS3 . 5 , ( $+5 ) 
10C6    C292          4644+1   CLR P1 . 2 
10C8    307502        4644+1   JNB FLAGS3 . 5 , ( $+5 ) 
10CB    C296          4644+1   CLR P1 . 6 
10CD    7406          4645     MOV A , # 6 
10CF    D5E0FD        4646     	DJNZ ACC,	$
10D2    0210D8        4647     	JMP	COMM61_NFET
                      4648     COMM61_NONDAMP: 
10D5    9001F3        4649     	MOV	DPTR, #PWM_CFET_ON
                      4650     COMM61_NFET: 
                      4651     	ANFET_OFF					; An off
10D8    207502        4651+1   JB FLAGS3 . 5 , ( $+5 ) 
10DB    D297          4651+1   SETB P1 . 7 
10DD    307502        4651+1   JNB FLAGS3 . 5 , ( $+5 ) 
10E0    D293          4651+1   SETB P1 . 3 
10E2    305A0E        4652     JNB FLAGS0 . 2 , COMM61_CP 
                      4653     	CNFET_ON					; Yes - Cn on
10E5    E525          4653+1   MOV A , CURRENT_PWM_LIMITED 
10E7    600A          4653+1   JZ ( $+12 ) 
10E9    207502        4653+1   JB FLAGS3 . 5 , ( $+5 ) 
10EC    C293          4653+1   CLR P1 . 3 
10EE    307502        4653+1   JNB FLAGS3 . 5 , ( $+5 ) 
10F1    C297          4653+1   CLR P1 . 7 
                      4654     COMM61_CP: 
                      4655     	SET_COMP_PHASE_A 			; Set comparator to phase A
10F3    207503        4655+1   JB FLAGS3 . 5 , ( $+6 ) 
10F6    759F11        4655+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
10F9    307503        4655+1   JNB FLAGS3 . 5 , ( $+6 ) 
10FC    759F13        4655+1   MOV CPT0MX , # 13H 
10FF    753E01        4656     	MOV	COMM_PHASE, #1
                      4657     
                      4658     COMM_EXIT: 
1102    D2AF          4659     	SETB	EA					; Enable all interrupts
1104    789C          4660     MOV R0 , # PGM_DEMAG_COMP 
1106    E6            4661     MOV A , @ R0 
1107    C3            4662     	CLR	C
1108    9402          4663     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
110A    4007          4664     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4665     
110C    C3            4666     	CLR	C
110D    E539          4667     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
110F    9403          4668     	SUBB	A, #3
1111    5002          4669     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4670     
                      4671     COMM_RESTORE_POWER: 
1113    C25C          4672     CLR FLAGS0 . 4 
                      4673     
                      4674     COMM_RETURN: 
1115    22            4675     	RET
                      4676     
                      4677     
                      4678     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4679     ;
                      4680     ; Switch power off routine
                      4681     ;
                      4682     ; No assumptions
                      4683     ;
                      4684     ; Switches all fets off 
                      4685     ;
                      4686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4687     SWITCH_POWER_OFF: 
1116    9001CD        4688     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4689     	ALL_NFETS_OFF			; Turn off all nfets
1119    D297          4689+1   SETB P1 . 7 
111B    D295          4689+1   SETB P1 . 5 
111D    D293          4689+1   SETB P1 . 3 
                      4690     	ALL_PFETS_OFF			; Turn off all pfets
111F    C296          4690+1   CLR P1 . 6 
1121    C294          4690+1   CLR P1 . 4 
1123    C292          4690+1   CLR P1 . 2 
1125    C25A          4691     CLR FLAGS0 . 2 
1127    22            4692     	RET			
                      4693     
                      4694     
                      4695     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4696     ;
                      4697     ; Decrement stepper step routine
                      4698     ;
                      4699     ; No assumptions
                      4700     ;
                      4701     ; Decrements the stepper step 
                      4702     ;
                      4703     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4704     DECREMENT_STEPPER_STEP: 
1128    C3            4705     	CLR	C
1129    E550          4706     	MOV	A, WT_STEPPER_STEP_L
112B    9535          4707     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
112D    E551          4708     	MOV	A, WT_STEPPER_STEP_H
112F    9536          4709     	SUBB	A, STEPPER_STEP_END_H	
1131    5001          4710     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
1133    22            4711     	RET
                      4712     
                      4713     DECREMENT_STEP: 
                      4714     	; Load programmed startup acceleration
1134    7890          4715     MOV R0 , # PGM_STARTUP_ACCEL 
1136    E6            4716     MOV A , @ R0 
1137    FF            4717     MOV R7 , A 
                      4718     	; Check acceleration setting and set step size accordingly
1138    C3            4719     	CLR	C
1139    EF            4720     MOV A , R7 
113A    9405          4721     	SUBB	A, #5
113C    5018          4722     	JNC	DEC_STEP_HIGH
113E    C3            4723     	CLR	C
113F    EF            4724     MOV A , R7 
1140    9404          4725     	SUBB	A, #4
1142    501B          4726     	JNC	DEC_STEP_MED_HIGH
1144    C3            4727     	CLR	C
1145    EF            4728     MOV A , R7 
1146    9403          4729     	SUBB	A, #3
1148    501E          4730     	JNC	DEC_STEP_MED
114A    C3            4731     	CLR	C
114B    EF            4732     MOV A , R7 
114C    9402          4733     	SUBB	A, #2
114E    5021          4734     	JNC	DEC_STEP_MED_LOW
1150    C3            4735     	CLR	C
1151    EF            4736     MOV A , R7 
1152    9401          4737     	SUBB	A, #1
1154    5024          4738     	JNC	DEC_STEP_LOW
                      4739     
                      4740     DEC_STEP_HIGH: 
1156    C3            4741     	CLR	C
1157    E550          4742     	MOV	A, WT_STEPPER_STEP_L
1159    943C          4743     	SUBB	A, #LOW(30 SHL 1)		
115B    F8            4744     MOV R0 , A 
115C    021183        4745     	JMP	DECREMENT_STEP_EXIT
                      4746     DEC_STEP_MED_HIGH: 
115F    C3            4747     	CLR	C
1160    E550          4748     	MOV	A, WT_STEPPER_STEP_L
1162    9428          4749     	SUBB	A, #LOW(20 SHL 1)		
1164    F8            4750     MOV R0 , A 
1165    021183        4751     	JMP	DECREMENT_STEP_EXIT
                      4752     DEC_STEP_MED: 
1168    C3            4753     	CLR	C
1169    E550          4754     	MOV	A, WT_STEPPER_STEP_L
116B    941A          4755     	SUBB	A, #LOW(13 SHL 1)		
116D    F8            4756     MOV R0 , A 
116E    021183        4757     	JMP	DECREMENT_STEP_EXIT
                      4758     DEC_STEP_MED_LOW: 
1171    C3            4759     	CLR	C
1172    E550          4760     	MOV	A, WT_STEPPER_STEP_L
1174    9412          4761     	SUBB	A, #LOW(9 SHL 1)		
1176    F8            4762     MOV R0 , A 
1177    021183        4763     	JMP	DECREMENT_STEP_EXIT
                      4764     DEC_STEP_LOW: 
117A    C3            4765     	CLR	C
117B    E550          4766     	MOV	A, WT_STEPPER_STEP_L
117D    940A          4767     	SUBB	A, #LOW(5 SHL 1)		
117F    F8            4768     MOV R0 , A 
1180    021183        4769     	JMP	DECREMENT_STEP_EXIT
                      4770     
                      4771     DECREMENT_STEP_EXIT: 
1183    E551          4772     	MOV	A, WT_STEPPER_STEP_H
1185    9400          4773     	SUBB	A, #0		
1187    F9            4774     MOV R1 , A 
1188    8850          4775     MOV WT_STEPPER_STEP_L , R0 
118A    8951          4776     MOV WT_STEPPER_STEP_H , R1 
118C    22            4777     	RET
                      4778     
                      4779     
                      4780     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4781     ;
                      4782     ; Stepper timer wait
                      4783     ;
                      4784     ; No assumptions
                      4785     ;
                      4786     ; Waits for the stepper step timer to elapse
                      4787     ;
                      4788     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4789     STEPPER_TIMER_WAIT: 
118D    305802        4790     JNB FLAGS0 . 0 , ( $+5 ) 
1190    218D          4791     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
1192    22            4792     	RET
                      4793     
                      4794     
                      4795     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4796     ;
                      4797     ; Set default parameters
                      4798     ;
                      4799     ; No assumptions
                      4800     ;
                      4801     ; Sets default programming parameters
                      4802     ;
                      4803     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4804     SET_DEFAULT_PARAMETERS: 
                      4805     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4866     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4927     IF MODE == 2	; Multi
1193    7880          4928     MOV R0 , # PGM_GOV_P_GAIN 
1195    7609          4929     MOV @ R0 , # 9 
1197    08            4930     INC R0 
1198    7609          4931     MOV @ R0 , # 9 
119A    08            4932     INC R0 
119B    7604          4933     MOV @ R0 , # 4 
119D    08            4934     INC R0 
119E    7601          4935     MOV @ R0 , # 1 
11A0    08            4936     INC R0 
11A1    7603          4937     MOV @ R0 , # 3 
11A3    08            4938     INC R0 
11A4    76FF          4939     MOV @ R0 , # 0XFF 
11A6    08            4940     INC R0 
11A7    7609          4941     MOV @ R0 , # 9 
11A9    08            4942     INC R0 
11AA    7601          4943     MOV @ R0 , # 1 
11AC    08            4944     INC R0 
11AD    7601          4945     MOV @ R0 , # 1 
11AF    08            4946     INC R0 
11B0    7601          4947     MOV @ R0 , # 1 
                      4948     
11B2    788C          4949     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
11B4    7600          4950     MOV @ R0 , # 0 
11B6    08            4951     INC R0 
11B7    76FF          4952     MOV @ R0 , # 0XFF 
11B9    08            4953     INC R0 
11BA    76FF          4954     MOV @ R0 , # 0XFF 
11BC    08            4955     INC R0 
11BD    7601          4956     MOV @ R0 , # 1 
11BF    08            4957     INC R0 
11C0    7605          4958     MOV @ R0 , # 5 
11C2    08            4959     INC R0 
11C3    76FF          4960     MOV @ R0 , # 0XFF 
11C5    08            4961     INC R0 
11C6    7603          4962     MOV @ R0 , # 3 
11C8    08            4963     INC R0 
11C9    7606          4964     MOV @ R0 , # 6 
11CB    08            4965     INC R0 
11CC    76FF          4966     MOV @ R0 , # 0XFF 
11CE    08            4967     INC R0 
11CF    7602          4968     MOV @ R0 , # 2 
11D1    08            4969     INC R0 
11D2    7603          4970     MOV @ R0 , # 3 
11D4    08            4971     INC R0 
11D5    76FA          4972     MOV @ R0 , # 250 
11D7    08            4973     INC R0 
11D8    7614          4974     MOV @ R0 , # 20 
11DA    08            4975     INC R0 
11DB    7614          4976     MOV @ R0 , # 20 
11DD    08            4977     INC R0 
11DE    7605          4978     MOV @ R0 , # 5 
11E0    08            4979     INC R0 
11E1    7601          4980     MOV @ R0 , # 1 
11E3    08            4981     INC R0 
11E4    7602          4982     MOV @ R0 , # 2 
11E6    08            4983     INC R0 
11E7    7600          4984     MOV @ R0 , # 0 
11E9    08            4985     INC R0 
11EA    767D          4986     MOV @ R0 , # 125 
                      4987     ENDIF
                      4988     
                      4989     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4990     ;
                      4991     ; 初始化变量 
                      4992     ; Skypup 2015.05.25
11EC    757400        4993     	MOV	PREV_RCP,	#0
11EF    757600        4994     	MOV	NHOLD_L,	#0
11F2    757700        4995     	MOV	NHOLD_H,	#0
11F5    757800        4996     MOV CSTATE , # 0 
                      4997     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
11F8    22            4998     	RET
                      4999     
                      5000     
                      5001     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5002     ;
                      5003     ; Decode parameters
                      5004     ;
                      5005     ; No assumptions
                      5006     ;
                      5007     ; Decodes programming parameters
                      5008     ;
                      5009     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5010     DECODE_PARAMETERS: 
                      5011     	; Load programmed damping force
11F9    7893          5012     MOV R0 , # PGM_DAMPING_FORCE 
11FB    E6            5013     MOV A , @ R0 
11FC    FF            5014     MOV R7 , A 
                      5015     	; Decode damping
11FD    756609        5016     	MOV	DAMPING_PERIOD, #9		; Set default
1200    756701        5017     	MOV	DAMPING_ON, #1
1203    C3            5018     	CLR	C
1204    BF0206        5019     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5020     
1207    756605        5021     	MOV	DAMPING_PERIOD, #5
120A    756701        5022     	MOV	DAMPING_ON, #1
                      5023     
                      5024     DECODE_DAMPING_3: 
120D    C3            5025     	CLR	C
120E    BF0306        5026     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5027     
1211    756605        5028     	MOV	DAMPING_PERIOD, #5
1214    756702        5029     	MOV	DAMPING_ON, #2
                      5030     
                      5031     DECODE_DAMPING_4: 
1217    C3            5032     	CLR	C
1218    BF0406        5033     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5034     
121B    756605        5035     	MOV	DAMPING_PERIOD, #5
121E    756703        5036     	MOV	DAMPING_ON, #3
                      5037     
                      5038     DECODE_DAMPING_5: 
1221    C3            5039     	CLR	C
1222    BF0506        5040     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5041     
1225    756609        5042     	MOV	DAMPING_PERIOD, #9
1228    756707        5043     	MOV	DAMPING_ON, #7
                      5044     
                      5045     DECODE_DAMPING_6: 
122B    C3            5046     	CLR	C
122C    BF0606        5047     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5048     
122F    756600        5049     	MOV	DAMPING_PERIOD, #0
1232    756700        5050     	MOV	DAMPING_ON, #0
                      5051     
                      5052     DECODE_DAMPING_DONE: 
                      5053     	; Load programmed pwm frequency
1235    7887          5054     MOV R0 , # PGM_PWM_FREQ 
1237    E6            5055     MOV A , @ R0 
1238    FF            5056     MOV R7 , A 
                      5057     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5064     IF MODE >= 1	; Tail or multi
1239    C26C          5065     CLR FLAGS2 . 4 
123B    C3            5066     	CLR	C
123C    BF0302        5067     CJNE R7 , # 3 , ( $+5 ) 
123F    D26C          5068     SETB FLAGS2 . 4 
1241    C26B          5069     CLR FLAGS2 . 3 
1243    C3            5070     	CLR	C
1244    BF0402        5071     CJNE R7 , # 4 , ( $+5 ) 
1247    D26B          5072     SETB FLAGS2 . 3 
                      5073     ENDIF
1249    C26A          5074     CLR FLAGS2 . 2 
124B    7418          5075     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
124D    552D          5076     	ANL	A, FLAGS2					; Check if any damped mode is set
124F    6002          5077     	JZ	($+4)
1251    D26A          5078     SETB FLAGS2 . 2 
1253    C265          5079     CLR FLAGS1 . 5 
1255    6002          5080     	JZ	($+4)
1257    D265          5081     SETB FLAGS1 . 5 
1259    D266          5082     SETB FLAGS1 . 6 
125B    6002          5083     	JZ	($+4)
125D    C266          5084     CLR FLAGS1 . 6 
                      5085     	; Load programmed direction
125F    7888          5086     MOV R0 , # PGM_DIRECTION 
                      5087     IF MODE >= 1	; Tail or multi
1261    E6            5088     MOV A , @ R0 
1262    C3            5089     	CLR	C
1263    9403          5090     	SUBB	A, #3
1265    6008          5091     	JZ	DECODE_PARAMS_DIR_SET
                      5092     ENDIF
                      5093     
1267    C275          5094     CLR FLAGS3 . 5 
1269    E6            5095     MOV A , @ R0 
126A    30E102        5096     	JNB	ACC.1, ($+5)
126D    D275          5097     SETB FLAGS3 . 5 
                      5098     DECODE_PARAMS_DIR_SET: 
126F    C276          5099     CLR FLAGS3 . 6 
1271    7889          5100     MOV R0 , # PGM_INPUT_POL 
1273    E6            5101     MOV A , @ R0 
1274    30E102        5102     	JNB	ACC.1, ($+5)
1277    D276          5103     SETB FLAGS3 . 6 
1279    C3            5104     	CLR	C
127A    EF            5105     MOV A , R7 
127B    9402          5106     	SUBB	A, #2
127D    6008          5107     	JZ	DECODE_PWM_FREQ_LOW
                      5108     
127F    758E01        5109     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1282    D26D          5110     SETB FLAGS2 . 5 
1284    02128C        5111     	JMP	DECODE_PWM_FREQ_END
                      5112     
                      5113     DECODE_PWM_FREQ_LOW: 
1287    758E00        5114     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
128A    C26D          5115     CLR FLAGS2 . 5 
                      5116     
                      5117     DECODE_PWM_FREQ_END: 
128C    22            5118     	RET
                      5119     
                      5120     
                      5121     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5122     ;
                      5123     ; Decode governor gain
                      5124     ;
                      5125     ; No assumptions
                      5126     ;
                      5127     ; Decodes governor gains
                      5128     ;
                      5129     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5130     DECODE_GOVERNOR_GAINS: 
                      5131     	; Decode governor gains
128D    7880          5132     MOV R0 , # PGM_GOV_P_GAIN 
128F    E6            5133     MOV A , @ R0 
1290    14            5134     	DEC	A	
1291    900080        5135     	MOV	DPTR, #GOV_GAIN_TABLE
1294    93            5136     	MOVC A, @A+DPTR	
1295    789F          5137     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1297    F6            5138     MOV @ R0 , A 
1298    7881          5139     MOV R0 , # PGM_GOV_I_GAIN 
129A    E6            5140     MOV A , @ R0 
129B    14            5141     	DEC	A	
129C    900080        5142     	MOV	DPTR, #GOV_GAIN_TABLE
129F    93            5143     	MOVC A, @A+DPTR	
12A0    78A0          5144     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
12A2    F6            5145     MOV @ R0 , A 
12A3    3116          5146     	CALL	SWITCH_POWER_OFF		; Reset DPTR
12A5    22            5147     	RET
                      5148     
                      5149     
                      5150     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5151     ;
                      5152     ; Decode throttle rate
                      5153     ;
                      5154     ; No assumptions
                      5155     ;
                      5156     ; Decodes throttle rate
                      5157     ;
                      5158     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5159     DECODE_THROTTLE_RATE: 
                      5160     	; Decode throttle rate
12A6    789B          5161     MOV R0 , # PGM_THROTTLE_RATE 
12A8    E6            5162     MOV A , @ R0 
12A9    14            5163     	DEC	A	
12AA    90008D        5164     	MOV	DPTR, #THROTTLE_RATE_TABLE
12AD    93            5165     	MOVC A, @A+DPTR	
12AE    78A1          5166     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
12B0    F6            5167     MOV @ R0 , A 
12B1    3116          5168     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12B3    22            5169     	RET
                      5170     
                      5171     
                      5172     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5173     ;
                      5174     ; Decode startup power
                      5175     ;
                      5176     ; No assumptions
                      5177     ;
                      5178     ; Decodes startup power
                      5179     ;
                      5180     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5181     DECODE_STARTUP_POWER: 
                      5182     	; Decode startup power
12B4    7886          5183     MOV R0 , # PGM_STARTUP_PWR 
12B6    E6            5184     MOV A , @ R0 
12B7    14            5185     	DEC	A	
12B8    90009A        5186     	MOV	DPTR, #STARTUP_POWER_TABLE
12BB    93            5187     	MOVC A, @A+DPTR	
12BC    78A2          5188     MOV R0 , # PGM_STARTUP_PWR_DECODED 
12BE    F6            5189     MOV @ R0 , A 
12BF    3116          5190     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12C1    22            5191     	RET
                      5192     
                      5193     
                      5194     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5195     ;
                      5196     ; Decode demag compensation
                      5197     ;
                      5198     ; No assumptions
                      5199     ;
                      5200     ; Decodes throttle rate
                      5201     ;
                      5202     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5203     DECODE_DEMAG_COMP: 
                      5204     	; Decode demag compensation
12C2    789C          5205     MOV R0 , # PGM_DEMAG_COMP 
12C4    E6            5206     MOV A , @ R0 
12C5    14            5207     	DEC	A	
12C6    9000A7        5208     	MOV	DPTR, #DEMAG_POWER_TABLE
12C9    93            5209     	MOVC A, @A+DPTR	
12CA    78A3          5210     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
12CC    F6            5211     MOV @ R0 , A 
12CD    3116          5212     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12CF    22            5213     	RET
                      5214     
                      5215     
                      5216     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5217     ;
                      5218     ; Set BEC voltage
                      5219     ;
                      5220     ; No assumptions
                      5221     ;
                      5222     ; Sets the BEC output voltage low or high
                      5223     ;
                      5224     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5225     SET_BEC_VOLTAGE: 
                      5226     	; Set bec voltage
                      5227     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
12D0    22            5237     	RET
                      5238     
                      5239     
                      5240     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5241     ;
                      5242     ; Find throttle gain
                      5243     ;
                      5244     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5245     ;
                      5246     ; Finds throttle gain from throttle calibration values
                      5247     ;
                      5248     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5249     FIND_THROTTLE_GAIN: 
                      5250     	; Load programmed minimum and maximum throttle
12D1    7896          5251     MOV R0 , # PGM_PPM_MIN_THROTTLE 
12D3    E6            5252     MOV A , @ R0 
12D4    FA            5253     MOV R2 , A 
12D5    7897          5254     MOV R0 , # PGM_PPM_MAX_THROTTLE 
12D7    E6            5255     MOV A , @ R0 
12D8    FB            5256     MOV R3 , A 
                      5257     	; Check if full range is chosen
12D9    307704        5258     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5259     
12DC    7A00          5260     MOV R2 , # 0 
12DE    7BFF          5261     MOV R3 , # 255 
                      5262     
                      5263     FIND_THROTTLE_GAIN_CALCULATE: 
                      5264     	; Calculate difference
12E0    C3            5265     	CLR	C
12E1    EB            5266     MOV A , R3 
12E2    9A            5267     SUBB A , R2 
12E3    FC            5268     MOV R4 , A 
                      5269     	; Check that difference is minimum 130
12E4    C3            5270     	CLR	C
12E5    9482          5271     	SUBB	A, #130
12E7    5002          5272     	JNC	($+4)
                      5273     
12E9    7C82          5274     MOV R4 , # 130 
                      5275     
                      5276     	; Find gain
12EB    756E00        5277     	MOV	PPM_THROTTLE_GAIN, #0
                      5278     TEST_THROTTLE_GAIN: 
12EE    056E          5279     	INC	PPM_THROTTLE_GAIN
12F0    EC            5280     MOV A , R4 
12F1    856EF0        5281     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
12F4    A4            5282     	MUL	AB
12F5    C3            5283     	CLR	C
12F6    E5F0          5284     	MOV	A, B
12F8    9480          5285     	SUBB	A, #128
12FA    40F2          5286     	JC	TEST_THROTTLE_GAIN
12FC    22            5287     	RET
                      5288     
                      5289     
                      5290     
                      5291     
                      5292     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5293     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5294     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5295     ;
                      5296     ; Main program start
                      5297     ;
                      5298     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5299     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5300     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5301     
                      5302     RESET: 
                      5303     	; Check flash lock byte
12FD    E5EF          5304     	MOV	A, RSTSRC			
12FF    20E603        5305     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5306     
1302    752000        5307     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5308     
1305    0520          5309     	INC	BIT_ACCESS
1307    903FFF        5310     MOV DPTR , # 16383 
130A    E520          5311     	MOV	A, BIT_ACCESS
130C    14            5312     	DEC	A
130D    6006          5313     	JZ	LOCK_BYTE_TEST
                      5314     
130F    901DFF        5315     MOV DPTR , # 7679 
1312    14            5316     	DEC	A
1313    6000          5317     	JZ	LOCK_BYTE_TEST
                      5318     
                      5319     LOCK_BYTE_TEST: 
1315    93            5320     	MOVC A, @A+DPTR		; Read lock byte
1316    04            5321     	INC	A				
1317    6003          5322     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5323     
                      5324     IF ONE_S_CAPABLE == 0		
1319    75EF12        5325     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5326     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5329     
                      5330     LOCK_BYTE_OK: 
                      5331     	; Select register bank 0 for main program routines
131C    C2D3          5332     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5333     	; Disable the WDT.
131E    53D9BF        5334     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5335     	; Initialize stack
1321    7581C0        5336     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5337     	; Initialize VDD monitor
1324    43FF80        5338     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1327    120815        5339     	CALL	WAIT1MS			; Wait at least 100us
                      5340     IF ONE_S_CAPABLE == 0		
132A    75EF02        5341     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5342     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5345     	; Set clock frequency
132D    43B203        5346     	ORL	OSCICN, #03H		; Set clock divider to 1
1330    E5B3          5347     	MOV	A, OSCICL				
1332    2404          5348     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1334    4002          5349     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5350     
1336    F5B3          5351     	MOV	OSCICL, A
                      5352     
                      5353     RESET_CAL_DONE: 
                      5354     	; Switch power off
1338    3116          5355     	CALL	SWITCH_POWER_OFF
                      5356     	; Ports initialization
133A    7580FF        5357     MOV P0 , # 255 
133D    75A400        5358     MOV P0MDOUT , # 0 
1340    75F1B2        5359     MOV P0MDIN , # -78 
1343    75D4DF        5360     MOV P0SKIP , # 223 
1346    7590A9        5361     MOV P1 , # 169 
1349    75A5FC        5362     MOV P1MDOUT , # 252 
134C    75F2FC        5363     MOV P1MDIN , # 252 
134F    75D501        5364     MOV P1SKIP , # 1 
                      5365     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
1352    75A601        5368     MOV P2MDOUT , # 1 
                      5369     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5376     	; Initialize the XBAR and related functionality
                      5377     	INITIALIZE_XBAR		
1355    75E241        5377+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5378     	; Clear RAM
1358    E4            5379     	CLR	A				; Clear accumulator
1359    F8            5380     MOV R0 , A 
                      5381     CLEAR_RAM: 	
135A    F6            5382     MOV @ R0 , A 
135B    D8FD          5383     DJNZ R0 , CLEAR_RAM 
                      5384     	; Set default programmed parameters
135D    3193          5385     	CALL	SET_DEFAULT_PARAMETERS
                      5386     	; Decode parameters
135F    31F9          5387     	CALL	DECODE_PARAMETERS
                      5388     	; Decode governor gains
1361    518D          5389     	CALL	DECODE_GOVERNOR_GAINS
                      5390     	; Decode throttle rate
1363    51A6          5391     	CALL	DECODE_THROTTLE_RATE
                      5392     	; Decode startup power
1365    51B4          5393     	CALL	DECODE_STARTUP_POWER
                      5394     	; Decode demag compensation
1367    51C2          5395     	CALL	DECODE_DEMAG_COMP
                      5396     	; Set BEC voltage
1369    51D0          5397     	CALL	SET_BEC_VOLTAGE
                      5398     	; Find throttle gain from stored min and max settings
136B    51D1          5399     	CALL	FIND_THROTTLE_GAIN
                      5400     	; Set beep strength
136D    7898          5401     MOV R0 , # PGM_BEEP_STRENGTH 
136F    866F          5402     MOV BEEP_STRENGTH , @ R0 
                      5403     	; Switch power off
1371    3116          5404     	CALL	SWITCH_POWER_OFF
                      5405     	; Timer control
1373    758850        5406     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5407     	; Timer mode
1376    758902        5408     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5409     	; Timer2: clk/12 for 128us and 32ms interrupts
1379    75C824        5410     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5411     	; Timer3: clk/12 for commutation timing
137C    759104        5412     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5413     	; PCA
137F    75D840        5414     	MOV	PCA0CN, #40H		; PCA enabled
                      5415     	; Initializing beep
1382    C2AF          5416     	CLR	EA				; Disable interrupts explicitly
1384    12082E        5417     	CALL WAIT200MS	
1387    120845        5418     	CALL BEEP_F1
138A    12081F        5419     	CALL WAIT10MS
138D    12084C        5420     	CALL BEEP_F2
1390    12081F        5421     	CALL WAIT10MS
1393    120853        5422     	CALL BEEP_F3
1396    12081F        5423     	CALL WAIT10MS
1399    12085A        5424     	CALL BEEP_F4
139C    12081F        5425     	CALL WAIT10MS
                      5426     
                      5427     	; Wait for receiver to initialize
139F    12083E        5428     	CALL	WAIT1S
13A2    12082E        5429     	CALL	WAIT200MS
13A5    12082E        5430     	CALL	WAIT200MS
13A8    120829        5431     	CALL	WAIT100MS
                      5432     
                      5433     
                      5434     	; Enable interrupts
13AB    75A822        5435     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
13AE    75B802        5436     	MOV	IP, #02H			; High priority to timer0 interrupts
13B1    75E690        5437     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5438     	; Initialize comparator
13B4    759B80        5439     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
13B7    759D03        5440     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5441     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5445     	; Initialize ADC
                      5446     	INITIALIZE_ADC			; Initialize ADC operation
13BA    75D10E        5446+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
13BD    75BC58        5446+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
13C0    75BB08        5446+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
13C3    75BA11        5446+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
13C6    75E880        5446+1   MOV ADC0CN , # 80H  ; ADC ENABLED
13C9    120815        5447     	CALL	WAIT1MS
13CC    D2AF          5448     	SETB	EA				; Enable all interrupts
                      5449     
                      5450     	; Measure number of lipo cells
13CE    120AFD        5451     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5452     	; Initialize rc pulse
                      5453     	RCP_INT_ENABLE		 			; Enable interrupt
13D1    43DA01        5453+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5454     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
13D4    C2D8          5454+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
13D6    C269          5455     CLR FLAGS2 . 1 
13D8    12082E        5456     	CALL WAIT200MS
                      5457     	; Set initial arm variable
13DB    753001        5458     	MOV	INITIAL_ARM, #1
13DE    757301        5459     	MOV	FLAG_BEFORE_ARM, #1
                      5460     
                      5461     	; Measure PWM frequency
                      5462     MEASURE_PWM_FREQ_INIT: 	
13E1    D259          5463     SETB FLAGS0 . 1 
                      5464     MEASURE_PWM_FREQ_START: 	
13E3    7A05          5465     MOV R2 , # 5 
                      5466     MEASURE_PWM_FREQ_LOOP: 	
                      5467     	; Check if period diff was accepted
13E5    E558          5468     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
13E7    7002          5469     	JNZ	($+4)
                      5470     
13E9    7A05          5471     MOV R2 , # 5 
                      5472     
13EB    12081A        5473     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
13EE    E559          5474     	MOV	A, NEW_RCP					; Load value
13F0    C3            5475     	CLR	C
13F1    9402          5476     SUBB A , # 2 
13F3    40EE          5477     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5478     
13F5    E52E          5479     	MOV	A, FLAGS3						; Check pwm frequency flags
13F7    541F          5480     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13F9    855B5A        5481     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
13FC    F55B          5482     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
13FE    B55AE2        5483     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5484     
1401    DAE2          5485     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5486     
                      5487     	; Clear measure pwm frequency flag
1403    C259          5488     CLR FLAGS0 . 1 
                      5489     	; Set up RC pulse interrupts after pwm frequency measurement
                      5490     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1405    53DACF        5490+1   ANL PCA0CPM0 , # 0CFH 
1408    207603        5490+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
140B    43DA20        5490+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
140E    307603        5490+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1411    43DA10        5490+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5491     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1414    C2D8          5491+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1416    C269          5492     CLR FLAGS2 . 1 
1418    120829        5493     	CALL WAIT100MS						; Wait for new RC pulse
                      5494     
                      5495     	; Validate RC pulse
                      5496     VALIDATE_RCP_START: 	
141B    12081A        5497     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
141E    7802          5498     MOV R0 , # 2 
1420    741F          5499     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1422    552E          5500     	ANL	A, FLAGS3						; Check pwm frequency flags
1424    7002          5501     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5502     
1426    7800          5503     MOV R0 , # 0 
                      5504     
1428    C3            5505     	CLR	C
1429    E559          5506     	MOV	A, NEW_RCP					; Load value
142B    98            5507     SUBB A , R0 
142C    40ED          5508     	JC	VALIDATE_RCP_START				; No - start over
                      5509     
                      5510     	; Beep arm sequence start signal
142E    C2AF          5511     	CLR 	EA							; Disable all interrupts
1430    120845        5512     	CALL BEEP_F1
1433    12081F        5513     	CALL WAIT10MS
1436    120845        5514     	CALL BEEP_F1
1439    12081F        5515     	CALL WAIT10MS
143C    12084C        5516     	CALL BEEP_F2
143F    12081F        5517     	CALL WAIT10MS
1442    12084C        5518     	CALL BEEP_F2
1445    12081F        5519     	CALL WAIT10MS
1448    D2AF          5520     	SETB	EA							; Enable all interrupts
144A    12082E        5521     	CALL WAIT200MS	
                      5522     
144D    757300        5523     	MOV	FLAG_BEFORE_ARM, #0		; 为了让定制的程序输出最低油门. Skypup 2015.05.26
                      5524     
                      5525     	; Arming sequence start
1450    754800        5526     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5527     ARMING_START: 
1453    C3            5528     	CLR	C
1454    E559          5529     	MOV	A, NEW_RCP			; Load new RC pulse value
1456    9548          5530     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1458    4003          5531     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5532     
145A    855948        5533     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5534     
                      5535     ARM_TARGET_UPDATED: 
145D    120829        5536     	CALL WAIT100MS				; Wait for new throttle value
1460    C3            5537     	CLR	C
1461    E559          5538     	MOV	A, NEW_RCP			; Load new RC pulse value
1463    9401          5539     SUBB A , # 1 
1465    4002          5540     	JC	ARM_END_BEEP			; Yes - proceed
                      5541     
1467    80EA          5542     	JMP	ARMING_START			; No - start over
                      5543     
                      5544     ARM_END_BEEP: 
                      5545     	; Beep arm sequence end signal
1469    C2AF          5546     	CLR 	EA					; Disable all interrupts
146B    12085A        5547     	CALL BEEP_F4
146E    12081F        5548     	CALL WAIT10MS
1471    12085A        5549     	CALL BEEP_F4
1474    12081F        5550     	CALL WAIT10MS
1477    120853        5551     	CALL BEEP_F3
147A    12081F        5552     	CALL WAIT10MS
147D    120853        5553     	CALL BEEP_F3
1480    12081F        5554     	CALL WAIT10MS
1483    D2AF          5555     	SETB	EA					; Enable all interrupts
1485    12082E        5556     	CALL WAIT200MS
                      5557     
                      5558     	; Clear initial arm variable
1488    753000        5559     	MOV	INITIAL_ARM, #0
                      5560     
                      5561     	; Armed and waiting for power on
                      5562     WAIT_FOR_POWER_ON: 
148B    E4            5563     	CLR	A
148C    F531          5564     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
148E    F532          5565     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5566     WAIT_FOR_POWER_ON_LOOP: 
1490    0531          5567     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1492    E531          5568     	MOV	A, POWER_ON_WAIT_CNT_L
1494    F4            5569     	CPL	A
1495    7039          5570     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5571     
1497    0532          5572     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1499    789A          5573     MOV R0 , # PGM_BEACON_DELAY 
149B    E6            5574     MOV A , @ R0 
149C    7819          5575     MOV R0 , # 25 
149E    14            5576     	DEC	A
149F    6012          5577     	JZ	BEEP_DELAY_SET
                      5578     
14A1    7832          5579     MOV R0 , # 50 
14A3    14            5580     	DEC	A
14A4    600D          5581     	JZ	BEEP_DELAY_SET
                      5582     
14A6    787D          5583     MOV R0 , # 125 
14A8    14            5584     	DEC	A
14A9    6008          5585     	JZ	BEEP_DELAY_SET
                      5586     
14AB    78FA          5587     MOV R0 , # 250 
14AD    14            5588     	DEC	A
14AE    6003          5589     	JZ	BEEP_DELAY_SET
                      5590     
14B0    753200        5591     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5592     
                      5593     BEEP_DELAY_SET: 
14B3    C3            5594     	CLR	C
14B4    E532          5595     	MOV	A, POWER_ON_WAIT_CNT_H
14B6    98            5596     SUBB A , R0 
14B7    4017          5597     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5598     
14B9    1532          5599     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14BB    7531B4        5600     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14BE    7899          5601     MOV R0 , # PGM_BEACON_STRENGTH 
14C0    866F          5602     MOV BEEP_STRENGTH , @ R0 
14C2    C2AF          5603     	CLR 	EA					; Disable all interrupts
14C4    12085A        5604     	CALL BEEP_F4				; Signal that there is no signal
14C7    D2AF          5605     	SETB	EA					; Enable all interrupts
14C9    7898          5606     MOV R0 , # PGM_BEEP_STRENGTH 
14CB    866F          5607     MOV BEEP_STRENGTH , @ R0 
14CD    120829        5608     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5609     
                      5610     WAIT_FOR_POWER_ON_NO_BEEP: 
14D0    12081F        5611     	CALL WAIT10MS
14D3    E528          5612     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14D5    7008          5613     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5614     
14D7    741F          5615     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
14D9    552E          5616     	ANL	A, FLAGS3						; Check pwm frequency flags
14DB    7002          5617     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5618     
14DD    61E1          5619     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5620     
                      5621     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14DF    C3            5622     	CLR	C
14E0    E559          5623     	MOV	A, NEW_RCP			; Load new RC pulse value
14E2    9406          5624     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
14E4    40AA          5625     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5626     
                      5627     IF MODE >= 1	; Tail or multi
14E6    7888          5628     MOV R0 , # PGM_DIRECTION 
14E8    E6            5629     MOV A , @ R0 
14E9    C3            5630     	CLR	C
14EA    9403          5631     	SUBB	A, #3
14EC    6003          5632     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5633     ENDIF
                      5634     
14EE    120829        5635     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5636     
14F1    E528          5637     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14F3    7003          5638     	JNZ	($+5)				; If it is not zero - proceed
                      5639     
14F5    0213E1        5640     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5641     
                      5642     
                      5643     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5644     ;
                      5645     ; Start entry point
                      5646     ;
                      5647     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5648     INIT_START: 
14F8    C2AF          5649     	CLR	EA
14FA    3116          5650     	CALL SWITCH_POWER_OFF
14FC    E4            5651     	CLR	A
14FD    F522          5652     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
14FF    F523          5653     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1501    F524          5654     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1503    F525          5655     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1505    D2AF          5656     	SETB	EA
1507    7885          5657     MOV R0 , # PGM_MOTOR_IDLE 
1509    8661          5658     MOV PWM_MOTOR_IDLE , @ R0 
150B    F540          5659     	MOV	GOV_TARGET_L, A		; Set target to zero
150D    F541          5660     	MOV	GOV_TARGET_H, A
150F    F542          5661     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1511    F543          5662     	MOV	GOV_INTEGRAL_H, A
1513    F544          5663     	MOV	GOV_INTEGRAL_X, A
1515    F56C          5664     	MOV	ADC_CONVERSION_CNT, A
1517    F549          5665     	MOV	GOV_ACTIVE, A
1519    F52B          5666     	MOV	FLAGS0, A				; Clear flags0
151B    F52C          5667     	MOV	FLAGS1, A				; Clear flags1
151D    F539          5668     	MOV	DEMAG_CONSECUTIVE_CNT, A
151F    120C7A        5669     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5670     	;**** **** **** **** ****
                      5671     	; Motor start beginning
                      5672     	;**** **** **** **** **** 
1522    756C08        5673     MOV ADC_CONVERSION_CNT , # 8 
                      5674     	SET_ADC_IP_TEMP
1525    75BB10        5674+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1528    120815        5675     	CALL WAIT1MS
152B    120B97        5676     	CALL START_ADC_CONVERSION
                      5677     READ_INITIAL_TEMP: 
                      5678     	GET_ADC_STATUS 
152E    E5E8          5678+1   MOV A , ADC0CN 
1530    20ECFB        5679     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5680     	READ_ADC_RESULT						; Read initial temperature
1533    A8BD          5680+1   MOV R0 , ADC0L 
1535    A9BE          5680+1   MOV R1 , ADC0H 
1537    E9            5681     MOV A , R1 
1538    7001          5682     	JNZ	($+3)							; Is reading below 256?
                      5683     
153A    F8            5684     MOV R0 , A 
                      5685     
153B    886D          5686     MOV CURRENT_AVERAGE_TEMP , R0 
153D    120B9B        5687     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1540    756C08        5688     MOV ADC_CONVERSION_CNT , # 8 
                      5689     	SET_ADC_IP_TEMP
1543    75BB10        5689+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5690     
                      5691     	; Go to the desired startup mode
1546    7895          5692     MOV R0 , # PGM_STARTUP_METHOD 
1548    E6            5693     MOV A , @ R0 
1549    30E003        5694     	JNB	ACC.0, DIRECT_METHOD_START
                      5695     
154C    02158F        5696     	JMP	STEPPER_METHOD_START
                      5697     
                      5698     DIRECT_METHOD_START: 
                      5699     	; Set up start operating conditions
154F    7887          5700     MOV R0 , # PGM_PWM_FREQ 
1551    E6            5701     MOV A , @ R0 
1552    FE            5702     MOV R6 , A 
1553    7602          5703     MOV @ R0 , # 2 
1555    31F9          5704     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1557    7887          5705     MOV R0 , # PGM_PWM_FREQ 
1559    EE            5706     MOV A , R6 
155A    F6            5707     MOV @ R0 , A 
                      5708     	; Set max allowed power
155B    D261          5709     SETB FLAGS1 . 1 
155D    C2AF          5710     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
155F    755EFF        5711     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1562    120C4A        5712     	CALL SET_STARTUP_PWM
1565    85225E        5713     	MOV	PWM_LIMIT, REQUESTED_PWM
1568    85225F        5714     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
156B    D2AF          5715     	SETB	EA
156D    C261          5716     CLR FLAGS1 . 1 
156F    752501        5717     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
1572    855D64        5718     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1575    756501        5719     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5720     	; Begin startup sequence
1578    D260          5721     SETB FLAGS1 . 0 
157A    D263          5722     SETB FLAGS1 . 3 
157C    753800        5723     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
157F    115E          5724     	CALL COMM5COMM6				; Initialize commutation
1581    11AB          5725     	CALL COMM6COMM1				
1583    120CF4        5726     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1586    120C7A        5727     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
1589    120D77        5728     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
158C    0216B2        5729     	JMP	RUN1
                      5730     
                      5731     
                      5732     STEPPER_METHOD_START: 
                      5733     	; Set up start operating conditions
158F    7887          5734     MOV R0 , # PGM_PWM_FREQ 
1591    E6            5735     MOV A , @ R0 
1592    FE            5736     MOV R6 , A 
1593    7603          5737     MOV @ R0 , # 3 
1595    7893          5738     MOV R0 , # PGM_DAMPING_FORCE 
1597    E6            5739     MOV A , @ R0 
1598    FD            5740     MOV R5 , A 
1599    7605          5741     MOV @ R0 , # 5 
159B    31F9          5742     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
159D    7887          5743     MOV R0 , # PGM_PWM_FREQ 
159F    EE            5744     MOV A , R6 
15A0    F6            5745     MOV @ R0 , A 
15A1    7893          5746     MOV R0 , # PGM_DAMPING_FORCE 
15A3    ED            5747     MOV A , R5 
15A4    F6            5748     MOV @ R0 , A 
                      5749     	; Begin startup sequence
15A5    D260          5750     SETB FLAGS1 . 0 
15A7    D261          5751     SETB FLAGS1 . 1 
15A9    D265          5752     SETB FLAGS1 . 5 
15AB    115E          5753     	CALL COMM5COMM6			; Initialize commutation
15AD    11AB          5754     	CALL COMM6COMM1			
15AF    755EFF        5755     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15B2    120C4A        5756     	CALL SET_STARTUP_PWM
15B5    120815        5757     	CALL WAIT1MS
15B8    120F22        5758     	CALL COMM1COMM2
15BB    120815        5759     	CALL WAIT1MS
15BE    120815        5760     	CALL WAIT1MS
15C1    120F76        5761     	CALL COMM2COMM3
15C4    12081A        5762     	CALL WAIT3MS			
15C7    120FC0        5763     	CALL COMM3COMM4
15CA    12081A        5764     	CALL WAIT3MS			
15CD    12081A        5765     	CALL WAIT3MS			
15D0    111D          5766     	CALL COMM4COMM5
15D2    12081F        5767     	CALL WAIT10MS				; Settle rotor
15D5    115E          5768     	CALL COMM5COMM6
15D7    12081A        5769     	CALL WAIT3MS				
15DA    120815        5770     	CALL WAIT1MS			
15DD    C261          5771     CLR FLAGS1 . 1 
15DF    D262          5772     SETB FLAGS1 . 2 
                      5773     
                      5774     	;**** **** **** **** ****
                      5775     	; Stepper phase beginning
                      5776     	;**** **** **** **** **** 
                      5777     STEPPER_ROT_BEG: 
15E1    120B97        5778     	CALL START_ADC_CONVERSION
15E4    120B9B        5779     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15E7    120C4A        5780     	CALL SET_STARTUP_PWM
15EA    756C08        5781     MOV ADC_CONVERSION_CNT , # 8 
                      5782     	SET_ADC_IP_TEMP
15ED    75BB10        5782+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5783     
15F0    11AB          5784     	CALL COMM6COMM1				; Commutate
15F2    120CED        5785     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
15F5    120D77        5786     	CALL CALC_NEW_WAIT_TIMES
15F8    3128          5787     	CALL DECREMENT_STEPPER_STEP
15FA    318D          5788     	CALL STEPPER_TIMER_WAIT
                      5789     
15FC    120F22        5790     	CALL COMM1COMM2			
15FF    120CED        5791     	CALL CALC_NEXT_COMM_TIMING_START	
1602    120D77        5792     	CALL CALC_NEW_WAIT_TIMES
1605    3128          5793     	CALL DECREMENT_STEPPER_STEP
1607    318D          5794     	CALL STEPPER_TIMER_WAIT
                      5795     
1609    120F76        5796     	CALL COMM2COMM3			
160C    120CED        5797     	CALL CALC_NEXT_COMM_TIMING_START	
160F    120D77        5798     	CALL CALC_NEW_WAIT_TIMES
1612    3128          5799     	CALL DECREMENT_STEPPER_STEP
1614    318D          5800     	CALL STEPPER_TIMER_WAIT
                      5801     
1616    120FC0        5802     	CALL COMM3COMM4			
1619    120CED        5803     	CALL CALC_NEXT_COMM_TIMING_START	
161C    120D77        5804     	CALL CALC_NEW_WAIT_TIMES
161F    3128          5805     	CALL DECREMENT_STEPPER_STEP
1621    318D          5806     	CALL STEPPER_TIMER_WAIT
                      5807     
1623    111D          5808     	CALL COMM4COMM5			
1625    120CED        5809     	CALL CALC_NEXT_COMM_TIMING_START	
1628    120D77        5810     	CALL CALC_NEW_WAIT_TIMES
162B    3128          5811     	CALL DECREMENT_STEPPER_STEP
162D    318D          5812     	CALL STEPPER_TIMER_WAIT
                      5813     
162F    115E          5814     	CALL COMM5COMM6			
1631    120CED        5815     	CALL CALC_NEXT_COMM_TIMING_START	
1634    120D77        5816     	CALL CALC_NEW_WAIT_TIMES
1637    3128          5817     	CALL DECREMENT_STEPPER_STEP	
                      5818     	; Check stepper step versus end criteria
1639    C3            5819     	CLR	C
163A    E550          5820     	MOV	A, WT_STEPPER_STEP_L
163C    9535          5821     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
163E    E551          5822     	MOV	A, WT_STEPPER_STEP_H
1640    9536          5823     	SUBB	A, STEPPER_STEP_END_H
1642    400C          5824     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5825     
                      5826     	; Wait for step
1644    318D          5827     	CALL STEPPER_TIMER_WAIT
1646    C3            5828     	CLR	C
1647    E559          5829     	MOV	A, NEW_RCP				; Load new pulse value
1649    9401          5830     SUBB A , # 1 
164B    5094          5831     	JNC	STEPPER_ROT_BEG
                      5832     
164D    0217E1        5833     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5834     
                      5835     STEPPER_ROT_EXIT: 
                      5836     	; Wait for step
1650    318D          5837     	CALL STEPPER_TIMER_WAIT
                      5838     	; Clear stepper phase
1652    C262          5839     CLR FLAGS1 . 2 
                      5840     	; Set dondamped low pwm frequency
1654    7887          5841     MOV R0 , # PGM_PWM_FREQ 
1656    E6            5842     MOV A , @ R0 
1657    FE            5843     MOV R6 , A 
1658    7602          5844     MOV @ R0 , # 2 
165A    31F9          5845     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
165C    7887          5846     MOV R0 , # PGM_PWM_FREQ 
165E    EE            5847     MOV A , R6 
165F    F6            5848     MOV @ R0 , A 
                      5849     	; Set spoolup power variables (power is now controlled from RCP)
1660    85225E        5850     	MOV	PWM_LIMIT, REQUESTED_PWM
1663    85605F        5851     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
1666    856025        5852     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
1669    855D64        5853     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
166C    756501        5854     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5855     	; Set direct startup phase to acquire sync quickly
166F    D263          5856     SETB FLAGS1 . 3 
1671    753800        5857     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1674    C2AF          5858     	CLR	EA						; Disable interrupts
                      5859     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
1676    207502        5859+1   JB FLAGS3 . 5 , ( $+5 ) 
1679    C296          5859+1   CLR P1 . 6 
167B    307502        5859+1   JNB FLAGS3 . 5 , ( $+5 ) 
167E    C292          5859+1   CLR P1 . 2 
                      5860     	CPFET_OFF						; Cp off
1680    207502        5860+1   JB FLAGS3 . 5 , ( $+5 ) 
1683    C292          5860+1   CLR P1 . 2 
1685    307502        5860+1   JNB FLAGS3 . 5 , ( $+5 ) 
1688    C296          5860+1   CLR P1 . 6 
168A    742D          5861     	MOV	A, #45					; 8us delay for pfets to go off
168C    D5E0FD        5862     	DJNZ	ACC, $
168F    D2AF          5863     	SETB	EA						; Enable interrupts
1691    11AB          5864     	CALL COMM6COMM1				
1693    120CF4        5865     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
1696    120D63        5866     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
1699    120D77        5867     	CALL CALC_NEW_WAIT_TIMES
169C    120E08        5868     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
169F    756C00        5869     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5870     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16A2    75BB08        5870+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16A5    0216B2        5871     	JMP	RUN1
                      5872     
                      5873     
                      5874     
                      5875     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5876     ;
                      5877     ; Run entry point
                      5878     ;
                      5879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5880     DAMPED_TRANSITION: 
                      5881     	; Transition from nondamped to damped if applicable
16A8    31F9          5882     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16AA    11AB          5883     	CALL	COMM6COMM1
16AC    756C00        5884     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5885     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16AF    75BB08        5885+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5886     
                      5887     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5888     ; Out_cA changes from low to high
                      5889     RUN1: 
16B2    120E2A        5890     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16B5    120EAF        5891     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16B8    120EDA        5892     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16BB    120944        5893     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16BE    120EEE        5894     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16C1    120F22        5895     	CALL COMM1COMM2			; Commutate
16C4    120CF4        5896     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
16C7    120D63        5897     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
16CA    120D77        5898     	CALL CALC_NEW_WAIT_TIMES
16CD    120E08        5899     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5900     
                      5901     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5902     ; Out_cB changes from high to low
                      5903     RUN2: 
16D0    120E21        5904     	CALL WAIT_FOR_COMP_OUT_LOW
16D3    120EAF        5905     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16D6    120EDA        5906     	CALL SETUP_COMM_WAIT	
16D9    1209A1        5907     	CALL CALC_GOVERNOR_PROP_ERROR
16DC    120EEE        5908     	CALL WAIT_FOR_COMM
16DF    120F76        5909     	CALL COMM2COMM3
16E2    120CF4        5910     	CALL CALC_NEXT_COMM_TIMING
16E5    120D63        5911     	CALL WAIT_ADVANCE_TIMING
16E8    120D77        5912     	CALL CALC_NEW_WAIT_TIMES
16EB    120E08        5913     	CALL WAIT_BEFORE_ZC_SCAN	
                      5914     
                      5915     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5916     ; Out_cC changes from low to high
                      5917     RUN3: 
16EE    120E2A        5918     	CALL WAIT_FOR_COMP_OUT_HIGH
16F1    120EAF        5919     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16F4    120EDA        5920     	CALL SETUP_COMM_WAIT	
16F7    1209DA        5921     	CALL CALC_GOVERNOR_INT_ERROR
16FA    120EEE        5922     	CALL WAIT_FOR_COMM
16FD    120FC0        5923     	CALL COMM3COMM4
1700    120CF4        5924     	CALL CALC_NEXT_COMM_TIMING
1703    120D63        5925     	CALL WAIT_ADVANCE_TIMING
1706    120D77        5926     	CALL CALC_NEW_WAIT_TIMES
1709    120E08        5927     	CALL WAIT_BEFORE_ZC_SCAN	
                      5928     
                      5929     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5930     ; Out_cA changes from high to low
                      5931     RUN4: 
170C    120E21        5932     	CALL WAIT_FOR_COMP_OUT_LOW
170F    120EAF        5933     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1712    120EDA        5934     	CALL SETUP_COMM_WAIT	
1715    120A37        5935     	CALL CALC_GOVERNOR_PROP_CORRECTION
1718    120EEE        5936     	CALL WAIT_FOR_COMM
171B    111D          5937     	CALL COMM4COMM5
171D    120CF4        5938     	CALL CALC_NEXT_COMM_TIMING
1720    120D63        5939     	CALL WAIT_ADVANCE_TIMING
1723    120D77        5940     	CALL CALC_NEW_WAIT_TIMES
1726    120E08        5941     	CALL WAIT_BEFORE_ZC_SCAN	
                      5942     
                      5943     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5944     ; Out_cB changes from low to high
                      5945     RUN5: 
1729    120E2A        5946     	CALL WAIT_FOR_COMP_OUT_HIGH
172C    120EAF        5947     	CALL	EVALUATE_COMPARATOR_INTEGRITY
172F    120EDA        5948     	CALL SETUP_COMM_WAIT	
1732    120A9B        5949     	CALL CALC_GOVERNOR_INT_CORRECTION
1735    120EEE        5950     	CALL WAIT_FOR_COMM
1738    115E          5951     	CALL COMM5COMM6
173A    120CF4        5952     	CALL CALC_NEXT_COMM_TIMING
173D    120D63        5953     	CALL WAIT_ADVANCE_TIMING
1740    120D77        5954     	CALL CALC_NEW_WAIT_TIMES
1743    120E08        5955     	CALL WAIT_BEFORE_ZC_SCAN	
                      5956     
                      5957     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5958     ; Out_cC changes from high to low
                      5959     RUN6: 
1746    120E21        5960     	CALL WAIT_FOR_COMP_OUT_LOW
1749    120B97        5961     	CALL START_ADC_CONVERSION
174C    120EAF        5962     	CALL	EVALUATE_COMPARATOR_INTEGRITY
174F    120EDA        5963     	CALL SETUP_COMM_WAIT	
1752    120B9B        5964     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1755    120EEE        5965     	CALL WAIT_FOR_COMM
1758    11AB          5966     	CALL COMM6COMM1
175A    120CF4        5967     	CALL CALC_NEXT_COMM_TIMING
175D    120D63        5968     	CALL WAIT_ADVANCE_TIMING
1760    120D77        5969     	CALL CALC_NEW_WAIT_TIMES
1763    120E08        5970     	CALL WAIT_BEFORE_ZC_SCAN	
                      5971     
                      5972     	; Check if it is direct startup
1766    306342        5973     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      5974     
                      5975     	; Set spoolup power variables
1769    85605E        5976     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
176C    85605F        5977     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
176F    855D64        5978     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1772    756501        5979     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5980     	; Check startup ok counter
1775    7964          5981     MOV R1 , # 100 
1777    7A14          5982     MOV R2 , # 20 
                      5983     IF MODE >= 1	; Tail or multi
1779    7888          5984     MOV R0 , # PGM_DIRECTION 
177B    E6            5985     MOV A , @ R0 
177C    B40304        5986     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      5987     
177F    791E          5988     MOV R1 , # 30 
1781    7A05          5989     MOV R2 , # 5 
                      5990     
                      5991     DIRECT_START_PARAMS_SET: 
                      5992     ENDIF
1783    C3            5993     	CLR	C
1784    E538          5994     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
1786    99            5995     SUBB A , R1 
1787    4015          5996     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5997     
1789    C263          5998     CLR FLAGS1 . 3 
178B    D264          5999     SETB FLAGS1 . 4 
178D    8A37          6000     MOV STARTUP_ROT_CNT , R2 
                      6001     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6005     IF MODE == 2	; Multi
178F    7888          6006     MOV R0 , # PGM_DIRECTION 
1791    E6            6007     MOV A , @ R0 
1792    B40306        6008     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6009     
1795    755EFF        6010     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
1798    755FFF        6011     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6012     
                      6013     DIRECT_START_PWM_LIM_SET: 
                      6014     ENDIF
179B    0217AB        6015     	JMP	NORMAL_RUN_CHECKS
                      6016     
                      6017     DIRECT_START_CHECK_RCP: 
179E    C3            6018     	CLR	C
179F    E559          6019     	MOV	A, NEW_RCP				; Load new pulse value
17A1    9401          6020     SUBB A , # 1 
17A3    4003          6021     	JC	($+5)
                      6022     
17A5    0216B2        6023     	LJMP	RUN1						; Continue to run 
                      6024     
17A8    0217E1        6025     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6026     
                      6027     
                      6028     NORMAL_RUN_CHECKS: 
                      6029     	; Check if it is initial run phase
17AB    306419        6030     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6031     
                      6032     	; Decrement startup rotaton count
17AE    E537          6033     	MOV	A, STARTUP_ROT_CNT
17B0    14            6034     	DEC	A
                      6035     	; Check number of nondamped rotations
17B1    7005          6036     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6037     
17B3    C264          6038     CLR FLAGS1 . 4 
17B5    0216A8        6039     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6040     
                      6041     NORMAL_RUN_CHECK_STARTUP_ROT: 
17B8    F537          6042     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6043     
17BA    C3            6044     	CLR	C
17BB    E559          6045     	MOV	A, NEW_RCP				; Load new pulse value
17BD    9401          6046     SUBB A , # 1 
17BF    4003          6047     	JC	($+5)
                      6048     
17C1    0216B2        6049     	LJMP	RUN1						; Continue to run 
                      6050     
17C4    0217E1        6051     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6052     
                      6053     
                      6054     INITIAL_RUN_PHASE_DONE: 
                      6055     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6068     	; Exit run loop after a given time
17C7    C3            6069     	CLR	C
17C8    E55C          6070     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
17CA    94FA          6071     SUBB A , # 250 
17CC    5013          6072     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6073     
                      6074     RUN6_CHECK_RCP_TIMEOUT: 
17CE    741F          6075     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
17D0    552E          6076     	ANL	A, FLAGS3					; Check pwm frequency flags
17D2    7004          6077     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6078     
17D4    E528          6079     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17D6    6009          6080     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6081     
                      6082     RUN6_CHECK_SPEED: 
17D8    C3            6083     	CLR	C
17D9    E53D          6084     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
17DB    94F0          6085     	SUBB	A, #0F0H
17DD    5002          6086     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
17DF    C1B2          6087     	JMP	RUN1						; Go back to run 1
                      6088     
                      6089     
                      6090     RUN_TO_WAIT_FOR_POWER_ON: 	
17E1    C2AF          6091     	CLR	EA
17E3    3116          6092     	CALL SWITCH_POWER_OFF
17E5    7887          6093     MOV R0 , # PGM_PWM_FREQ 
17E7    E6            6094     MOV A , @ R0 
17E8    FE            6095     MOV R6 , A 
17E9    7602          6096     MOV @ R0 , # 2 
17EB    31F9          6097     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
17ED    7887          6098     MOV R0 , # PGM_PWM_FREQ 
17EF    EE            6099     MOV A , R6 
17F0    F6            6100     MOV @ R0 , A 
17F1    E4            6101     	CLR	A
17F2    F522          6102     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
17F4    F523          6103     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
17F6    F524          6104     	MOV	CURRENT_PWM, A				; Set current pwm to zero
17F8    F525          6105     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
17FA    F561          6106     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
17FC    C260          6107     CLR FLAGS1 . 0 
17FE    D2AF          6108     	SETB	EA
1800    120815        6109     	CALL	WAIT1MS					; Wait for pwm to be stopped
1803    121116        6110     	CALL SWITCH_POWER_OFF
                      6111     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6142     IF MODE >= 1	; Tail or multi
1806    741F          6143     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1808    552E          6144     	ANL	A, FLAGS3					; Check pwm frequency flags
180A    7007          6145     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6146     
180C    E528          6147     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
180E    7003          6148     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6149     
1810    0213E1        6150     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6151     
                      6152     JMP_WAIT_FOR_POWER_ON: 
1813    02148B        6153     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6154     ENDIF
                      6155     
                      6156     
                      6157     END
MACRO ASSEMBLER BLHELI                                      05/26/15 11:12:51 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17B8H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E75H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D48H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B9BH   A 
MEASURE_LIPO_WAIT~  C ADDR   0B0DH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AC8H   A 
GOVERNOR_CORR_NEG~  C ADDR   0A8AH   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0076H   A 
HOLD_FULL_H. . . .  N NUMB   0002h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0000h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
INIT_START . . . .  C ADDR   14F8H   A 
FIND_THROTTLE_GAI~  C ADDR   12E0H   A 
COMM45_NFET. . . .  C ADDR   1042H   A 
COMM45_NONDAMP . .  C ADDR   103FH   A 
COMM4COMM5 . . . .  C ADDR   101DH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D6DH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C2EH   A 
IF_STATE_FULL. . .  C ADDR   07A6H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0074H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   12B4H   A 
GOVERNOR_CHECK_PWM  C ADDR   0A17H   A 
GOVERNOR_ACTIVATE.  C ADDR   0969H   A 
ENDIF_STATE_WAIT_~  C ADDR   07CEH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
WAIT_FOR_POWER_ON.  C ADDR   148BH   A 
SET_DEFAULT_PARAM~  C ADDR   1193H   A 
COMM56_NONDAMP . .  C ADDR   1085H   A 
COMM23_CP. . . . .  C ADDR   0FAEH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CF4H   A 
COMM5COMM6 . . . .  C ADDR   105EH   A 
CALC_GOVERNOR_INT~  C ADDR   0AA2H   A 
CALC_GOVERNOR_TAR~  C ADDR   09A0H   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   12FDH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1DFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   15E1H   A 
DECODE_THROTTLE_R~  C ADDR   12A6H   A 
STEPPER_STEP_MED_~  C ADDR   0CC6H   A 
INITIALIZE_ALL_TI~  C ADDR   0C7AH   A 
STARTUP_PWM_SET_P~  C ADDR   0C6EH   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0078H   A 
HOLD_FULL_L. . . .  N NUMB   00EEh            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   13E1H   A 
COMM61_CP. . . . .  C ADDR   10F3H   A 
COMM_EXIT. . . . .  C ADDR   1102H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D4FH   A 
CALC_GOVERNOR_INT~  C ADDR   0A9BH   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   16B2H   A 
CLEAR_RAM. . . . .  C ADDR   135AH   A 
SET_BEC_VOLTAGE. .  C ADDR   12D0H   A 
DECODE_GOVERNOR_G~  C ADDR   128DH   A 
DEC_STEP_HIGH. . .  C ADDR   1156H   A 
WAIT_FOR_COMM. . .  C ADDR   0EEEH   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D96H   A 
MEASURE_LIPO_ADD_~  C ADDR   0B8AH   A 
CALC_GOVERNOR_PRO~  C ADDR   09D9H   A 
DIV_U16_BY_U16_DI~  C ADDR   08BDH   A 
WAIT100MS. . . . .  C ADDR   0829H   A 
WAIT1MS. . . . . .  C ADDR   0815H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   179BH   A 
RUN2 . . . . . . .  C ADDR   16D0H   A 
COMM45_CP. . . . .  C ADDR   1055H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0E08H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B92H   A 
GOVERNOR_CORR_INT~  C ADDR   0AE7H   A 
GOVERNOR_STORE_PR~  C ADDR   09D5H   A 
DIV_U16_BY_U16_DI~  C ADDR   08C7H   A 
WAIT200MS. . . . .  C ADDR   082EH   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   16EEH   A 
DIRECT_METHOD_STA~  C ADDR   154FH   A 
DECODE_DAMPING_DO~  C ADDR   1235H   A 
PWM_WAIT . . . . .  C ADDR   0E9AH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C3EH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0ACFH   A 
GOVERNOR_CHECK_IN~  C ADDR   09FFH   A 
DIV_U16_BY_U16_DI~  C ADDR   08DEH   A 
WAIT3MS. . . . . .  C ADDR   081AH   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   1813H   A 
DIRECT_START_CHEC~  C ADDR   179EH   A 
RUN4 . . . . . . .  C ADDR   170CH   A 
STORE_TIMES_UP_OR~  C ADDR   0DE8H   A 
STORE_TIMES_DECRE~  C ADDR   0DFBH   A 
STEPPER_STEP_SET .  C ADDR   0CE0H   A 
TEMP_AVERAGE_INC .  C ADDR   0BCEH   A 
GOVERNOR_CORR_INT~  C ADDR   0AF8H   A 
MULT_S16_BY_U8_DI~  C ADDR   08EDH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   0014h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   1729H   A 
COMP_READ. . . . .  C ADDR   0EA0H   A 
COMP_WAIT_SET_RES~  C ADDR   0E61H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D9CH   A 
GOVERNOR_CORR_NEG~  C ADDR   0AECH   A 
GOVERNOR_LIMIT_PR~  C ADDR   09CAH   A 
GOVERNOR_TARGET_C~  C ADDR   094CH   A 
CALC_GOVERNOR_TAR~  C ADDR   0944H   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   1746H   A 
ARMING_START . . .  C ADDR   1453H   A 
MEASURE_PWM_FREQ_~  C ADDR   13E5H   A 
DECREMENT_STEP_EX~  C ADDR   1183H   A 
COMM_RETURN. . . .  C ADDR   1115H   A 
GOVERNOR_DEACTIVA~  C ADDR   0956H   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
FLAG_BEFORE_ARM. .  D ADDR   0073H   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
COMP_PWM_HIGH_ON_~  N NUMB   0018h            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   145DH   A 
EVALUATE_COMPARAT~  C ADDR   0EAFH   A 
TEMP_CHECK_EXIT. .  C ADDR   0BF8H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A71H   A 
SET_PREV_RCP . . .  C ADDR   07CEH   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
NORMAL_RUN_CHECKS.  C ADDR   17ABH   A 
DEC_STEP_MED_LOW .  C ADDR   1171H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E30H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D63H   A 
CALC_GOVERNOR_PRO~  C ADDR   09A1H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0F08H   A 
ENDIF_INITIAL_ARM.  C ADDR   07CEH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0007h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   12C2H   A 
EVAL_COMP_EXIT . .  C ADDR   0ED9H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0EC1H   A 
STEPPER_STEP_LOW .  C ADDR   0CD4H   A 
MEASURE_LIPO_ADJU~  C ADDR   0B4FH   A 
PCA_INT_SET_TIMEO~  C ADDR   07E1H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
STEPPER_ROT_EXIT .  C ADDR   1650H   A 
STEPPER_METHOD_ST~  C ADDR   158FH   A 
DECODE_PARAMS_DIR~  C ADDR   126FH   A 
COMM12_DAMP. . . .  C ADDR   0F2CH   A 
SETUP_COMM_WAIT. .  C ADDR   0EDAH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CEDH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0C24H   A 
CALC_GOVERNOR_INT~  C ADDR   0A36H   A 
ENDIF_STATE_CRUISE  C ADDR   07CEH   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   1469H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E21H   A 
LOAD_MIN_TIME. . .  C ADDR   0DB8H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D77H   A 
SET_STARTUP_PWM. .  C ADDR   0C4AH   A 
GOVERNOR_STORE_IN~  C ADDR   0A30H   A 
GOVERNOR_ACTIVATE~  C ADDR   0993H   A 
ELSE_INITIAL_ARM .  C ADDR   07CEH   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   000Fh            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   17CEH   A 
DECREMENT_STEP . .  C ADDR   1134H   A 
COMM23_DAMP. . . .  C ADDR   0F7EH   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0F0AH   A 
ADJUST_TIMING. . .  C ADDR   0DBCH   A 
STEPPER_STEP_MED_~  C ADDR   0CAAH   A 
MEASURE_LIPO_DIVI~  C ADDR   0B6FH   A 
MEASURE_LIPO_START  C ADDR   0AFDH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A9AH   A 
GOVERNOR_INT_MIN_~  C ADDR   0A2BH   A 
GOVERNOR_LIMIT_PR~  C ADDR   09D1H   A 
BEEP_F1. . . . . .  C ADDR   0845H   A 
WAIT1S_LOOP. . . .  C ADDR   0840H   A 
END_PROCEDURE_GET~  C ADDR   0795H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
INITIAL_RUN_PHASE~  C ADDR   17C7H   A 
TEST_THROTTLE_GAIN  C ADDR   12EEH   A 
STEPPER_STEP_MED .  C ADDR   0CB8H   A 
GOVERNOR_STORE_PR~  C ADDR   0A98H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A5CH   A 
MULT_S16_BY_U8_PO~  C ADDR   0907H   A 
DIV_U16_BY_U16 . .  C ADDR   08B5H   A 
BEEP_ONOFF . . . .  C ADDR   0868H   A 
BEEP_F2. . . . . .  C ADDR   084CH   A 
ELSE_STATE_CRUISE.  C ADDR   07B9H   A 
ELSE_FLAG_BEFORE_~  C ADDR   07A1H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   12D1H   A 
DECREMENT_STEPPER~  C ADDR   1128H   A 
COMM61_DAMP. . . .  C ADDR   10B3H   A 
COMM34_DAMP. . . .  C ADDR   0FD2H   A 
TEMP_AVERAGE_INC_~  C ADDR   0BBEH   A 
GOVERNOR_INT_MAX_~  C ADDR   0A24H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A08H   A 
BEEP_F3. . . . . .  C ADDR   0853H   A 
SET_PWM_IN_HIGH. .  C ADDR   0791H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   00A9h            
TEMP_LIMIT . . . .  N NUMB   006Dh            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
DAMPED_TRANSITION.  C ADDR   16A8H   A 
BEEP_DELAY_SET . .  C ADDR   14B3H   A 
LOCK_BYTE_OK . . .  C ADDR   131CH   A 
DECODE_PWM_FREQ_L~  C ADDR   1287H   A 
DECODE_DAMPING_3 .  C ADDR   120DH   A 
CALC_NEW_WAIT_RED~  C ADDR   0D87H   A 
BEEP_F4. . . . . .  C ADDR   085AH   A 
SET_PWM_IN . . . .  C ADDR   0793H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
DIRECT_START_PARA~  C ADDR   1783H   A 
DECODE_DAMPING_4 .  C ADDR   1217H   A 
COMM45_DAMP. . . .  C ADDR   1025H   A 
WAIT_FOR_COMM_SET~  C ADDR   0F1AH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BD6H   A 
GOVERNOR_APPLY_IN~  C ADDR   0AD3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A67H   A 
BEEP_OFF . . . . .  C ADDR   08A9H   A 
WAIT10MS . . . . .  C ADDR   081FH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   00DFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
RESET_CAL_DONE . .  C ADDR   1338H   A 
DECODE_DAMPING_5 .  C ADDR   1221H   A 
DECODE_PARAMETERS.  C ADDR   11F9H   A 
STEPPER_TIMER_WAIT  C ADDR   118DH   A 
STORE_TIMES_INCRE~  C ADDR   0DEEH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0C1DH   A 
MEASURE_LIPO_CELLS  C ADDR   0AFDH   A 
CALC_GOVERNOR_INT~  C ADDR   09DAH   A 
IF_INITIAL_ARM . .  C ADDR   07C2H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07FBH   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
RUN6_CHECK_SPEED .  C ADDR   17D8H   A 
WAIT_FOR_POWER_ON~  C ADDR   14DFH   A 
DECODE_DAMPING_6 .  C ADDR   122BH   A 
DEC_STEP_LOW . . .  C ADDR   117AH   A 
COMM56_DAMP. . . .  C ADDR   1070H   A 
SWITCH_POWER_OFF .  C ADDR   1116H   A 
WAIT30MS . . . . .  C ADDR   0824H   A 
ENDIF_STATE_FULL .  C ADDR   07CEH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0075h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   17E1H   A 
EVAL_COMP_CHECK_T~  C ADDR   0ECFH   A 
ADJUST_TIMING_TWO~  C ADDR   0DDEH   A 
CHECK_VOLTAGE_RET.  C ADDR   0C49H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A3EH   A 
GOVERNOR_ACTIVATE~  C ADDR   099AH   A 
WAIT1S . . . . . .  C ADDR   083EH   A 
WAITXMS_M. . . . .  C ADDR   0835H   A 
IF_STATE_CRUISE. .  C ADDR   07B2H   A 
IF_FLAG_BEFORE_ARM  C ADDR   079AH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0075H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   152EH   A 
WAIT_FOR_POWER_ON~  C ADDR   14D0H   A 
DECODE_PWM_FREQ_E~  C ADDR   128CH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0F1CH   A 
PWM_WAIT_STARTUP .  C ADDR   0E95H   A 
START_ADC_CONVERS~  C ADDR   0B97H   A 
MULT_S16_BY_U8_EX~  C ADDR   093BH   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
MUX_A. . . . . . .  N NUMB   0002h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   141BH   A 
LOCK_BYTE_TEST . .  C ADDR   1315H   A 
DEC_STEP_MED_HIGH.  C ADDR   115FH   A 
COMM_RESTORE_POWER  C ADDR   1113H   A 
COMM12_NONDAMP . .  C ADDR   0F41H   A 
COMM1COMM2 . . . .  C ADDR   0F22H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BD4H   A 
TEMP_AVERAGE_DEC .  C ADDR   0BCAH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A37H   A 
WAITXMS_O. . . . .  C ADDR   0833H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07EDH   A 
ELES_STATE_FULL. .  C ADDR   07ADH   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
MUX_B. . . . . . .  N NUMB   0000h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0007h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
WAIT_FOR_POWER_ON~  C ADDR   1490H   A 
DEC_STEP_MED . . .  C ADDR   1168H   A 
READ_TIMER . . . .  C ADDR   0CF8H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BFCH   A 
CALC_GOVERNOR_INT~  C ADDR   0AFCH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A11H   A 
MULT_S16_BY_U8_DI~  C ADDR   0920H   A 
BEEP . . . . . . .  C ADDR   0861H   A 
PROCEDURE_GETPWM .  C ADDR   0786H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0077H   A 
HOLD_CRUISE_L. . .  N NUMB   0030h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
COMM23_NFET. . . .  C ADDR   0F9BH   A 
COMM23_NONDAMP . .  C ADDR   0F98H   A 
COMM2COMM3 . . . .  C ADDR   0F76H   A 
STEPPER_STEP_HIGH.  C ADDR   0C9CH   A 
MEASURE_LIPO_CELL~  C ADDR   0B34H   A 
GOVERNOR_STORE_IN~  C ADDR   0AFAH   A 
GOVERNOR_CHECK_IN~  C ADDR   0ABCH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A85H   A 
GOVERNOR_ACTIVATE~  C ADDR   0987H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
COMP_PWM_LOW_ON_D~  N NUMB   0008h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B96H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A6DH   A 
GOVERNOR_CHECK_PR~  C ADDR   09BEH   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   00FCh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   13E3H   A 
COMM61_NFET. . . .  C ADDR   10D8H   A 
COMM61_NONDAMP . .  C ADDR   10D5H   A 
COMM6COMM1 . . . .  C ADDR   10ABH   A 
COMM34_NONDAMP . .  C ADDR   0FDFH   A 
COMM3COMM4 . . . .  C ADDR   0FC0H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E4EH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E2AH   A 
STARTUP_PWM_EXIT .  C ADDR   0C79H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B86H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A96H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6136    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     88    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
