MACRO ASSEMBLER BLHELI                                      05/26/15 01:39:48 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       145     
                       146     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       150     
                       151     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       155     
                       156     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                 157     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       158     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       768     ENDIF
                       769     
                       770     
                       771     ;**** **** **** **** ****
                       772     ; TX programming defaults
                       773     ;
                       774     ; Parameter dependencies:
                       775     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       776     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       777     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       778     ; - Damping force is only used if DampedLight or Damped is selected
                       779     ;
                       780     ; Main
  0007                 781     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 782     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 783     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 784     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 785     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 786     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 787     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 788     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 789     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 790     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 791     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 792     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 793     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 794     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 795     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 796     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 797     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 798     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 799     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       800     ; Tail
  0003                 801     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 802     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 803     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 804     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 805     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 806     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 807     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       808     IF DAMPED_MODE_ENABLE == 1
  0004                 809     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       810     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 813     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 814     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 815     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 816     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 817     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 818     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       819     ; Multi
  0009                 820     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 821     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 822     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 823     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 824     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 825     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 826     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 827     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 828     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 829     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       830     IF DAMPED_MODE_ENABLE == 1
  0001                 831     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       832     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 835     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 836     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 837     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0050                 838     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 80	; Beep strength
  0050                 839     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0005                 840     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       841     ; Common
  0000                 842     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 843     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 844     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 845     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 846     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       847     
                       848     ;**** **** **** **** ****
                       849     ; Constant definitions for main
                       850     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       872     ; Constant definitions for tail
                       873     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       894     ; Constant definitions for multi
                       895     IF MODE == 2
                       896     
  0001                 897     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       898     
  000A                 899     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 900     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 901     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 902     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 903     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 904     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 905     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 906     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       907     
  0032                 908     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 909     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       910     
  000A                 911     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 912     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       913     
  0008                 914     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       915     
                       916     ENDIF
                       917     
                       918     ;**** **** **** **** ****
                       919     ; Temporary register definitions
  REG                  920     TEMP1		EQU	R0
  REG                  921     TEMP2		EQU	R1
  REG                  922     TEMP3		EQU	R2
  REG                  923     TEMP4		EQU	R3
  REG                  924     TEMP5		EQU	R4
  REG                  925     TEMP6		EQU	R5
  REG                  926     TEMP7		EQU	R6
  REG                  927     TEMP8		EQU	R7
                       928     
                       929     ;**** **** **** **** ****
                       930     ; Register definitions
------                 931     DSEG AT 20H					; Variables segment 
                       932     
0020                   933     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   934     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       935     
0022                   936     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   937     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   938     CURRENT_PWM: 				DS	1		; Current pwm
0025                   939     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   940     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   941     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   942     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   943     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   944     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       945     
002B                   946     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 947     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 948     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 949     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 950     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 951     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       952     ;						EQU 	5
                       953     ;						EQU 	6
                       954     ;						EQU 	7
                       955     
002C                   956     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 957     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 958     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 959     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 960     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 961     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 962     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 963     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       964     ;						EQU 	7
                       965     
002D                   966     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 967     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 968     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 969     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 970     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 971     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 972     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       973     ;						EQU 	6	
                       974     ;						EQU 	7	
                       975     
002E                   976     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 977     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 978     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 979     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 980     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 981     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 982     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 983     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 984     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       985     
                       986     ;**** **** **** **** ****
                       987     ; RAM definitions
------                 988     DSEG AT 30H						; Ram data segment, direct addressing
                       989     
0030                   990     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       991     
0031                   992     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   993     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       994     
0033                   995     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   996     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   997     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   998     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   999     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                  1000     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                  1001     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                      1002     
003A                  1003     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                  1004     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                  1005     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                  1006     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                  1007     COMM_PHASE: 				DS	1		; Current commutation phase
003F                  1008     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                      1009     
0040                  1010     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                  1011     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                  1012     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                  1013     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                  1014     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                  1015     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                  1016     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                  1017     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                  1018     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                  1019     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                      1020     
004A                  1021     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                  1022     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                  1023     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                  1024     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                  1025     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                  1026     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                  1027     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                  1028     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                      1029     
0052                  1030     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                  1031     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                  1032     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                  1033     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                  1034     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                  1035     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                  1036     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                  1037     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                  1038     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  1039     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  1040     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                  1041     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      1042     
005E                  1043     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                  1044     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                  1045     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                  1046     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                  1047     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                  1048     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      1049     
0064                  1050     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                  1051     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                      1052     
0066                  1053     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                  1054     DAMPING_ON: 				DS	1		; Damping on part of damping period
                      1055     
0068                  1056     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                  1057     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                  1058     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                  1059     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                  1060     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      1061     
006D                  1062     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      1063     
006E                  1064     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                  1065     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      1066     
0070                  1067     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                  1068     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                  1069     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      1070     
                      1071     
                      1072     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1073     ;
                      1074     ; Skypup 2015.05.25
                      1075     ; 宏定义
                      1076     ;
                      1077     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1078     ;
  0002                1079     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                1080     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                      1081     ;
  00FF                1082     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                1083     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                      1084     ;
  00EE                1085     HOLD_FULL_L		EQU	0EEH	; 750 0x02EE 低位
  0002                1086     HOLD_FULL_H		EQU	2H	; 750 0x02EE 高位
  0030                1087     HOLD_CRUISE_L		EQU	30H	; 30000 0x7530 低位
  0075                1088     HOLD_CRUISE_H		EQU	75H	; 30000 0x7530 高位
                      1089     
                      1090     
                      1091     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1092     ;
                      1093     ; Skypup 2015.05.25
                      1094     ; 变量定义
                      1095     ;
                      1096     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1097     ;
0073                  1098     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                      1099     ;
0074                  1100     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                1101     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1102     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1103     ;
0075                  1104     NHOLD_L: 					DS	1		; nHold 低位
0076                  1105     NHOLD_H: 					DS	1		; nHold 高位
                      1106     ;
0077                  1107     CSTATE: 					DS	1		; 状态
                      1108     ;
                      1109     ;	State 状态矩阵
                      1110     ; 
                      1111     ;	00   ->   10   ->   20   ->   00
                      1112     ; 
                      1113     ;	00:Wait          -> 10
                      1114     ;	10:Full          -> 20
                      1115     ;	20:Cruise        -> 00
  0000                1116     STATE_WAIT		EQU	0X00
  0010                1117     STATE_FULL		EQU	0X10
  0020                1118     STATE_CRUISE		EQU	0X20
  000F                1119     STATE_INIT		EQU	0XFF
                      1120     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1121     
                      1122     ; Indirect addressing data segment. The variables below must be in this sequence
------                1123     ISEG AT 080H					
0080                  1124     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1125     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1126     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1127     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1128     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1129     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1130     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1131     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1132     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1133     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1134     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1135     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1136     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1137     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1138     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1139     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1140     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1141     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1142     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1143     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1144     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1145     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1146     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1147     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1148     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1149     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1150     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1151     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1152     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1153     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1154     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1155     
                      1156     ; The sequence of the variables below is no longer of importance
009F                  1157     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1158     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1159     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1160     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1161     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1162     
                      1163     
                      1164     ; Indirect addressing data segment
------                1165     ISEG AT 0D0H					
00D0                  1166     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1167     
                      1168     
                      1169     ;**** **** **** **** ****
------                1170     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1171     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1172     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1173     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1174     
1A00    0B            1175     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1176     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1177     EEP_LAYOUT_REVISION:  DB 17 
                      1178     
                      1179     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1212     
                      1213     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1246     
                      1247     IF MODE == 2
1A03    09            1248     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1249     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1250     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1251     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1252     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1253     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1254     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1255     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1256     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1257     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1258     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1259     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1260     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1261     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1262     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1263     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1264     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1265     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1266     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1267     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1268     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1269     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1270     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1271     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    50            1272     EEP_PGM_BEEP_STRENGTH:  DB 80 
1A1C    50            1273     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    05            1274     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1275     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1276     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1277     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1278     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1279     ENDIF
                      1280     
                      1281     
1A22    FF            1282     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1283     
------                1284     CSEG AT 1A60H
1A60    6F72672E      1285     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1286     
                      1287     ;**** **** **** **** ****
                      1288             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1288+1   CSEG AT 0  ; CODE SEGMENT START
0000    02129D        1288+1   JMP RESET 
------                1288+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1288+1   JMP T0_INT 
------                1288+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1288+1   JMP T2_INT 
------                1288+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1288+1   JMP PCA_INT 
------                1288+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1288+1   JMP T3_INT 
------                1289     CSEG AT 80H			; Code segment after interrupt vectors 
                      1290     
                      1291     ;**** **** **** **** ****
                      1292     
                      1293     ; Table definitions
0080    02030406      1294     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1295     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1296     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1297     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1298     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1301     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1309     IF MODE == 2
                      1310       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1311     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1312       ENDIF
                      1313       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1316     ENDIF
                      1317     
                      1318     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1319     ;
                      1320     ; Timer0 interrupt routine
                      1321     ;
                      1322     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1323     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1324     ;
                      1325     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1326     T0_INT: 	; Used for pwm control
00BA    C2AF          1327     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1328     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1329     	PUSH	ACC		
                      1330     	; Check if pwm is on
00C0    205A10        1331     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1332     
                      1333     	; Do not execute pwm when stopped
00C3    30600A        1334     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1335     	; Do not execute pwm on during demag recovery
00C6    205C07        1336     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1337     	; Pwm on cycle. 
00C9    302F02        1338     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1339     
                      1340     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1341     	CLR	A					
00CD    73            1342     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1343     
                      1344     T0_INT_PWM_ON_LOW_PWM: 
                      1345     
                      1346     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1347     	JMP	T0_INT_PWM_ON_EXECUTE
                      1348     ENDIF
                      1349     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1366     
                      1367     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1368     	JMP	T0_INT_PWM_ON_EXIT
                      1369     
                      1370     
                      1371     T0_INT_PWM_OFF: 
00D3    306306        1372     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1373     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1373+1   CLR P1 . 2 
00D8    C296          1373+1   CLR P1 . 6 
00DA    C295          1373+1   CLR P1 . 5 
                      1374     T0_INT_PWM_OFF_START_CHECKED: 
                      1375     	; Pwm off cycle
00DC    85258A        1376     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1377     	; Clear pwm on flag
00DF    C25A          1378     CLR FLAGS0 . 2 
                      1379     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1380     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1381     	CPL	A						; Full pwm?
00E4    7002          1382     	JNZ	($+4)					; No - branch
00E6    21C6          1383     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1384     
00E8    0563          1385     	INC	PWM_OFF_CNT				; Increment event counter
                      1386     	; Do not execute pwm when stopped
00EA    306013        1387     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1388     
                      1389     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1390     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1391     
                      1392     	; Separate exit commands here for minimum delay
00F0    758B00        1393     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1394     	POP	ACC			; Restore preserved registers
00F5    D0D0          1395     	POP	PSW
                      1396     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1396+1   CLR P1 . 2 
00F9    C296          1396+1   CLR P1 . 6 
00FB    C295          1396+1   CLR P1 . 5 
00FD    D2AF          1397     	SETB	EA			; Enable all interrupts
00FF    32            1398     	RETI
                      1399     
                      1400     T0_INT_PWM_OFF_STOPPED: 
                      1401     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1401+1   CLR P1 . 2 
0102    C296          1401+1   CLR P1 . 6 
0104    C295          1401+1   CLR P1 . 5 
0106    0201B6        1402     	JMP	T0_INT_PWM_OFF_EXIT
                      1403     
                      1404     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1405     SETB FLAGS1 . 5 
010B    C266          1406     CLR FLAGS1 . 6 
010D    E567          1407     	MOV	A, DAMPING_ON
010F    601C          1408     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1409     
0111    C3            1410     	CLR	C
0112    E563          1411     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1412     	DEC	A
0115    9567          1413     	SUBB	A, DAMPING_ON
0117    4014          1414     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1415     
0119    C265          1416     CLR FLAGS1 . 5 
011B    D266          1417     SETB FLAGS1 . 6 
011D    C3            1418     	CLR	C
011E    E563          1419     	MOV	A, PWM_OFF_CNT					
0120    9566          1420     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1421     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1422     
0124    0201B6        1423     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1424     
                      1425     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1426     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1427     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1428     
                      1429     T0_INT_PWM_OFF_DO_DAMPED: 
                      1430     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1431     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1432     
                      1433     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1433+1   CLR P1 . 2 
0132    C296          1433+1   CLR P1 . 6 
0134    C295          1433+1   CLR P1 . 5 
0136    7406          1434     MOV A , # 6 
0138    D5E0FD        1435     	DJNZ	ACC, $	
                      1436     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1436+1   SETB P1 . 3 
013D    D297          1436+1   SETB P1 . 7 
013F    D294          1436+1   SETB P1 . 4 
0141    0201B6        1437     	JMP	T0_INT_PWM_OFF_EXIT
                      1438     
                      1439     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1440     IF DAMPED_MODE_ENABLE == 1
0144    D266          1441     SETB FLAGS1 . 6 
                      1442     ENDIF
                      1443     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1443+1   CLR P1 . 2 
0148    C296          1443+1   CLR P1 . 6 
014A    C295          1443+1   CLR P1 . 5 
014C    E53E          1444     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1445     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1446     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1447     
                      1448     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1451     MOV A , # 6 
0156    D5E0FD        1452     	DJNZ	ACC, $	
                      1453     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1453+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1453+1   SETB P1 . 7 
015E    307502        1453+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1453+1   SETB P1 . 3 
                      1454     ENDIF
0163    0201B6        1455     	JMP	T0_INT_PWM_OFF_EXIT
                      1456     
                      1457     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1458     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1459     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1462     MOV A , # 6 
016B    D5E0FD        1463     	DJNZ	ACC, $	
                      1464     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1464+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1464+1   SETB P1 . 7 
0173    307502        1464+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1464+1   SETB P1 . 3 
                      1465     ENDIF
0178    0201B6        1466     	JMP	T0_INT_PWM_OFF_EXIT
                      1467     
                      1468     T0_INT_PWM_OFF_COMM_3: 
                      1469     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1472     MOV A , # 6 
017D    D5E0FD        1473     	DJNZ	ACC, $	
                      1474     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1474+1   SETB P1 . 4 
                      1475     ENDIF
0182    0201B6        1476     	JMP	T0_INT_PWM_OFF_EXIT
                      1477     
                      1478     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1479     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1480     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1481     
                      1482     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1485     MOV A , # 6 
018D    D5E0FD        1486     	DJNZ	ACC, $	
                      1487     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1487+1   SETB P1 . 4 
                      1488     ENDIF
0192    0201B6        1489     	JMP	T0_INT_PWM_OFF_EXIT
                      1490     
                      1491     T0_INT_PWM_OFF_COMM_5: 
                      1492     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1495     MOV A , # 6 
0197    D5E0FD        1496     	DJNZ	ACC, $	
                      1497     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1497+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1497+1   SETB P1 . 3 
019F    307502        1497+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1497+1   SETB P1 . 7 
                      1498     ENDIF
01A4    0201B6        1499     	JMP	T0_INT_PWM_OFF_EXIT
                      1500     
                      1501     T0_INT_PWM_OFF_COMM_6: 
                      1502     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1505     MOV A , # 6 
01A9    D5E0FD        1506     	DJNZ	ACC, $	
                      1507     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1507+1   SETB P1 . 3 
01B1    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1507+1   SETB P1 . 7 
                      1508     ENDIF
                      1509     
                      1510     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1511     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1512     	POP	ACC			; Restore preserved registers
01BB    D0D0          1513     	POP	PSW
                      1514     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1514+1   CLR P1 . 2 
01BF    C296          1514+1   CLR P1 . 6 
01C1    C295          1514+1   CLR P1 . 5 
01C3    D2AF          1515     	SETB	EA			; Enable all interrupts
01C5    32            1516     	RETI
                      1517     
                      1518     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1519     	POP	ACC			; Restore preserved registers
01C8    D0D0          1520     	POP	PSW
01CA    D2AF          1521     	SETB	EA			; Enable all interrupts
01CC    32            1522     	RETI
                      1523     
                      1524     
                      1525     
                      1526     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1527     	AJMP	T0_INT_PWM_ON_EXIT
                      1528     
                      1529     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1530     	ANFET_ON	
01CF    E525          1530+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1530+1   JZ ( $+12 ) 
01D3    207502        1530+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1530+1   SETB P1 . 2 
01D8    307502        1530+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1530+1   SETB P1 . 6 
                      1531     	BNFET_OFF
01DD    C295          1531+1   CLR P1 . 5 
01DF    61D3          1532     	AJMP	T0_INT_PWM_ON_EXIT
                      1533     
                      1534     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1535     	BNFET_ON
01E1    E525          1535+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1535+1   JZ ( $+4 ) 
01E5    D295          1535+1   SETB P1 . 5 
                      1536     	CNFET_OFF
01E7    207502        1536+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1536+1   CLR P1 . 6 
01EC    307502        1536+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1536+1   CLR P1 . 2 
01F1    61D3          1537     	AJMP	T0_INT_PWM_ON_EXIT
                      1538     
                      1539     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1540     	CNFET_ON
01F3    E525          1540+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1540+1   JZ ( $+12 ) 
01F7    207502        1540+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1540+1   SETB P1 . 6 
01FC    307502        1540+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1540+1   SETB P1 . 2 
                      1541     	ANFET_OFF
0201    207502        1541+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1541+1   CLR P1 . 2 
0206    307502        1541+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1541+1   CLR P1 . 6 
020B    61D3          1542     	AJMP	T0_INT_PWM_ON_EXIT
                      1543     
                      1544     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1545     	APFET_OFF
020D    207502        1545+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1545+1   CLR P1 . 3 
0212    307502        1545+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1545+1   CLR P1 . 7 
                      1546     	ANFET_ON								; Switch nFETs
0217    E525          1546+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1546+1   JZ ( $+12 ) 
021B    207502        1546+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1546+1   SETB P1 . 2 
0220    307502        1546+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1546+1   SETB P1 . 6 
                      1547     	CPFET_OFF
0225    207502        1547+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1547+1   CLR P1 . 7 
022A    307502        1547+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1547+1   CLR P1 . 3 
                      1548     	BNFET_OFF 							
022F    C295          1548+1   CLR P1 . 5 
0231    61D3          1549     	AJMP	T0_INT_PWM_ON_EXIT
                      1550     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1551     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1552     	APFET_OFF
0233    207502        1552+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1552+1   CLR P1 . 3 
0238    307502        1552+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1552+1   CLR P1 . 7 
                      1553     	CPFET_OFF
023D    207502        1553+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1553+1   CLR P1 . 7 
0242    307502        1553+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1553+1   CLR P1 . 3 
0247    7406          1554     MOV A , # 6 
0249    D5E0FD        1555     	DJNZ ACC,	$
                      1556     	ANFET_ON								; Switch nFETs
024C    E525          1556+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1556+1   JZ ( $+12 ) 
0250    207502        1556+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1556+1   SETB P1 . 2 
0255    307502        1556+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1556+1   SETB P1 . 6 
                      1557     	BNFET_OFF 							
025A    C295          1557+1   CLR P1 . 5 
025C    61D3          1558     	AJMP	T0_INT_PWM_ON_EXIT
                      1559     
                      1560     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1561     	APFET_OFF
025E    207502        1561+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1561+1   CLR P1 . 3 
0263    307502        1561+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1561+1   CLR P1 . 7 
                      1562     	ANFET_ON								; Switch nFETs
0268    E525          1562+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1562+1   JZ ( $+12 ) 
026C    207502        1562+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1562+1   SETB P1 . 2 
0271    307502        1562+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1562+1   SETB P1 . 6 
                      1563     	BPFET_OFF
0276    C294          1563+1   CLR P1 . 4 
                      1564     	BNFET_OFF								
0278    C295          1564+1   CLR P1 . 5 
027A    61D3          1565     	AJMP	T0_INT_PWM_ON_EXIT
                      1566     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1567     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1568     	APFET_OFF
027C    207502        1568+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1568+1   CLR P1 . 3 
0281    307502        1568+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1568+1   CLR P1 . 7 
                      1569     	BPFET_OFF
0286    C294          1569+1   CLR P1 . 4 
0288    7406          1570     MOV A , # 6 
028A    D5E0FD        1571     	DJNZ ACC,	$
                      1572     	ANFET_ON								; Switch nFETs
028D    E525          1572+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1572+1   JZ ( $+12 ) 
0291    207502        1572+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1572+1   SETB P1 . 2 
0296    307502        1572+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1572+1   SETB P1 . 6 
                      1573     	BNFET_OFF								
029B    C295          1573+1   CLR P1 . 5 
029D    61D3          1574     	AJMP	T0_INT_PWM_ON_EXIT
                      1575     
                      1576     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1577     	BPFET_OFF
029F    C294          1577+1   CLR P1 . 4 
                      1578     	BNFET_ON								; Switch nFETs
02A1    E525          1578+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1578+1   JZ ( $+4 ) 
02A5    D295          1578+1   SETB P1 . 5 
                      1579     	APFET_OFF
02A7    207502        1579+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1579+1   CLR P1 . 3 
02AC    307502        1579+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1579+1   CLR P1 . 7 
                      1580     	CNFET_OFF								
02B1    207502        1580+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1580+1   CLR P1 . 6 
02B6    307502        1580+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1580+1   CLR P1 . 2 
02BB    61D3          1581     	AJMP	T0_INT_PWM_ON_EXIT
                      1582     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1583     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1584     	BPFET_OFF
02BD    C294          1584+1   CLR P1 . 4 
                      1585     	APFET_OFF
02BF    207502        1585+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1585+1   CLR P1 . 3 
02C4    307502        1585+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1585+1   CLR P1 . 7 
02C9    7406          1586     MOV A , # 6 
02CB    D5E0FD        1587     	DJNZ ACC,	$
                      1588     	BNFET_ON								; Switch nFETs
02CE    E525          1588+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1588+1   JZ ( $+4 ) 
02D2    D295          1588+1   SETB P1 . 5 
                      1589     	CNFET_OFF								
02D4    207502        1589+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1589+1   CLR P1 . 6 
02D9    307502        1589+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1589+1   CLR P1 . 2 
02DE    61D3          1590     	AJMP	T0_INT_PWM_ON_EXIT
                      1591     
                      1592     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1593     	BPFET_OFF
02E0    C294          1593+1   CLR P1 . 4 
                      1594     	BNFET_ON								; Switch nFETs
02E2    E525          1594+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1594+1   JZ ( $+4 ) 
02E6    D295          1594+1   SETB P1 . 5 
                      1595     	CPFET_OFF
02E8    207502        1595+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1595+1   CLR P1 . 7 
02ED    307502        1595+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1595+1   CLR P1 . 3 
                      1596     	CNFET_OFF								
02F2    207502        1596+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1596+1   CLR P1 . 6 
02F7    307502        1596+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1596+1   CLR P1 . 2 
02FC    61D3          1597     	AJMP	T0_INT_PWM_ON_EXIT
                      1598     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1599     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1600     	BPFET_OFF
02FE    C294          1600+1   CLR P1 . 4 
                      1601     	CPFET_OFF
0300    207502        1601+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1601+1   CLR P1 . 7 
0305    307502        1601+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1601+1   CLR P1 . 3 
030A    7406          1602     MOV A , # 6 
030C    D5E0FD        1603     	DJNZ ACC,	$
                      1604     	BNFET_ON								; Switch nFETs
030F    E525          1604+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1604+1   JZ ( $+4 ) 
0313    D295          1604+1   SETB P1 . 5 
                      1605     	CNFET_OFF								
0315    207502        1605+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1605+1   CLR P1 . 6 
031A    307502        1605+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1605+1   CLR P1 . 2 
031F    61D3          1606     	AJMP	T0_INT_PWM_ON_EXIT
                      1607     
                      1608     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1609     	CPFET_OFF
0321    207502        1609+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1609+1   CLR P1 . 7 
0326    307502        1609+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1609+1   CLR P1 . 3 
                      1610     	CNFET_ON								; Switch nFETs
032B    E525          1610+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1610+1   JZ ( $+12 ) 
032F    207502        1610+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1610+1   SETB P1 . 6 
0334    307502        1610+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1610+1   SETB P1 . 2 
                      1611     	BPFET_OFF
0339    C294          1611+1   CLR P1 . 4 
                      1612     	ANFET_OFF								
033B    207502        1612+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1612+1   CLR P1 . 2 
0340    307502        1612+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1612+1   CLR P1 . 6 
0345    61D3          1613     	AJMP	T0_INT_PWM_ON_EXIT
                      1614     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1615     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1616     	CPFET_OFF
0347    207502        1616+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1616+1   CLR P1 . 7 
034C    307502        1616+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1616+1   CLR P1 . 3 
                      1617     	BPFET_OFF
0351    C294          1617+1   CLR P1 . 4 
0353    7406          1618     MOV A , # 6 
0355    D5E0FD        1619     	DJNZ ACC,	$
                      1620     	CNFET_ON								; Switch nFETs
0358    E525          1620+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1620+1   JZ ( $+12 ) 
035C    207502        1620+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1620+1   SETB P1 . 6 
0361    307502        1620+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1620+1   SETB P1 . 2 
                      1621     	ANFET_OFF								
0366    207502        1621+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1621+1   CLR P1 . 2 
036B    307502        1621+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1621+1   CLR P1 . 6 
0370    61D3          1622     	AJMP	T0_INT_PWM_ON_EXIT
                      1623     
                      1624     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1625     	CPFET_OFF
0372    207502        1625+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1625+1   CLR P1 . 7 
0377    307502        1625+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1625+1   CLR P1 . 3 
                      1626     	CNFET_ON								; Switch nFETs
037C    E525          1626+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1626+1   JZ ( $+12 ) 
0380    207502        1626+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1626+1   SETB P1 . 6 
0385    307502        1626+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1626+1   SETB P1 . 2 
                      1627     	APFET_OFF
038A    207502        1627+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1627+1   CLR P1 . 3 
038F    307502        1627+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1627+1   CLR P1 . 7 
                      1628     	ANFET_OFF								
0394    207502        1628+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1628+1   CLR P1 . 2 
0399    307502        1628+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1628+1   CLR P1 . 6 
039E    61D3          1629     	AJMP	T0_INT_PWM_ON_EXIT
                      1630     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1631     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1632     	CPFET_OFF
03A0    207502        1632+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1632+1   CLR P1 . 7 
03A5    307502        1632+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1632+1   CLR P1 . 3 
                      1633     	APFET_OFF
03AA    207502        1633+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1633+1   CLR P1 . 3 
03AF    307502        1633+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1633+1   CLR P1 . 7 
03B4    7406          1634     MOV A , # 6 
03B6    D5E0FD        1635     	DJNZ ACC,	$
                      1636     	CNFET_ON								; Switch nFETs
03B9    E525          1636+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1636+1   JZ ( $+12 ) 
03BD    207502        1636+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1636+1   SETB P1 . 6 
03C2    307502        1636+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1636+1   SETB P1 . 2 
                      1637     	ANFET_OFF								
03C7    207502        1637+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1637+1   CLR P1 . 2 
03CC    307502        1637+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1637+1   CLR P1 . 6 
03D1    61D3          1638     	AJMP	T0_INT_PWM_ON_EXIT
                      1639     
                      1640     T0_INT_PWM_ON_EXIT: 
                      1641     	; Set timer for coming on cycle length
03D3    E525          1642     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1643     	CPL	A						; cpl is 255-x
03D6    F58A          1644     	MOV	TL0, A					; Write start point for timer
                      1645     	; Set other variables
03D8    758B00        1646     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1647     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1648     SETB FLAGS0 . 2 
                      1649     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1650     	; Exit interrupt
03E0    D0E0          1651     	POP	ACC			; Restore preserved registers
03E2    D0D0          1652     	POP	PSW
03E4    D2AF          1653     	SETB	EA			; Enable all interrupts
03E6    32            1654     	RETI
                      1655     
                      1656     
                      1657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1658     ;
                      1659     ; Timer2 interrupt routine
                      1660     ;
                      1661     ; No assumptions
                      1662     ;
                      1663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1664     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1665     	CLR	EA
03E9    C2AD          1666     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1667     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1668     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1669     	PUSH	ACC
03F2    D2D3          1670     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1671     	SETB	EA
                      1672     	; Clear low byte interrupt flag
03F6    C2CE          1673     	CLR	TF2L						; Clear interrupt flag
                      1674     	; Check RC pulse timeout counter
03F8    E528          1675     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1676     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1677     
                      1678     	; Decrement timeout counter (if PWM)
03FC    741F          1679     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1680     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1681     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1682     
0402    1528          1683     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1684     	AJMP	T2_INT_SKIP_START
                      1685     
                      1686     T2_INT_PULSES_ABSENT: 
                      1687     	; Timeout counter has reached zero, pulses are absent
0406    7800          1688     MOV R0 , # 0 
0408    7900          1689     MOV R1 , # 0 
                      1690     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1690+1   MOV A , P0 
040C    307601        1690+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1690+1   CPL A  ; YES - INVERT
0410    30E502        1691     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1692     MOV R0 , # 255 
                      1693     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1693+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1693+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1693+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1693+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1693+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1694     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1694+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1695     CLR FLAGS2 . 1 
                      1696     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1696+1   MOV A , P0 
042A    307601        1696+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1696+1   CPL A  ; YES - INVERT
042E    30E502        1697     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1698     MOV R1 , # 255 
0433    C3            1699     	CLR	C
0434    E8            1700     MOV A , R0 
0435    99            1701     SUBB A , R1 
0436    70CE          1702     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1703     
0438    305903        1704     JNB FLAGS0 . 1 , ( $+6 ) 
                      1705     
043B    752818        1706     MOV RCP_TIMEOUT_CNT , # 24 
                      1707     
043E    741F          1708     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1709     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1710     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1711     
0444    752818        1712     MOV RCP_TIMEOUT_CNT , # 24 
                      1713     
                      1714     
                      1715     T2_INT_PPM_TIMEOUT_SET: 
                      1716     
                      1717     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1718     ; 
                      1719     ; 对 RCP 信号处理
                      1720     ; 1 小于 1500us 最低油门
                      1721     ; 2 大于 1500us 正常处理
                      1722     ; 
                      1723     ;	clr C
                      1724     ;	mov A, Temp1
                      1725     ;	subb A, #80h
                      1726     ;	jnc skypup_01
                      1727     ;	mov	Temp1, #RCP_MIN
                      1728     ; skypup_01:
                      1729     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1730     MOV NEW_RCP , R0 
0449    D268          1731     SETB FLAGS2 . 0 
                      1732     
                      1733     T2_INT_SKIP_START: 
                      1734     	; Check RC pulse skip counter
044B    E529          1735     	MOV	A, RCP_SKIP_CNT			
044D    6004          1736     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1737     	
                      1738     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1739     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1740     	AJMP	T2_INT_RCP_UPDATE_START
                      1741     
                      1742     T2_INT_SKIP_END: 
0453    741F          1743     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1744     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1745     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1746     
                      1747     	; Skip counter has reached zero, start looking for RC pulses again
                      1748     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1748+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1749     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1749+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1750     	
                      1751     T2_INT_RCP_UPDATE_START: 
                      1752     	; Process updated RC pulse
045E    206802        1753     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1754     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1755     
0463    E559          1756     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1757     MOV R0 , A 
0466    C268          1758     CLR FLAGS2 . 0 
                      1759     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1760     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1761     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1762     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1763     
                      1764     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1767     
                      1768     IF MODE == 2	; Multi
046E    7982          1769     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1770     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1771     ENDIF
                      1772     
                      1773     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1774     	CLR	C
0474    E8            1775     MOV A , R0 
0475    94F0          1776     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1777     	JC	T2_INT_RCP_UPDATE_MULT
                      1778     
0479    74F0          1779     	MOV	A, #240			; Set requested pwm to max
047B    F8            1780     MOV R0 , A 
                      1781     
                      1782     T2_INT_RCP_UPDATE_MULT: 	
                      1783     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1784     MOV A , R0 
047D    C4            1785     	SWAP	A			; After this "0.0625"
047E    540F          1786     	ANL	A, #0FH
0480    28            1787     ADD A , R0 
0481    F8            1788     MOV R0 , A 
                      1789     	; Adjust tail gain
0482    7984          1790     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1791     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1792     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1793     
0489    C3            1794     	CLR	C
048A    13            1795     	RRC	A			; After this "0.5"
048B    C3            1796     	CLR	C
048C    13            1797     	RRC	A			; After this "0.25"
048D    8721          1798     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1799     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1800     
0492    C3            1801     	CLR	C
0493    13            1802     	RRC	A			; After this "0.125"
                      1803     
                      1804     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1805     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1806     
0497    C3            1807     	CLR	C
0498    C8            1808     XCH A , R0 
0499    98            1809     SUBB A , R0 
049A    F8            1810     MOV R0 , A 
049B    81A4          1811     	AJMP	T2_INT_PWM_MIN_RUN
                      1812     
                      1813     T2_INT_RCP_GAIN_POS: 
049D    28            1814     ADD A , R0 
049E    F8            1815     MOV R0 , A 
049F    5003          1816     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1817     
04A1    74FF          1818     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1819     MOV R0 , A 
                      1820     
                      1821     T2_INT_PWM_MIN_RUN:  
                      1822     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1832     
                      1833     T2_INT_PWM_UPDATE:  
                      1834     	; Check if any startup phase flags are set
04A4    E52C          1835     	MOV	A, FLAGS1
04A6    5406          1836     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1837     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1838     
                      1839     	; Update requested_pwm
04AA    8822          1840     MOV REQUESTED_PWM , R0 
                      1841     	; Limit pwm during direct start
04AC    30630A        1842     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1843     
04AF    C3            1844     	CLR	C
04B0    E522          1845     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1846     	SUBB	A, PWM_LIMIT
04B4    4003          1847     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1848     
04B6    855E22        1849     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1850     
                      1851     T2_INT_CURRENT_PWM_UPDATE:  
                      1852     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1853     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1854     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1855     ENDIF
                      1856     
                      1857     	; Update current pwm, with limited throttle change rate
04BE    C3            1858     	CLR	C
04BF    E522          1859     	MOV	A, REQUESTED_PWM	 
04C1    9524          1860     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1861     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1862     
                      1863     	; 缓启动
04C5    78A1          1864     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1865     	;mov	Temp1, #1
04C7    96            1866     SUBB A , @ R0 
                      1867     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1868     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1869     
04CA    E524          1870     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1871     ADD A , @ R0 
                      1872     	; add	A, Temp1
04CD    F524          1873     	MOV	CURRENT_PWM, A
04CF    5009          1874     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1875     
04D1    7524FF        1876     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1877     	JMP	T2_INT_CURRENT_PWM_DONE
                      1878     
                      1879     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1880     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1881     T2_INT_CURRENT_PWM_DONE: 
                      1882     IF MODE >= 1	; Tail or multi
                      1883     	; Set current_pwm_limited
04DA    A824          1884     MOV R0 , CURRENT_PWM 
04DC    C3            1885     	CLR	C
04DD    E524          1886     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1887     	SUBB	A, PWM_LIMIT
04E1    4002          1888     	JC	($+4)					; If current pwm below limit - branch
                      1889     
04E3    A85E          1890     MOV R0 , PWM_LIMIT 
                      1891     
04E5    8825          1892     MOV CURRENT_PWM_LIMITED , R0 
                      1893     ENDIF
                      1894     T2_INT_PWM_EXIT: 	
                      1895     	; Check if high byte flag is set
04E7    20CF0C        1896     	JB	TF2H, T2H_INT		
04EA    D0E0          1897     	POP	ACC			; Restore preserved registers
04EC    D0D0          1898     	POP	PSW
04EE    C2D3          1899     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1900     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1901     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1902     	RETI
                      1903     
                      1904     T2H_INT: 
                      1905     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1906     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1907     MOV R0 , # 1 
                      1908     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1909     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1910     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1911     
                      1912     	; Decrement timeout counter (if PPM)
04FE    741F          1913     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1914     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1915     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1916     
0504    1528          1917     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1918     
                      1919     T2H_INT_RCP_STOP_CHECK: 
                      1920     	; Check RC pulse against stop value
0506    C3            1921     	CLR	C
0507    E559          1922     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1923     SUBB A , # 1 
050B    4005          1924     	JC	T2H_INT_RCP_STOP
                      1925     
                      1926     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1927     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1928     	AJMP	T2H_INT_RCP_GOV_PWM
                      1929     
                      1930     T2H_INT_RCP_STOP: 	
                      1931     	; RC pulse less than stop value
0512    755D00        1932     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1933     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1934     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1935     	ADD	A, #1
051C    F55C          1936     	MOV	RCP_STOP_CNT, A
051E    5003          1937     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1938     
0520    755CFF        1939     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1940     
                      1941     T2H_INT_RCP_GOV_PWM: 
                      1942     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      2071     IF MODE == 2	; Multi
0523    E55F          2072     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          2073     	ADD	A, #10
0527    5005          2074     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      2075     
0529    755FFF        2076     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          2077     	AJMP	T2H_INT_RCP_EXIT
                      2078     
                      2079     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          2080     	MOV	PWM_LIMIT_SPOOLUP, A
                      2081     ENDIF
                      2082     
                      2083     T2H_INT_RCP_EXIT: 
0530    D0E0          2084     	POP	ACC			; Restore preserved registers
0532    D0D0          2085     	POP	PSW
0534    C2D3          2086     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        2087     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          2088     	SETB	ET2			; Enable timer2 interrupts
053B    32            2089     	RETI
                      2090     
                      2091     
                      2092     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2093     ;
                      2094     ; Timer3 interrupt routine
                      2095     ;
                      2096     ; No assumptions
                      2097     ;
                      2098     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2099     T3_INT: 	; Used for commutation timing
053C    C2AF          2100     	CLR 	EA			; Disable all interrupts
053E    53917F        2101     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          2102     CLR FLAGS0 . 0 
0543    D2AF          2103     	SETB	EA			; Enable all interrupts
0545    32            2104     	RETI
                      2105     
                      2106     
                      2107     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2108     ;
                      2109     ; PCA interrupt routine
                      2110     ;
                      2111     ; No assumptions
                      2112     ;
                      2113     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2114     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2115     	CLR	EA
0548    53E6EF        2116     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2117     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2118     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2119     	PUSH	ACC
0551    C0F0          2120     	PUSH	B
0553    D2D3          2121     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2122     	SETB	EA
                      2123     	; Get the PCA counter values
                      2124     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2124+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2124+1   MOV R1 , PCA0CPH0 
                      2125     	; Clear interrupt flag
                      2126     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2126+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2127     	; Check which edge it is
055D    306902        2128     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          2129     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2130     
                      2131     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2131+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2131+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2131+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2131+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2131+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2132     SETB FLAGS2 . 1 
                      2133     	; Read RC signal level
                      2134     	READ_RCP_INT			
0573    E580          2134+1   MOV A , P0 
0575    307601        2134+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2134+1   CPL A  ; YES - INVERT
                      2135     	; Test RC signal level
0579    20E502        2136     JB ACC . 5 , ( $+5 ) 
057C    A185          2137     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2138     
                      2139     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2140     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2141     MOV RCP_PREV_EDGE_H , R1 
0582    0207F2        2142     	LJMP	PCA_INT_EXIT				; Exit
                      2143     
                      2144     PCA_INT_FAIL_MINIMUM: 
                      2145     	; Prepare for next interrupt
                      2146     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2146+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2146+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2146+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2146+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2146+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2147     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2147+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2148     CLR FLAGS2 . 1 
0598    741F          2149     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2150     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          2151     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      2152     
059E    E1D8          2153     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      2154     
05A0    7800          2155     MOV R0 , # 0 
                      2156     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          2156+1   MOV A , P0 
05A4    307601        2156+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            2156+1   CPL A  ; YES - INVERT
05A8    30E502        2157     JNB ACC . 5 , ( $+5 ) 
05AB    E1D8          2158     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      2159     
                      2160     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2161     ; 
                      2162     ; 对 RCP 信号处理
                      2163     ; 1 小于 1500us 最低油门
                      2164     ; 2 大于 1500us 正常处理
                      2165     ; 
                      2166     ;	clr C
                      2167     ;	mov A, Temp1
                      2168     ;	subb A, #80h
                      2169     ;	jnc skypup_02
                      2170     ;	mov	Temp1, #RCP_MIN
                      2171     ; skypup_02:
                      2172     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2173     
05AD    8859          2174     MOV NEW_RCP , R0 
05AF    E186          2175     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2176     
                      2177     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2178     	; Prepare for next interrupt
                      2179     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        2179+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        2179+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        2179+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        2179+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        2179+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          2180     CLR FLAGS2 . 1 
                      2181     	; Check if pwm frequency shall be measured
05C2    205902        2182     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          2183     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2184     
                      2185     	; Set second edge trig only during pwm frequency measurement
                      2186     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        2186+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        2186+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        2186+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        2186+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        2186+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2187     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          2187+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          2188     SETB FLAGS2 . 1 
                      2189     	; Store edge data to RAM
05DA    8854          2190     MOV RCP_EDGE_L , R0 
05DC    8955          2191     MOV RCP_EDGE_H , R1 
                      2192     	; Calculate pwm frequency
05DE    C3            2193     	CLR	C
05DF    E8            2194     MOV A , R0 
05E0    9552          2195     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            2196     MOV R0 , A 
05E3    E9            2197     MOV A , R1 
05E4    9553          2198     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            2199     MOV R1 , A 
05E7    E4            2200     	CLR	A
05E8    FB            2201     MOV R3 , A 
05E9    7AFA          2202     MOV R2 , # 250 
                      2203     	; Check if pwm frequency is 12kHz
05EB    C3            2204     	CLR	C
05EC    E8            2205     MOV A , R0 
05ED    94C8          2206     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            2207     MOV A , R1 
05F0    9400          2208     	SUBB	A, #HIGH(200)
05F2    5008          2209     	JNC	PCA_INT_CHECK_8KHZ
                      2210     
05F4    E4            2211     	CLR	A
05F5    D2E4          2212     SETB ACC . 4 
05F7    FB            2213     MOV R3 , A 
05F8    7A0A          2214     MOV R2 , # 10 
05FA    C13E          2215     	AJMP	PCA_INT_RESTORE_EDGE
                      2216     
                      2217     PCA_INT_CHECK_8KHZ: 
                      2218     	; Check if pwm frequency is 8kHz
05FC    C3            2219     	CLR	C
05FD    E8            2220     MOV A , R0 
05FE    9468          2221     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            2222     MOV A , R1 
0601    9401          2223     	SUBB	A, #HIGH(360)
0603    5008          2224     	JNC	PCA_INT_CHECK_4KHZ
                      2225     
0605    E4            2226     	CLR	A
0606    D2E3          2227     SETB ACC . 3 
0608    FB            2228     MOV R3 , A 
0609    7A0F          2229     MOV R2 , # 15 
060B    C13E          2230     	AJMP	PCA_INT_RESTORE_EDGE
                      2231     
                      2232     PCA_INT_CHECK_4KHZ: 
                      2233     	; Check if pwm frequency is 4kHz
060D    C3            2234     	CLR	C
060E    E8            2235     MOV A , R0 
060F    94D0          2236     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2237     MOV A , R1 
0612    9402          2238     	SUBB	A, #HIGH(720)
0614    5008          2239     	JNC	PCA_INT_CHECK_2KHZ
                      2240     
0616    E4            2241     	CLR	A
0617    D2E2          2242     SETB ACC . 2 
0619    FB            2243     MOV R3 , A 
061A    7A1E          2244     MOV R2 , # 30 
061C    C13E          2245     	AJMP	PCA_INT_RESTORE_EDGE
                      2246     
                      2247     PCA_INT_CHECK_2KHZ: 
                      2248     	; Check if pwm frequency is 2kHz
061E    C3            2249     	CLR	C
061F    E8            2250     MOV A , R0 
0620    94A0          2251     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2252     MOV A , R1 
0623    9405          2253     	SUBB	A, #HIGH(1440)
0625    5008          2254     	JNC	PCA_INT_CHECK_1KHZ
                      2255     
0627    E4            2256     	CLR	A
0628    D2E1          2257     SETB ACC . 1 
062A    FB            2258     MOV R3 , A 
062B    7A3C          2259     MOV R2 , # 60 
062D    C13E          2260     	AJMP	PCA_INT_RESTORE_EDGE
                      2261     
                      2262     PCA_INT_CHECK_1KHZ: 
                      2263     	; Check if pwm frequency is 1kHz
062F    C3            2264     	CLR	C
0630    E8            2265     MOV A , R0 
0631    9498          2266     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2267     MOV A , R1 
0634    9408          2268     	SUBB	A, #HIGH(2200)
0636    5006          2269     	JNC	PCA_INT_RESTORE_EDGE
                      2270     
0638    E4            2271     	CLR	A
0639    D2E0          2272     SETB ACC . 0 
063B    FB            2273     MOV R3 , A 
063C    7A78          2274     MOV R2 , # 120 
                      2275     
                      2276     PCA_INT_RESTORE_EDGE: 
                      2277     	; Calculate difference between this period and previous period
063E    C3            2278     	CLR	C
063F    E8            2279     MOV A , R0 
0640    9556          2280     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2281     MOV R4 , A 
0643    E9            2282     MOV A , R1 
0644    9557          2283     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2284     MOV R5 , A 
                      2285     	; Make positive
0647    30E708        2286     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2287     MOV A , R4 
064B    F4            2288     	CPL	A
064C    2401          2289     	ADD	A, #1
064E    FC            2290     MOV R4 , A 
064F    ED            2291     MOV A , R5 
0650    F4            2292     	CPL	A
0651    FD            2293     MOV R5 , A 
                      2294     
                      2295     PCA_INT_CHECK_DIFF: 
                      2296     	; Check difference
0652    755800        2297     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2298     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2299     
0657    C3            2300     	CLR	C
0658    EC            2301     MOV A , R4 
0659    9A            2302     SUBB A , R2 
065A    5003          2303     	JNC	PCA_INT_STORE_DATA
                      2304     
065C    755801        2305     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2306     
                      2307     PCA_INT_STORE_DATA: 
                      2308     	; Store previous period
065F    8856          2309     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2310     MOV RCP_PREV_PERIOD_H , R1 
                      2311     	; Restore edge data from RAM
0663    A854          2312     MOV R0 , RCP_EDGE_L 
0665    A955          2313     MOV R1 , RCP_EDGE_H 
                      2314     	; Store pre previous edge
0667    8852          2315     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2316     MOV RCP_PREPREV_EDGE_H , R1 
                      2317     
                      2318     PCA_INT_FALL: 
                      2319     	; RC pulse edge was second, calculate new pulse length
066B    C3            2320     	CLR	C
066C    E8            2321     MOV A , R0 
066D    9526          2322     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2323     MOV R0 , A 
0670    E9            2324     MOV A , R1 
0671    9527          2325     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2326     MOV R1 , A 
0674    307402        2327     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2328     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2329     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2330     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2331     
067E    307202        2332     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2333     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2334     
0683    E9            2335     MOV A , R1 
0684    C3            2336     	CLR	C
0685    13            2337     	RRC	A
0686    F9            2338     MOV R1 , A 
0687    E8            2339     MOV A , R0 
0688    13            2340     	RRC	A
0689    F8            2341     MOV R0 , A 
                      2342     
068A    307102        2343     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2344     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2345     
068F    E9            2346     MOV A , R1 
0690    C3            2347     	CLR	C
0691    13            2348     	RRC	A
0692    F9            2349     MOV R1 , A 
0693    E8            2350     MOV A , R0 
0694    13            2351     	RRC	A
0695    F8            2352     MOV R0 , A 
                      2353     
0696    307002        2354     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2355     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2356     
069B    E9            2357     MOV A , R1 
069C    C3            2358     	CLR	C
069D    13            2359     	RRC	A
069E    FD            2360     MOV R5 , A 
069F    E8            2361     MOV A , R0 
06A0    13            2362     	RRC	A
06A1    FC            2363     MOV R4 , A 
                      2364     	; Skip range limitation if pwm frequency measurement
06A2    205918        2365     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2366     
                      2367     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2368     	CLR	C
06A6    EC            2369     MOV A , R4 
06A7    941C          2370     	SUBB	A, #28
06A9    ED            2371     MOV A , R5 
06AA    9402          2372     	SUBB A, #2
06AC    4003          2373     	JC	($+5)						; No - proceed
                      2374     
06AE    0207D8        2375     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2376     
                      2377     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2378     MOV A , R5 
06B2    7009          2379     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2380     
06B4    C3            2381     	CLR	C
06B5    EC            2382     MOV A , R4 
06B6    94C8          2383     	SUBB	A, #200
06B8    5003          2384     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2385     
06BA    0207D8        2386     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2387     
                      2388     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2389     	; Calculate "1000us" plus throttle minimum
06BD    7400          2390     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2391     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2392     
                      2393     IF MODE >= 1	; Tail or multi
06C2    7888          2394     MOV R0 , # PGM_DIRECTION 
06C4    E6            2395     MOV A , @ R0 
                      2396     ENDIF
06C5    7896          2397     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2398     IF MODE >= 1	; Tail or multi
06C7    B40302        2399     	CJNE	A, #3, ($+5)
                      2400     
06CA    789E          2401     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2402     ENDIF
06CC    E6            2403     MOV A , @ R0 
                      2404     
                      2405     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2406     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2407     MOV R6 , A 
06D0    E4            2408     	CLR	A
06D1    3400          2409     	ADDC	A, #0
06D3    FF            2410     MOV R7 , A 
                      2411     
06D4    C3            2412     	CLR	C
06D5    EC            2413     MOV A , R4 
06D6    9E            2414     SUBB A , R6 
06D7    FC            2415     MOV R4 , A 
06D8    ED            2416     MOV A , R5 
06D9    9F            2417     SUBB A , R7 
06DA    FD            2418     MOV R5 , A 
                      2419     IF MODE >= 1	; Tail or multi
06DB    9208          2420     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2421     MOV R0 , # PGM_DIRECTION 
06DF    E6            2422     MOV A , @ R0 
06E0    B40322        2423     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2424     
06E3    A208          2425     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2426     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2427     
                      2428     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2429     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2430     
06EA    C2AF          2431     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2432     SETB FLAGS3 . 5 
06EE    C1F7          2433     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2434     
                      2435     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2436     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2437     
06F3    C2AF          2438     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2439     CLR FLAGS3 . 5 
                      2440     
                      2441     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2442     	ALL_NFETS_OFF
06F7    C292          2442+1   CLR P1 . 2 
06F9    C296          2442+1   CLR P1 . 6 
06FB    C295          2442+1   CLR P1 . 5 
                      2443     	ALL_PFETS_OFF
06FD    C293          2443+1   CLR P1 . 3 
06FF    C297          2443+1   CLR P1 . 7 
0701    C294          2443+1   CLR P1 . 4 
0703    D2AF          2444     	SETB	EA
                      2445     
                      2446     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2447     	MOV	C, BIT_ACCESS_INT.0
                      2448     ENDIF
0707    5017          2449     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2450     
                      2451     IF MODE >= 1	; Tail or multi
0709    E6            2452     MOV A , @ R0 
070A    B4030D        2453     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2454     
070D    EC            2455     MOV A , R4 
070E    F4            2456     	CPL	A
070F    2401          2457     	ADD	A, #1
0711    FC            2458     MOV R4 , A 
0712    ED            2459     MOV A , R5 
0713    F4            2460     	CPL	A
0714    3400          2461     	ADDC	A, #0
0716    FD            2462     MOV R5 , A 
0717    020720        2463     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2464     
                      2465     PCA_INT_PPM_UNIDIR_NEG: 
                      2466     ENDIF
071A    7800          2467     MOV R0 , # 0 
071C    7900          2468     MOV R1 , # 0 
071E    E16A          2469     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2470     
                      2471     PCA_INT_PPM_NEG_CHECKED: 
                      2472     IF MODE >= 1	; Tail or multi
0720    7888          2473     MOV R0 , # PGM_DIRECTION 
0722    E6            2474     MOV A , @ R0 
0723    B40315        2475     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2476     
0726    EC            2477     MOV A , R4 
0727    33            2478     	RLC	A
0728    FC            2479     MOV R4 A 
0729    ED            2480     MOV A , R5 
072A    33            2481     	RLC	A
072B    FD            2482     MOV R5 A 
072C    C3            2483     	CLR	C							; Subtract deadband
072D    EC            2484     MOV A , R4 
072E    9405          2485     	SUBB	A, #5		
0730    FC            2486     MOV R4 , A 
0731    ED            2487     MOV A , R5 
0732    9400          2488     	SUBB	A, #0
0734    FD            2489     MOV R5 , A 
0735    5004          2490     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2491     
0737    7C00          2492     MOV R4 , # 0 
0739    7D00          2493     MOV R5 , # 0 
                      2494     
                      2495     PCA_INT_PPM_BIDIR_DONE: 
                      2496     ENDIF
073B    C3            2497     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2498     MOV A , R4 
073D    94FF          2499     SUBB A , # 255 
073F    ED            2500     MOV A , R5 
0740    9400          2501     	SUBB	A, #0
0742    4006          2502     	JC	PCA_INT_PPM_MAX_CHECKED
                      2503     
0744    78FF          2504     MOV R0 , # 255 
0746    7900          2505     MOV R1 , # 0 
0748    E16A          2506     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2507     
                      2508     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2509     MOV A , R4 
074B    856EF0        2510     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2511     	MUL	AB
074F    C5F0          2512     	XCH	A, B
0751    A2F7          2513     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2514     	RLC	A
0754    F8            2515     MOV R0 , A 
0755    7900          2516     MOV R1 , # 0 
0757    4003          2517     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2518     	
0759    020786        2519     	JMP	PCA_INT_LIMITED			
                      2520     
                      2521     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2522     MOV R0 , # 255 
075E    7900          2523     MOV R1 , # 0 
0760    020786        2524     	JMP	PCA_INT_LIMITED			
                      2525     
                      2526     PCA_INT_PWM_DIVIDE: 
0763    E9            2527     MOV A , R1 
0764    C3            2528     	CLR	C
0765    13            2529     	RRC	A
0766    F9            2530     MOV R1 , A 
0767    E8            2531     MOV A , R0 
0768    13            2532     	RRC	A
0769    F8            2533     MOV R0 , A 
                      2534     
                      2535     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2536     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2537     MOV A , R1 
076E    6002          2538     	JZ	($+4)
                      2539     
0770    78FF          2540     MOV R0 , # 255 
                      2541     
0772    C3            2542     	CLR	C
0773    E8            2543     MOV A , R0 
0774    13            2544     	RRC	A
0775    38            2545     ADDC A , R0 
0776    F8            2546     MOV R0 , A 
0777    E4            2547     	CLR	A
0778    3400          2548     	ADDC	A, #0
077A    F9            2549     MOV R1 , A 
                      2550     
                      2551     PCA_INT_CHECK_LEGAL_RANGE: 
                      2552     	; Check that RC pulse is within legal range
077B    C3            2553     	CLR	C
077C    E8            2554     MOV A , R0 
077D    94FF          2555     SUBB A , # 255 
077F    E9            2556     MOV A , R1 
0780    9400          2557     	SUBB	A, #0
0782    4002          2558     	JC	PCA_INT_LIMITED
                      2559     
0784    78FF          2560     MOV R0 , # 255 
                      2561     
                      2562     PCA_INT_LIMITED: 
                      2563     
                      2564     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2565     ; 
                      2566     ; Skypup 2015.05.25
                      2567     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2568     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2569     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2570     ; 
0786    C3            2571     	CLR	C
0787    E530          2572     	MOV	A, INITIAL_ARM
0789    6005          2573     	JZ	STATE_IS_ARMED
078B    8859          2574     MOV NEW_RCP , R0 
078D    0207C5        2575     	LJMP ENDIF_STATE
                      2576     
                      2577     STATE_IS_ARMED: 
0790    C3            2578     	CLR	C
0791    E8            2579     MOV A , R0 
0792    94A0          2580     SUBB A , # 160 
0794    5005          2581     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
0796    7800          2582     MOV R0 , # 0 
0798    02079D        2583     	JMP	SET_PWM_IN
                      2584     SET_PWM_IN_HIGH: 
079B    7801          2585     MOV R0 , # 1 
                      2586     SET_PWM_IN: 
079D    8874          2587     MOV NPWMIN , R0 
                      2588     
                      2589     ; 	; 判断是否 PWM_IN_HIGH
                      2590     ; 	mov	Temp1, nPWMIn
                      2591     ; 	cjne	Temp1, #PWM_IN_HIGH, lsss
                      2592     ; 	mov	Temp1, #PWM_CRUISE
                      2593     ;	mov	New_Rcp, Temp1	
                      2594     ; 	jmp	endif_state
                      2595     ; lsss:
                      2596     ; 	; 最低油门
                      2597     ; 	mov	Temp1, #RCP_MIN
                      2598     ; 	mov	New_Rcp, Temp1	
                      2599     ; 	jmp	endif_state
                      2600     
                      2601     ; 状态 cState
079F    A877          2602     MOV R0 , CSTATE 
07A1    B80F1A        2603     CJNE R0 , # 15 , ELES_STATE_INIT 
                      2604     IF_STATE_INIT: 
                      2605     ; STATE_INIT 状态
                      2606     ; 初始油门
07A4    787F          2607     MOV R0 , # 127 
07A6    8859          2608     MOV NEW_RCP , R0 
07A8    E5EE          2609     MOV A , 238 
07AA    04            2610     	INC	A
07AB    C3            2611     	CLR 	C
07AC    F5EE          2612     MOV 238 , A 
07AE    9432          2613     	SUBB A, #50
07B0    4013          2614     	JC	ENDIF_STATE
07B2    E4            2615     	CLR	A
07B3    F5EE          2616     MOV 238 , A 
07B5    F502          2617     MOV 2 , A 
07B7    7800          2618     MOV R0 , # 0 
07B9    8877          2619     MOV CSTATE , R0 
07BB    0207C5        2620     	LJMP ENDIF_STATE
                      2621     
                      2622     ELES_STATE_INIT: 
07BE    7801          2623     MOV R0 , # ( RCP_MIN + 1 ) 
07C0    8859          2624     MOV NEW_RCP , R0 
07C2    0207C5        2625     	LJMP ENDIF_STATE
                      2626     
                      2627     ;
                      2628     ; 判断 cState 状态
                      2629     ;
                      2630     ;	mov	Temp1, cState				; 状态
                      2631     ;	cjne	Temp1, #STATE_FULL, eles_state_full
                      2632     ;if_state_full:
                      2633     ; STATE_FULL 状态
                      2634     ; 以下是 StateFull(); 的代码
                      2635     ;
                      2636     ; 全油门
                      2637     ;	mov	Temp1, #PWM_FULL
                      2638     ;	mov	Temp1, #RCP_MIN
                      2639     ;	mov	New_Rcp, Temp1	
                      2640     	; 
                      2641     ;	ljmp endif_state
                      2642     
                      2643     ;eles_state_full:
                      2644     ;	mov	Temp1, #PWM_FULL
                      2645     ;	mov	Temp1, #RCP_MIN
                      2646     ;	mov	New_Rcp, Temp1	
                      2647     	; 
                      2648     ;	ljmp endif_state
                      2649     
                      2650     
                      2651     ;	mov	Temp1, cState
                      2652     ;	cjne	Temp1, #STATE_CRUISE, else_state_cruise
                      2653     ;
                      2654     ;if_state_cruise:
                      2655     	; STATE_FULL 状态
                      2656     	; 以下是 StateCruise(); 的代码
                      2657     	;
                      2658     	; 巡航油门
                      2659     ;	mov	Temp1, #PWM_CRUISE
                      2660     ;	mov	Temp1, #RCP_MIN
                      2661     ;	mov	New_Rcp, Temp1	
                      2662     	; 
                      2663     ;	jmp endif_state
                      2664     
                      2665     ;else_state_cruise:
                      2666     	; STATE_FULL 状态
                      2667     	; 以下是 StateWait(); 的代码
                      2668     	;
                      2669     	; 最低油门
                      2670     ;	mov	Temp1, #RCP_MIN
                      2671     ;	mov	New_Rcp, Temp1	
                      2672     	; 
                      2673     	; 判断是否 PWM_IN_HIGH
                      2674     ;	mov	Temp1, nPWMIn
                      2675     ;	cjne	Temp1, #PWM_IN_HIGH, endif_state
                      2676     ;	mov	Temp1, #STATE_FULL		; 状态切换为 STATE_FULL
                      2677     ;	mov	cState, Temp1
                      2678     ;	jmp	endif_state
                      2679     
                      2680     ENDIF_STATE: 
                      2681     
                      2682     ; skypup_03:
                      2683     ; 
                      2684     ; 	clr C
                      2685     ; 	mov A, Temp1
                      2686     ; 	subb A, Prev_Rcp				; 上一个 Rcp > 当前 Rcp ?
                      2687     ; 	jc skypup_04					; No
                      2688     ; 
                      2689     ; 	subb A, #THR_DELTA				; 油门缓启动增量 > Rcp 增加值 ?
                      2690     ; 	jc skypup_04					; No
                      2691     ; 
                      2692     ; 	clr C						; 这一句能否去掉? Skypup 2015.05.25
                      2693     ; 	mov A, Prev_Rcp
                      2694     ; 	add A, #THR_DELTA
                      2695     ; 	mov Temp1, A
                      2696     ; 	jnc skypup_04					; 没有发生进位溢出
                      2697     ; 
                      2698     ; 	mov Temp1, #0FFh	
                      2699     ; 	
                      2700     ; skypup_04:
                      2701     
                      2702     	; 记录 New_Rcp 值
07C5    E559          2703     	MOV A, NEW_RCP
07C7    F573          2704     	MOV PREV_RCP, A
                      2705     
                      2706     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2707     	; RC pulse value accepted
                      2708     	; mov	New_Rcp, Temp1				; Store new pulse length
07C9    D268          2709     SETB FLAGS2 . 0 
07CB    205902        2710     JB FLAGS0 . 1 , ( $+5 ) 
07CE    E1D8          2711     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2712     
07D0    741F          2713     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07D2    F4            2714     	CPL	A
07D3    552E          2715     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07D5    4B            2716     ORL A , R3 
07D6    F52E          2717     	MOV	FLAGS3, A
                      2718     
                      2719     PCA_INT_SET_TIMEOUT: 
07D8    752818        2720     MOV RCP_TIMEOUT_CNT , # 24 
07DB    741F          2721     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07DD    552E          2722     	ANL	A, FLAGS3					; Check pwm frequency flags
07DF    7003          2723     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2724     
07E1    75280A        2725     MOV RCP_TIMEOUT_CNT , # 10 
                      2726     
                      2727     PCA_INT_PPM_TIMEOUT_SET: 
07E4    305902        2728     JNB FLAGS0 . 1 , ( $+5 ) 
07E7    E1F2          2729     	AJMP PCA_INT_EXIT				; Yes - exit
                      2730     
07E9    741F          2731     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07EB    552E          2732     	ANL	A, FLAGS3					; Check pwm frequency flags
07ED    6003          2733     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2734     
                      2735     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07EF    53DAFE        2735+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2736     
                      2737     PCA_INT_EXIT: 	; Exit interrupt routine	
07F2    752906        2738     MOV RCP_SKIP_CNT , # 6 
07F5    741F          2739     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07F7    552E          2740     	ANL	A, FLAGS3					; Check pwm frequency flags
07F9    7003          2741     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2742     
07FB    75290A        2743     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2744     
07FE    D0F0          2745     	POP	B			; Restore preserved registers
0800    D0E0          2746     	POP	ACC			
0802    D0D0          2747     	POP	PSW
0804    C2D3          2748     	CLR	PSW.3		; Select register bank 0 for main program routines	
0806    D2AD          2749     	SETB	ET2			; Enable timer2 interrupts
0808    43E610        2750     	ORL	EIE1, #10H	; Enable PCA0 interrupts
080B    32            2751     	RETI
                      2752     
                      2753     
                      2754     
                      2755     
                      2756     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2757     ;
                      2758     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2759     ;
                      2760     ; No assumptions
                      2761     ;
                      2762     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2763     WAIT1MS: 	
080C    7901          2764     MOV R1 , # 1 
080E    02082A        2765     	JMP	WAITXMS_O
                      2766     
                      2767     WAIT3MS: 	
0811    7903          2768     MOV R1 , # 3 
0813    02082A        2769     	JMP	WAITXMS_O
                      2770     
                      2771     WAIT10MS: 	
0816    790A          2772     MOV R1 , # 10 
0818    02082A        2773     	JMP	WAITXMS_O
                      2774     
                      2775     WAIT30MS: 	
081B    791E          2776     MOV R1 , # 30 
081D    02082A        2777     	JMP	WAITXMS_O
                      2778     
                      2779     WAIT100MS: 	
0820    7964          2780     MOV R1 , # 100 
0822    02082A        2781     	JMP	WAITXMS_O
                      2782     
                      2783     WAIT200MS: 	
0825    79C8          2784     MOV R1 , # 200 
0827    02082A        2785     	JMP	WAITXMS_O
                      2786     
                      2787     WAITXMS_O: 	; Outer loop
082A    7817          2788     MOV R0 , # 23 
                      2789     WAITXMS_M: 	; Middle loop
082C    E4            2790     	CLR	A
082D    D5E0FD        2791      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0830    D8FA          2792     DJNZ R0 , WAITXMS_M 
0832    D9F6          2793     DJNZ R1 , WAITXMS_O 
0834    22            2794     	RET
                      2795     
                      2796     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2797     ;
                      2798     ; Wait 1 second routine
                      2799     ;
                      2800     ; No assumptions
                      2801     ;
                      2802     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2803     WAIT1S: 
0835    7C05          2804     MOV R4 , # 5 
                      2805     WAIT1S_LOOP: 
0837    1125          2806     	CALL WAIT200MS
0839    DCFC          2807     DJNZ R4 , WAIT1S_LOOP 
083B    22            2808     	RET
                      2809     
                      2810     
                      2811     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2812     ;
                      2813     ; Beeper routines (4 different entry points) 
                      2814     ;
                      2815     ; No assumptions
                      2816     ;
                      2817     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2818     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
083C    7A14          2819     MOV R2 , # 20 
083E    7B78          2820     MOV R3 , # 120 
0840    020858        2821     	JMP	BEEP
                      2822     
                      2823     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0843    7A10          2824     MOV R2 , # 16 
0845    7B8C          2825     MOV R3 , # 140 
0847    020858        2826     	JMP	BEEP
                      2827     
                      2828     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
084A    7A0D          2829     MOV R2 , # 13 
084C    7BB4          2830     MOV R3 , # 180 
084E    020858        2831     	JMP	BEEP
                      2832     
                      2833     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0851    7A0B          2834     MOV R2 , # 11 
0853    7BC8          2835     MOV R3 , # 200 
0855    020858        2836     	JMP	BEEP
                      2837     
                      2838     BEEP: 	; Beep loop start
0858    AC25          2839     MOV R4 , CURRENT_PWM_LIMITED 
085A    752501        2840     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
085D    7902          2841     MOV R1 , # 2 
                      2842     BEEP_ONOFF: 
085F    B275          2843     CPL FLAGS3 . 5 
0861    E4            2844     	CLR	A
                      2845     	BPFET_OFF			; BpFET off
0862    C294          2845+1   CLR P1 . 4 
0864    D5E0FD        2846     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2847     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
0867    E525          2847+1   MOV A , CURRENT_PWM_LIMITED 
0869    6002          2847+1   JZ ( $+4 ) 
086B    D295          2847+1   SETB P1 . 5 
086D    D5E0FD        2848     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2849     	BNFET_OFF			; BnFET off again
0870    C295          2849+1   CLR P1 . 5 
0872    D5E0FD        2850     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2851     	BPFET_ON			; BpFET on
0875    D294          2851+1   SETB P1 . 4 
0877    D5E0FD        2852     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2853     	; Turn on nfet
                      2854     	ANFET_ON			; AnFET on
087A    E525          2854+1   MOV A , CURRENT_PWM_LIMITED 
087C    600A          2854+1   JZ ( $+12 ) 
087E    207502        2854+1   JB FLAGS3 . 5 , ( $+5 ) 
0881    D292          2854+1   SETB P1 . 2 
0883    307502        2854+1   JNB FLAGS3 . 5 , ( $+5 ) 
0886    D296          2854+1   SETB P1 . 6 
0888    E56F          2855     	MOV	A, BEEP_STRENGTH
088A    D5E0FD        2856     	DJNZ	ACC, $		
                      2857     	; Turn off nfet
                      2858     	ANFET_OFF			; AnFET off
088D    207502        2858+1   JB FLAGS3 . 5 , ( $+5 ) 
0890    C292          2858+1   CLR P1 . 2 
0892    307502        2858+1   JNB FLAGS3 . 5 , ( $+5 ) 
0895    C296          2858+1   CLR P1 . 6 
0897    7496          2859     	MOV	A, #150		; 25s off
0899    D5E0FD        2860     	DJNZ	ACC, $		
089C    D9C1          2861     DJNZ R1 , BEEP_ONOFF 
                      2862     	; Copy variable
089E    EA            2863     MOV A , R2 
089F    F8            2864     MOV R0 , A 
                      2865     BEEP_OFF: 		; Fets off loop
08A0    D5E0FD        2866     	DJNZ	ACC, $
08A3    D8FB          2867     DJNZ R0 , BEEP_OFF 
08A5    DBB1          2868     DJNZ R3 , BEEP 
                      2869     	BPFET_OFF			; BpFET off
08A7    C294          2869+1   CLR P1 . 4 
08A9    8C25          2870     MOV CURRENT_PWM_LIMITED , R4 
08AB    22            2871     	RET
                      2872     
                      2873     
                      2874     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2875     ;
                      2876     ; Division 16bit unsigned by 16bit unsigned
                      2877     ;
                      2878     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2879     ; Result will be in Temp2/Temp1
                      2880     ;
                      2881     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2882     DIV_U16_BY_U16: 	
08AC    C3            2883     	CLR	C       
08AD    7C00          2884     MOV R4 , # 0 
08AF    7D00          2885     MOV R5 , # 0 
08B1    75F000        2886     	MOV	B, #0
                      2887     DIV_U16_BY_U16_DIV1: 
08B4    05F0          2888     	INC	B      			; Increment counter for each left shift
08B6    EA            2889     MOV A , R2 
08B7    33            2890     	RLC	A      		
08B8    FA            2891     MOV R2 , A 
08B9    EB            2892     MOV A , R3 
08BA    33            2893     	RLC	A      	  	
08BB    FB            2894     MOV R3 , A 
08BC    50F6          2895     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2896     DIV_U16_BY_U16_DIV2:         
08BE    EB            2897     MOV A , R3 
08BF    13            2898     	RRC	A      
08C0    FB            2899     MOV R3 , A 
08C1    EA            2900     MOV A , R2 
08C2    13            2901     	RRC	A      
08C3    FA            2902     MOV R2 , A 
08C4    C3            2903     	CLR	C      
08C5    E9            2904     MOV A , R1 
08C6    FF            2905     MOV R7 , A 
08C7    E8            2906     MOV A , R0 
08C8    FE            2907     MOV R6 , A 
08C9    E8            2908     MOV A , R0 
08CA    9A            2909     SUBB A , R2 
08CB    F8            2910     MOV R0 , A 
08CC    E9            2911     MOV A , R1 
08CD    9B            2912     SUBB A , R3 
08CE    F9            2913     MOV R1 , A 
08CF    5004          2914     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08D1    EF            2915     MOV A , R7 
08D2    F9            2916     MOV R1 , A 
08D3    EE            2917     MOV A , R6 
08D4    F8            2918     MOV R0 , A 
                      2919     DIV_U16_BY_U16_DIV3: 
08D5    B3            2920     	CPL	C      			; Invert carry, so it can be directly copied into result
08D6    EC            2921     MOV A , R4 
08D7    33            2922     	RLC	A      			; Shift carry flag into temporary result
08D8    FC            2923     MOV R4 , A 
08D9    ED            2924     MOV A , R5 
08DA    33            2925     	RLC	A
08DB    FD            2926     MOV R5 , A 
08DC    D5F0DF        2927     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08DF    ED            2928     MOV A , R5 
08E0    F9            2929     MOV R1 , A 
08E1    EC            2930     MOV A , R4 
08E2    F8            2931     MOV R0 , A 
08E3    22            2932     	RET
                      2933     
                      2934     
                      2935     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2936     ;
                      2937     ; Multiplication 16bit signed by 8bit unsigned
                      2938     ;
                      2939     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2940     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2941     ;
                      2942     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2943     MULT_S16_BY_U8_DIV_16: 
08E4    E8            2944     MOV A , R0 
08E5    89F0          2945     MOV B , R1 
08E7    8A20          2946     MOV BIT_ACCESS , R2 
08E9    D2D4          2947     	SETB	PSW.4		; Select register bank 2 for math routines
08EB    F8            2948     MOV R0 , A 
08EC    A9F0          2949     MOV R1 , B 
08EE    7B00          2950     MOV R3 , # 0 
08F0    30F70B        2951     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2952     
08F3    7BFF          2953     MOV R3 , # 0FFH 
08F5    F4            2954     	CPL	A
08F6    2401          2955     	ADD	A, #1
08F8    F8            2956     MOV R0 , A 
08F9    E9            2957     MOV A , R1 
08FA    F4            2958     	CPL	A
08FB    3400          2959     	ADDC	A, #0
08FD    F9            2960     MOV R1 , A 
                      2961     MULT_S16_BY_U8_POSITIVE: 
08FE    E8            2962     MOV A , R0 
08FF    8520F0        2963     	MOV	B, BIT_ACCESS
0902    A4            2964     	MUL	AB
0903    ADF0          2965     MOV R5 , B 
0905    F8            2966     MOV R0 , A 
0906    E9            2967     MOV A , R1 
0907    8520F0        2968     	MOV	B, BIT_ACCESS
090A    A4            2969     	MUL	AB
090B    AFF0          2970     MOV R7 , B 
090D    FE            2971     MOV R6 , A 
090E    ED            2972     MOV A , R5 
090F    2E            2973     ADD A , R6 
0910    F9            2974     MOV R1 , A 
0911    7400          2975     	MOV	A, #0
0913    3F            2976     ADDC A , R7 
0914    FA            2977     MOV R2 , A 
0915    7C04          2978     MOV R4 , # 4 
                      2979     MULT_S16_BY_U8_DIV_LOOP: 
0917    C3            2980     	CLR	C			; Rotate right 
0918    EA            2981     MOV A , R2 
0919    13            2982     	RRC	A
091A    FA            2983     MOV R2 , A 
091B    E9            2984     MOV A , R1 
091C    13            2985     	RRC	A
091D    F9            2986     MOV R1 , A 
091E    E8            2987     MOV A , R0 
091F    13            2988     	RRC	A
0920    F8            2989     MOV R0 , A 
0921    DCF4          2990     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2991     
0923    8BF0          2992     MOV B , R3 
0925    30F70A        2993     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2994     
0928    E8            2995     MOV A , R0 
0929    F4            2996     	CPL	A
092A    2401          2997     	ADD	A, #1
092C    F8            2998     MOV R0 , A 
092D    E9            2999     MOV A , R1 
092E    F4            3000     	CPL	A
092F    3400          3001     	ADDC	A, #0
0931    F9            3002     MOV R1 , A 
                      3003     
                      3004     MULT_S16_BY_U8_EXIT: 
0932    E8            3005     MOV A , R0 
0933    89F0          3006     MOV B , R1 
0935    C2D4          3007     	CLR	PSW.4		; Select normal register bank
0937    F8            3008     MOV R0 , A 
0938    A9F0          3009     MOV R1 , B 
093A    22            3010     	RET
                      3011     
                      3012     
                      3013     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3014     ;
                      3015     ; Calculate governor routines
                      3016     ;
                      3017     ; No assumptions
                      3018     ;
                      3019     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      3020     ; The governor task is split into several routines in order to distribute processing time
                      3021     ;
                      3022     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3023     ; First governor routine - calculate governor target
                      3024     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3164     IF MODE == 2	; Multi
                      3165     CALC_GOVERNOR_TARGET: 
093B    7882          3166     MOV R0 , # PGM_GOV_MODE 
093D    B60403        3167     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0940    020997        3168     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3169     
                      3170     GOVERNOR_TARGET_CALC: 
                      3171     	; Stop governor for stop RC pulse	
0943    C3            3172     	CLR	C
0944    E559          3173     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0946    9401          3174     SUBB A , # 1 
0948    4003          3175     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3176     
094A    020960        3177     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3178     
                      3179     GOVERNOR_DEACTIVATE: 
094D    852224        3180     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0950    E4            3181     	CLR	A
0951    F540          3182     	MOV	GOV_TARGET_L, A			; Set target to zero
0953    F541          3183     	MOV	GOV_TARGET_H, A
0955    F542          3184     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0957    F543          3185     	MOV	GOV_INTEGRAL_H, A
0959    F544          3186     	MOV	GOV_INTEGRAL_X, A
095B    F549          3187     	MOV	GOV_ACTIVE, A
095D    020997        3188     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3189     
                      3190     GOVERNOR_ACTIVATE: 
0960    7882          3191     MOV R0 , # PGM_GOV_MODE 
0962    E6            3192     MOV A , @ R0 
0963    FC            3193     MOV R4 , A 
0964    754901        3194     	MOV	GOV_ACTIVE, #1
0967    E522          3195     	MOV	A, REQUESTED_PWM			; Load requested pwm
0969    F523          3196     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3197     	; Calculate comm period target 2*(51000/Requested_Pwm)
096B    7838          3198     MOV R0 , # 38H 
096D    79C7          3199     MOV R1 , # 0C7H 
096F    AA3C          3200     MOV R2 , COMM_PERIOD4X_L 
0971    AB3D          3201     MOV R3 , COMM_PERIOD4X_H 
                      3202     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
0973    C3            3203     	CLR	C
0974    EB            3204     MOV A , R3 
0975    13            3205     	RRC	A
0976    FB            3206     MOV R3 , A 
0977    EA            3207     MOV A , R2 
0978    13            3208     	RRC	A
0979    FA            3209     MOV R2 , A 
                      3210     	; Check range
097A    EC            3211     MOV A , R4 
097B    14            3212     	DEC	A
097C    6013          3213     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3214     GOVERNOR_ACTIVATE_100K: 
097E    C3            3215     	CLR	C
097F    EB            3216     MOV A , R3 
0980    13            3217     	RRC	A
0981    FB            3218     MOV R3 , A 
0982    EA            3219     MOV A , R2 
0983    13            3220     	RRC	A
0984    FA            3221     MOV R2 , A 
0985    EC            3222     MOV A , R4 
0986    14            3223     	DEC	A
0987    14            3224     	DEC	A
0988    6007          3225     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3226     GOVERNOR_ACTIVATE_50K: 
098A    C3            3227     	CLR	C
098B    EB            3228     MOV A , R3 
098C    13            3229     	RRC	A
098D    FB            3230     MOV R3 , A 
098E    EA            3231     MOV A , R2 
098F    13            3232     	RRC	A
0990    FA            3233     MOV R2 , A 
                      3234     GOVERNOR_ACTIVATE_RANGE_SET: 
0991    11AC          3235     	CALL	DIV_U16_BY_U16
                      3236     	; Store governor target
0993    8840          3237     MOV GOV_TARGET_L , R0 
0995    8941          3238     MOV GOV_TARGET_H , R1 
                      3239     CALC_GOVERNOR_TARGET_EXIT: 
0997    22            3240     	RET						
                      3241     ENDIF
                      3242     
                      3243     
                      3244     ; Second governor routine - calculate governor proportional error
                      3245     CALC_GOVERNOR_PROP_ERROR: 
                      3246     	; Exit if governor is inactive
0998    E549          3247     	MOV	A, GOV_ACTIVE
099A    6034          3248     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3249     
                      3250     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3268     IF MODE == 2	; Multi
                      3269     	; Calculate error
099C    C3            3270     	CLR	C
099D    E540          3271     	MOV	A, GOV_TARGET_L
099F    9523          3272     	SUBB	A, GOVERNOR_REQ_PWM
09A1    F8            3273     MOV R0 , A 
09A2    E541          3274     	MOV	A, GOV_TARGET_H
09A4    9400          3275     	SUBB	A, #0
09A6    F9            3276     MOV R1 , A 
                      3277     ENDIF
                      3278     	; Check error and limit
09A7    500C          3279     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3280     
09A9    C3            3281     	CLR	C
09AA    E8            3282     MOV A , R0 
09AB    9480          3283     	SUBB	A, #80H					; Is error too negative?
09AD    E9            3284     MOV A , R1 
09AE    94FF          3285     	SUBB	A, #0FFH
09B0    4016          3286     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
09B2    0209CC        3287     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3288     
                      3289     GOVERNOR_CHECK_PROP_LIMIT_POS: 
09B5    C3            3290     	CLR	C
09B6    E8            3291     MOV A , R0 
09B7    947F          3292     	SUBB	A, #7FH					; Is error too positive?
09B9    E9            3293     MOV A , R1 
09BA    9400          3294     	SUBB	A, #00H
09BC    5003          3295     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
09BE    0209CC        3296     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3297     
                      3298     GOVERNOR_LIMIT_PROP_ERROR_POS: 
09C1    787F          3299     MOV R0 , # 7FH 
09C3    7900          3300     MOV R1 , # 00H 
09C5    0209CC        3301     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3302     
                      3303     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09C8    7880          3304     MOV R0 , # 80H 
09CA    79FF          3305     MOV R1 , # 0FFH 
                      3306     
                      3307     GOVERNOR_STORE_PROP_ERROR: 
                      3308     	; Store proportional
09CC    8845          3309     MOV GOV_PROPORTIONAL_L , R0 
09CE    8946          3310     MOV GOV_PROPORTIONAL_H , R1 
                      3311     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09D0    22            3312     	RET						
                      3313     
                      3314     
                      3315     ; Third governor routine - calculate governor integral error
                      3316     CALC_GOVERNOR_INT_ERROR: 
                      3317     	; Exit if governor is inactive
09D1    E549          3318     	MOV	A, GOV_ACTIVE
09D3    6058          3319     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3320     
                      3321     	; Add proportional to integral
09D5    E545          3322     	MOV	A, GOV_PROPORTIONAL_L
09D7    2542          3323     	ADD	A, GOV_INTEGRAL_L
09D9    F8            3324     MOV R0 , A 
09DA    E546          3325     	MOV	A, GOV_PROPORTIONAL_H
09DC    3543          3326     	ADDC	A, GOV_INTEGRAL_H
09DE    F9            3327     MOV R1 , A 
09DF    854620        3328     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09E2    E4            3329     	CLR	A
09E3    300701        3330     	JNB	BIT_ACCESS.7, ($+4)			
09E6    F4            3331     	CPL	A
09E7    3544          3332     	ADDC	A, GOV_INTEGRAL_X
09E9    FA            3333     MOV R2 , A 
                      3334     	; Check integral and limit
09EA    30E709        3335     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3336     
09ED    C3            3337     	CLR	C
09EE    EA            3338     MOV A , R2 
09EF    94F0          3339     	SUBB	A, #0F0H					; Is error too negative?
09F1    4015          3340     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09F3    020A0E        3341     	JMP	GOVERNOR_CHECK_PWM
                      3342     
                      3343     GOVERNOR_CHECK_INT_LIMIT_POS: 
09F6    C3            3344     	CLR	C
09F7    EA            3345     MOV A , R2 
09F8    940F          3346     	SUBB	A, #0FH					; Is error too positive?
09FA    5003          3347     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09FC    020A0E        3348     	JMP	GOVERNOR_CHECK_PWM
                      3349     
                      3350     GOVERNOR_LIMIT_INT_ERROR_POS: 
09FF    78FF          3351     MOV R0 , # 0FFH 
0A01    79FF          3352     MOV R1 , # 0FFH 
0A03    7A0F          3353     MOV R2 , # 0FH 
0A05    020A0E        3354     	JMP	GOVERNOR_CHECK_PWM
                      3355     
                      3356     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0A08    7800          3357     MOV R0 , # 00H 
0A0A    7900          3358     MOV R1 , # 00H 
0A0C    7AF0          3359     MOV R2 , # 0F0H 
                      3360     
                      3361     GOVERNOR_CHECK_PWM: 
                      3362     	; Check current pwm
0A0E    C3            3363     	CLR	C
0A0F    E524          3364     	MOV	A, CURRENT_PWM
0A11    955E          3365     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0A13    5006          3366     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3367     
0A15    E524          3368     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0A17    6009          3369     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3370     
0A19    4127          3371     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3372     
                      3373     GOVERNOR_INT_MAX_PWM: 
0A1B    E546          3374     	MOV	A, GOV_PROPORTIONAL_H
0A1D    20E70D        3375     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3376     
0A20    4127          3377     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3378     
                      3379     GOVERNOR_INT_MIN_PWM: 
0A22    E546          3380     	MOV	A, GOV_PROPORTIONAL_H
0A24    30E706        3381     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3382     
                      3383     GOVERNOR_STORE_INT_ERROR: 
                      3384     	; Store integral
0A27    8842          3385     MOV GOV_INTEGRAL_L , R0 
0A29    8943          3386     MOV GOV_INTEGRAL_H , R1 
0A2B    8A44          3387     MOV GOV_INTEGRAL_X , R2 
                      3388     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A2D    22            3389     	RET						
                      3390     
                      3391     
                      3392     ; Fourth governor routine - calculate governor proportional correction
                      3393     CALC_GOVERNOR_PROP_CORRECTION: 
                      3394     	; Exit if governor is inactive
0A2E    E549          3395     	MOV	A, GOV_ACTIVE
0A30    7003          3396     	JNZ	CALC_GOVERNOR_PROP_CORR
0A32    020A91        3397     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3398     
                      3399     CALC_GOVERNOR_PROP_CORR: 
                      3400     	; Load proportional gain
0A35    789F          3401     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A37    E6            3402     MOV A , @ R0 
0A38    FA            3403     MOV R2 , A 
                      3404     	; Load proportional
0A39    C3            3405     	CLR	C
0A3A    E545          3406     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A3C    33            3407     	RLC	A
0A3D    F8            3408     MOV R0 , A 
0A3E    E546          3409     	MOV	A, GOV_PROPORTIONAL_H
0A40    33            3410     	RLC	A
0A41    F9            3411     MOV R1 , A 
                      3412     	; Apply gain
0A42    11E4          3413     	CALL	MULT_S16_BY_U8_DIV_16
                      3414     	; Check error and limit (to low byte)
0A44    E9            3415     MOV A , R1 
0A45    30E70B        3416     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3417     
0A48    C3            3418     	CLR	C
0A49    E8            3419     MOV A , R0 
0A4A    9480          3420     	SUBB	A, #80H					; Is error too negative?
0A4C    E9            3421     MOV A , R1 
0A4D    94FF          3422     	SUBB	A, #0FFH
0A4F    4013          3423     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A51    4168          3424     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3425     
                      3426     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A53    C3            3427     	CLR	C
0A54    E8            3428     MOV A , R0 
0A55    947F          3429     	SUBB	A, #7FH					; Is error too positive?
0A57    E9            3430     MOV A , R1 
0A58    9400          3431     	SUBB	A, #00H
0A5A    5002          3432     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A5C    4168          3433     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3434     
                      3435     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A5E    787F          3436     MOV R0 , # 7FH 
0A60    7900          3437     MOV R1 , # 00H 
0A62    4168          3438     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3439     
                      3440     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A64    7880          3441     MOV R0 , # 80H 
0A66    79FF          3442     MOV R1 , # 0FFH 
                      3443     
                      3444     GOVERNOR_APPLY_PROP_CORR: 
                      3445     	; Test proportional sign
0A68    E8            3446     MOV A , R0 
0A69    20E715        3447     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3448     
                      3449     	; Subtract positive proportional
0A6C    C3            3450     	CLR	C
0A6D    E523          3451     	MOV	A, GOVERNOR_REQ_PWM
0A6F    98            3452     SUBB A , R0 
0A70    F8            3453     MOV R0 , A 
                      3454     	; Check result
0A71    4009          3455     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3456     
0A73    C3            3457     	CLR	C
0A74    E8            3458     MOV A , R0 
0A75    9401          3459     	SUBB	A, #1
0A77    4003          3460     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A79    020A8F        3461     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3462     
                      3463     GOVERNOR_CORR_PROP_MIN_PWM: 
0A7C    7801          3464     MOV R0 , # 1 
0A7E    020A8F        3465     	JMP	GOVERNOR_STORE_PROP_CORR
                      3466     
                      3467     GOVERNOR_CORR_NEG_PROP: 
                      3468     	; Add negative proportional
0A81    E8            3469     MOV A , R0 
0A82    F4            3470     	CPL	A
0A83    2401          3471     	ADD	A, #1
0A85    2523          3472     	ADD	A, GOVERNOR_REQ_PWM
0A87    F8            3473     MOV R0 , A 
                      3474     	; Check result
0A88    4003          3475     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A8A    020A8F        3476     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3477     
                      3478     GOVERNOR_CORR_PROP_MAX_PWM: 
0A8D    78FF          3479     MOV R0 , # 255 
                      3480     GOVERNOR_STORE_PROP_CORR: 
                      3481     	; Store proportional pwm
0A8F    8847          3482     MOV GOV_PROP_PWM , R0 
                      3483     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A91    22            3484     	RET
                      3485     
                      3486     
                      3487     ; Fifth governor routine - calculate governor integral correction
                      3488     CALC_GOVERNOR_INT_CORRECTION: 
                      3489     	; Exit if governor is inactive
0A92    E549          3490     	MOV	A, GOV_ACTIVE
0A94    7003          3491     	JNZ	CALC_GOVERNOR_INT_CORR
0A96    020AF3        3492     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3493     
                      3494     CALC_GOVERNOR_INT_CORR: 
                      3495     	; Load integral gain
0A99    78A0          3496     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A9B    E6            3497     MOV A , @ R0 
0A9C    FA            3498     MOV R2 , A 
                      3499     	; Load integral
0A9D    A843          3500     MOV R0 , GOV_INTEGRAL_H 
0A9F    A944          3501     MOV R1 , GOV_INTEGRAL_X 
                      3502     	; Apply gain
0AA1    11E4          3503     	CALL	MULT_S16_BY_U8_DIV_16
                      3504     	; Check integral and limit
0AA3    E9            3505     MOV A , R1 
0AA4    30E70C        3506     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3507     
0AA7    C3            3508     	CLR	C
0AA8    E8            3509     MOV A , R0 
0AA9    9401          3510     	SUBB	A, #01H					; Is integral too negative?
0AAB    E9            3511     MOV A , R1 
0AAC    94FF          3512     	SUBB	A, #0FFH
0AAE    4016          3513     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0AB0    020ACA        3514     	JMP	GOVERNOR_APPLY_INT_CORR
                      3515     
                      3516     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0AB3    C3            3517     	CLR	C
0AB4    E8            3518     MOV A , R0 
0AB5    94FF          3519     	SUBB	A, #0FFH					; Is integral too positive?
0AB7    E9            3520     MOV A , R1 
0AB8    9400          3521     	SUBB	A, #00H
0ABA    5003          3522     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0ABC    020ACA        3523     	JMP	GOVERNOR_APPLY_INT_CORR
                      3524     
                      3525     GOVERNOR_LIMIT_INT_CORR_POS: 
0ABF    78FF          3526     MOV R0 , # 0FFH 
0AC1    7900          3527     MOV R1 , # 00H 
0AC3    020ACA        3528     	JMP	GOVERNOR_APPLY_INT_CORR
                      3529     
                      3530     GOVERNOR_LIMIT_INT_CORR_NEG: 
0AC6    7801          3531     MOV R0 , # 01H 
0AC8    79FF          3532     MOV R1 , # 0FFH 
                      3533     
                      3534     GOVERNOR_APPLY_INT_CORR: 
                      3535     	; Test integral sign
0ACA    E9            3536     MOV A , R1 
0ACB    20E715        3537     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3538     
                      3539     	; Subtract positive integral
0ACE    C3            3540     	CLR	C
0ACF    E547          3541     	MOV	A, GOV_PROP_PWM
0AD1    98            3542     SUBB A , R0 
0AD2    F8            3543     MOV R0 , A 
                      3544     	; Check result
0AD3    4009          3545     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3546     
0AD5    C3            3547     	CLR	C
0AD6    E8            3548     MOV A , R0 
0AD7    9401          3549     	SUBB	A, #1
0AD9    4003          3550     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0ADB    020AF1        3551     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3552     
                      3553     GOVERNOR_CORR_INT_MIN_PWM: 
0ADE    7800          3554     MOV R0 , # 0 
0AE0    020AF1        3555     	JMP	GOVERNOR_STORE_INT_CORR
                      3556     
                      3557     GOVERNOR_CORR_NEG_INT: 
                      3558     	; Add negative integral
0AE3    E8            3559     MOV A , R0 
0AE4    F4            3560     	CPL	A
0AE5    2401          3561     	ADD	A, #1
0AE7    2547          3562     	ADD	A, GOV_PROP_PWM
0AE9    F8            3563     MOV R0 , A 
                      3564     	; Check result
0AEA    4003          3565     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AEC    020AF1        3566     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3567     
                      3568     GOVERNOR_CORR_INT_MAX_PWM: 
0AEF    78FF          3569     MOV R0 , # 255 
                      3570     GOVERNOR_STORE_INT_CORR: 
                      3571     	; Store current pwm
0AF1    8824          3572     MOV CURRENT_PWM , R0 
                      3573     CALC_GOVERNOR_INT_CORR_EXIT: 
0AF3    22            3574     	RET
                      3575     
                      3576     
                      3577     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3578     ;
                      3579     ; Measure lipo cells
                      3580     ;
                      3581     ; No assumptions
                      3582     ;
                      3583     ; Measure voltage and calculate lipo cells
                      3584     ;
                      3585     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3586     MEASURE_LIPO_CELLS: 
                      3587     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3591     MEASURE_LIPO_START: 
                      3592     	; Load programmed low voltage limit
0AF4    7883          3593     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AF6    E6            3594     MOV A , @ R0 
0AF7    F520          3595     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3596     	; Set commutation to BpFET on
0AF9    121011        3597     	CALL	COMM5COMM6			
                      3598     	; Start adc
                      3599     	START_ADC 
0AFC    75E890        3599+1   MOV ADC0CN , # 90H  ; ADC START
                      3600     	; Wait for ADC reference to settle, and then start again
0AFF    110C          3601     	CALL	WAIT1MS
                      3602     	START_ADC
0B01    75E890        3602+1   MOV ADC0CN , # 90H  ; ADC START
                      3603     	; Wait for ADC conversion to complete
                      3604     MEASURE_LIPO_WAIT_ADC: 
                      3605     	GET_ADC_STATUS 
0B04    E5E8          3605+1   MOV A , ADC0CN 
0B06    20ECFB        3606     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3607     	; Read ADC result
                      3608     	READ_ADC_RESULT
0B09    A8BD          3608+1   MOV R0 , ADC0L 
0B0B    A9BE          3608+1   MOV R1 , ADC0H 
                      3609     	; Stop ADC
                      3610     	STOP_ADC
                      3611     	; Switch power off
0B0D    1210B7        3612     	CALL	SWITCH_POWER_OFF		
                      3613     	; Set limit step
0B10    756A55        3614     MOV LIPO_ADC_LIMIT_L , # 85 
0B13    756B00        3615     MOV LIPO_ADC_LIMIT_H , # 0 
0B16    C3            3616     	CLR	C
0B17    7400          3617     MOV A , # 0 
0B19    13            3618     	RRC	A
0B1A    FD            3619     MOV R5 , A 
0B1B    7455          3620     MOV A , # 85 
0B1D    13            3621     	RRC	A
0B1E    FC            3622     MOV R4 , A 
0B1F    7455          3623     MOV A , # 85 
0B21    2C            3624     ADD A , R4 
0B22    FC            3625     MOV R4 , A 
0B23    7400          3626     MOV A , # 0 
0B25    3D            3627     ADDC A , R5 
0B26    FD            3628     MOV R5 , A 
0B27    EC            3629     MOV A , R4 
0B28    FA            3630     MOV R2 , A 
0B29    ED            3631     MOV A , R5 
0B2A    FB            3632     MOV R3 , A 
                      3633     MEASURE_LIPO_CELL_LOOP: 
                      3634     	; Check voltage against xS lower limit
0B2B    C3            3635     	CLR	C
0B2C    E8            3636     MOV A , R0 
0B2D    9A            3637     SUBB A , R2 
0B2E    E9            3638     MOV A , R1 
0B2F    9B            3639     SUBB A , R3 
0B30    4014          3640     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3641     
                      3642     	; Set xS voltage limit
0B32    E56A          3643     	MOV	A, LIPO_ADC_LIMIT_L		
0B34    2455          3644     ADD A , # 85 
0B36    F56A          3645     	MOV	LIPO_ADC_LIMIT_L, A
0B38    E56B          3646     	MOV	A, LIPO_ADC_LIMIT_H		
0B3A    3400          3647     ADDC A , # 0 
0B3C    F56B          3648     	MOV	LIPO_ADC_LIMIT_H, A
                      3649     	; Set (x+1)S lower limit
0B3E    EA            3650     MOV A , R2 
0B3F    2C            3651     ADD A , R4 
0B40    FA            3652     MOV R2 , A 
0B41    EB            3653     MOV A , R3 
0B42    3D            3654     ADDC A , R5 
0B43    FB            3655     MOV R3 , A 
0B44    80E5          3656     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3657     
                      3658     MEASURE_LIPO_ADJUST: 
0B46    AE6A          3659     MOV R6 , LIPO_ADC_LIMIT_L 
0B48    AF6B          3660     MOV R7 , LIPO_ADC_LIMIT_H 
                      3661     	; Calculate 3.125%
0B4A    C3            3662     	CLR	C
0B4B    E56B          3663     	MOV	A, LIPO_ADC_LIMIT_H
0B4D    13            3664     	RRC	A
0B4E    F9            3665     MOV R1 , A 
0B4F    E56A          3666     	MOV	A, LIPO_ADC_LIMIT_L	
0B51    13            3667     	RRC	A
0B52    F8            3668     MOV R0 , A 
0B53    C3            3669     	CLR	C
0B54    E9            3670     MOV A , R1 
0B55    13            3671     	RRC	A
0B56    F9            3672     MOV R1 , A 
0B57    E8            3673     MOV A , R0 
0B58    13            3674     	RRC	A
0B59    F8            3675     MOV R0 , A 
0B5A    E56A          3676     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B5C    28            3677     ADD A , R0 
0B5D    F568          3678     	MOV	LIPO_ADC_REFERENCE_L, A
0B5F    E56B          3679     	MOV	A, LIPO_ADC_LIMIT_H
0B61    39            3680     ADDC A , R1 
0B62    F569          3681     	MOV	LIPO_ADC_REFERENCE_H, A
                      3682     	; Divide three times to get to 3.125%
0B64    7A03          3683     MOV R2 , # 3 
                      3684     MEASURE_LIPO_DIVIDE_LOOP: 
0B66    C3            3685     	CLR	C
0B67    E9            3686     MOV A , R1 
0B68    13            3687     	RRC	A
0B69    F9            3688     MOV R1 , A 
0B6A    E8            3689     MOV A , R0 
0B6B    13            3690     	RRC	A
0B6C    F8            3691     MOV R0 , A 
0B6D    DAF7          3692     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3693     
                      3694     	; Add the programmed number of 0.1V (or 3.125% increments)
0B6F    AA20          3695     MOV R2 , BIT_ACCESS 
0B71    1A            3696     DEC R2 
0B72    7009          3697     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3698     
0B74    756A00        3699     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B77    756B00        3700     	MOV	LIPO_ADC_LIMIT_H, #0
0B7A    020B8D        3701     	JMP	MEASURE_LIPO_EXIT	
                      3702     
                      3703     MEASURE_LIPO_LIMIT_ON: 
0B7D    1A            3704     DEC R2 
0B7E    EA            3705     MOV A , R2 
0B7F    6008          3706     	JZ	MEASURE_LIPO_UPDATE
                      3707     
                      3708     MEASURE_LIPO_ADD_LOOP: 
0B81    EE            3709     MOV A , R6 
0B82    28            3710     ADD A , R0 
0B83    FE            3711     MOV R6 , A 
0B84    EF            3712     MOV A , R7 
0B85    39            3713     ADDC A , R1 
0B86    FF            3714     MOV R7 , A 
0B87    DAF8          3715     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3716     
                      3717     MEASURE_LIPO_UPDATE: 
                      3718     	; Set ADC limit
0B89    8E6A          3719     MOV LIPO_ADC_LIMIT_L , R6 
0B8B    8F6B          3720     MOV LIPO_ADC_LIMIT_H , R7 
                      3721     MEASURE_LIPO_EXIT: 
0B8D    22            3722     	RET
                      3723     
                      3724     
                      3725     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3726     ;
                      3727     ; Start ADC conversion
                      3728     ;
                      3729     ; No assumptions
                      3730     ;
                      3731     ; Start conversion used for measuring power supply voltage
                      3732     ;
                      3733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3734     START_ADC_CONVERSION: 
                      3735     	; Start adc
                      3736     	START_ADC 
0B8E    75E890        3736+1   MOV ADC0CN , # 90H  ; ADC START
0B91    22            3737     	RET
                      3738     
                      3739     
                      3740     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3741     ;
                      3742     ; Check temperature, power supply voltage and limit power
                      3743     ;
                      3744     ; No assumptions
                      3745     ;
                      3746     ; Used to limit main motor power in order to maintain the required voltage
                      3747     ;
                      3748     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3749     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3750     	; Load programmed low voltage limit
0B92    7883          3751     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B94    E6            3752     MOV A , @ R0 
0B95    FF            3753     MOV R7 , A 
                      3754     	; Wait for ADC conversion to complete
                      3755     	GET_ADC_STATUS 
0B96    E5E8          3755+1   MOV A , ADC0CN 
0B98    20ECF7        3756     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3757     	; Read ADC result
                      3758     	READ_ADC_RESULT
0B9B    A8BD          3758+1   MOV R0 , ADC0L 
0B9D    A9BE          3758+1   MOV R1 , ADC0H 
                      3759     	; Stop ADC
                      3760     	STOP_ADC
                      3761     
0B9F    056C          3762     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0BA1    C3            3763     	CLR	C
0BA2    E56C          3764     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0BA4    9408          3765     SUBB A , # 8 
0BA6    404B          3766     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3767     
0BA8    756C00        3768     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0BAB    E9            3769     MOV A , R1 
0BAC    7007          3770     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3771     
0BAE    E56D          3772     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0BB0    601B          3773     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0BB2    020BC1        3774     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3775     
                      3776     TEMP_AVERAGE_INC_DEC: 
0BB5    C3            3777     	CLR	C
0BB6    E8            3778     MOV A , R0 
0BB7    956D          3779     	SUBB	A, CURRENT_AVERAGE_TEMP
0BB9    6010          3780     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3781     
0BBB    E56D          3782     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0BBD    5006          3783     	JNC	TEMP_AVERAGE_INC				
                      3784     
0BBF    600C          3785     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3786     TEMP_AVERAGE_DEC: 
0BC1    14            3787     	DEC	A						; Decrement average
0BC2    020BCD        3788     	JMP	TEMP_AVERAGE_UPDATED
                      3789     
                      3790     TEMP_AVERAGE_INC: 
0BC5    04            3791     	INC	A						; Increment average
0BC6    60F9          3792     	JZ	TEMP_AVERAGE_DEC
0BC8    020BCD        3793     	JMP	TEMP_AVERAGE_UPDATED
                      3794     
                      3795     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BCB    E56D          3796     	MOV	A, CURRENT_AVERAGE_TEMP
                      3797     TEMP_AVERAGE_UPDATED: 
0BCD    F56D          3798     	MOV	CURRENT_AVERAGE_TEMP, A
0BCF    C3            3799     	CLR	C
0BD0    9472          3800     SUBB A , # 114 
0BD2    401B          3801     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3802     
0BD4    755EC0        3803     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3804     
0BD7    C3            3805     	CLR	C
0BD8    9404          3806     SUBB A , # 4 
0BDA    4013          3807     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3808     
0BDC    755E80        3809     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3810     
0BDF    C3            3811     	CLR	C
0BE0    9404          3812     SUBB A , # 4 
0BE2    400B          3813     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3814     
0BE4    755E40        3815     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3816     
0BE7    C3            3817     	CLR	C
0BE8    9404          3818     SUBB A , # 4 
0BEA    4003          3819     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3820     
0BEC    755E00        3821     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3822     
                      3823     TEMP_CHECK_EXIT: 
                      3824     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BEF    75BB09        3824+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BF2    22            3825     	RET
                      3826     
                      3827     CHECK_VOLTAGE_START: 
                      3828     IF MODE == 0 OR MODE == 2	; Main or multi
                      3829     	; Check if low voltage limiting is enabled
0BF3    EF            3830     MOV A , R7 
0BF4    C3            3831     	CLR	C
0BF5    9401          3832     	SUBB	A, #1					; Is low voltage limit disabled?
0BF7    601B          3833     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3834     
                      3835     	; Check if ADC is saturated
0BF9    C3            3836     	CLR	C
0BFA    E8            3837     MOV A , R0 
0BFB    94FF          3838     	SUBB	A, #0FFH
0BFD    E9            3839     MOV A , R1 
0BFE    9403          3840     	SUBB	A, #03H
0C00    5012          3841     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3842     
                      3843     	; Check voltage against limit
0C02    C3            3844     	CLR	C
0C03    E8            3845     MOV A , R0 
0C04    956A          3846     	SUBB	A, LIPO_ADC_LIMIT_L
0C06    E9            3847     MOV A , R1 
0C07    956B          3848     	SUBB	A, LIPO_ADC_LIMIT_H
0C09    5009          3849     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3850     
                      3851     	; Decrease pwm limit
0C0B    E55E          3852     	MOV  A, PWM_LIMIT
0C0D    600C          3853     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3854     
0C0F    155E          3855     	DEC	PWM_LIMIT					; Decrement limit
0C11    020C1B        3856     	JMP	CHECK_VOLTAGE_LIM
                      3857     
                      3858     CHECK_VOLTAGE_GOOD: 
                      3859     	; Increase pwm limit
0C14    E55E          3860     	MOV  A, PWM_LIMIT
0C16    F4            3861     	CPL	A			
0C17    6002          3862     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3863     
0C19    055E          3864     	INC	PWM_LIMIT					; Increment limit
                      3865     
                      3866     CHECK_VOLTAGE_LIM: 
0C1B    A85E          3867     MOV R0 , PWM_LIMIT 
0C1D    C3            3868     	CLR	C
0C1E    E524          3869     	MOV	A, CURRENT_PWM
0C20    98            3870     SUBB A , R0 
0C21    5002          3871     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3872     
0C23    A824          3873     MOV R0 , CURRENT_PWM 
                      3874     
                      3875     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3876     	; Slow spoolup
0C25    C3            3877     	CLR	C
0C26    E8            3878     MOV A , R0 
0C27    955F          3879     	SUBB	A, PWM_LIMIT_SPOOLUP
0C29    400A          3880     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3881     
0C2B    A85F          3882     MOV R0 , PWM_LIMIT_SPOOLUP 
0C2D    E55F          3883     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C2F    F4            3884     	CPL	A
0C30    6003          3885     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3886      
0C32    855F5E        3887     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3888     
                      3889     CHECK_VOLTAGE_EXIT: 
0C35    8825          3890     MOV CURRENT_PWM_LIMITED , R0 
                      3891     ENDIF
                      3892     	; Set adc mux for next conversion
0C37    C3            3893     	CLR	C
0C38    E56C          3894     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C3A    B40703        3895     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3896     
                      3897     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C3D    75BB10        3897+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3898     
                      3899     CHECK_VOLTAGE_RET: 
0C40    22            3900     	RET
                      3901     
                      3902     
                      3903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3904     ;
                      3905     ; Set startup PWM routine
                      3906     ;
                      3907     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3908     ;
                      3909     ; Used for pwm control during startup
                      3910     ;
                      3911     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3912     SET_STARTUP_PWM: 	
                      3913     	; Set pwm values according to startup phase flags
0C41    306102        3914     JNB FLAGS1 . 1 , ( $+5 ) 
0C44    7832          3915     MOV R0 , # 50 
0C46    306202        3916     JNB FLAGS1 . 2 , ( $+5 ) 
0C49    7878          3917     MOV R0 , # 120 
                      3918     
                      3919     	; Update pwm variables if any startup phase flag is set
0C4B    E52C          3920     	MOV	A, FLAGS1
0C4D    5406          3921     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C4F    601F          3922     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3923     
                      3924     	; Adjust startup power
0C51    E8            3925     MOV A , R0 
0C52    79A2          3926     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C54    87F0          3927     MOV B , @ R1 
0C56    A4            3928     	MUL	AB
0C57    C5F0          3929     	XCH	A, B
0C59    A2F7          3930     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C5B    33            3931     	RLC	A
0C5C    F8            3932     MOV R0 , A 
0C5D    C3            3933     	CLR	C
0C5E    E8            3934     MOV A , R0 
0C5F    955E          3935     	SUBB	A, PWM_LIMIT	
0C61    4002          3936     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3937     
0C63    A85E          3938     MOV R0 , PWM_LIMIT 
                      3939     
                      3940     STARTUP_PWM_SET_PWM: 
                      3941     	; Set pwm variables
0C65    8822          3942     MOV REQUESTED_PWM , R0 
0C67    8824          3943     MOV CURRENT_PWM , R0 
0C69    8825          3944     MOV CURRENT_PWM_LIMITED , R0 
0C6B    306102        3945     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3946     
0C6E    8860          3947     MOV PWM_SPOOLUP_BEG , R0 
                      3948     
                      3949     STARTUP_PWM_EXIT: 
0C70    22            3950     	RET
                      3951     
                      3952     
                      3953     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3954     ;
                      3955     ; Initialize all timings routine
                      3956     ;
                      3957     ; No assumptions
                      3958     ;
                      3959     ; Part of initialization before motor start
                      3960     ;
                      3961     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3962     INITIALIZE_ALL_TIMINGS:  
                      3963     	; Load programmed startup rpm
0C71    788F          3964     MOV R0 , # PGM_STARTUP_RPM 
0C73    E6            3965     MOV A , @ R0 
0C74    FF            3966     MOV R7 , A 
                      3967     	; Check startup rpm setting and set step accordingly
0C75    C3            3968     	CLR	C
0C76    EF            3969     MOV A , R7 
0C77    9405          3970     	SUBB	A, #5
0C79    5018          3971     	JNC	STEPPER_STEP_HIGH
0C7B    C3            3972     	CLR	C
0C7C    EF            3973     MOV A , R7 
0C7D    9404          3974     	SUBB	A, #4
0C7F    5020          3975     	JNC	STEPPER_STEP_MED_HIGH
0C81    C3            3976     	CLR	C
0C82    EF            3977     MOV A , R7 
0C83    9403          3978     	SUBB	A, #3
0C85    5028          3979     	JNC	STEPPER_STEP_MED
0C87    C3            3980     	CLR	C
0C88    EF            3981     MOV A , R7 
0C89    9402          3982     	SUBB	A, #2
0C8B    5030          3983     	JNC	STEPPER_STEP_MED_LOW
0C8D    C3            3984     	CLR	C
0C8E    EF            3985     MOV A , R7 
0C8F    9401          3986     	SUBB	A, #1
0C91    5038          3987     	JNC	STEPPER_STEP_LOW
                      3988     
                      3989     STEPPER_STEP_HIGH: 
0C93    7533A0        3990     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C96    75340F        3991     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C99    75353C        3992     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C9C    753605        3993     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C9F    81D7          3994     	AJMP	STEPPER_STEP_SET
                      3995     STEPPER_STEP_MED_HIGH: 
0CA1    7533C0        3996     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0CA4    753412        3997     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0CA7    753540        3998     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0CAA    753606        3999     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0CAD    81D7          4000     	AJMP	STEPPER_STEP_SET
                      4001     STEPPER_STEP_MED: 
0CAF    753370        4002     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0CB2    753417        4003     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0CB5    7535D0        4004     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0CB8    753607        4005     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0CBB    81D7          4006     	AJMP	STEPPER_STEP_SET
                      4007     STEPPER_STEP_MED_LOW: 
0CBD    75334C        4008     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0CC0    75341D        4009     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0CC3    7535C4        4010     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0CC6    753609        4011     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CC9    81D7          4012     	AJMP	STEPPER_STEP_SET
                      4013     STEPPER_STEP_LOW: 
0CCB    753328        4014     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CCE    753423        4015     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CD1    7535B8        4016     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CD4    75360B        4017     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      4018     
                      4019     STEPPER_STEP_SET: 
0CD7    853350        4020     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CDA    853451        4021     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CDD    753C00        4022     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CE0    753D08        4023     	MOV	COMM_PERIOD4X_H, #08H
0CE3    22            4024     	RET
                      4025     
                      4026     
                      4027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4028     ;
                      4029     ; Calculate next commutation timing routine
                      4030     ;
                      4031     ; No assumptions
                      4032     ;
                      4033     ; Called immediately after each commutation
                      4034     ; Also sets up timer 3 to wait advance timing
                      4035     ; Two entry points are used
                      4036     ;
                      4037     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4038     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CE4    A850          4039     MOV R0 , WT_STEPPER_STEP_L 
0CE6    A951          4040     MOV R1 , WT_STEPPER_STEP_H 
0CE8    020CEF        4041     	JMP	READ_TIMER
                      4042     
                      4043     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CEB    A84A          4044     MOV R0 , WT_ADVANCE_L 
0CED    A94B          4045     MOV R1 , WT_ADVANCE_H 
                      4046     READ_TIMER: 
                      4047     	; Set up next wait
0CEF    759100        4048     	MOV	TMR3CN, #00H		; Timer3 disabled
0CF2    C3            4049     	CLR	C
0CF3    E4            4050     	CLR	A
0CF4    98            4051     SUBB A , R0 
0CF5    F594          4052     	MOV	TMR3L, A
0CF7    E4            4053     	CLR	A
0CF8    99            4054     SUBB A , R1 
0CF9    F595          4055     	MOV	TMR3H, A
0CFB    759104        4056     	MOV	TMR3CN, #04H		; Timer3 enabled
0CFE    D258          4057     SETB FLAGS0 . 0 
                      4058     	; Read commutation time
0D00    75C820        4059     	MOV	TMR2CN, #20H		; Timer2 disabled
0D03    A8CC          4060     MOV R0 , TMR2L 
0D05    A9CD          4061     MOV R1 , TMR2H 
0D07    75C824        4062     	MOV	TMR2CN, #24H		; Timer2 enabled
                      4063     	; Calculate this commutation time
0D0A    AA3A          4064     MOV R2 , PREV_COMM_L 
0D0C    AB3B          4065     MOV R3 , PREV_COMM_H 
0D0E    883A          4066     MOV PREV_COMM_L , R0 
0D10    893B          4067     MOV PREV_COMM_H , R1 
0D12    C3            4068     	CLR	C
0D13    E8            4069     MOV A , R0 
0D14    9A            4070     SUBB A , R2 
0D15    F8            4071     MOV R0 , A 
0D16    E9            4072     MOV A , R1 
0D17    9B            4073     SUBB A , R3 
0D18    F9            4074     MOV R1 , A 
                      4075     	; Calculate next zero cross scan timeout 
0D19    AA3C          4076     MOV R2 , COMM_PERIOD4X_L 
0D1B    AB3D          4077     MOV R3 , COMM_PERIOD4X_H 
0D1D    C3            4078     	CLR	C
0D1E    EB            4079     MOV A , R3 
0D1F    13            4080     	RRC	A					; Divide by 2
0D20    FD            4081     MOV R5 , A 
0D21    EA            4082     MOV A , R2 
0D22    13            4083     	RRC	A
0D23    FC            4084     MOV R4 , A 
0D24    C3            4085     	CLR	C
0D25    ED            4086     MOV A , R5 
0D26    13            4087     	RRC	A					; Divide by 2 again
0D27    FD            4088     MOV R5 , A 
0D28    EC            4089     MOV A , R4 
0D29    13            4090     	RRC	A
0D2A    FC            4091     MOV R4 , A 
0D2B    C3            4092     	CLR	C
0D2C    EA            4093     MOV A , R2 
0D2D    9C            4094     SUBB A , R4 
0D2E    FA            4095     MOV R2 , A 
0D2F    EB            4096     MOV A , R3 
0D30    9D            4097     SUBB A , R5 
0D31    FB            4098     MOV R3 , A 
                      4099     
0D32    EA            4100     MOV A , R2 
0D33    28            4101     ADD A , R0 
0D34    FA            4102     MOV R2 , A 
0D35    EB            4103     MOV A , R3 
0D36    39            4104     ADDC A , R1 
0D37    FB            4105     MOV R3 , A 
0D38    8A3C          4106     MOV COMM_PERIOD4X_L , R2 
0D3A    8B3D          4107     MOV COMM_PERIOD4X_H , R3 
0D3C    4001          4108     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4109     
0D3E    22            4110     	RET
                      4111     
                      4112     CALC_NEXT_COMM_SLOW: 
0D3F    753CFF        4113     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D42    753DFF        4114     	MOV	COMM_PERIOD4X_H, #0FFH
0D45    22            4115     	RET
                      4116     
                      4117     
                      4118     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4119     ;
                      4120     ; Setup zero cross scan wait
                      4121     ;
                      4122     ; No assumptions
                      4123     ;
                      4124     ; Sets up timer 3 to wait the zero cross scan wait time
                      4125     ;
                      4126     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4127     SETUP_ZC_SCAN_WAIT: 
0D46    759100        4128     	MOV	TMR3CN, #00H		; Timer3 disabled
0D49    C3            4129     	CLR	C
0D4A    E4            4130     	CLR	A
0D4B    954C          4131     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D4D    F594          4132     	MOV	TMR3L, A
0D4F    E4            4133     	CLR	A
0D50    954D          4134     	SUBB	A, WT_ZC_SCAN_H		
0D52    F595          4135     	MOV	TMR3H, A
0D54    759104        4136     	MOV	TMR3CN, #04H		; Timer3 enabled
0D57    D258          4137     SETB FLAGS0 . 0 
0D59    22            4138     	RET
                      4139     
                      4140     
                      4141     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4142     ;
                      4143     ; Wait advance timing routine
                      4144     ;
                      4145     ; No assumptions
                      4146     ;
                      4147     ; Waits for the advance timing to elapse, waits one zero cross
                      4148     ; wait and sets up the next zero cross wait
                      4149     ;
                      4150     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4151     WAIT_ADVANCE_TIMING: 	
0D5A    7F01          4152     MOV R7 , # 1 
0D5C    789C          4153     MOV R0 , # PGM_DEMAG_COMP 
0D5E    E6            4154     MOV A , @ R0 
0D5F    14            4155     	DEC	A
0D60    6002          4156     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4157     
0D62    7F02          4158     MOV R7 , # 2 
                      4159     
                      4160     WAIT_ADVANCE_TIMING_WAIT: 
0D64    305802        4161     JNB FLAGS0 . 0 , ( $+5 ) 
0D67    A164          4162     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4163     
0D69    B146          4164     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D6B    DFF7          4165     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4166     
0D6D    22            4167     	RET
                      4168     
                      4169     
                      4170     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4171     ;
                      4172     ; Calculate new wait times routine
                      4173     ;
                      4174     ; No assumptions
                      4175     ;
                      4176     ; Calculates new wait times
                      4177     ;
                      4178     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4179     CALC_NEW_WAIT_TIMES: 	
                      4180     	; Load programmed commutation timing
0D6E    7892          4181     MOV R0 , # PGM_COMM_TIMING 
0D70    E6            4182     MOV A , @ R0 
0D71    FF            4183     MOV R7 , A 
0D72    7E14          4184     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4185     IF MODE == 2
0D74    A83D          4186     MOV R0 , COMM_PERIOD4X_H 
0D76    C3            4187     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D77    E8            4188     MOV A , R0 
0D78    9404          4189     	SUBB	A, #4
0D7A    4002          4190     	JC	CALC_NEW_WAIT_RED_SET
                      4191     
0D7C    7804          4192     MOV R0 , # 4 
                      4193     
                      4194     CALC_NEW_WAIT_RED_SET: 
0D7E    C3            4195     	CLR	C
0D7F    E8            4196     MOV A , R0 
0D80    33            4197     	RLC	A
0D81    F8            4198     MOV R0 , A 
0D82    C3            4199     	CLR	C
0D83    EE            4200     MOV A , R6 
0D84    98            4201     SUBB A , R0 
0D85    FE            4202     MOV R6 , A 
                      4203     ENDIF
0D86    306304        4204     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4205     
0D89    7F03          4206     MOV R7 , # 3 
0D8B    7E00          4207     MOV R6 , # 0 
                      4208     
                      4209     CALC_NEW_WAIT_DIR_START_SET: 
                      4210     	; Load current commutation timing
0D8D    A93D          4211     MOV R1 , COMM_PERIOD4X_H 
0D8F    A83C          4212     MOV R0 , COMM_PERIOD4X_L 
0D91    7A04          4213     MOV R2 , # 4 
                      4214     DIVIDE_WAIT_TIMES: 
0D93    C3            4215     	CLR	C
0D94    E9            4216     MOV A , R1 
0D95    13            4217     	RRC	A					; Divide by 2
0D96    F9            4218     MOV R1 , A 
0D97    E8            4219     MOV A , R0 
0D98    13            4220     	RRC	A
0D99    F8            4221     MOV R0 , A 
0D9A    DAF7          4222     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4223     
0D9C    C3            4224     	CLR	C
0D9D    E8            4225     MOV A , R0 
0D9E    9E            4226     SUBB A , R6 
0D9F    F8            4227     MOV R0 , A 
0DA0    E9            4228     MOV A , R1 
0DA1    9400          4229     	SUBB	A, #0
0DA3    F9            4230     MOV R1 , A 
0DA4    4009          4231     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4232     
0DA6    C3            4233     	CLR	C
0DA7    E8            4234     MOV A , R0 
0DA8    9402          4235     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0DAA    E9            4236     MOV A , R1 
0DAB    9400          4237     	SUBB	A, #0
0DAD    5004          4238     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4239     
                      4240     LOAD_MIN_TIME: 
0DAF    7802          4241     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0DB1    E4            4242     	CLR	A
0DB2    F9            4243     MOV R1 , A 
                      4244     
                      4245     ADJUST_TIMING: 
0DB3    E9            4246     MOV A , R1 
0DB4    FB            4247     MOV R3 , A 
0DB5    E8            4248     MOV A , R0 
0DB6    FA            4249     MOV R2 , A 
0DB7    C3            4250     	CLR	C
0DB8    E9            4251     MOV A , R1 
0DB9    13            4252     	RRC	A					; Divide by 2
0DBA    FD            4253     MOV R5 , A 
0DBB    E8            4254     MOV A , R0 
0DBC    13            4255     	RRC	A
0DBD    FC            4256     MOV R4 , A 
0DBE    C3            4257     	CLR	C
0DBF    EF            4258     MOV A , R7 
0DC0    9403          4259     	SUBB	A, #3				; Is timing normal?
0DC2    602E          4260     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4261     
0DC4    EF            4262     MOV A , R7 
0DC5    20E00D        4263     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4264     
0DC8    E8            4265     MOV A , R0 
0DC9    2C            4266     ADD A , R4 
0DCA    F8            4267     MOV R0 , A 
0DCB    E9            4268     MOV A , R1 
0DCC    3D            4269     ADDC A , R5 
0DCD    F9            4270     MOV R1 , A 
0DCE    EC            4271     MOV A , R4 
0DCF    FA            4272     MOV R2 , A 
0DD0    ED            4273     MOV A , R5 
0DD1    FB            4274     MOV R3 , A 
0DD2    020DDF        4275     	JMP	STORE_TIMES_UP_OR_DOWN
                      4276     
                      4277     ADJUST_TIMING_TWO_STEPS: 
0DD5    E8            4278     MOV A , R0 
0DD6    28            4279     ADD A , R0 
0DD7    F8            4280     MOV R0 , A 
0DD8    E9            4281     MOV A , R1 
0DD9    39            4282     ADDC A , R1 
0DDA    F9            4283     MOV R1 , A 
0DDB    7A02          4284     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DDD    E4            4285     	CLR	A
0DDE    FB            4286     MOV R3 , A 
                      4287     
                      4288     STORE_TIMES_UP_OR_DOWN: 
0DDF    C3            4289     	CLR	C
0DE0    EF            4290     MOV A , R7 
0DE1    9403          4291     	SUBB	A, #3				; Is timing higher than normal?
0DE3    400D          4292     	JC	STORE_TIMES_DECREASE	; No - branch
                      4293     
                      4294     STORE_TIMES_INCREASE: 
0DE5    8A4E          4295     MOV WT_COMM_L , R2 
0DE7    8B4F          4296     MOV WT_COMM_H , R3 
0DE9    884A          4297     MOV WT_ADVANCE_L , R0 
0DEB    894B          4298     MOV WT_ADVANCE_H , R1 
0DED    8C4C          4299     MOV WT_ZC_SCAN_L , R4 
0DEF    8D4D          4300     MOV WT_ZC_SCAN_H , R5 
0DF1    22            4301     	RET
                      4302     
                      4303     STORE_TIMES_DECREASE: 
0DF2    884E          4304     MOV WT_COMM_L , R0 
0DF4    894F          4305     MOV WT_COMM_H , R1 
0DF6    8A4A          4306     MOV WT_ADVANCE_L , R2 
0DF8    8B4B          4307     MOV WT_ADVANCE_H , R3 
0DFA    8C4C          4308     MOV WT_ZC_SCAN_L , R4 
0DFC    8D4D          4309     MOV WT_ZC_SCAN_H , R5 
0DFE    22            4310     	RET
                      4311     
                      4312     
                      4313     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4314     ;
                      4315     ; Wait before zero cross scan routine
                      4316     ;
                      4317     ; No assumptions
                      4318     ;
                      4319     ; Waits for the zero cross scan wait time to elapse
                      4320     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4321     ;
                      4322     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4323     WAIT_BEFORE_ZC_SCAN: 	
0DFF    305802        4324     JNB FLAGS0 . 0 , ( $+5 ) 
0E02    A1FF          4325     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4326     
0E04    759100        4327     	MOV	TMR3CN, #00H		; Timer3 disabled
0E07    C3            4328     	CLR	C
0E08    E4            4329     	CLR	A
0E09    953C          4330     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0E0B    F594          4331     	MOV	TMR3L, A
0E0D    E4            4332     	CLR	A
0E0E    953D          4333     	SUBB	A, COMM_PERIOD4X_H		
0E10    F595          4334     	MOV	TMR3H, A
0E12    759104        4335     	MOV	TMR3CN, #04H		; Timer3 enabled
0E15    D258          4336     SETB FLAGS0 . 0 
0E17    22            4337     	RET
                      4338     
                      4339     
                      4340     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4341     ;
                      4342     ; Wait for comparator to go low/high routines
                      4343     ;
                      4344     ; No assumptions
                      4345     ;
                      4346     ; Waits for the zero cross scan wait time to elapse
                      4347     ; Then scans for comparator going low/high
                      4348     ;
                      4349     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4350     WAIT_FOR_COMP_OUT_LOW: 
0E18    753F00        4351     	MOV	COMP_WAIT_READS, #0
0E1B    752000        4352     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E1E    020E27        4353     	JMP	WAIT_FOR_COMP_OUT_START
                      4354     
                      4355     WAIT_FOR_COMP_OUT_HIGH: 
0E21    753F00        4356     	MOV	COMP_WAIT_READS, #0
0E24    752040        4357     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4358     
                      4359     WAIT_FOR_COMP_OUT_START: 
0E27    D2AF          4360     	SETB	EA						; Enable interrupts
0E29    053F          4361     	INC	COMP_WAIT_READS
0E2B    205801        4362     JB FLAGS0 . 0 , ( $+4 ) 
0E2E    22            4363     	RET							; Yes - return
                      4364     
                      4365     	; Set default comparator response times
0E2F    759D00        4366     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4367     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4370     	; Select number of comparator readings based upon current rotation speed
0E32    E53D          4371     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E34    C3            4372     	CLR	C
0E35    13            4373     	RRC	A						; Divide by 4
0E36    C3            4374     	CLR	C
0E37    13            4375     	RRC	A
0E38    F8            4376     MOV R0 , A 
0E39    08            4377     INC R0 
0E3A    6030          4378     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4379     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E3C    306A06        4380     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4381     
0E3F    C3            4382     	CLR	C
0E40    13            4383     	RRC	A						; Divide by 4 again
0E41    C3            4384     	CLR	C
0E42    13            4385     	RRC	A
0E43    F8            4386     MOV R0 , A 
0E44    08            4387     INC R0 
                      4388     
                      4389     COMP_WAIT_SET_MAX_READINGS: 
0E45    C3            4390     	CLR	C
0E46    E8            4391     MOV A , R0 
0E47    940A          4392     	SUBB	A, #10
0E49    4002          4393     	JC	($+4)
                      4394     
0E4B    780A          4395     MOV R0 , # 10 
                      4396     
0E4D    306D08        4397     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4398     
0E50    C3            4399     	CLR	C
0E51    E8            4400     MOV A , R0 
0E52    9404          4401     	SUBB	A, #4
0E54    4002          4402     	JC	($+4)
                      4403     
0E56    7804          4404     MOV R0 , # 4 
                      4405     
                      4406     COMP_WAIT_SET_RESPONSE_TIME: 
0E58    C3            4407     	CLR	C
0E59    E53D          4408     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E5B    9408          4409     	SUBB	A, #8
0E5D    400D          4410     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4411     
0E5F    759D02        4412     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4413     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E62    C3            4416     	CLR	C
0E63    E53D          4417     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E65    9410          4418     	SUBB	A, #16
0E67    4003          4419     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4420     
0E69    759D03        4421     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4422     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4425     
                      4426     COMP_WAIT_ON_COMP_ABLE: 
0E6C    205803        4427     JB FLAGS0 . 0 , ( $+6 ) 
0E6F    D2AF          4428     	SETB	EA							; Enable interrupts
0E71    22            4429     	RET								; Yes - return
                      4430     
0E72    791E          4431     MOV R1 , # 30 
0E74    206D02        4432     JB FLAGS2 . 5 , ( $+5 ) 
0E77    790A          4433     MOV R1 , # 10 
0E79    D2AF          4434     	SETB	EA							; Enable interrupts
0E7B    00            4435     	NOP								; Allocate only just enough time to capture interrupt
0E7C    00            4436     	NOP
0E7D    C2AF          4437     	CLR	EA							; Disable interrupts
0E7F    205A0A        4438     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4439     
0E82    793C          4440     MOV R1 , # 60 
0E84    206D02        4441     JB FLAGS2 . 5 , ( $+5 ) 
0E87    7914          4442     MOV R1 , # 20 
0E89    3066E0        4443     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4444     
                      4445     PWM_WAIT_STARTUP: 						
0E8C    306302        4446     JNB FLAGS1 . 3 , PWM_WAIT 
                      4447     
0E8F    7978          4448     MOV R1 , # 120 
                      4449     PWM_WAIT: 						
0E91    C3            4450     	CLR	C
0E92    E58B          4451     	MOV	A, TL1
0E94    99            4452     SUBB A , R1 
                      4453     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E95    40D5          4458     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4459     ENDIF
                      4460     
                      4461     COMP_READ: 
                      4462     	READ_COMP_OUT 					; Read comparator output
0E97    E59B          4462+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E99    F4            4463     	CPL	A
0E9A    5440          4464     	ANL	A, #40H
0E9C    B52002        4465     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4466     
0E9F    C127          4467     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4468     
0EA1    D8C9          4469     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4470     
0EA3    D2AF          4471     	SETB	EA						; Enable interrupts
0EA5    22            4472     	RET							
                      4473     
                      4474     
                      4475     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4476     ;
                      4477     ; Evaluate comparator integrity
                      4478     ;
                      4479     ; No assumptions
                      4480     ;
                      4481     ; Checks comparator signal behaviour versus expected behaviour
                      4482     ;
                      4483     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4484     EVALUATE_COMPARATOR_INTEGRITY: 
0EA6    C25B          4485     CLR FLAGS0 . 3 
                      4486     	; Check if demag compensation is enabled
0EA8    789C          4487     MOV R0 , # PGM_DEMAG_COMP 
0EAA    E6            4488     MOV A , @ R0 
0EAB    14            4489     	DEC	A
0EAC    600A          4490     	JZ	EVAL_COMP_NO_DEMAG
                      4491     
                      4492     	; Check if a demag situation has occurred
0EAE    E53F          4493     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0EB0    14            4494     	DEC	A
0EB1    7005          4495     	JNZ	EVAL_COMP_NO_DEMAG
                      4496     
0EB3    206302        4497     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4498     
0EB6    D25B          4499     SETB FLAGS0 . 3 
                      4500     
                      4501     EVAL_COMP_NO_DEMAG: 
0EB8    30630B        4502     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4503     
0EBB    0538          4504     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0EBD    205810        4505     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4506     
0EC0    753800        4507     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0EC3    020ED0        4508     	JMP	EVAL_COMP_EXIT
                      4509     
                      4510     EVAL_COMP_CHECK_TIMEOUT: 
0EC6    205807        4511     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EC9    1581          4512     	DEC	SP							; Routine exit without "ret" command
0ECB    1581          4513     	DEC	SP
0ECD    021778        4514     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4515     
                      4516     EVAL_COMP_EXIT: 
0ED0    22            4517     	RET
                      4518     
                      4519     
                      4520     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4521     ;
                      4522     ; Setup commutation timing routine
                      4523     ;
                      4524     ; No assumptions
                      4525     ;
                      4526     ; Sets up and starts wait from commutation to zero cross
                      4527     ;
                      4528     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4529     SETUP_COMM_WAIT:  
0ED1    759100        4530     	MOV	TMR3CN, #00H		; Timer3 disabled
0ED4    C3            4531     	CLR	C
0ED5    E4            4532     	CLR	A
0ED6    954E          4533     	SUBB	A, WT_COMM_L		; Set wait commutation value
0ED8    F594          4534     	MOV	TMR3L, A
0EDA    E4            4535     	CLR	A
0EDB    954F          4536     	SUBB	A, WT_COMM_H		
0EDD    F595          4537     	MOV	TMR3H, A
0EDF    759104        4538     	MOV	TMR3CN, #04H		; Timer3 enabled
0EE2    D258          4539     SETB FLAGS0 . 0 
0EE4    22            4540     	RET
                      4541     
                      4542     
                      4543     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4544     ;
                      4545     ; Wait for commutation routine
                      4546     ;
                      4547     ; No assumptions
                      4548     ;
                      4549     ; Waits from zero cross to commutation 
                      4550     ;
                      4551     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4552     WAIT_FOR_COMM:  
                      4553     	; Increment or reset consecutive count
0EE5    0539          4554     	INC	DEMAG_CONSECUTIVE_CNT
0EE7    205B03        4555     JB FLAGS0 . 3 , ( $+6 ) 
                      4556     
0EEA    753900        4557     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4558     
                      4559     	; Check if a demag situation has occurred
0EED    305B23        4560     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4561     
                      4562     	; Load programmed demag compensation
0EF0    78A3          4563     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0EF2    E6            4564     MOV A , @ R0 
0EF3    FF            4565     MOV R7 , A 
                      4566     
                      4567     	; Check for power off
0EF4    BF0108        4568     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4569     
0EF7    D25C          4570     SETB FLAGS0 . 4 
                      4571     	ALL_NFETS_OFF
0EF9    C292          4571+1   CLR P1 . 2 
0EFB    C296          4571+1   CLR P1 . 6 
0EFD    C295          4571+1   CLR P1 . 5 
                      4572     
                      4573     	; Wait a blind wait
                      4574     WAIT_FOR_COMM_BLIND: 
0EFF    B146          4575     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4576     WAIT_DEMAG_DEFAULT_ZC: 	
0F01    305802        4577     JNB FLAGS0 . 0 , ( $+5 ) 
0F04    E101          4578     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4579     
                      4580     	; Check for power off
0F06    BF0208        4581     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4582     
0F09    D25C          4583     SETB FLAGS0 . 4 
                      4584     	ALL_NFETS_OFF
0F0B    C292          4584+1   CLR P1 . 2 
0F0D    C296          4584+1   CLR P1 . 6 
0F0F    C295          4584+1   CLR P1 . 5 
                      4585     
                      4586     WAIT_FOR_COMM_SETUP: 
0F11    D1D1          4587     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4588     WAIT_FOR_COMM_WAIT: 
0F13    305802        4589     JNB FLAGS0 . 0 , ( $+5 ) 
0F16    E113          4590     	AJMP	WAIT_FOR_COMM_WAIT					
                      4591     
0F18    22            4592     	RET
                      4593     
                      4594     
                      4595     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4596     ;
                      4597     ; Commutation routines
                      4598     ;
                      4599     ; No assumptions
                      4600     ;
                      4601     ; Performs commutation switching 
                      4602     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4603     ;
                      4604     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4605     COMM1COMM2: 	
0F19    C2AF          4606     	CLR 	EA					; Disable all interrupts
                      4607     	BPFET_OFF					; Bp off
0F1B    C294          4607+1   CLR P1 . 4 
0F1D    206A03        4608     JB FLAGS2 . 2 , COMM12_DAMP 
0F20    020F38        4609     	JMP	COMM12_NONDAMP
                      4610     COMM12_DAMP: 
                      4611     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4615     IF DAMPED_MODE_ENABLE == 1
0F23    900347        4616     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4617     ENDIF
0F26    30650F        4618     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4619     	CPFET_OFF				
0F29    207502        4619+1   JB FLAGS3 . 5 , ( $+5 ) 
0F2C    C297          4619+1   CLR P1 . 7 
0F2E    307502        4619+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F31    C293          4619+1   CLR P1 . 3 
0F33    7406          4620     MOV A , # 6 
0F35    D5E0FD        4621     	DJNZ ACC,	$
                      4622     COMM12_NONDAMP: 
                      4623     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4631     	APFET_ON					; Ap on
0F38    207502        4631+1   JB FLAGS3 . 5 , ( $+5 ) 
0F3B    D293          4631+1   SETB P1 . 3 
0F3D    307502        4631+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F40    D297          4631+1   SETB P1 . 7 
                      4632     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F42    759F80        4632+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F45    753E02        4633     	MOV	COMM_PHASE, #2
0F48    0210A3        4634     	JMP	COMM_EXIT
                      4635     
                      4636     COMM2COMM3: 	
0F4B    C2AF          4637     	CLR 	EA					; Disable all interrupts
0F4D    206A03        4638     JB FLAGS2 . 2 , COMM23_DAMP 
0F50    020F6D        4639     	JMP	COMM23_NONDAMP
                      4640     COMM23_DAMP: 
                      4641     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4644     IF DAMPED_MODE_ENABLE == 1
0F53    9002FE        4645     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4646     ENDIF
0F56    306517        4647     JNB FLAGS1 . 5 , COMM23_NFET 
                      4648     	BPFET_OFF				
0F59    C294          4648+1   CLR P1 . 4 
                      4649     	CPFET_OFF				
0F5B    207502        4649+1   JB FLAGS3 . 5 , ( $+5 ) 
0F5E    C297          4649+1   CLR P1 . 7 
0F60    307502        4649+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F63    C293          4649+1   CLR P1 . 3 
0F65    7406          4650     MOV A , # 6 
0F67    D5E0FD        4651     	DJNZ ACC,	$
0F6A    020F70        4652     	JMP	COMM23_NFET
                      4653     COMM23_NONDAMP: 
0F6D    9001E1        4654     	MOV	DPTR, #PWM_BFET_ON	
                      4655     COMM23_NFET: 
                      4656     	CNFET_OFF					; Cn off
0F70    207502        4656+1   JB FLAGS3 . 5 , ( $+5 ) 
0F73    C296          4656+1   CLR P1 . 6 
0F75    307502        4656+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F78    C292          4656+1   CLR P1 . 2 
0F7A    305A06        4657     JNB FLAGS0 . 2 , COMM23_CP 
                      4658     	BNFET_ON					; Yes - Bn on
0F7D    E525          4658+1   MOV A , CURRENT_PWM_LIMITED 
0F7F    6002          4658+1   JZ ( $+4 ) 
0F81    D295          4658+1   SETB P1 . 5 
                      4659     COMM23_CP: 
                      4660     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F83    207503        4660+1   JB FLAGS3 . 5 , ( $+6 ) 
0F86    759F89        4660+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F89    307503        4660+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F8C    759F81        4660+1   MOV CPT0MX , # 81H 
0F8F    753E03        4661     	MOV	COMM_PHASE, #3
0F92    0210A3        4662     	JMP	COMM_EXIT
                      4663     
                      4664     COMM3COMM4: 	
0F95    C2AF          4665     	CLR 	EA					; Disable all interrupts
                      4666     	APFET_OFF					; Ap off
0F97    207502        4666+1   JB FLAGS3 . 5 , ( $+5 ) 
0F9A    C293          4666+1   CLR P1 . 3 
0F9C    307502        4666+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F9F    C297          4666+1   CLR P1 . 7 
0FA1    206A03        4667     JB FLAGS2 . 2 , COMM34_DAMP 
0FA4    020FB4        4668     	JMP	COMM34_NONDAMP
                      4669     COMM34_DAMP: 
                      4670     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4674     IF DAMPED_MODE_ENABLE == 1
0FA7    9002BD        4675     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4676     ENDIF
0FAA    306507        4677     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4678     	BPFET_OFF				
0FAD    C294          4678+1   CLR P1 . 4 
0FAF    7406          4679     MOV A , # 6 
0FB1    D5E0FD        4680     	DJNZ ACC,	$
                      4681     COMM34_NONDAMP: 
                      4682     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4690     	CPFET_ON					; Cp on
0FB4    207502        4690+1   JB FLAGS3 . 5 , ( $+5 ) 
0FB7    D297          4690+1   SETB P1 . 7 
0FB9    307502        4690+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FBC    D293          4690+1   SETB P1 . 3 
                      4691     	SET_COMP_PHASE_A 			; Set comparator to phase A
0FBE    207503        4691+1   JB FLAGS3 . 5 , ( $+6 ) 
0FC1    759F81        4691+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FC4    307503        4691+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FC7    759F89        4691+1   MOV CPT0MX , # 89H 
0FCA    753E04        4692     	MOV	COMM_PHASE, #4
0FCD    0210A3        4693     	JMP	COMM_EXIT
                      4694     
                      4695     COMM4COMM5: 	
0FD0    C2AF          4696     	CLR 	EA					; Disable all interrupts
0FD2    206A03        4697     JB FLAGS2 . 2 , COMM45_DAMP 
0FD5    020FF2        4698     	JMP	COMM45_NONDAMP
                      4699     COMM45_DAMP: 
                      4700     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4703     IF DAMPED_MODE_ENABLE == 1
0FD8    90027C        4704     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4705     ENDIF
0FDB    306517        4706     JNB FLAGS1 . 5 , COMM45_NFET 
                      4707     	APFET_OFF				
0FDE    207502        4707+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE1    C293          4707+1   CLR P1 . 3 
0FE3    307502        4707+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FE6    C297          4707+1   CLR P1 . 7 
                      4708     	BPFET_OFF				
0FE8    C294          4708+1   CLR P1 . 4 
0FEA    7406          4709     MOV A , # 6 
0FEC    D5E0FD        4710     	DJNZ ACC,	$
0FEF    020FF5        4711     	JMP	COMM45_NFET
                      4712     COMM45_NONDAMP: 
0FF2    9001CF        4713     	MOV	DPTR, #PWM_AFET_ON
                      4714     COMM45_NFET: 
                      4715     	BNFET_OFF					; Bn off
0FF5    C295          4715+1   CLR P1 . 5 
0FF7    305A0E        4716     JNB FLAGS0 . 2 , COMM45_CP 
                      4717     	ANFET_ON					; Yes - An on
0FFA    E525          4717+1   MOV A , CURRENT_PWM_LIMITED 
0FFC    600A          4717+1   JZ ( $+12 ) 
0FFE    207502        4717+1   JB FLAGS3 . 5 , ( $+5 ) 
1001    D292          4717+1   SETB P1 . 2 
1003    307502        4717+1   JNB FLAGS3 . 5 , ( $+5 ) 
1006    D296          4717+1   SETB P1 . 6 
                      4718     COMM45_CP: 
                      4719     	SET_COMP_PHASE_B 			; Set comparator to phase B
1008    759F80        4719+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
100B    753E05        4720     	MOV	COMM_PHASE, #5
100E    0210A3        4721     	JMP	COMM_EXIT
                      4722     
                      4723     COMM5COMM6: 	
1011    C2AF          4724     	CLR 	EA					; Disable all interrupts
                      4725     	CPFET_OFF					; Cp off
1013    207502        4725+1   JB FLAGS3 . 5 , ( $+5 ) 
1016    C297          4725+1   CLR P1 . 7 
1018    307502        4725+1   JNB FLAGS3 . 5 , ( $+5 ) 
101B    C293          4725+1   CLR P1 . 3 
101D    206A03        4726     JB FLAGS2 . 2 , COMM56_DAMP 
1020    021038        4727     	JMP	COMM56_NONDAMP
                      4728     COMM56_DAMP: 
                      4729     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4733     IF DAMPED_MODE_ENABLE == 1
1023    900233        4734     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4735     ENDIF
1026    30650F        4736     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4737     	APFET_OFF				
1029    207502        4737+1   JB FLAGS3 . 5 , ( $+5 ) 
102C    C293          4737+1   CLR P1 . 3 
102E    307502        4737+1   JNB FLAGS3 . 5 , ( $+5 ) 
1031    C297          4737+1   CLR P1 . 7 
1033    7406          4738     MOV A , # 6 
1035    D5E0FD        4739     	DJNZ ACC,	$
                      4740     COMM56_NONDAMP: 
                      4741     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4749     	BPFET_ON					; Bp on
1038    D294          4749+1   SETB P1 . 4 
                      4750     	SET_COMP_PHASE_C 			; Set comparator to phase C
103A    207503        4750+1   JB FLAGS3 . 5 , ( $+6 ) 
103D    759F89        4750+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1040    307503        4750+1   JNB FLAGS3 . 5 , ( $+6 ) 
1043    759F81        4750+1   MOV CPT0MX , # 81H 
1046    753E06        4751     	MOV	COMM_PHASE, #6
1049    0210A3        4752     	JMP	COMM_EXIT
                      4753     
                      4754     COMM6COMM1: 	
104C    C2AF          4755     	CLR 	EA					; Disable all interrupts
104E    206A03        4756     JB FLAGS2 . 2 , COMM61_DAMP 
1051    021076        4757     	JMP	COMM61_NONDAMP
                      4758     COMM61_DAMP: 
                      4759     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4762     IF DAMPED_MODE_ENABLE == 1
1054    9003A0        4763     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4764     ENDIF
1057    30651F        4765     JNB FLAGS1 . 5 , COMM61_NFET 
                      4766     	APFET_OFF				
105A    207502        4766+1   JB FLAGS3 . 5 , ( $+5 ) 
105D    C293          4766+1   CLR P1 . 3 
105F    307502        4766+1   JNB FLAGS3 . 5 , ( $+5 ) 
1062    C297          4766+1   CLR P1 . 7 
                      4767     	CPFET_OFF				
1064    207502        4767+1   JB FLAGS3 . 5 , ( $+5 ) 
1067    C297          4767+1   CLR P1 . 7 
1069    307502        4767+1   JNB FLAGS3 . 5 , ( $+5 ) 
106C    C293          4767+1   CLR P1 . 3 
106E    7406          4768     MOV A , # 6 
1070    D5E0FD        4769     	DJNZ ACC,	$
1073    021079        4770     	JMP	COMM61_NFET
                      4771     COMM61_NONDAMP: 
1076    9001F3        4772     	MOV	DPTR, #PWM_CFET_ON
                      4773     COMM61_NFET: 
                      4774     	ANFET_OFF					; An off
1079    207502        4774+1   JB FLAGS3 . 5 , ( $+5 ) 
107C    C292          4774+1   CLR P1 . 2 
107E    307502        4774+1   JNB FLAGS3 . 5 , ( $+5 ) 
1081    C296          4774+1   CLR P1 . 6 
1083    305A0E        4775     JNB FLAGS0 . 2 , COMM61_CP 
                      4776     	CNFET_ON					; Yes - Cn on
1086    E525          4776+1   MOV A , CURRENT_PWM_LIMITED 
1088    600A          4776+1   JZ ( $+12 ) 
108A    207502        4776+1   JB FLAGS3 . 5 , ( $+5 ) 
108D    D296          4776+1   SETB P1 . 6 
108F    307502        4776+1   JNB FLAGS3 . 5 , ( $+5 ) 
1092    D292          4776+1   SETB P1 . 2 
                      4777     COMM61_CP: 
                      4778     	SET_COMP_PHASE_A 			; Set comparator to phase A
1094    207503        4778+1   JB FLAGS3 . 5 , ( $+6 ) 
1097    759F81        4778+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
109A    307503        4778+1   JNB FLAGS3 . 5 , ( $+6 ) 
109D    759F89        4778+1   MOV CPT0MX , # 89H 
10A0    753E01        4779     	MOV	COMM_PHASE, #1
                      4780     
                      4781     COMM_EXIT: 
10A3    D2AF          4782     	SETB	EA					; Enable all interrupts
10A5    789C          4783     MOV R0 , # PGM_DEMAG_COMP 
10A7    E6            4784     MOV A , @ R0 
10A8    C3            4785     	CLR	C
10A9    9402          4786     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
10AB    4007          4787     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4788     
10AD    C3            4789     	CLR	C
10AE    E539          4790     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
10B0    9403          4791     	SUBB	A, #3
10B2    5002          4792     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4793     
                      4794     COMM_RESTORE_POWER: 
10B4    C25C          4795     CLR FLAGS0 . 4 
                      4796     
                      4797     COMM_RETURN: 
10B6    22            4798     	RET
                      4799     
                      4800     
                      4801     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4802     ;
                      4803     ; Switch power off routine
                      4804     ;
                      4805     ; No assumptions
                      4806     ;
                      4807     ; Switches all fets off 
                      4808     ;
                      4809     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4810     SWITCH_POWER_OFF: 
10B7    9001CD        4811     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4812     	ALL_NFETS_OFF			; Turn off all nfets
10BA    C292          4812+1   CLR P1 . 2 
10BC    C296          4812+1   CLR P1 . 6 
10BE    C295          4812+1   CLR P1 . 5 
                      4813     	ALL_PFETS_OFF			; Turn off all pfets
10C0    C293          4813+1   CLR P1 . 3 
10C2    C297          4813+1   CLR P1 . 7 
10C4    C294          4813+1   CLR P1 . 4 
10C6    C25A          4814     CLR FLAGS0 . 2 
10C8    22            4815     	RET			
                      4816     
                      4817     
                      4818     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4819     ;
                      4820     ; Decrement stepper step routine
                      4821     ;
                      4822     ; No assumptions
                      4823     ;
                      4824     ; Decrements the stepper step 
                      4825     ;
                      4826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4827     DECREMENT_STEPPER_STEP: 
10C9    C3            4828     	CLR	C
10CA    E550          4829     	MOV	A, WT_STEPPER_STEP_L
10CC    9535          4830     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
10CE    E551          4831     	MOV	A, WT_STEPPER_STEP_H
10D0    9536          4832     	SUBB	A, STEPPER_STEP_END_H	
10D2    5001          4833     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
10D4    22            4834     	RET
                      4835     
                      4836     DECREMENT_STEP: 
                      4837     	; Load programmed startup acceleration
10D5    7890          4838     MOV R0 , # PGM_STARTUP_ACCEL 
10D7    E6            4839     MOV A , @ R0 
10D8    FF            4840     MOV R7 , A 
                      4841     	; Check acceleration setting and set step size accordingly
10D9    C3            4842     	CLR	C
10DA    EF            4843     MOV A , R7 
10DB    9405          4844     	SUBB	A, #5
10DD    5018          4845     	JNC	DEC_STEP_HIGH
10DF    C3            4846     	CLR	C
10E0    EF            4847     MOV A , R7 
10E1    9404          4848     	SUBB	A, #4
10E3    501B          4849     	JNC	DEC_STEP_MED_HIGH
10E5    C3            4850     	CLR	C
10E6    EF            4851     MOV A , R7 
10E7    9403          4852     	SUBB	A, #3
10E9    501E          4853     	JNC	DEC_STEP_MED
10EB    C3            4854     	CLR	C
10EC    EF            4855     MOV A , R7 
10ED    9402          4856     	SUBB	A, #2
10EF    5021          4857     	JNC	DEC_STEP_MED_LOW
10F1    C3            4858     	CLR	C
10F2    EF            4859     MOV A , R7 
10F3    9401          4860     	SUBB	A, #1
10F5    5024          4861     	JNC	DEC_STEP_LOW
                      4862     
                      4863     DEC_STEP_HIGH: 
10F7    C3            4864     	CLR	C
10F8    E550          4865     	MOV	A, WT_STEPPER_STEP_L
10FA    943C          4866     	SUBB	A, #LOW(30 SHL 1)		
10FC    F8            4867     MOV R0 , A 
10FD    021124        4868     	JMP	DECREMENT_STEP_EXIT
                      4869     DEC_STEP_MED_HIGH: 
1100    C3            4870     	CLR	C
1101    E550          4871     	MOV	A, WT_STEPPER_STEP_L
1103    9428          4872     	SUBB	A, #LOW(20 SHL 1)		
1105    F8            4873     MOV R0 , A 
1106    021124        4874     	JMP	DECREMENT_STEP_EXIT
                      4875     DEC_STEP_MED: 
1109    C3            4876     	CLR	C
110A    E550          4877     	MOV	A, WT_STEPPER_STEP_L
110C    941A          4878     	SUBB	A, #LOW(13 SHL 1)		
110E    F8            4879     MOV R0 , A 
110F    021124        4880     	JMP	DECREMENT_STEP_EXIT
                      4881     DEC_STEP_MED_LOW: 
1112    C3            4882     	CLR	C
1113    E550          4883     	MOV	A, WT_STEPPER_STEP_L
1115    9412          4884     	SUBB	A, #LOW(9 SHL 1)		
1117    F8            4885     MOV R0 , A 
1118    021124        4886     	JMP	DECREMENT_STEP_EXIT
                      4887     DEC_STEP_LOW: 
111B    C3            4888     	CLR	C
111C    E550          4889     	MOV	A, WT_STEPPER_STEP_L
111E    940A          4890     	SUBB	A, #LOW(5 SHL 1)		
1120    F8            4891     MOV R0 , A 
1121    021124        4892     	JMP	DECREMENT_STEP_EXIT
                      4893     
                      4894     DECREMENT_STEP_EXIT: 
1124    E551          4895     	MOV	A, WT_STEPPER_STEP_H
1126    9400          4896     	SUBB	A, #0		
1128    F9            4897     MOV R1 , A 
1129    8850          4898     MOV WT_STEPPER_STEP_L , R0 
112B    8951          4899     MOV WT_STEPPER_STEP_H , R1 
112D    22            4900     	RET
                      4901     
                      4902     
                      4903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4904     ;
                      4905     ; Stepper timer wait
                      4906     ;
                      4907     ; No assumptions
                      4908     ;
                      4909     ; Waits for the stepper step timer to elapse
                      4910     ;
                      4911     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4912     STEPPER_TIMER_WAIT: 
112E    305802        4913     JNB FLAGS0 . 0 , ( $+5 ) 
1131    212E          4914     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
1133    22            4915     	RET
                      4916     
                      4917     
                      4918     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4919     ;
                      4920     ; Set default parameters
                      4921     ;
                      4922     ; No assumptions
                      4923     ;
                      4924     ; Sets default programming parameters
                      4925     ;
                      4926     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4927     SET_DEFAULT_PARAMETERS: 
                      4928     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4989     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      5050     IF MODE == 2	; Multi
1134    7880          5051     MOV R0 , # PGM_GOV_P_GAIN 
1136    7609          5052     MOV @ R0 , # 9 
1138    08            5053     INC R0 
1139    7609          5054     MOV @ R0 , # 9 
113B    08            5055     INC R0 
113C    7604          5056     MOV @ R0 , # 4 
113E    08            5057     INC R0 
113F    7601          5058     MOV @ R0 , # 1 
1141    08            5059     INC R0 
1142    7603          5060     MOV @ R0 , # 3 
1144    08            5061     INC R0 
1145    76FF          5062     MOV @ R0 , # 0XFF 
1147    08            5063     INC R0 
1148    7609          5064     MOV @ R0 , # 9 
114A    08            5065     INC R0 
114B    7601          5066     MOV @ R0 , # 1 
114D    08            5067     INC R0 
114E    7601          5068     MOV @ R0 , # 1 
1150    08            5069     INC R0 
1151    7601          5070     MOV @ R0 , # 1 
                      5071     
1153    788C          5072     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1155    7600          5073     MOV @ R0 , # 0 
1157    08            5074     INC R0 
1158    76FF          5075     MOV @ R0 , # 0XFF 
115A    08            5076     INC R0 
115B    76FF          5077     MOV @ R0 , # 0XFF 
115D    08            5078     INC R0 
115E    7601          5079     MOV @ R0 , # 1 
1160    08            5080     INC R0 
1161    7605          5081     MOV @ R0 , # 5 
1163    08            5082     INC R0 
1164    76FF          5083     MOV @ R0 , # 0XFF 
1166    08            5084     INC R0 
1167    7603          5085     MOV @ R0 , # 3 
1169    08            5086     INC R0 
116A    7606          5087     MOV @ R0 , # 6 
116C    08            5088     INC R0 
116D    76FF          5089     MOV @ R0 , # 0XFF 
116F    08            5090     INC R0 
1170    7602          5091     MOV @ R0 , # 2 
1172    08            5092     INC R0 
1173    7603          5093     MOV @ R0 , # 3 
1175    08            5094     INC R0 
1176    76FA          5095     MOV @ R0 , # 250 
1178    08            5096     INC R0 
1179    7650          5097     MOV @ R0 , # 80 
117B    08            5098     INC R0 
117C    7650          5099     MOV @ R0 , # 80 
117E    08            5100     INC R0 
117F    7605          5101     MOV @ R0 , # 5 
1181    08            5102     INC R0 
1182    7601          5103     MOV @ R0 , # 1 
1184    08            5104     INC R0 
1185    7602          5105     MOV @ R0 , # 2 
1187    08            5106     INC R0 
1188    7600          5107     MOV @ R0 , # 0 
118A    08            5108     INC R0 
118B    767D          5109     MOV @ R0 , # 125 
                      5110     ENDIF
                      5111     
                      5112     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5113     ;
                      5114     ; 初始化变量 
                      5115     ; Skypup 2015.05.25
118D    E4            5116     	CLR	A
118E    F573          5117     	MOV	PREV_RCP,	A
1190    F575          5118     	MOV	NHOLD_L,	A
1192    F576          5119     	MOV	NHOLD_H,	A
1194    780F          5120     MOV R0 , # 15 
1196    8877          5121     MOV CSTATE , R0 
                      5122     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1198    22            5123     	RET
                      5124     
                      5125     
                      5126     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5127     ;
                      5128     ; Decode parameters
                      5129     ;
                      5130     ; No assumptions
                      5131     ;
                      5132     ; Decodes programming parameters
                      5133     ;
                      5134     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5135     DECODE_PARAMETERS: 
                      5136     	; Load programmed damping force
1199    7893          5137     MOV R0 , # PGM_DAMPING_FORCE 
119B    E6            5138     MOV A , @ R0 
119C    FF            5139     MOV R7 , A 
                      5140     	; Decode damping
119D    756609        5141     	MOV	DAMPING_PERIOD, #9		; Set default
11A0    756701        5142     	MOV	DAMPING_ON, #1
11A3    C3            5143     	CLR	C
11A4    BF0206        5144     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5145     
11A7    756605        5146     	MOV	DAMPING_PERIOD, #5
11AA    756701        5147     	MOV	DAMPING_ON, #1
                      5148     
                      5149     DECODE_DAMPING_3: 
11AD    C3            5150     	CLR	C
11AE    BF0306        5151     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5152     
11B1    756605        5153     	MOV	DAMPING_PERIOD, #5
11B4    756702        5154     	MOV	DAMPING_ON, #2
                      5155     
                      5156     DECODE_DAMPING_4: 
11B7    C3            5157     	CLR	C
11B8    BF0406        5158     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5159     
11BB    756605        5160     	MOV	DAMPING_PERIOD, #5
11BE    756703        5161     	MOV	DAMPING_ON, #3
                      5162     
                      5163     DECODE_DAMPING_5: 
11C1    C3            5164     	CLR	C
11C2    BF0506        5165     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5166     
11C5    756609        5167     	MOV	DAMPING_PERIOD, #9
11C8    756707        5168     	MOV	DAMPING_ON, #7
                      5169     
                      5170     DECODE_DAMPING_6: 
11CB    C3            5171     	CLR	C
11CC    BF0606        5172     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5173     
11CF    756600        5174     	MOV	DAMPING_PERIOD, #0
11D2    756700        5175     	MOV	DAMPING_ON, #0
                      5176     
                      5177     DECODE_DAMPING_DONE: 
                      5178     	; Load programmed pwm frequency
11D5    7887          5179     MOV R0 , # PGM_PWM_FREQ 
11D7    E6            5180     MOV A , @ R0 
11D8    FF            5181     MOV R7 , A 
                      5182     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5189     IF MODE >= 1	; Tail or multi
11D9    C26C          5190     CLR FLAGS2 . 4 
11DB    C3            5191     	CLR	C
11DC    BF0302        5192     CJNE R7 , # 3 , ( $+5 ) 
11DF    D26C          5193     SETB FLAGS2 . 4 
11E1    C26B          5194     CLR FLAGS2 . 3 
11E3    C3            5195     	CLR	C
11E4    BF0402        5196     CJNE R7 , # 4 , ( $+5 ) 
11E7    D26B          5197     SETB FLAGS2 . 3 
                      5198     ENDIF
11E9    C26A          5199     CLR FLAGS2 . 2 
11EB    7418          5200     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11ED    552D          5201     	ANL	A, FLAGS2					; Check if any damped mode is set
11EF    6002          5202     	JZ	($+4)
11F1    D26A          5203     SETB FLAGS2 . 2 
11F3    C265          5204     CLR FLAGS1 . 5 
11F5    6002          5205     	JZ	($+4)
11F7    D265          5206     SETB FLAGS1 . 5 
11F9    D266          5207     SETB FLAGS1 . 6 
11FB    6002          5208     	JZ	($+4)
11FD    C266          5209     CLR FLAGS1 . 6 
                      5210     	; Load programmed direction
11FF    7888          5211     MOV R0 , # PGM_DIRECTION 
                      5212     IF MODE >= 1	; Tail or multi
1201    E6            5213     MOV A , @ R0 
1202    C3            5214     	CLR	C
1203    9403          5215     	SUBB	A, #3
1205    6008          5216     	JZ	DECODE_PARAMS_DIR_SET
                      5217     ENDIF
                      5218     
1207    C275          5219     CLR FLAGS3 . 5 
1209    E6            5220     MOV A , @ R0 
120A    30E102        5221     	JNB	ACC.1, ($+5)
120D    D275          5222     SETB FLAGS3 . 5 
                      5223     DECODE_PARAMS_DIR_SET: 
120F    C276          5224     CLR FLAGS3 . 6 
1211    7889          5225     MOV R0 , # PGM_INPUT_POL 
1213    E6            5226     MOV A , @ R0 
1214    30E102        5227     	JNB	ACC.1, ($+5)
1217    D276          5228     SETB FLAGS3 . 6 
1219    C3            5229     	CLR	C
121A    EF            5230     MOV A , R7 
121B    9402          5231     	SUBB	A, #2
121D    6008          5232     	JZ	DECODE_PWM_FREQ_LOW
                      5233     
121F    758E01        5234     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1222    D26D          5235     SETB FLAGS2 . 5 
1224    02122C        5236     	JMP	DECODE_PWM_FREQ_END
                      5237     
                      5238     DECODE_PWM_FREQ_LOW: 
1227    758E00        5239     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
122A    C26D          5240     CLR FLAGS2 . 5 
                      5241     
                      5242     DECODE_PWM_FREQ_END: 
122C    22            5243     	RET
                      5244     
                      5245     
                      5246     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5247     ;
                      5248     ; Decode governor gain
                      5249     ;
                      5250     ; No assumptions
                      5251     ;
                      5252     ; Decodes governor gains
                      5253     ;
                      5254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5255     DECODE_GOVERNOR_GAINS: 
                      5256     	; Decode governor gains
122D    7880          5257     MOV R0 , # PGM_GOV_P_GAIN 
122F    E6            5258     MOV A , @ R0 
1230    14            5259     	DEC	A	
1231    900080        5260     	MOV	DPTR, #GOV_GAIN_TABLE
1234    93            5261     	MOVC A, @A+DPTR	
1235    789F          5262     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1237    F6            5263     MOV @ R0 , A 
1238    7881          5264     MOV R0 , # PGM_GOV_I_GAIN 
123A    E6            5265     MOV A , @ R0 
123B    14            5266     	DEC	A	
123C    900080        5267     	MOV	DPTR, #GOV_GAIN_TABLE
123F    93            5268     	MOVC A, @A+DPTR	
1240    78A0          5269     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1242    F6            5270     MOV @ R0 , A 
1243    11B7          5271     	CALL	SWITCH_POWER_OFF		; Reset DPTR
1245    22            5272     	RET
                      5273     
                      5274     
                      5275     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5276     ;
                      5277     ; Decode throttle rate
                      5278     ;
                      5279     ; No assumptions
                      5280     ;
                      5281     ; Decodes throttle rate
                      5282     ;
                      5283     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5284     DECODE_THROTTLE_RATE: 
                      5285     	; Decode throttle rate
1246    789B          5286     MOV R0 , # PGM_THROTTLE_RATE 
1248    E6            5287     MOV A , @ R0 
1249    14            5288     	DEC	A	
124A    90008D        5289     	MOV	DPTR, #THROTTLE_RATE_TABLE
124D    93            5290     	MOVC A, @A+DPTR	
124E    78A1          5291     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
1250    F6            5292     MOV @ R0 , A 
1251    11B7          5293     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1253    22            5294     	RET
                      5295     
                      5296     
                      5297     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5298     ;
                      5299     ; Decode startup power
                      5300     ;
                      5301     ; No assumptions
                      5302     ;
                      5303     ; Decodes startup power
                      5304     ;
                      5305     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5306     DECODE_STARTUP_POWER: 
                      5307     	; Decode startup power
1254    7886          5308     MOV R0 , # PGM_STARTUP_PWR 
1256    E6            5309     MOV A , @ R0 
1257    14            5310     	DEC	A	
1258    90009A        5311     	MOV	DPTR, #STARTUP_POWER_TABLE
125B    93            5312     	MOVC A, @A+DPTR	
125C    78A2          5313     MOV R0 , # PGM_STARTUP_PWR_DECODED 
125E    F6            5314     MOV @ R0 , A 
125F    11B7          5315     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1261    22            5316     	RET
                      5317     
                      5318     
                      5319     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5320     ;
                      5321     ; Decode demag compensation
                      5322     ;
                      5323     ; No assumptions
                      5324     ;
                      5325     ; Decodes throttle rate
                      5326     ;
                      5327     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5328     DECODE_DEMAG_COMP: 
                      5329     	; Decode demag compensation
1262    789C          5330     MOV R0 , # PGM_DEMAG_COMP 
1264    E6            5331     MOV A , @ R0 
1265    14            5332     	DEC	A	
1266    9000A7        5333     	MOV	DPTR, #DEMAG_POWER_TABLE
1269    93            5334     	MOVC A, @A+DPTR	
126A    78A3          5335     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
126C    F6            5336     MOV @ R0 , A 
126D    11B7          5337     	CALL	SWITCH_POWER_OFF			; Reset DPTR
126F    22            5338     	RET
                      5339     
                      5340     
                      5341     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5342     ;
                      5343     ; Set BEC voltage
                      5344     ;
                      5345     ; No assumptions
                      5346     ;
                      5347     ; Sets the BEC output voltage low or high
                      5348     ;
                      5349     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5350     SET_BEC_VOLTAGE: 
                      5351     	; Set bec voltage
                      5352     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1270    22            5362     	RET
                      5363     
                      5364     
                      5365     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5366     ;
                      5367     ; Find throttle gain
                      5368     ;
                      5369     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5370     ;
                      5371     ; Finds throttle gain from throttle calibration values
                      5372     ;
                      5373     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5374     FIND_THROTTLE_GAIN: 
                      5375     	; Load programmed minimum and maximum throttle
1271    7896          5376     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1273    E6            5377     MOV A , @ R0 
1274    FA            5378     MOV R2 , A 
1275    7897          5379     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1277    E6            5380     MOV A , @ R0 
1278    FB            5381     MOV R3 , A 
                      5382     	; Check if full range is chosen
1279    307704        5383     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5384     
127C    7A00          5385     MOV R2 , # 0 
127E    7BFF          5386     MOV R3 , # 255 
                      5387     
                      5388     FIND_THROTTLE_GAIN_CALCULATE: 
                      5389     	; Calculate difference
1280    C3            5390     	CLR	C
1281    EB            5391     MOV A , R3 
1282    9A            5392     SUBB A , R2 
1283    FC            5393     MOV R4 , A 
                      5394     	; Check that difference is minimum 130
1284    C3            5395     	CLR	C
1285    9482          5396     	SUBB	A, #130
1287    5002          5397     	JNC	($+4)
                      5398     
1289    7C82          5399     MOV R4 , # 130 
                      5400     
                      5401     	; Find gain
128B    756E00        5402     	MOV	PPM_THROTTLE_GAIN, #0
                      5403     TEST_THROTTLE_GAIN: 
128E    056E          5404     	INC	PPM_THROTTLE_GAIN
1290    EC            5405     MOV A , R4 
1291    856EF0        5406     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1294    A4            5407     	MUL	AB
1295    C3            5408     	CLR	C
1296    E5F0          5409     	MOV	A, B
1298    9480          5410     	SUBB	A, #128
129A    40F2          5411     	JC	TEST_THROTTLE_GAIN
129C    22            5412     	RET
                      5413     
                      5414     
                      5415     
                      5416     
                      5417     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5418     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5419     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5420     ;
                      5421     ; Main program start
                      5422     ;
                      5423     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5424     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5425     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5426     
                      5427     RESET: 
                      5428     	; Check flash lock byte
129D    E5EF          5429     	MOV	A, RSTSRC			
129F    20E603        5430     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5431     
12A2    752000        5432     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5433     
12A5    0520          5434     	INC	BIT_ACCESS
12A7    903FFF        5435     MOV DPTR , # 16383 
12AA    E520          5436     	MOV	A, BIT_ACCESS
12AC    14            5437     	DEC	A
12AD    6006          5438     	JZ	LOCK_BYTE_TEST
                      5439     
12AF    901FFF        5440     MOV DPTR , # 8191 
12B2    14            5441     	DEC	A
12B3    6000          5442     	JZ	LOCK_BYTE_TEST
                      5443     
                      5444     LOCK_BYTE_TEST: 
12B5    93            5445     	MOVC A, @A+DPTR		; Read lock byte
12B6    04            5446     	INC	A				
12B7    6003          5447     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5448     
                      5449     IF ONE_S_CAPABLE == 0		
12B9    75EF12        5450     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5451     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5454     
                      5455     LOCK_BYTE_OK: 
                      5456     	; Select register bank 0 for main program routines
12BC    C2D3          5457     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5458     	; Disable the WDT.
12BE    53D9BF        5459     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5460     	; Initialize stack
12C1    7581C0        5461     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5462     	; Initialize VDD monitor
12C4    43FF80        5463     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
12C7    12080C        5464     	CALL	WAIT1MS			; Wait at least 100us
                      5465     IF ONE_S_CAPABLE == 0		
12CA    75EF02        5466     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5467     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5470     	; Set clock frequency
12CD    43B203        5471     	ORL	OSCICN, #03H		; Set clock divider to 1
12D0    E5B3          5472     	MOV	A, OSCICL				
12D2    2404          5473     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
12D4    4002          5474     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5475     
12D6    F5B3          5476     	MOV	OSCICL, A
                      5477     
                      5478     RESET_CAL_DONE: 
                      5479     	; Switch power off
12D8    11B7          5480     	CALL	SWITCH_POWER_OFF
                      5481     	; Ports initialization
12DA    7580FF        5482     MOV P0 , # 255 
12DD    75A400        5483     MOV P0MDOUT , # 0 
12E0    75F1F0        5484     MOV P0MDIN , # -16 
12E3    75D4DF        5485     MOV P0SKIP , # -33 
12E6    759002        5486     MOV P1 , # 2 
12E9    75A5FC        5487     MOV P1MDOUT , # 252 
12EC    75F2FD        5488     MOV P1MDIN , # -3 
12EF    75D502        5489     MOV P1SKIP , # 2 
                      5490     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12F2    75A610        5493     MOV P2MDOUT , # 16 
                      5494     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5501     	; Initialize the XBAR and related functionality
                      5502     	INITIALIZE_XBAR		
12F5    75A0FF        5502+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12F8    75F3F1        5502+1   MOV P2MDIN , # -15 
12FB    75E241        5502+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5503     	; Clear RAM
12FE    E4            5504     	CLR	A				; Clear accumulator
12FF    F8            5505     MOV R0 , A 
                      5506     CLEAR_RAM: 	
1300    F6            5507     MOV @ R0 , A 
1301    D8FD          5508     DJNZ R0 , CLEAR_RAM 
                      5509     	; Set default programmed parameters
1303    3134          5510     	CALL	SET_DEFAULT_PARAMETERS
                      5511     	; Decode parameters
1305    3199          5512     	CALL	DECODE_PARAMETERS
                      5513     	; Decode governor gains
1307    512D          5514     	CALL	DECODE_GOVERNOR_GAINS
                      5515     	; Decode throttle rate
1309    5146          5516     	CALL	DECODE_THROTTLE_RATE
                      5517     	; Decode startup power
130B    5154          5518     	CALL	DECODE_STARTUP_POWER
                      5519     	; Decode demag compensation
130D    5162          5520     	CALL	DECODE_DEMAG_COMP
                      5521     	; Set BEC voltage
130F    5170          5522     	CALL	SET_BEC_VOLTAGE
                      5523     	; Find throttle gain from stored min and max settings
1311    5171          5524     	CALL	FIND_THROTTLE_GAIN
                      5525     	; Set beep strength
1313    7898          5526     MOV R0 , # PGM_BEEP_STRENGTH 
1315    866F          5527     MOV BEEP_STRENGTH , @ R0 
                      5528     	; Switch power off
1317    11B7          5529     	CALL	SWITCH_POWER_OFF
                      5530     	; Timer control
1319    758850        5531     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5532     	; Timer mode
131C    758902        5533     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5534     	; Timer2: clk/12 for 128us and 32ms interrupts
131F    75C824        5535     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5536     	; Timer3: clk/12 for commutation timing
1322    759104        5537     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5538     	; PCA
1325    75D840        5539     	MOV	PCA0CN, #40H		; PCA enabled
                      5540     	; Initializing beep
1328    C2AF          5541     	CLR	EA				; Disable interrupts explicitly
132A    120825        5542     	CALL WAIT200MS	
132D    12083C        5543     	CALL BEEP_F1
1330    12081B        5544     	CALL WAIT30MS
1333    120843        5545     	CALL BEEP_F2
1336    12081B        5546     	CALL WAIT30MS
1339    12084A        5547     	CALL BEEP_F3
133C    12081B        5548     	CALL WAIT30MS
133F    120851        5549     	CALL BEEP_F4
1342    12081B        5550     	CALL WAIT30MS
                      5551     
                      5552     	; Wait for receiver to initialize
                      5553     	; call	wait1s
                      5554     	; call	wait200ms
                      5555     	; call	wait200ms
                      5556     	; call	wait100ms
                      5557     
                      5558     	; Enable interrupts
1345    75A822        5559     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1348    75B802        5560     	MOV	IP, #02H			; High priority to timer0 interrupts
134B    75E690        5561     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5562     	; Initialize comparator
134E    759B80        5563     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1351    759D03        5564     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5565     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5569     	; Initialize ADC
                      5570     	INITIALIZE_ADC			; Initialize ADC operation
1354    75D10E        5570+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1357    75BC58        5570+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
135A    75BB09        5570+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
135D    75BA11        5570+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1360    75E880        5570+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1363    12080C        5571     	CALL	WAIT1MS
1366    D2AF          5572     	SETB	EA				; Enable all interrupts
                      5573     	; Measure number of lipo cells
1368    120AF4        5574     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5575     	; Initialize rc pulse
                      5576     	RCP_INT_ENABLE		 			; Enable interrupt
136B    43DA01        5576+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5577     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
136E    C2D8          5577+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1370    C269          5578     CLR FLAGS2 . 1 
1372    120825        5579     	CALL WAIT200MS
                      5580     	; Set initial arm variable
1375    753001        5581     	MOV	INITIAL_ARM, #1
                      5582     
                      5583     	; Measure PWM frequency
                      5584     MEASURE_PWM_FREQ_INIT: 	
1378    D259          5585     SETB FLAGS0 . 1 
                      5586     MEASURE_PWM_FREQ_START: 	
137A    7A05          5587     MOV R2 , # 5 
                      5588     MEASURE_PWM_FREQ_LOOP: 	
                      5589     	; Check if period diff was accepted
137C    E558          5590     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
137E    7002          5591     	JNZ	($+4)
                      5592     
1380    7A05          5593     MOV R2 , # 5 
                      5594     
1382    120811        5595     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1385    E559          5596     	MOV	A, NEW_RCP					; Load value
1387    C3            5597     	CLR	C
1388    9402          5598     SUBB A , # 2 
138A    40EE          5599     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5600     
138C    E52E          5601     	MOV	A, FLAGS3						; Check pwm frequency flags
138E    541F          5602     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1390    855B5A        5603     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1393    F55B          5604     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1395    B55AE2        5605     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5606     
1398    DAE2          5607     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5608     
                      5609     	; Clear measure pwm frequency flag
139A    C259          5610     CLR FLAGS0 . 1 
                      5611     	; Set up RC pulse interrupts after pwm frequency measurement
                      5612     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
139C    53DACF        5612+1   ANL PCA0CPM0 , # 0CFH 
139F    207603        5612+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
13A2    43DA20        5612+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
13A5    307603        5612+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
13A8    43DA10        5612+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5613     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
13AB    C2D8          5613+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
13AD    C269          5614     CLR FLAGS2 . 1 
13AF    120820        5615     	CALL WAIT100MS						; Wait for new RC pulse
                      5616     
                      5617     	; Validate RC pulse
                      5618     VALIDATE_RCP_START: 	
13B2    120811        5619     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
13B5    7802          5620     MOV R0 , # 2 
13B7    741F          5621     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13B9    552E          5622     	ANL	A, FLAGS3						; Check pwm frequency flags
13BB    7002          5623     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5624     
13BD    7800          5625     MOV R0 , # 0 
                      5626     
13BF    C3            5627     	CLR	C
13C0    E559          5628     	MOV	A, NEW_RCP					; Load value
13C2    98            5629     SUBB A , R0 
13C3    40ED          5630     	JC	VALIDATE_RCP_START				; No - start over
                      5631     
                      5632     	; Beep arm sequence start signal
13C5    C2AF          5633     	CLR 	EA							; Disable all interrupts
13C7    12083C        5634     	CALL BEEP_F1
13CA    12081B        5635     	CALL WAIT30MS
13CD    12083C        5636     	CALL BEEP_F1
13D0    12081B        5637     	CALL WAIT30MS
13D3    120843        5638     	CALL BEEP_F2
13D6    12081B        5639     	CALL WAIT30MS
13D9    120843        5640     	CALL BEEP_F2
13DC    12081B        5641     	CALL WAIT30MS
13DF    D2AF          5642     	SETB	EA							; Enable all interrupts
13E1    120825        5643     	CALL WAIT200MS	
                      5644     
                      5645     	; Arming sequence start
13E4    754800        5646     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5647     ARMING_START: 
13E7    C3            5648     	CLR	C
13E8    E559          5649     	MOV	A, NEW_RCP			; Load new RC pulse value
13EA    9548          5650     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
13EC    4003          5651     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5652     
13EE    855948        5653     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5654     
                      5655     ARM_TARGET_UPDATED: 
13F1    120820        5656     	CALL WAIT100MS				; Wait for new throttle value
13F4    C3            5657     	CLR	C
13F5    E559          5658     	MOV	A, NEW_RCP			; Load new RC pulse value
13F7    9401          5659     SUBB A , # 1 
13F9    4002          5660     	JC	ARM_END_BEEP			; Yes - proceed
                      5661     
13FB    80EA          5662     	JMP	ARMING_START			; No - start over
                      5663     
                      5664     ARM_END_BEEP: 
                      5665     	; Beep arm sequence end signal
13FD    C2AF          5666     	CLR 	EA					; Disable all interrupts
13FF    120851        5667     	CALL BEEP_F4
1402    12081B        5668     	CALL WAIT30MS
1405    120851        5669     	CALL BEEP_F4
1408    12081B        5670     	CALL WAIT30MS
140B    12084A        5671     	CALL BEEP_F3
140E    12081B        5672     	CALL WAIT30MS
1411    12084A        5673     	CALL BEEP_F3
1414    12081B        5674     	CALL WAIT30MS
1417    D2AF          5675     	SETB	EA					; Enable all interrupts
1419    120825        5676     	CALL WAIT200MS
                      5677     
                      5678     	; Clear initial arm variable
141C    753000        5679     	MOV	INITIAL_ARM, #0
                      5680     
                      5681     	; Armed and waiting for power on
                      5682     WAIT_FOR_POWER_ON: 
141F    E4            5683     	CLR	A
1420    F531          5684     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1422    F532          5685     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5686     WAIT_FOR_POWER_ON_LOOP: 
1424    0531          5687     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1426    E531          5688     	MOV	A, POWER_ON_WAIT_CNT_L
1428    F4            5689     	CPL	A
1429    7039          5690     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5691     
142B    0532          5692     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
142D    789A          5693     MOV R0 , # PGM_BEACON_DELAY 
142F    E6            5694     MOV A , @ R0 
1430    7819          5695     MOV R0 , # 25 
1432    14            5696     	DEC	A
1433    6012          5697     	JZ	BEEP_DELAY_SET
                      5698     
1435    7832          5699     MOV R0 , # 50 
1437    14            5700     	DEC	A
1438    600D          5701     	JZ	BEEP_DELAY_SET
                      5702     
143A    787D          5703     MOV R0 , # 125 
143C    14            5704     	DEC	A
143D    6008          5705     	JZ	BEEP_DELAY_SET
                      5706     
143F    78FA          5707     MOV R0 , # 250 
1441    14            5708     	DEC	A
1442    6003          5709     	JZ	BEEP_DELAY_SET
                      5710     
1444    753200        5711     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5712     
                      5713     BEEP_DELAY_SET: 
1447    C3            5714     	CLR	C
1448    E532          5715     	MOV	A, POWER_ON_WAIT_CNT_H
144A    98            5716     SUBB A , R0 
144B    4017          5717     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5718     
144D    1532          5719     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
144F    7531B4        5720     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
1452    7899          5721     MOV R0 , # PGM_BEACON_STRENGTH 
1454    866F          5722     MOV BEEP_STRENGTH , @ R0 
1456    C2AF          5723     	CLR 	EA					; Disable all interrupts
1458    120851        5724     	CALL BEEP_F4				; Signal that there is no signal
145B    D2AF          5725     	SETB	EA					; Enable all interrupts
145D    7898          5726     MOV R0 , # PGM_BEEP_STRENGTH 
145F    866F          5727     MOV BEEP_STRENGTH , @ R0 
1461    120820        5728     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5729     
                      5730     WAIT_FOR_POWER_ON_NO_BEEP: 
1464    120816        5731     	CALL WAIT10MS
1467    E528          5732     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
1469    7008          5733     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5734     
146B    741F          5735     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
146D    552E          5736     	ANL	A, FLAGS3						; Check pwm frequency flags
146F    7002          5737     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5738     
1471    6178          5739     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5740     
                      5741     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1473    C3            5742     	CLR	C
1474    E559          5743     	MOV	A, NEW_RCP			; Load new RC pulse value
1476    9406          5744     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
1478    40AA          5745     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5746     
                      5747     IF MODE >= 1	; Tail or multi
147A    7888          5748     MOV R0 , # PGM_DIRECTION 
147C    E6            5749     MOV A , @ R0 
147D    C3            5750     	CLR	C
147E    9403          5751     	SUBB	A, #3
1480    6003          5752     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5753     ENDIF
                      5754     
1482    120820        5755     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5756     
1485    E528          5757     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1487    7003          5758     	JNZ	($+5)				; If it is not zero - proceed
                      5759     
1489    021378        5760     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5761     
                      5762     
                      5763     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5764     ;
                      5765     ; Start entry point
                      5766     ;
                      5767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5768     INIT_START: 
148C    C2AF          5769     	CLR	EA
148E    11B7          5770     	CALL SWITCH_POWER_OFF
1490    E4            5771     	CLR	A
1491    F522          5772     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1493    F523          5773     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1495    F524          5774     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1497    F525          5775     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1499    D2AF          5776     	SETB	EA
149B    7885          5777     MOV R0 , # PGM_MOTOR_IDLE 
149D    8661          5778     MOV PWM_MOTOR_IDLE , @ R0 
149F    F540          5779     	MOV	GOV_TARGET_L, A		; Set target to zero
14A1    F541          5780     	MOV	GOV_TARGET_H, A
14A3    F542          5781     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
14A5    F543          5782     	MOV	GOV_INTEGRAL_H, A
14A7    F544          5783     	MOV	GOV_INTEGRAL_X, A
14A9    F56C          5784     	MOV	ADC_CONVERSION_CNT, A
14AB    F549          5785     	MOV	GOV_ACTIVE, A
14AD    F52B          5786     	MOV	FLAGS0, A				; Clear flags0
14AF    F52C          5787     	MOV	FLAGS1, A				; Clear flags1
14B1    F539          5788     	MOV	DEMAG_CONSECUTIVE_CNT, A
14B3    120C71        5789     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5790     	;**** **** **** **** ****
                      5791     	; Motor start beginning
                      5792     	;**** **** **** **** **** 
14B6    756C08        5793     MOV ADC_CONVERSION_CNT , # 8 
                      5794     	SET_ADC_IP_TEMP
14B9    75BB10        5794+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
14BC    12080C        5795     	CALL WAIT1MS
14BF    120B8E        5796     	CALL START_ADC_CONVERSION
                      5797     READ_INITIAL_TEMP: 
                      5798     	GET_ADC_STATUS 
14C2    E5E8          5798+1   MOV A , ADC0CN 
14C4    20ECFB        5799     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5800     	READ_ADC_RESULT						; Read initial temperature
14C7    A8BD          5800+1   MOV R0 , ADC0L 
14C9    A9BE          5800+1   MOV R1 , ADC0H 
14CB    E9            5801     MOV A , R1 
14CC    7001          5802     	JNZ	($+3)							; Is reading below 256?
                      5803     
14CE    F8            5804     MOV R0 , A 
                      5805     
14CF    886D          5806     MOV CURRENT_AVERAGE_TEMP , R0 
14D1    120B92        5807     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14D4    756C08        5808     MOV ADC_CONVERSION_CNT , # 8 
                      5809     	SET_ADC_IP_TEMP
14D7    75BB10        5809+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5810     
                      5811     	; Go to the desired startup mode
14DA    7895          5812     MOV R0 , # PGM_STARTUP_METHOD 
14DC    E6            5813     MOV A , @ R0 
14DD    30E003        5814     	JNB	ACC.0, DIRECT_METHOD_START
                      5815     
14E0    021523        5816     	JMP	STEPPER_METHOD_START
                      5817     
                      5818     DIRECT_METHOD_START: 
                      5819     	; Set up start operating conditions
14E3    7887          5820     MOV R0 , # PGM_PWM_FREQ 
14E5    E6            5821     MOV A , @ R0 
14E6    FE            5822     MOV R6 , A 
14E7    7602          5823     MOV @ R0 , # 2 
14E9    3199          5824     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
14EB    7887          5825     MOV R0 , # PGM_PWM_FREQ 
14ED    EE            5826     MOV A , R6 
14EE    F6            5827     MOV @ R0 , A 
                      5828     	; Set max allowed power
14EF    D261          5829     SETB FLAGS1 . 1 
14F1    C2AF          5830     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
14F3    755EFF        5831     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
14F6    120C41        5832     	CALL SET_STARTUP_PWM
14F9    85225E        5833     	MOV	PWM_LIMIT, REQUESTED_PWM
14FC    85225F        5834     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
14FF    D2AF          5835     	SETB	EA
1501    C261          5836     CLR FLAGS1 . 1 
1503    752501        5837     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
1506    855D64        5838     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1509    756501        5839     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5840     	; Begin startup sequence
150C    D260          5841     SETB FLAGS1 . 0 
150E    D263          5842     SETB FLAGS1 . 3 
1510    753800        5843     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1513    1111          5844     	CALL COMM5COMM6				; Initialize commutation
1515    114C          5845     	CALL COMM6COMM1				
1517    120CEB        5846     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
151A    120C71        5847     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
151D    120D6E        5848     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
1520    021648        5849     	JMP	RUN1
                      5850     
                      5851     
                      5852     STEPPER_METHOD_START: 
                      5853     	; Set up start operating conditions
1523    7887          5854     MOV R0 , # PGM_PWM_FREQ 
1525    E6            5855     MOV A , @ R0 
1526    FE            5856     MOV R6 , A 
1527    7603          5857     MOV @ R0 , # 3 
1529    7893          5858     MOV R0 , # PGM_DAMPING_FORCE 
152B    E6            5859     MOV A , @ R0 
152C    FD            5860     MOV R5 , A 
152D    7605          5861     MOV @ R0 , # 5 
152F    3199          5862     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1531    7887          5863     MOV R0 , # PGM_PWM_FREQ 
1533    EE            5864     MOV A , R6 
1534    F6            5865     MOV @ R0 , A 
1535    7893          5866     MOV R0 , # PGM_DAMPING_FORCE 
1537    ED            5867     MOV A , R5 
1538    F6            5868     MOV @ R0 , A 
                      5869     	; Begin startup sequence
1539    D260          5870     SETB FLAGS1 . 0 
153B    D261          5871     SETB FLAGS1 . 1 
153D    D265          5872     SETB FLAGS1 . 5 
153F    1111          5873     	CALL COMM5COMM6			; Initialize commutation
1541    114C          5874     	CALL COMM6COMM1			
1543    755EFF        5875     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1546    120C41        5876     	CALL SET_STARTUP_PWM
1549    12080C        5877     	CALL WAIT1MS
154C    120F19        5878     	CALL COMM1COMM2
154F    12080C        5879     	CALL WAIT1MS
1552    12080C        5880     	CALL WAIT1MS
1555    120F4B        5881     	CALL COMM2COMM3
1558    120811        5882     	CALL WAIT3MS			
155B    120F95        5883     	CALL COMM3COMM4
155E    120811        5884     	CALL WAIT3MS			
1561    120811        5885     	CALL WAIT3MS			
1564    120FD0        5886     	CALL COMM4COMM5
1567    120816        5887     	CALL WAIT10MS				; Settle rotor
156A    1111          5888     	CALL COMM5COMM6
156C    120811        5889     	CALL WAIT3MS				
156F    12080C        5890     	CALL WAIT1MS			
1572    C261          5891     CLR FLAGS1 . 1 
1574    D262          5892     SETB FLAGS1 . 2 
                      5893     
                      5894     	;**** **** **** **** ****
                      5895     	; Stepper phase beginning
                      5896     	;**** **** **** **** **** 
                      5897     STEPPER_ROT_BEG: 
1576    120B8E        5898     	CALL START_ADC_CONVERSION
1579    120B92        5899     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
157C    120C41        5900     	CALL SET_STARTUP_PWM
157F    756C08        5901     MOV ADC_CONVERSION_CNT , # 8 
                      5902     	SET_ADC_IP_TEMP
1582    75BB10        5902+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5903     
1585    114C          5904     	CALL COMM6COMM1				; Commutate
1587    120CE4        5905     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
158A    120D6E        5906     	CALL CALC_NEW_WAIT_TIMES
158D    11C9          5907     	CALL DECREMENT_STEPPER_STEP
158F    312E          5908     	CALL STEPPER_TIMER_WAIT
                      5909     
1591    120F19        5910     	CALL COMM1COMM2			
1594    120CE4        5911     	CALL CALC_NEXT_COMM_TIMING_START	
1597    120D6E        5912     	CALL CALC_NEW_WAIT_TIMES
159A    11C9          5913     	CALL DECREMENT_STEPPER_STEP
159C    312E          5914     	CALL STEPPER_TIMER_WAIT
                      5915     
159E    120F4B        5916     	CALL COMM2COMM3			
15A1    120CE4        5917     	CALL CALC_NEXT_COMM_TIMING_START	
15A4    120D6E        5918     	CALL CALC_NEW_WAIT_TIMES
15A7    11C9          5919     	CALL DECREMENT_STEPPER_STEP
15A9    312E          5920     	CALL STEPPER_TIMER_WAIT
                      5921     
15AB    120F95        5922     	CALL COMM3COMM4			
15AE    120CE4        5923     	CALL CALC_NEXT_COMM_TIMING_START	
15B1    120D6E        5924     	CALL CALC_NEW_WAIT_TIMES
15B4    11C9          5925     	CALL DECREMENT_STEPPER_STEP
15B6    312E          5926     	CALL STEPPER_TIMER_WAIT
                      5927     
15B8    120FD0        5928     	CALL COMM4COMM5			
15BB    120CE4        5929     	CALL CALC_NEXT_COMM_TIMING_START	
15BE    120D6E        5930     	CALL CALC_NEW_WAIT_TIMES
15C1    11C9          5931     	CALL DECREMENT_STEPPER_STEP
15C3    312E          5932     	CALL STEPPER_TIMER_WAIT
                      5933     
15C5    1111          5934     	CALL COMM5COMM6			
15C7    120CE4        5935     	CALL CALC_NEXT_COMM_TIMING_START	
15CA    120D6E        5936     	CALL CALC_NEW_WAIT_TIMES
15CD    11C9          5937     	CALL DECREMENT_STEPPER_STEP	
                      5938     	; Check stepper step versus end criteria
15CF    C3            5939     	CLR	C
15D0    E550          5940     	MOV	A, WT_STEPPER_STEP_L
15D2    9535          5941     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
15D4    E551          5942     	MOV	A, WT_STEPPER_STEP_H
15D6    9536          5943     	SUBB	A, STEPPER_STEP_END_H
15D8    400C          5944     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5945     
                      5946     	; Wait for step
15DA    312E          5947     	CALL STEPPER_TIMER_WAIT
15DC    C3            5948     	CLR	C
15DD    E559          5949     	MOV	A, NEW_RCP				; Load new pulse value
15DF    9401          5950     SUBB A , # 1 
15E1    5093          5951     	JNC	STEPPER_ROT_BEG
                      5952     
15E3    021778        5953     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5954     
                      5955     STEPPER_ROT_EXIT: 
                      5956     	; Wait for step
15E6    312E          5957     	CALL STEPPER_TIMER_WAIT
                      5958     	; Clear stepper phase
15E8    C262          5959     CLR FLAGS1 . 2 
                      5960     	; Set dondamped low pwm frequency
15EA    7887          5961     MOV R0 , # PGM_PWM_FREQ 
15EC    E6            5962     MOV A , @ R0 
15ED    FE            5963     MOV R6 , A 
15EE    7602          5964     MOV @ R0 , # 2 
15F0    3199          5965     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
15F2    7887          5966     MOV R0 , # PGM_PWM_FREQ 
15F4    EE            5967     MOV A , R6 
15F5    F6            5968     MOV @ R0 , A 
                      5969     	; Set spoolup power variables (power is now controlled from RCP)
15F6    85225E        5970     	MOV	PWM_LIMIT, REQUESTED_PWM
15F9    85605F        5971     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
15FC    856025        5972     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
15FF    855D64        5973     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1602    756501        5974     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5975     	; Set direct startup phase to acquire sync quickly
1605    D263          5976     SETB FLAGS1 . 3 
1607    753800        5977     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
160A    C2AF          5978     	CLR	EA						; Disable interrupts
                      5979     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
160C    207502        5979+1   JB FLAGS3 . 5 , ( $+5 ) 
160F    C293          5979+1   CLR P1 . 3 
1611    307502        5979+1   JNB FLAGS3 . 5 , ( $+5 ) 
1614    C297          5979+1   CLR P1 . 7 
                      5980     	CPFET_OFF						; Cp off
1616    207502        5980+1   JB FLAGS3 . 5 , ( $+5 ) 
1619    C297          5980+1   CLR P1 . 7 
161B    307502        5980+1   JNB FLAGS3 . 5 , ( $+5 ) 
161E    C293          5980+1   CLR P1 . 3 
1620    742D          5981     	MOV	A, #45					; 8us delay for pfets to go off
1622    D5E0FD        5982     	DJNZ	ACC, $
1625    D2AF          5983     	SETB	EA						; Enable interrupts
1627    114C          5984     	CALL COMM6COMM1				
1629    120CEB        5985     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
162C    120D5A        5986     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
162F    120D6E        5987     	CALL CALC_NEW_WAIT_TIMES
1632    120DFF        5988     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
1635    756C00        5989     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5990     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
1638    75BB09        5990+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
163B    021648        5991     	JMP	RUN1
                      5992     
                      5993     
                      5994     
                      5995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5996     ;
                      5997     ; Run entry point
                      5998     ;
                      5999     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6000     DAMPED_TRANSITION: 
                      6001     	; Transition from nondamped to damped if applicable
163E    3199          6002     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1640    114C          6003     	CALL	COMM6COMM1
1642    756C00        6004     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      6005     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
1645    75BB09        6005+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      6006     
                      6007     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      6008     ; Out_cA changes from low to high
                      6009     RUN1: 
1648    120E21        6010     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
164B    120EA6        6011     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
164E    120ED1        6012     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1651    12093B        6013     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1654    120EE5        6014     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1657    120F19        6015     	CALL COMM1COMM2			; Commutate
165A    120CEB        6016     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
165D    120D5A        6017     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1660    120D6E        6018     	CALL CALC_NEW_WAIT_TIMES
1663    120DFF        6019     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      6020     
                      6021     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      6022     ; Out_cB changes from high to low
                      6023     RUN2: 
1666    120E18        6024     	CALL WAIT_FOR_COMP_OUT_LOW
1669    120EA6        6025     	CALL	EVALUATE_COMPARATOR_INTEGRITY
166C    120ED1        6026     	CALL SETUP_COMM_WAIT	
166F    120998        6027     	CALL CALC_GOVERNOR_PROP_ERROR
1672    120EE5        6028     	CALL WAIT_FOR_COMM
1675    120F4B        6029     	CALL COMM2COMM3
1678    120CEB        6030     	CALL CALC_NEXT_COMM_TIMING
167B    120D5A        6031     	CALL WAIT_ADVANCE_TIMING
167E    120D6E        6032     	CALL CALC_NEW_WAIT_TIMES
1681    120DFF        6033     	CALL WAIT_BEFORE_ZC_SCAN	
                      6034     
                      6035     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6036     ; Out_cC changes from low to high
                      6037     RUN3: 
1684    120E21        6038     	CALL WAIT_FOR_COMP_OUT_HIGH
1687    120EA6        6039     	CALL	EVALUATE_COMPARATOR_INTEGRITY
168A    120ED1        6040     	CALL SETUP_COMM_WAIT	
168D    1209D1        6041     	CALL CALC_GOVERNOR_INT_ERROR
1690    120EE5        6042     	CALL WAIT_FOR_COMM
1693    120F95        6043     	CALL COMM3COMM4
1696    120CEB        6044     	CALL CALC_NEXT_COMM_TIMING
1699    120D5A        6045     	CALL WAIT_ADVANCE_TIMING
169C    120D6E        6046     	CALL CALC_NEW_WAIT_TIMES
169F    120DFF        6047     	CALL WAIT_BEFORE_ZC_SCAN	
                      6048     
                      6049     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6050     ; Out_cA changes from high to low
                      6051     RUN4: 
16A2    120E18        6052     	CALL WAIT_FOR_COMP_OUT_LOW
16A5    120EA6        6053     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16A8    120ED1        6054     	CALL SETUP_COMM_WAIT	
16AB    120A2E        6055     	CALL CALC_GOVERNOR_PROP_CORRECTION
16AE    120EE5        6056     	CALL WAIT_FOR_COMM
16B1    120FD0        6057     	CALL COMM4COMM5
16B4    120CEB        6058     	CALL CALC_NEXT_COMM_TIMING
16B7    120D5A        6059     	CALL WAIT_ADVANCE_TIMING
16BA    120D6E        6060     	CALL CALC_NEW_WAIT_TIMES
16BD    120DFF        6061     	CALL WAIT_BEFORE_ZC_SCAN	
                      6062     
                      6063     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6064     ; Out_cB changes from low to high
                      6065     RUN5: 
16C0    120E21        6066     	CALL WAIT_FOR_COMP_OUT_HIGH
16C3    120EA6        6067     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16C6    120ED1        6068     	CALL SETUP_COMM_WAIT	
16C9    120A92        6069     	CALL CALC_GOVERNOR_INT_CORRECTION
16CC    120EE5        6070     	CALL WAIT_FOR_COMM
16CF    1111          6071     	CALL COMM5COMM6
16D1    120CEB        6072     	CALL CALC_NEXT_COMM_TIMING
16D4    120D5A        6073     	CALL WAIT_ADVANCE_TIMING
16D7    120D6E        6074     	CALL CALC_NEW_WAIT_TIMES
16DA    120DFF        6075     	CALL WAIT_BEFORE_ZC_SCAN	
                      6076     
                      6077     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6078     ; Out_cC changes from high to low
                      6079     RUN6: 
16DD    120E18        6080     	CALL WAIT_FOR_COMP_OUT_LOW
16E0    120B8E        6081     	CALL START_ADC_CONVERSION
16E3    120EA6        6082     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16E6    120ED1        6083     	CALL SETUP_COMM_WAIT	
16E9    120B92        6084     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
16EC    120EE5        6085     	CALL WAIT_FOR_COMM
16EF    114C          6086     	CALL COMM6COMM1
16F1    120CEB        6087     	CALL CALC_NEXT_COMM_TIMING
16F4    120D5A        6088     	CALL WAIT_ADVANCE_TIMING
16F7    120D6E        6089     	CALL CALC_NEW_WAIT_TIMES
16FA    120DFF        6090     	CALL WAIT_BEFORE_ZC_SCAN	
                      6091     
                      6092     	; Check if it is direct startup
16FD    306342        6093     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6094     
                      6095     	; Set spoolup power variables
1700    85605E        6096     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
1703    85605F        6097     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
1706    855D64        6098     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1709    756501        6099     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6100     	; Check startup ok counter
170C    7964          6101     MOV R1 , # 100 
170E    7A14          6102     MOV R2 , # 20 
                      6103     IF MODE >= 1	; Tail or multi
1710    7888          6104     MOV R0 , # PGM_DIRECTION 
1712    E6            6105     MOV A , @ R0 
1713    B40304        6106     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6107     
1716    791E          6108     MOV R1 , # 30 
1718    7A05          6109     MOV R2 , # 5 
                      6110     
                      6111     DIRECT_START_PARAMS_SET: 
                      6112     ENDIF
171A    C3            6113     	CLR	C
171B    E538          6114     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
171D    99            6115     SUBB A , R1 
171E    4015          6116     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6117     
1720    C263          6118     CLR FLAGS1 . 3 
1722    D264          6119     SETB FLAGS1 . 4 
1724    8A37          6120     MOV STARTUP_ROT_CNT , R2 
                      6121     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6125     IF MODE == 2	; Multi
1726    7888          6126     MOV R0 , # PGM_DIRECTION 
1728    E6            6127     MOV A , @ R0 
1729    B40306        6128     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6129     
172C    755EFF        6130     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
172F    755FFF        6131     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6132     
                      6133     DIRECT_START_PWM_LIM_SET: 
                      6134     ENDIF
1732    021742        6135     	JMP	NORMAL_RUN_CHECKS
                      6136     
                      6137     DIRECT_START_CHECK_RCP: 
1735    C3            6138     	CLR	C
1736    E559          6139     	MOV	A, NEW_RCP				; Load new pulse value
1738    9401          6140     SUBB A , # 1 
173A    4003          6141     	JC	($+5)
                      6142     
173C    021648        6143     	LJMP	RUN1						; Continue to run 
                      6144     
173F    021778        6145     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6146     
                      6147     
                      6148     NORMAL_RUN_CHECKS: 
                      6149     	; Check if it is initial run phase
1742    306419        6150     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6151     
                      6152     	; Decrement startup rotaton count
1745    E537          6153     	MOV	A, STARTUP_ROT_CNT
1747    14            6154     	DEC	A
                      6155     	; Check number of nondamped rotations
1748    7005          6156     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6157     
174A    C264          6158     CLR FLAGS1 . 4 
174C    02163E        6159     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6160     
                      6161     NORMAL_RUN_CHECK_STARTUP_ROT: 
174F    F537          6162     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6163     
1751    C3            6164     	CLR	C
1752    E559          6165     	MOV	A, NEW_RCP				; Load new pulse value
1754    9401          6166     SUBB A , # 1 
1756    4003          6167     	JC	($+5)
                      6168     
1758    021648        6169     	LJMP	RUN1						; Continue to run 
                      6170     
175B    021778        6171     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6172     
                      6173     
                      6174     INITIAL_RUN_PHASE_DONE: 
                      6175     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6188     	; Exit run loop after a given time
175E    C3            6189     	CLR	C
175F    E55C          6190     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1761    94FA          6191     SUBB A , # 250 
1763    5013          6192     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6193     
                      6194     RUN6_CHECK_RCP_TIMEOUT: 
1765    741F          6195     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1767    552E          6196     	ANL	A, FLAGS3					; Check pwm frequency flags
1769    7004          6197     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6198     
176B    E528          6199     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
176D    6009          6200     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6201     
                      6202     RUN6_CHECK_SPEED: 
176F    C3            6203     	CLR	C
1770    E53D          6204     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1772    94F0          6205     	SUBB	A, #0F0H
1774    5002          6206     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
1776    C148          6207     	JMP	RUN1						; Go back to run 1
                      6208     
                      6209     
                      6210     RUN_TO_WAIT_FOR_POWER_ON: 	
1778    C2AF          6211     	CLR	EA
177A    11B7          6212     	CALL SWITCH_POWER_OFF
177C    7887          6213     MOV R0 , # PGM_PWM_FREQ 
177E    E6            6214     MOV A , @ R0 
177F    FE            6215     MOV R6 , A 
1780    7602          6216     MOV @ R0 , # 2 
1782    3199          6217     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1784    7887          6218     MOV R0 , # PGM_PWM_FREQ 
1786    EE            6219     MOV A , R6 
1787    F6            6220     MOV @ R0 , A 
1788    E4            6221     	CLR	A
1789    F522          6222     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
178B    F523          6223     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
178D    F524          6224     	MOV	CURRENT_PWM, A				; Set current pwm to zero
178F    F525          6225     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1791    F561          6226     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1793    C260          6227     CLR FLAGS1 . 0 
1795    D2AF          6228     	SETB	EA
1797    12080C        6229     	CALL	WAIT1MS					; Wait for pwm to be stopped
179A    11B7          6230     	CALL SWITCH_POWER_OFF
                      6231     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6262     IF MODE >= 1	; Tail or multi
179C    741F          6263     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
179E    552E          6264     	ANL	A, FLAGS3					; Check pwm frequency flags
17A0    7006          6265     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6266     
17A2    E528          6267     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17A4    7002          6268     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6269     
17A6    6178          6270     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6271     
                      6272     JMP_WAIT_FOR_POWER_ON: 
17A8    811F          6273     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6274     ENDIF
                      6275     
                      6276     
                      6277     END
MACRO ASSEMBLER BLHELI                                      05/26/15 01:39:48 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   174FH   A 
COMP_WAIT_ON_COMP~  C ADDR   0E6CH   A 
CALC_NEXT_COMM_SL~  C ADDR   0D3FH   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B92H   A 
MEASURE_LIPO_WAIT~  C ADDR   0B04H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0ABFH   A 
GOVERNOR_CORR_NEG~  C ADDR   0A81H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0075H   A 
HOLD_FULL_H. . . .  N NUMB   0002h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
INIT_START . . . .  C ADDR   148CH   A 
FIND_THROTTLE_GAI~  C ADDR   1280H   A 
COMM45_NFET. . . .  C ADDR   0FF5H   A 
COMM45_NONDAMP . .  C ADDR   0FF2H   A 
COMM4COMM5 . . . .  C ADDR   0FD0H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D64H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C25H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0073H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   1254H   A 
GOVERNOR_CHECK_PWM  C ADDR   0A0EH   A 
GOVERNOR_ACTIVATE.  C ADDR   0960H   A 
IF_STATE_INIT. . .  C ADDR   07A4H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
WAIT_FOR_POWER_ON.  C ADDR   141FH   A 
SET_DEFAULT_PARAM~  C ADDR   1134H   A 
COMM56_NONDAMP . .  C ADDR   1038H   A 
COMM23_CP. . . . .  C ADDR   0F83H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CEBH   A 
COMM5COMM6 . . . .  C ADDR   1011H   A 
CALC_GOVERNOR_INT~  C ADDR   0A99H   A 
CALC_GOVERNOR_TAR~  C ADDR   0997H   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   129DH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   1576H   A 
DECODE_THROTTLE_R~  C ADDR   1246H   A 
STEPPER_STEP_MED_~  C ADDR   0CBDH   A 
INITIALIZE_ALL_TI~  C ADDR   0C71H   A 
STARTUP_PWM_SET_P~  C ADDR   0C65H   A 
STATE_IS_ARMED . .  C ADDR   0790H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0077H   A 
HOLD_FULL_L. . . .  N NUMB   00EEh            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   1378H   A 
COMM61_CP. . . . .  C ADDR   1094H   A 
COMM_EXIT. . . . .  C ADDR   10A3H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D46H   A 
CALC_GOVERNOR_INT~  C ADDR   0A92H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   1648H   A 
CLEAR_RAM. . . . .  C ADDR   1300H   A 
SET_BEC_VOLTAGE. .  C ADDR   1270H   A 
DECODE_GOVERNOR_G~  C ADDR   122DH   A 
DEC_STEP_HIGH. . .  C ADDR   10F7H   A 
WAIT_FOR_COMM. . .  C ADDR   0EE5H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D8DH   A 
MEASURE_LIPO_ADD_~  C ADDR   0B81H   A 
CALC_GOVERNOR_PRO~  C ADDR   09D0H   A 
DIV_U16_BY_U16_DI~  C ADDR   08B4H   A 
WAIT100MS. . . . .  C ADDR   0820H   A 
WAIT1MS. . . . . .  C ADDR   080CH   A 
ENDIF_STATE. . . .  C ADDR   07C5H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   1732H   A 
RUN2 . . . . . . .  C ADDR   1666H   A 
COMM45_CP. . . . .  C ADDR   1008H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DFFH   A 
MEASURE_LIPO_UPDA~  C ADDR   0B89H   A 
GOVERNOR_CORR_INT~  C ADDR   0ADEH   A 
GOVERNOR_STORE_PR~  C ADDR   09CCH   A 
DIV_U16_BY_U16_DI~  C ADDR   08BEH   A 
WAIT200MS. . . . .  C ADDR   0825H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   1684H   A 
DIRECT_METHOD_STA~  C ADDR   14E3H   A 
DECODE_DAMPING_DO~  C ADDR   11D5H   A 
PWM_WAIT . . . . .  C ADDR   0E91H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C35H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AC6H   A 
GOVERNOR_CHECK_IN~  C ADDR   09F6H   A 
DIV_U16_BY_U16_DI~  C ADDR   08D5H   A 
WAIT3MS. . . . . .  C ADDR   0811H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   17A8H   A 
DIRECT_START_CHEC~  C ADDR   1735H   A 
RUN4 . . . . . . .  C ADDR   16A2H   A 
STORE_TIMES_UP_OR~  C ADDR   0DDFH   A 
STORE_TIMES_DECRE~  C ADDR   0DF2H   A 
STEPPER_STEP_SET .  C ADDR   0CD7H   A 
TEMP_AVERAGE_INC .  C ADDR   0BC5H   A 
GOVERNOR_CORR_INT~  C ADDR   0AEFH   A 
MULT_S16_BY_U8_DI~  C ADDR   08E4H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   16C0H   A 
COMP_READ. . . . .  C ADDR   0E97H   A 
COMP_WAIT_SET_RES~  C ADDR   0E58H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D93H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AE3H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09C1H   A 
GOVERNOR_TARGET_C~  C ADDR   0943H   A 
CALC_GOVERNOR_TAR~  C ADDR   093BH   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   16DDH   A 
ARMING_START . . .  C ADDR   13E7H   A 
MEASURE_PWM_FREQ_~  C ADDR   137CH   A 
DECREMENT_STEP_EX~  C ADDR   1124H   A 
COMM_RETURN. . . .  C ADDR   10B6H   A 
GOVERNOR_DEACTIVA~  C ADDR   094DH   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   13F1H   A 
EVALUATE_COMPARAT~  C ADDR   0EA6H   A 
TEMP_CHECK_EXIT. .  C ADDR   0BEFH   A 
GOVERNOR_APPLY_PR~  C ADDR   0A68H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
NORMAL_RUN_CHECKS.  C ADDR   1742H   A 
DEC_STEP_MED_LOW .  C ADDR   1112H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E27H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D5AH   A 
CALC_GOVERNOR_PRO~  C ADDR   0998H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0EFFH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1262H   A 
EVAL_COMP_EXIT . .  C ADDR   0ED0H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0EB8H   A 
STEPPER_STEP_LOW .  C ADDR   0CCBH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B46H   A 
PCA_INT_SET_TIMEO~  C ADDR   07D8H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   15E6H   A 
STEPPER_METHOD_ST~  C ADDR   1523H   A 
DECODE_PARAMS_DIR~  C ADDR   120FH   A 
COMM12_DAMP. . . .  C ADDR   0F23H   A 
SETUP_COMM_WAIT. .  C ADDR   0ED1H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CE4H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0C1BH   A 
CALC_GOVERNOR_INT~  C ADDR   0A2DH   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   13FDH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E18H   A 
LOAD_MIN_TIME. . .  C ADDR   0DAFH   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D6EH   A 
SET_STARTUP_PWM. .  C ADDR   0C41H   A 
GOVERNOR_STORE_IN~  C ADDR   0A27H   A 
GOVERNOR_ACTIVATE~  C ADDR   098AH   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   1765H   A 
DECREMENT_STEP . .  C ADDR   10D5H   A 
COMM23_DAMP. . . .  C ADDR   0F53H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0F01H   A 
ADJUST_TIMING. . .  C ADDR   0DB3H   A 
STEPPER_STEP_MED_~  C ADDR   0CA1H   A 
MEASURE_LIPO_DIVI~  C ADDR   0B66H   A 
MEASURE_LIPO_START  C ADDR   0AF4H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A91H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A22H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09C8H   A 
BEEP_F1. . . . . .  C ADDR   083CH   A 
WAIT1S_LOOP. . . .  C ADDR   0837H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
INITIAL_RUN_PHASE~  C ADDR   175EH   A 
TEST_THROTTLE_GAIN  C ADDR   128EH   A 
STEPPER_STEP_MED .  C ADDR   0CAFH   A 
GOVERNOR_STORE_PR~  C ADDR   0A8FH   A 
GOVERNOR_CHECK_PR~  C ADDR   0A53H   A 
MULT_S16_BY_U8_PO~  C ADDR   08FEH   A 
DIV_U16_BY_U16 . .  C ADDR   08ACH   A 
BEEP_ONOFF . . . .  C ADDR   085FH   A 
BEEP_F2. . . . . .  C ADDR   0843H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   1271H   A 
DECREMENT_STEPPER~  C ADDR   10C9H   A 
COMM61_DAMP. . . .  C ADDR   1054H   A 
COMM34_DAMP. . . .  C ADDR   0FA7H   A 
TEMP_AVERAGE_INC_~  C ADDR   0BB5H   A 
GOVERNOR_INT_MAX_~  C ADDR   0A1BH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09FFH   A 
BEEP_F3. . . . . .  C ADDR   084AH   A 
SET_PWM_IN_HIGH. .  C ADDR   079BH   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
STATE_INIT . . . .  N NUMB   000Fh            
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
DAMPED_TRANSITION.  C ADDR   163EH   A 
BEEP_DELAY_SET . .  C ADDR   1447H   A 
LOCK_BYTE_OK . . .  C ADDR   12BCH   A 
DECODE_PWM_FREQ_L~  C ADDR   1227H   A 
DECODE_DAMPING_3 .  C ADDR   11ADH   A 
CALC_NEW_WAIT_RED~  C ADDR   0D7EH   A 
BEEP_F4. . . . . .  C ADDR   0851H   A 
SET_PWM_IN . . . .  C ADDR   079DH   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
DIRECT_START_PARA~  C ADDR   171AH   A 
DECODE_DAMPING_4 .  C ADDR   11B7H   A 
COMM45_DAMP. . . .  C ADDR   0FD8H   A 
WAIT_FOR_COMM_SET~  C ADDR   0F11H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BCDH   A 
GOVERNOR_APPLY_IN~  C ADDR   0ACAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A5EH   A 
BEEP_OFF . . . . .  C ADDR   08A0H   A 
WAIT10MS . . . . .  C ADDR   0816H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
RESET_CAL_DONE . .  C ADDR   12D8H   A 
DECODE_DAMPING_5 .  C ADDR   11C1H   A 
DECODE_PARAMETERS.  C ADDR   1199H   A 
STEPPER_TIMER_WAIT  C ADDR   112EH   A 
STORE_TIMES_INCRE~  C ADDR   0DE5H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0C14H   A 
MEASURE_LIPO_CELLS  C ADDR   0AF4H   A 
CALC_GOVERNOR_INT~  C ADDR   09D1H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07F2H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
RUN6_CHECK_SPEED .  C ADDR   176FH   A 
WAIT_FOR_POWER_ON~  C ADDR   1473H   A 
DECODE_DAMPING_6 .  C ADDR   11CBH   A 
DEC_STEP_LOW . . .  C ADDR   111BH   A 
COMM56_DAMP. . . .  C ADDR   1023H   A 
SWITCH_POWER_OFF .  C ADDR   10B7H   A 
WAIT30MS . . . . .  C ADDR   081BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0075h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   1778H   A 
EVAL_COMP_CHECK_T~  C ADDR   0EC6H   A 
ADJUST_TIMING_TWO~  C ADDR   0DD5H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C40H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A35H   A 
GOVERNOR_ACTIVATE~  C ADDR   0991H   A 
WAIT1S . . . . . .  C ADDR   0835H   A 
WAITXMS_M. . . . .  C ADDR   082CH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0074H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   14C2H   A 
WAIT_FOR_POWER_ON~  C ADDR   1464H   A 
DECODE_PWM_FREQ_E~  C ADDR   122CH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0F13H   A 
PWM_WAIT_STARTUP .  C ADDR   0E8CH   A 
START_ADC_CONVERS~  C ADDR   0B8EH   A 
MULT_S16_BY_U8_EX~  C ADDR   0932H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   13B2H   A 
LOCK_BYTE_TEST . .  C ADDR   12B5H   A 
DEC_STEP_MED_HIGH.  C ADDR   1100H   A 
COMM_RESTORE_POWER  C ADDR   10B4H   A 
COMM12_NONDAMP . .  C ADDR   0F38H   A 
COMM1COMM2 . . . .  C ADDR   0F19H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BCBH   A 
TEMP_AVERAGE_DEC .  C ADDR   0BC1H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A2EH   A 
WAITXMS_O. . . . .  C ADDR   082AH   A 
PCA_INT_PPM_TIMEO~  C ADDR   07E4H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
WAIT_FOR_POWER_ON~  C ADDR   1424H   A 
DEC_STEP_MED . . .  C ADDR   1109H   A 
READ_TIMER . . . .  C ADDR   0CEFH   A 
CHECK_VOLTAGE_STA~  C ADDR   0BF3H   A 
CALC_GOVERNOR_INT~  C ADDR   0AF3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A08H   A 
MULT_S16_BY_U8_DI~  C ADDR   0917H   A 
BEEP . . . . . . .  C ADDR   0858H   A 
ELES_STATE_INIT. .  C ADDR   07BEH   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0076H   A 
HOLD_CRUISE_L. . .  N NUMB   0030h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
COMM23_NFET. . . .  C ADDR   0F70H   A 
COMM23_NONDAMP . .  C ADDR   0F6DH   A 
COMM2COMM3 . . . .  C ADDR   0F4BH   A 
STEPPER_STEP_HIGH.  C ADDR   0C93H   A 
MEASURE_LIPO_CELL~  C ADDR   0B2BH   A 
GOVERNOR_STORE_IN~  C ADDR   0AF1H   A 
GOVERNOR_CHECK_IN~  C ADDR   0AB3H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A7CH   A 
GOVERNOR_ACTIVATE~  C ADDR   097EH   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B8DH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A64H   A 
GOVERNOR_CHECK_PR~  C ADDR   09B5H   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   137AH   A 
COMM61_NFET. . . .  C ADDR   1079H   A 
COMM61_NONDAMP . .  C ADDR   1076H   A 
COMM6COMM1 . . . .  C ADDR   104CH   A 
COMM34_NONDAMP . .  C ADDR   0FB4H   A 
COMM3COMM4 . . . .  C ADDR   0F95H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E45H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E21H   A 
STARTUP_PWM_EXIT .  C ADDR   0C70H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B7DH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A8DH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6028    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     87    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
