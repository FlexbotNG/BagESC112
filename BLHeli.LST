MACRO ASSEMBLER BLHELI                                      05/25/15 17:18:21 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
  005D                  49     SKYWALKER_20A_MULTI 			EQU 93 
  0060                  50     SKYWALKER_40A_MULTI 			EQU 96  
  009F                  51     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        52     
                        53     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                        57     
                        58     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                        62     
                        63     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                  64     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                        65     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       675     ENDIF
                       676     
                       677     ;**** **** **** **** ****
                       678     ; TX programming defaults
                       679     ;
                       680     ; Parameter dependencies:
                       681     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       682     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       683     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       684     ; - Damping force is only used if DampedLight or Damped is selected
                       685     ;
                       686     ; Multi
  0009                 687     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 688     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 689     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 690     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 691     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 692     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 693     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 694     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 695     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 696     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       697     IF DAMPED_MODE_ENABLE == 1
  0001                 698     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       699     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 702     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 703     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 704     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                 705     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0028                 706     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 40	; Beacon strength
  0005                 707     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       708     ; Common
  0000                 709     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1=Enabled 	0=Disabled
  0003                 710     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 711     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 712     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (used in bidirectional mode)
  0000                 713     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       714     
                       715     ;**** **** **** **** ****
                       716     ; Constant definitions for multi
                       717     IF MODE == 2
                       718     
  0001                 719     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       720     
  000A                 721     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 722     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 723     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 724     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 725     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 726     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 727     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 728     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       729     
  0032                 730     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 731     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       732     
  000A                 733     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 734     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       735     
  0008                 736     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       737     
                       738     ENDIF
                       739     
                       740     ; Skypup 2015.05.25
  0002                 741     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 742     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       743     
                       744     ;**** **** **** **** ****
                       745     ; Temporary register definitions
  REG                  746     TEMP1		EQU	R0
  REG                  747     TEMP2		EQU	R1
  REG                  748     TEMP3		EQU	R2
  REG                  749     TEMP4		EQU	R3
  REG                  750     TEMP5		EQU	R4
  REG                  751     TEMP6		EQU	R5
  REG                  752     TEMP7		EQU	R6
  REG                  753     TEMP8		EQU	R7
                       754     
                       755     ;**** **** **** **** ****
                       756     ; Register definitions
------                 757     DSEG AT 20H					; Variables segment 
                       758     
0020                   759     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   760     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       761     
0022                   762     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   763     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   764     CURRENT_PWM: 				DS	1		; Current pwm
0025                   765     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   766     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   767     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   768     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   769     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   770     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       771     
002B                   772     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 773     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 774     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 775     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 776     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 777     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       778     ;						EQU 	5
                       779     ;						EQU 	6
                       780     ;						EQU 	7
                       781     
002C                   782     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 783     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 784     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 785     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 786     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 787     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 788     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 789     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       790     ;						EQU 	7
                       791     
002D                   792     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 793     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 794     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 795     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 796     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 797     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 798     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       799     ;						EQU 	6	
                       800     ;						EQU 	7	
                       801     
002E                   802     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 803     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 804     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 805     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 806     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 807     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 808     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 809     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 810     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       811     
                       812     ;**** **** **** **** ****
                       813     ; RAM definitions
------                 814     DSEG AT 30H						; Ram data segment, direct addressing
                       815     
0030                   816     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       817     
0031                   818     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   819     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       820     
0033                   821     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   822     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   823     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   824     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   825     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   826     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   827     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       828     
003A                   829     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   830     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   831     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   832     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   833     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   834     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       835     
0040                   836     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   837     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   838     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   839     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   840     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   841     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   842     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   843     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   844     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   845     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       846     
004A                   847     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   848     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   849     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   850     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   851     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   852     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   853     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   854     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       855     
0052                   856     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   857     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   858     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   859     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   860     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   861     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   862     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   863     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   864     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   865     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   866     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   867     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       868     
005E                   869     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   870     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   871     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   872     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   873     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   874     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       875     
0064                   876     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   877     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       878     
0066                   879     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   880     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       881     
0068                   882     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   883     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   884     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   885     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   886     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       887     
006D                   888     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       889     
006E                   890     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   891     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       892     
0070                   893     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   894     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   895     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       896     
                       897     ; Skypup 2015.05.25
0073                   898     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
0074                   899     RUN_COUNT_L: 				DS	1		; 运行循环计数低位
0075                   900     RUN_COUNT_H: 				DS	1		; 运行循环计数高位
0076                   901     TEMP_SKYPUP: 				DS	1		; 临时变量
                       902     
                       903     ; Indirect addressing data segment. The variables below must be in this sequence
------                 904     ISEG AT 080H					
0080                   905     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                   906     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                   907     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                   908     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                   909     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                   910     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                   911     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                   912     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                   913     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                   914     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                   915     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                   916     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                   917     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                   918     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                   919     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                   920     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                   921     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                   922     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                   923     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                   924     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                   925     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                   926     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                   927     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                   928     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                   929     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                   930     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                   931     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                   932     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                   933     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                   934     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                   935     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                       936     
                       937     ; The sequence of the variables below is no longer of importance
009F                   938     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                   939     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                   940     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                   941     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                   942     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                       943     
                       944     
                       945     ; Indirect addressing data segment
------                 946     ISEG AT 0D0H					
00D0                   947     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                       948     
                       949     
                       950     ;**** **** **** **** ****
------                 951     CSEG AT 1A00H            ; "Eeprom" segment
  000B                 952     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                 953     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                 954     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                       955     
1A00    0B             956     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02             957     EEP_FW_SUB_REVISION:  DB 2 
1A02    11             958     EEP_LAYOUT_REVISION:  DB 17 
                       959     
                       960     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                       993     
                       994     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1027     
                      1028     IF MODE == 2
1A03    09            1029     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1030     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1031     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1032     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1033     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1034     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1035     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1036     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1037     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1038     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1039     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1040     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1041     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1042     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1043     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1044     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1045     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1046     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1047     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1048     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1049     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1050     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1051     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1052     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    28            1053     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    28            1054     EEP_PGM_BEACON_STRENGTH:  DB 40 
1A1D    05            1055     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    0D            1056     EEP_PGM_THROTTLE_RATE:  DB 13 
1A1F    02            1057     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1058     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1059     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1060     ENDIF
                      1061     
                      1062     
1A22    FF            1063     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1064     
------                1065     CSEG AT 1A60H
1A60    6F72672E      1066     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1067     
                      1068     ;**** **** **** **** ****
                      1069             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1069+1   CSEG AT 0  ; CODE SEGMENT START
0000    02126B        1069+1   JMP RESET 
------                1069+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1069+1   JMP T0_INT 
------                1069+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1069+1   JMP T2_INT 
------                1069+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1069+1   JMP PCA_INT 
------                1069+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1069+1   JMP T3_INT 
------                1070     CSEG AT 80H			; Code segment after interrupt vectors 
                      1071     
                      1072     ;**** **** **** **** ****
                      1073     
                      1074     ; Table definitions
0080    02030406      1075     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1076     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1077     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1078     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1079     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1082     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1090     IF MODE == 2
                      1091       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1092     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1093       ENDIF
                      1094       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1097     ENDIF
                      1098     
                      1099     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1100     ;
                      1101     ; Timer0 interrupt routine
                      1102     ;
                      1103     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1104     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1105     ;
                      1106     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1107     T0_INT: 	; Used for pwm control
00BA    C2AF          1108     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1109     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1110     	PUSH	ACC		
                      1111     	; Check if pwm is on
00C0    205A10        1112     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1113     
                      1114     	; Do not execute pwm when stopped
00C3    30600A        1115     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1116     	; Do not execute pwm on during demag recovery
00C6    205C07        1117     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1118     	; Pwm on cycle. 
00C9    302F02        1119     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1120     
                      1121     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1122     	CLR	A					
00CD    73            1123     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1124     
                      1125     T0_INT_PWM_ON_LOW_PWM: 
                      1126     
                      1127     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1128     	JMP	T0_INT_PWM_ON_EXECUTE
                      1129     ENDIF
                      1130     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1147     
                      1148     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1149     	JMP	T0_INT_PWM_ON_EXIT
                      1150     
                      1151     
                      1152     T0_INT_PWM_OFF: 
00D3    306306        1153     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1154     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1154+1   CLR P1 . 2 
00D8    C296          1154+1   CLR P1 . 6 
00DA    C295          1154+1   CLR P1 . 5 
                      1155     T0_INT_PWM_OFF_START_CHECKED: 
                      1156     	; Pwm off cycle
00DC    85258A        1157     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1158     	; Clear pwm on flag
00DF    C25A          1159     CLR FLAGS0 . 2 
                      1160     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1161     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1162     	CPL	A						; Full pwm?
00E4    7002          1163     	JNZ	($+4)					; No - branch
00E6    21C6          1164     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1165     
00E8    0563          1166     	INC	PWM_OFF_CNT				; Increment event counter
                      1167     	; Do not execute pwm when stopped
00EA    306013        1168     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1169     
                      1170     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1171     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1172     
                      1173     	; Separate exit commands here for minimum delay
00F0    758B00        1174     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1175     	POP	ACC			; Restore preserved registers
00F5    D0D0          1176     	POP	PSW
                      1177     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1177+1   CLR P1 . 2 
00F9    C296          1177+1   CLR P1 . 6 
00FB    C295          1177+1   CLR P1 . 5 
00FD    D2AF          1178     	SETB	EA			; Enable all interrupts
00FF    32            1179     	RETI
                      1180     
                      1181     T0_INT_PWM_OFF_STOPPED: 
                      1182     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1182+1   CLR P1 . 2 
0102    C296          1182+1   CLR P1 . 6 
0104    C295          1182+1   CLR P1 . 5 
0106    0201B6        1183     	JMP	T0_INT_PWM_OFF_EXIT
                      1184     
                      1185     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1186     SETB FLAGS1 . 5 
010B    C266          1187     CLR FLAGS1 . 6 
010D    E567          1188     	MOV	A, DAMPING_ON
010F    601C          1189     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1190     
0111    C3            1191     	CLR	C
0112    E563          1192     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1193     	DEC	A
0115    9567          1194     	SUBB	A, DAMPING_ON
0117    4014          1195     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1196     
0119    C265          1197     CLR FLAGS1 . 5 
011B    D266          1198     SETB FLAGS1 . 6 
011D    C3            1199     	CLR	C
011E    E563          1200     	MOV	A, PWM_OFF_CNT					
0120    9566          1201     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1202     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1203     
0124    0201B6        1204     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1205     
                      1206     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1207     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1208     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1209     
                      1210     T0_INT_PWM_OFF_DO_DAMPED: 
                      1211     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1212     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1213     
                      1214     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1214+1   CLR P1 . 2 
0132    C296          1214+1   CLR P1 . 6 
0134    C295          1214+1   CLR P1 . 5 
0136    7406          1215     MOV A , # 6 
0138    D5E0FD        1216     	DJNZ	ACC, $	
                      1217     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1217+1   SETB P1 . 3 
013D    D297          1217+1   SETB P1 . 7 
013F    D294          1217+1   SETB P1 . 4 
0141    0201B6        1218     	JMP	T0_INT_PWM_OFF_EXIT
                      1219     
                      1220     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1221     IF DAMPED_MODE_ENABLE == 1
0144    D266          1222     SETB FLAGS1 . 6 
                      1223     ENDIF
                      1224     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1224+1   CLR P1 . 2 
0148    C296          1224+1   CLR P1 . 6 
014A    C295          1224+1   CLR P1 . 5 
014C    E53E          1225     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1226     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1227     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1228     
                      1229     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1232     MOV A , # 6 
0156    D5E0FD        1233     	DJNZ	ACC, $	
                      1234     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1234+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1234+1   SETB P1 . 7 
015E    307502        1234+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1234+1   SETB P1 . 3 
                      1235     ENDIF
0163    0201B6        1236     	JMP	T0_INT_PWM_OFF_EXIT
                      1237     
                      1238     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1239     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1240     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1243     MOV A , # 6 
016B    D5E0FD        1244     	DJNZ	ACC, $	
                      1245     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1245+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1245+1   SETB P1 . 7 
0173    307502        1245+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1245+1   SETB P1 . 3 
                      1246     ENDIF
0178    0201B6        1247     	JMP	T0_INT_PWM_OFF_EXIT
                      1248     
                      1249     T0_INT_PWM_OFF_COMM_3: 
                      1250     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1253     MOV A , # 6 
017D    D5E0FD        1254     	DJNZ	ACC, $	
                      1255     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1255+1   SETB P1 . 4 
                      1256     ENDIF
0182    0201B6        1257     	JMP	T0_INT_PWM_OFF_EXIT
                      1258     
                      1259     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1260     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1261     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1262     
                      1263     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1266     MOV A , # 6 
018D    D5E0FD        1267     	DJNZ	ACC, $	
                      1268     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1268+1   SETB P1 . 4 
                      1269     ENDIF
0192    0201B6        1270     	JMP	T0_INT_PWM_OFF_EXIT
                      1271     
                      1272     T0_INT_PWM_OFF_COMM_5: 
                      1273     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1276     MOV A , # 6 
0197    D5E0FD        1277     	DJNZ	ACC, $	
                      1278     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1278+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1278+1   SETB P1 . 3 
019F    307502        1278+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1278+1   SETB P1 . 7 
                      1279     ENDIF
01A4    0201B6        1280     	JMP	T0_INT_PWM_OFF_EXIT
                      1281     
                      1282     T0_INT_PWM_OFF_COMM_6: 
                      1283     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1286     MOV A , # 6 
01A9    D5E0FD        1287     	DJNZ	ACC, $	
                      1288     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1288+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1288+1   SETB P1 . 3 
01B1    307502        1288+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1288+1   SETB P1 . 7 
                      1289     ENDIF
                      1290     
                      1291     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1292     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1293     	POP	ACC			; Restore preserved registers
01BB    D0D0          1294     	POP	PSW
                      1295     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1295+1   CLR P1 . 2 
01BF    C296          1295+1   CLR P1 . 6 
01C1    C295          1295+1   CLR P1 . 5 
01C3    D2AF          1296     	SETB	EA			; Enable all interrupts
01C5    32            1297     	RETI
                      1298     
                      1299     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1300     	POP	ACC			; Restore preserved registers
01C8    D0D0          1301     	POP	PSW
01CA    D2AF          1302     	SETB	EA			; Enable all interrupts
01CC    32            1303     	RETI
                      1304     
                      1305     
                      1306     
                      1307     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1308     	AJMP	T0_INT_PWM_ON_EXIT
                      1309     
                      1310     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1311     	ANFET_ON	
01CF    E525          1311+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1311+1   JZ ( $+12 ) 
01D3    207502        1311+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1311+1   SETB P1 . 2 
01D8    307502        1311+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1311+1   SETB P1 . 6 
                      1312     	BNFET_OFF
01DD    C295          1312+1   CLR P1 . 5 
01DF    61D3          1313     	AJMP	T0_INT_PWM_ON_EXIT
                      1314     
                      1315     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1316     	BNFET_ON
01E1    E525          1316+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1316+1   JZ ( $+4 ) 
01E5    D295          1316+1   SETB P1 . 5 
                      1317     	CNFET_OFF
01E7    207502        1317+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1317+1   CLR P1 . 6 
01EC    307502        1317+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1317+1   CLR P1 . 2 
01F1    61D3          1318     	AJMP	T0_INT_PWM_ON_EXIT
                      1319     
                      1320     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1321     	CNFET_ON
01F3    E525          1321+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1321+1   JZ ( $+12 ) 
01F7    207502        1321+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1321+1   SETB P1 . 6 
01FC    307502        1321+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1321+1   SETB P1 . 2 
                      1322     	ANFET_OFF
0201    207502        1322+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1322+1   CLR P1 . 2 
0206    307502        1322+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1322+1   CLR P1 . 6 
020B    61D3          1323     	AJMP	T0_INT_PWM_ON_EXIT
                      1324     
                      1325     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1326     	APFET_OFF
020D    207502        1326+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1326+1   CLR P1 . 3 
0212    307502        1326+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1326+1   CLR P1 . 7 
                      1327     	ANFET_ON								; Switch nFETs
0217    E525          1327+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1327+1   JZ ( $+12 ) 
021B    207502        1327+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1327+1   SETB P1 . 2 
0220    307502        1327+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1327+1   SETB P1 . 6 
                      1328     	CPFET_OFF
0225    207502        1328+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1328+1   CLR P1 . 7 
022A    307502        1328+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1328+1   CLR P1 . 3 
                      1329     	BNFET_OFF 							
022F    C295          1329+1   CLR P1 . 5 
0231    61D3          1330     	AJMP	T0_INT_PWM_ON_EXIT
                      1331     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1332     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1333     	APFET_OFF
0233    207502        1333+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1333+1   CLR P1 . 3 
0238    307502        1333+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1333+1   CLR P1 . 7 
                      1334     	CPFET_OFF
023D    207502        1334+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1334+1   CLR P1 . 7 
0242    307502        1334+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1334+1   CLR P1 . 3 
0247    7406          1335     MOV A , # 6 
0249    D5E0FD        1336     	DJNZ ACC,	$
                      1337     	ANFET_ON								; Switch nFETs
024C    E525          1337+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1337+1   JZ ( $+12 ) 
0250    207502        1337+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1337+1   SETB P1 . 2 
0255    307502        1337+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1337+1   SETB P1 . 6 
                      1338     	BNFET_OFF 							
025A    C295          1338+1   CLR P1 . 5 
025C    61D3          1339     	AJMP	T0_INT_PWM_ON_EXIT
                      1340     
                      1341     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1342     	APFET_OFF
025E    207502        1342+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1342+1   CLR P1 . 3 
0263    307502        1342+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1342+1   CLR P1 . 7 
                      1343     	ANFET_ON								; Switch nFETs
0268    E525          1343+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1343+1   JZ ( $+12 ) 
026C    207502        1343+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1343+1   SETB P1 . 2 
0271    307502        1343+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1343+1   SETB P1 . 6 
                      1344     	BPFET_OFF
0276    C294          1344+1   CLR P1 . 4 
                      1345     	BNFET_OFF								
0278    C295          1345+1   CLR P1 . 5 
027A    61D3          1346     	AJMP	T0_INT_PWM_ON_EXIT
                      1347     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1348     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1349     	APFET_OFF
027C    207502        1349+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1349+1   CLR P1 . 3 
0281    307502        1349+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1349+1   CLR P1 . 7 
                      1350     	BPFET_OFF
0286    C294          1350+1   CLR P1 . 4 
0288    7406          1351     MOV A , # 6 
028A    D5E0FD        1352     	DJNZ ACC,	$
                      1353     	ANFET_ON								; Switch nFETs
028D    E525          1353+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1353+1   JZ ( $+12 ) 
0291    207502        1353+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1353+1   SETB P1 . 2 
0296    307502        1353+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1353+1   SETB P1 . 6 
                      1354     	BNFET_OFF								
029B    C295          1354+1   CLR P1 . 5 
029D    61D3          1355     	AJMP	T0_INT_PWM_ON_EXIT
                      1356     
                      1357     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1358     	BPFET_OFF
029F    C294          1358+1   CLR P1 . 4 
                      1359     	BNFET_ON								; Switch nFETs
02A1    E525          1359+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1359+1   JZ ( $+4 ) 
02A5    D295          1359+1   SETB P1 . 5 
                      1360     	APFET_OFF
02A7    207502        1360+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1360+1   CLR P1 . 3 
02AC    307502        1360+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1360+1   CLR P1 . 7 
                      1361     	CNFET_OFF								
02B1    207502        1361+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1361+1   CLR P1 . 6 
02B6    307502        1361+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1361+1   CLR P1 . 2 
02BB    61D3          1362     	AJMP	T0_INT_PWM_ON_EXIT
                      1363     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1364     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1365     	BPFET_OFF
02BD    C294          1365+1   CLR P1 . 4 
                      1366     	APFET_OFF
02BF    207502        1366+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1366+1   CLR P1 . 3 
02C4    307502        1366+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1366+1   CLR P1 . 7 
02C9    7406          1367     MOV A , # 6 
02CB    D5E0FD        1368     	DJNZ ACC,	$
                      1369     	BNFET_ON								; Switch nFETs
02CE    E525          1369+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1369+1   JZ ( $+4 ) 
02D2    D295          1369+1   SETB P1 . 5 
                      1370     	CNFET_OFF								
02D4    207502        1370+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1370+1   CLR P1 . 6 
02D9    307502        1370+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1370+1   CLR P1 . 2 
02DE    61D3          1371     	AJMP	T0_INT_PWM_ON_EXIT
                      1372     
                      1373     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1374     	BPFET_OFF
02E0    C294          1374+1   CLR P1 . 4 
                      1375     	BNFET_ON								; Switch nFETs
02E2    E525          1375+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1375+1   JZ ( $+4 ) 
02E6    D295          1375+1   SETB P1 . 5 
                      1376     	CPFET_OFF
02E8    207502        1376+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1376+1   CLR P1 . 7 
02ED    307502        1376+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1376+1   CLR P1 . 3 
                      1377     	CNFET_OFF								
02F2    207502        1377+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1377+1   CLR P1 . 6 
02F7    307502        1377+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1377+1   CLR P1 . 2 
02FC    61D3          1378     	AJMP	T0_INT_PWM_ON_EXIT
                      1379     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1380     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1381     	BPFET_OFF
02FE    C294          1381+1   CLR P1 . 4 
                      1382     	CPFET_OFF
0300    207502        1382+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1382+1   CLR P1 . 7 
0305    307502        1382+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1382+1   CLR P1 . 3 
030A    7406          1383     MOV A , # 6 
030C    D5E0FD        1384     	DJNZ ACC,	$
                      1385     	BNFET_ON								; Switch nFETs
030F    E525          1385+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1385+1   JZ ( $+4 ) 
0313    D295          1385+1   SETB P1 . 5 
                      1386     	CNFET_OFF								
0315    207502        1386+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1386+1   CLR P1 . 6 
031A    307502        1386+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1386+1   CLR P1 . 2 
031F    61D3          1387     	AJMP	T0_INT_PWM_ON_EXIT
                      1388     
                      1389     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1390     	CPFET_OFF
0321    207502        1390+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1390+1   CLR P1 . 7 
0326    307502        1390+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1390+1   CLR P1 . 3 
                      1391     	CNFET_ON								; Switch nFETs
032B    E525          1391+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1391+1   JZ ( $+12 ) 
032F    207502        1391+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1391+1   SETB P1 . 6 
0334    307502        1391+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1391+1   SETB P1 . 2 
                      1392     	BPFET_OFF
0339    C294          1392+1   CLR P1 . 4 
                      1393     	ANFET_OFF								
033B    207502        1393+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1393+1   CLR P1 . 2 
0340    307502        1393+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1393+1   CLR P1 . 6 
0345    61D3          1394     	AJMP	T0_INT_PWM_ON_EXIT
                      1395     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1396     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1397     	CPFET_OFF
0347    207502        1397+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1397+1   CLR P1 . 7 
034C    307502        1397+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1397+1   CLR P1 . 3 
                      1398     	BPFET_OFF
0351    C294          1398+1   CLR P1 . 4 
0353    7406          1399     MOV A , # 6 
0355    D5E0FD        1400     	DJNZ ACC,	$
                      1401     	CNFET_ON								; Switch nFETs
0358    E525          1401+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1401+1   JZ ( $+12 ) 
035C    207502        1401+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1401+1   SETB P1 . 6 
0361    307502        1401+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1401+1   SETB P1 . 2 
                      1402     	ANFET_OFF								
0366    207502        1402+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1402+1   CLR P1 . 2 
036B    307502        1402+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1402+1   CLR P1 . 6 
0370    61D3          1403     	AJMP	T0_INT_PWM_ON_EXIT
                      1404     
                      1405     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1406     	CPFET_OFF
0372    207502        1406+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1406+1   CLR P1 . 7 
0377    307502        1406+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1406+1   CLR P1 . 3 
                      1407     	CNFET_ON								; Switch nFETs
037C    E525          1407+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1407+1   JZ ( $+12 ) 
0380    207502        1407+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1407+1   SETB P1 . 6 
0385    307502        1407+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1407+1   SETB P1 . 2 
                      1408     	APFET_OFF
038A    207502        1408+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1408+1   CLR P1 . 3 
038F    307502        1408+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1408+1   CLR P1 . 7 
                      1409     	ANFET_OFF								
0394    207502        1409+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1409+1   CLR P1 . 2 
0399    307502        1409+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1409+1   CLR P1 . 6 
039E    61D3          1410     	AJMP	T0_INT_PWM_ON_EXIT
                      1411     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1412     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1413     	CPFET_OFF
03A0    207502        1413+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1413+1   CLR P1 . 7 
03A5    307502        1413+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1413+1   CLR P1 . 3 
                      1414     	APFET_OFF
03AA    207502        1414+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1414+1   CLR P1 . 3 
03AF    307502        1414+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1414+1   CLR P1 . 7 
03B4    7406          1415     MOV A , # 6 
03B6    D5E0FD        1416     	DJNZ ACC,	$
                      1417     	CNFET_ON								; Switch nFETs
03B9    E525          1417+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1417+1   JZ ( $+12 ) 
03BD    207502        1417+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1417+1   SETB P1 . 6 
03C2    307502        1417+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1417+1   SETB P1 . 2 
                      1418     	ANFET_OFF								
03C7    207502        1418+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1418+1   CLR P1 . 2 
03CC    307502        1418+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1418+1   CLR P1 . 6 
03D1    61D3          1419     	AJMP	T0_INT_PWM_ON_EXIT
                      1420     
                      1421     T0_INT_PWM_ON_EXIT: 
                      1422     	; Set timer for coming on cycle length
03D3    E525          1423     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1424     	CPL	A						; cpl is 255-x
03D6    F58A          1425     	MOV	TL0, A					; Write start point for timer
                      1426     	; Set other variables
03D8    758B00        1427     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1428     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1429     SETB FLAGS0 . 2 
                      1430     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1431     	; Exit interrupt
03E0    D0E0          1432     	POP	ACC			; Restore preserved registers
03E2    D0D0          1433     	POP	PSW
03E4    D2AF          1434     	SETB	EA			; Enable all interrupts
03E6    32            1435     	RETI
                      1436     
                      1437     
                      1438     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1439     ;
                      1440     ; Timer2 interrupt routine
                      1441     ;
                      1442     ; No assumptions
                      1443     ;
                      1444     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1445     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1446     	CLR	EA
03E9    C2AD          1447     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1448     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1449     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1450     	PUSH	ACC
03F2    D2D3          1451     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1452     	SETB	EA
                      1453     	; Clear low byte interrupt flag
03F6    C2CE          1454     	CLR	TF2L						; Clear interrupt flag
                      1455     	; Check RC pulse timeout counter
03F8    E528          1456     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1457     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1458     
                      1459     	; Decrement timeout counter (if PWM)
03FC    741F          1460     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1461     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1462     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1463     
0402    1528          1464     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1465     	AJMP	T2_INT_SKIP_START
                      1466     
                      1467     T2_INT_PULSES_ABSENT: 
                      1468     	; Timeout counter has reached zero, pulses are absent
0406    7800          1469     MOV R0 , # 0 
0408    7900          1470     MOV R1 , # 0 
                      1471     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1471+1   MOV A , P0 
040C    307601        1471+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1471+1   CPL A  ; YES - INVERT
0410    30E502        1472     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1473     MOV R0 , # 255 
                      1474     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1474+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1474+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1474+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1474+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1474+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1475     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1475+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1476     CLR FLAGS2 . 1 
                      1477     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1477+1   MOV A , P0 
042A    307601        1477+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1477+1   CPL A  ; YES - INVERT
042E    30E502        1478     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1479     MOV R1 , # 255 
0433    C3            1480     	CLR	C
0434    E8            1481     MOV A , R0 
0435    99            1482     SUBB A , R1 
0436    70CE          1483     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1484     
0438    305903        1485     JNB FLAGS0 . 1 , ( $+6 ) 
                      1486     
043B    752818        1487     MOV RCP_TIMEOUT_CNT , # 24 
                      1488     
043E    741F          1489     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1490     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1491     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1492     
0444    752818        1493     MOV RCP_TIMEOUT_CNT , # 24 
                      1494     
                      1495     
                      1496     T2_INT_PPM_TIMEOUT_SET: 
                      1497     
                      1498     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1499     ; 
                      1500     ; 对 RCP 信号处理
                      1501     ; 1 小于 1500us 最低油门
                      1502     ; 2 大于 1500us 正常处理
                      1503     ; 
                      1504     ;	clr C
                      1505     ;	mov A, Temp1
                      1506     ;	subb A, #80h
                      1507     ;	jnc skypup_01
                      1508     ;	mov	Temp1, #RCP_MIN
                      1509     ; skypup_01:
                      1510     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
0447    8859          1511     MOV NEW_RCP , R0 
0449    D268          1512     SETB FLAGS2 . 0 
                      1513     
                      1514     T2_INT_SKIP_START: 
                      1515     	; Check RC pulse skip counter
044B    E529          1516     	MOV	A, RCP_SKIP_CNT			
044D    6004          1517     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1518     	
                      1519     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1520     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1521     	AJMP	T2_INT_RCP_UPDATE_START
                      1522     
                      1523     T2_INT_SKIP_END: 
0453    741F          1524     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1525     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1526     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1527     
                      1528     	; Skip counter has reached zero, start looking for RC pulses again
                      1529     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1529+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1530     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1530+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1531     	
                      1532     T2_INT_RCP_UPDATE_START: 
                      1533     	; Process updated RC pulse
045E    206802        1534     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1535     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1536     
0463    E559          1537     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1538     MOV R0 , A 
0466    C268          1539     CLR FLAGS2 . 0 
                      1540     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1541     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1542     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1543     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1544     
                      1545     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1548     
                      1549     IF MODE == 2	; Multi
046E    7982          1550     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1551     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1552     ENDIF
                      1553     
                      1554     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1555     	CLR	C
0474    E8            1556     MOV A , R0 
0475    94F0          1557     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1558     	JC	T2_INT_RCP_UPDATE_MULT
                      1559     
0479    74F0          1560     	MOV	A, #240			; Set requested pwm to max
047B    F8            1561     MOV R0 , A 
                      1562     
                      1563     T2_INT_RCP_UPDATE_MULT: 	
                      1564     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1565     MOV A , R0 
047D    C4            1566     	SWAP	A			; After this "0.0625"
047E    540F          1567     	ANL	A, #0FH
0480    28            1568     ADD A , R0 
0481    F8            1569     MOV R0 , A 
                      1570     	; Adjust tail gain
0482    7984          1571     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1572     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1573     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1574     
0489    C3            1575     	CLR	C
048A    13            1576     	RRC	A			; After this "0.5"
048B    C3            1577     	CLR	C
048C    13            1578     	RRC	A			; After this "0.25"
048D    8721          1579     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1580     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1581     
0492    C3            1582     	CLR	C
0493    13            1583     	RRC	A			; After this "0.125"
                      1584     
                      1585     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1586     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1587     
0497    C3            1588     	CLR	C
0498    C8            1589     XCH A , R0 
0499    98            1590     SUBB A , R0 
049A    F8            1591     MOV R0 , A 
049B    81A4          1592     	AJMP	T2_INT_PWM_MIN_RUN
                      1593     
                      1594     T2_INT_RCP_GAIN_POS: 
049D    28            1595     ADD A , R0 
049E    F8            1596     MOV R0 , A 
049F    5003          1597     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1598     
04A1    74FF          1599     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1600     MOV R0 , A 
                      1601     
                      1602     T2_INT_PWM_MIN_RUN:  
                      1603     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1613     
                      1614     T2_INT_PWM_UPDATE:  
                      1615     	; Check if any startup phase flags are set
04A4    E52C          1616     	MOV	A, FLAGS1
04A6    5406          1617     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1618     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1619     
                      1620     	; Update requested_pwm
04AA    8822          1621     MOV REQUESTED_PWM , R0 
                      1622     	; Limit pwm during direct start
04AC    30630A        1623     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1624     
04AF    C3            1625     	CLR	C
04B0    E522          1626     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1627     	SUBB	A, PWM_LIMIT
04B4    4003          1628     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1629     
04B6    855E22        1630     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1631     
                      1632     T2_INT_CURRENT_PWM_UPDATE:  
                      1633     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1634     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1635     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1636     ENDIF
                      1637     
                      1638     	; Update current pwm, with limited throttle change rate
04BE    C3            1639     	CLR	C
04BF    E522          1640     	MOV	A, REQUESTED_PWM	 
04C1    9524          1641     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1642     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1643     
                      1644     	; 缓启动
04C5    78A1          1645     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1646     	;mov	Temp1, #1
04C7    96            1647     SUBB A , @ R0 
                      1648     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1649     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1650     
04CA    E524          1651     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1652     ADD A , @ R0 
                      1653     	; add	A, Temp1
04CD    F524          1654     	MOV	CURRENT_PWM, A
04CF    5009          1655     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1656     
04D1    7524FF        1657     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1658     	JMP	T2_INT_CURRENT_PWM_DONE
                      1659     
                      1660     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1661     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1662     T2_INT_CURRENT_PWM_DONE: 
                      1663     IF MODE >= 1	; Tail or multi
                      1664     	; Set current_pwm_limited
04DA    A824          1665     MOV R0 , CURRENT_PWM 
04DC    C3            1666     	CLR	C
04DD    E524          1667     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1668     	SUBB	A, PWM_LIMIT
04E1    4002          1669     	JC	($+4)					; If current pwm below limit - branch
                      1670     
04E3    A85E          1671     MOV R0 , PWM_LIMIT 
                      1672     
04E5    8825          1673     MOV CURRENT_PWM_LIMITED , R0 
                      1674     ENDIF
                      1675     T2_INT_PWM_EXIT: 	
                      1676     	; Check if high byte flag is set
04E7    20CF0C        1677     	JB	TF2H, T2H_INT		
04EA    D0E0          1678     	POP	ACC			; Restore preserved registers
04EC    D0D0          1679     	POP	PSW
04EE    C2D3          1680     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1681     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1682     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1683     	RETI
                      1684     
                      1685     T2H_INT: 
                      1686     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1687     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1688     MOV R0 , # 1 
                      1689     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1690     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1691     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1692     
                      1693     	; Decrement timeout counter (if PPM)
04FE    741F          1694     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1695     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1696     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1697     
0504    1528          1698     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1699     
                      1700     T2H_INT_RCP_STOP_CHECK: 
                      1701     	; Check RC pulse against stop value
0506    C3            1702     	CLR	C
0507    E559          1703     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1704     SUBB A , # 1 
050B    4005          1705     	JC	T2H_INT_RCP_STOP
                      1706     
                      1707     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1708     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1709     	AJMP	T2H_INT_RCP_GOV_PWM
                      1710     
                      1711     T2H_INT_RCP_STOP: 	
                      1712     	; RC pulse less than stop value
0512    755D00        1713     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1714     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1715     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1716     	ADD	A, #1
051C    F55C          1717     	MOV	RCP_STOP_CNT, A
051E    5003          1718     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1719     
0520    755CFF        1720     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1721     
                      1722     T2H_INT_RCP_GOV_PWM: 
                      1723     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1852     IF MODE == 2	; Multi
0523    E55F          1853     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1854     	ADD	A, #10
0527    5005          1855     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1856     
0529    755FFF        1857     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1858     	AJMP	T2H_INT_RCP_EXIT
                      1859     
                      1860     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1861     	MOV	PWM_LIMIT_SPOOLUP, A
                      1862     ENDIF
                      1863     
                      1864     T2H_INT_RCP_EXIT: 
0530    D0E0          1865     	POP	ACC			; Restore preserved registers
0532    D0D0          1866     	POP	PSW
0534    C2D3          1867     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1868     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1869     	SETB	ET2			; Enable timer2 interrupts
053B    32            1870     	RETI
                      1871     
                      1872     
                      1873     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1874     ;
                      1875     ; Timer3 interrupt routine
                      1876     ;
                      1877     ; No assumptions
                      1878     ;
                      1879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1880     T3_INT: 	; Used for commutation timing
053C    C2AF          1881     	CLR 	EA			; Disable all interrupts
053E    53917F        1882     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1883     CLR FLAGS0 . 0 
0543    D2AF          1884     	SETB	EA			; Enable all interrupts
0545    32            1885     	RETI
                      1886     
                      1887     
                      1888     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1889     ;
                      1890     ; PCA interrupt routine
                      1891     ;
                      1892     ; No assumptions
                      1893     ;
                      1894     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1895     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          1896     	CLR	EA
0548    53E6EF        1897     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          1898     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          1899     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          1900     	PUSH	ACC
0551    C0F0          1901     	PUSH	B
0553    D2D3          1902     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          1903     	SETB	EA
                      1904     	; Get the PCA counter values
                      1905     	GET_RCP_CAPTURE_VALUES
0557    A8FB          1905+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          1905+1   MOV R1 , PCA0CPH0 
                      1906     	; Clear interrupt flag
                      1907     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          1907+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1908     	; Check which edge it is
055D    306902        1909     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          1910     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      1911     
                      1912     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        1912+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        1912+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        1912+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        1912+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        1912+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          1913     SETB FLAGS2 . 1 
                      1914     	; Read RC signal level
                      1915     	READ_RCP_INT			
0573    E580          1915+1   MOV A , P0 
0575    307601        1915+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            1915+1   CPL A  ; YES - INVERT
                      1916     	; Test RC signal level
0579    20E502        1917     JB ACC . 5 , ( $+5 ) 
057C    A185          1918     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      1919     
                      1920     	; RC pulse was high, store RC pulse start timestamp
057E    8826          1921     MOV RCP_PREV_EDGE_L , R0 
0580    8927          1922     MOV RCP_PREV_EDGE_H , R1 
0582    0207D1        1923     	LJMP	PCA_INT_EXIT				; Exit
                      1924     
                      1925     PCA_INT_FAIL_MINIMUM: 
                      1926     	; Prepare for next interrupt
                      1927     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        1927+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        1927+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        1927+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        1927+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        1927+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1928     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          1928+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          1929     CLR FLAGS2 . 1 
0598    741F          1930     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          1931     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          1932     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      1933     
059E    E1B7          1934     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      1935     
05A0    7800          1936     MOV R0 , # 0 
                      1937     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          1937+1   MOV A , P0 
05A4    307601        1937+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            1937+1   CPL A  ; YES - INVERT
05A8    30E502        1938     JNB ACC . 5 , ( $+5 ) 
05AB    E1B7          1939     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      1940     
                      1941     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1942     ; 
                      1943     ; 对 RCP 信号处理
                      1944     ; 1 小于 1500us 最低油门
                      1945     ; 2 大于 1500us 正常处理
                      1946     ; 
                      1947     ;	clr C
                      1948     ;	mov A, Temp1
                      1949     ;	subb A, #80h
                      1950     ;	jnc skypup_02
                      1951     ;	mov	Temp1, #RCP_MIN
                      1952     ; skypup_02:
                      1953     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      1954     
05AD    8859          1955     MOV NEW_RCP , R0 
05AF    E186          1956     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      1957     
                      1958     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      1959     	; Prepare for next interrupt
                      1960     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        1960+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        1960+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        1960+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        1960+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        1960+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          1961     CLR FLAGS2 . 1 
                      1962     	; Check if pwm frequency shall be measured
05C2    205902        1963     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          1964     	AJMP	PCA_INT_FALL				; No - skip measurements
                      1965     
                      1966     	; Set second edge trig only during pwm frequency measurement
                      1967     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        1967+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        1967+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        1967+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        1967+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        1967+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      1968     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          1968+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          1969     SETB FLAGS2 . 1 
                      1970     	; Store edge data to RAM
05DA    8854          1971     MOV RCP_EDGE_L , R0 
05DC    8955          1972     MOV RCP_EDGE_H , R1 
                      1973     	; Calculate pwm frequency
05DE    C3            1974     	CLR	C
05DF    E8            1975     MOV A , R0 
05E0    9552          1976     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            1977     MOV R0 , A 
05E3    E9            1978     MOV A , R1 
05E4    9553          1979     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            1980     MOV R1 , A 
05E7    E4            1981     	CLR	A
05E8    FB            1982     MOV R3 , A 
05E9    7AFA          1983     MOV R2 , # 250 
                      1984     	; Check if pwm frequency is 12kHz
05EB    C3            1985     	CLR	C
05EC    E8            1986     MOV A , R0 
05ED    94C8          1987     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            1988     MOV A , R1 
05F0    9400          1989     	SUBB	A, #HIGH(200)
05F2    5008          1990     	JNC	PCA_INT_CHECK_8KHZ
                      1991     
05F4    E4            1992     	CLR	A
05F5    D2E4          1993     SETB ACC . 4 
05F7    FB            1994     MOV R3 , A 
05F8    7A0A          1995     MOV R2 , # 10 
05FA    C13E          1996     	AJMP	PCA_INT_RESTORE_EDGE
                      1997     
                      1998     PCA_INT_CHECK_8KHZ: 
                      1999     	; Check if pwm frequency is 8kHz
05FC    C3            2000     	CLR	C
05FD    E8            2001     MOV A , R0 
05FE    9468          2002     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            2003     MOV A , R1 
0601    9401          2004     	SUBB	A, #HIGH(360)
0603    5008          2005     	JNC	PCA_INT_CHECK_4KHZ
                      2006     
0605    E4            2007     	CLR	A
0606    D2E3          2008     SETB ACC . 3 
0608    FB            2009     MOV R3 , A 
0609    7A0F          2010     MOV R2 , # 15 
060B    C13E          2011     	AJMP	PCA_INT_RESTORE_EDGE
                      2012     
                      2013     PCA_INT_CHECK_4KHZ: 
                      2014     	; Check if pwm frequency is 4kHz
060D    C3            2015     	CLR	C
060E    E8            2016     MOV A , R0 
060F    94D0          2017     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2018     MOV A , R1 
0612    9402          2019     	SUBB	A, #HIGH(720)
0614    5008          2020     	JNC	PCA_INT_CHECK_2KHZ
                      2021     
0616    E4            2022     	CLR	A
0617    D2E2          2023     SETB ACC . 2 
0619    FB            2024     MOV R3 , A 
061A    7A1E          2025     MOV R2 , # 30 
061C    C13E          2026     	AJMP	PCA_INT_RESTORE_EDGE
                      2027     
                      2028     PCA_INT_CHECK_2KHZ: 
                      2029     	; Check if pwm frequency is 2kHz
061E    C3            2030     	CLR	C
061F    E8            2031     MOV A , R0 
0620    94A0          2032     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2033     MOV A , R1 
0623    9405          2034     	SUBB	A, #HIGH(1440)
0625    5008          2035     	JNC	PCA_INT_CHECK_1KHZ
                      2036     
0627    E4            2037     	CLR	A
0628    D2E1          2038     SETB ACC . 1 
062A    FB            2039     MOV R3 , A 
062B    7A3C          2040     MOV R2 , # 60 
062D    C13E          2041     	AJMP	PCA_INT_RESTORE_EDGE
                      2042     
                      2043     PCA_INT_CHECK_1KHZ: 
                      2044     	; Check if pwm frequency is 1kHz
062F    C3            2045     	CLR	C
0630    E8            2046     MOV A , R0 
0631    9498          2047     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2048     MOV A , R1 
0634    9408          2049     	SUBB	A, #HIGH(2200)
0636    5006          2050     	JNC	PCA_INT_RESTORE_EDGE
                      2051     
0638    E4            2052     	CLR	A
0639    D2E0          2053     SETB ACC . 0 
063B    FB            2054     MOV R3 , A 
063C    7A78          2055     MOV R2 , # 120 
                      2056     
                      2057     PCA_INT_RESTORE_EDGE: 
                      2058     	; Calculate difference between this period and previous period
063E    C3            2059     	CLR	C
063F    E8            2060     MOV A , R0 
0640    9556          2061     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2062     MOV R4 , A 
0643    E9            2063     MOV A , R1 
0644    9557          2064     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2065     MOV R5 , A 
                      2066     	; Make positive
0647    30E708        2067     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2068     MOV A , R4 
064B    F4            2069     	CPL	A
064C    2401          2070     	ADD	A, #1
064E    FC            2071     MOV R4 , A 
064F    ED            2072     MOV A , R5 
0650    F4            2073     	CPL	A
0651    FD            2074     MOV R5 , A 
                      2075     
                      2076     PCA_INT_CHECK_DIFF: 
                      2077     	; Check difference
0652    755800        2078     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2079     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2080     
0657    C3            2081     	CLR	C
0658    EC            2082     MOV A , R4 
0659    9A            2083     SUBB A , R2 
065A    5003          2084     	JNC	PCA_INT_STORE_DATA
                      2085     
065C    755801        2086     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2087     
                      2088     PCA_INT_STORE_DATA: 
                      2089     	; Store previous period
065F    8856          2090     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2091     MOV RCP_PREV_PERIOD_H , R1 
                      2092     	; Restore edge data from RAM
0663    A854          2093     MOV R0 , RCP_EDGE_L 
0665    A955          2094     MOV R1 , RCP_EDGE_H 
                      2095     	; Store pre previous edge
0667    8852          2096     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2097     MOV RCP_PREPREV_EDGE_H , R1 
                      2098     
                      2099     PCA_INT_FALL: 
                      2100     	; RC pulse edge was second, calculate new pulse length
066B    C3            2101     	CLR	C
066C    E8            2102     MOV A , R0 
066D    9526          2103     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2104     MOV R0 , A 
0670    E9            2105     MOV A , R1 
0671    9527          2106     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2107     MOV R1 , A 
0674    307402        2108     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2109     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2110     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2111     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2112     
067E    307202        2113     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2114     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2115     
0683    E9            2116     MOV A , R1 
0684    C3            2117     	CLR	C
0685    13            2118     	RRC	A
0686    F9            2119     MOV R1 , A 
0687    E8            2120     MOV A , R0 
0688    13            2121     	RRC	A
0689    F8            2122     MOV R0 , A 
                      2123     
068A    307102        2124     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2125     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2126     
068F    E9            2127     MOV A , R1 
0690    C3            2128     	CLR	C
0691    13            2129     	RRC	A
0692    F9            2130     MOV R1 , A 
0693    E8            2131     MOV A , R0 
0694    13            2132     	RRC	A
0695    F8            2133     MOV R0 , A 
                      2134     
0696    307002        2135     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2136     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2137     
069B    E9            2138     MOV A , R1 
069C    C3            2139     	CLR	C
069D    13            2140     	RRC	A
069E    FD            2141     MOV R5 , A 
069F    E8            2142     MOV A , R0 
06A0    13            2143     	RRC	A
06A1    FC            2144     MOV R4 , A 
                      2145     	; Skip range limitation if pwm frequency measurement
06A2    205918        2146     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2147     
                      2148     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2149     	CLR	C
06A6    EC            2150     MOV A , R4 
06A7    941C          2151     	SUBB	A, #28
06A9    ED            2152     MOV A , R5 
06AA    9402          2153     	SUBB A, #2
06AC    4003          2154     	JC	($+5)						; No - proceed
                      2155     
06AE    0207B7        2156     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2157     
                      2158     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2159     MOV A , R5 
06B2    7009          2160     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2161     
06B4    C3            2162     	CLR	C
06B5    EC            2163     MOV A , R4 
06B6    94C8          2164     	SUBB	A, #200
06B8    5003          2165     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2166     
06BA    0207B7        2167     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2168     
                      2169     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2170     	; Calculate "1000us" plus throttle minimum
06BD    7400          2171     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2172     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2173     
                      2174     IF MODE >= 1	; Tail or multi
06C2    7888          2175     MOV R0 , # PGM_DIRECTION 
06C4    E6            2176     MOV A , @ R0 
                      2177     ENDIF
06C5    7896          2178     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2179     IF MODE >= 1	; Tail or multi
06C7    B40302        2180     	CJNE	A, #3, ($+5)
                      2181     
06CA    789E          2182     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2183     ENDIF
06CC    E6            2184     MOV A , @ R0 
                      2185     
                      2186     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2187     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2188     MOV R6 , A 
06D0    E4            2189     	CLR	A
06D1    3400          2190     	ADDC	A, #0
06D3    FF            2191     MOV R7 , A 
                      2192     
06D4    C3            2193     	CLR	C
06D5    EC            2194     MOV A , R4 
06D6    9E            2195     SUBB A , R6 
06D7    FC            2196     MOV R4 , A 
06D8    ED            2197     MOV A , R5 
06D9    9F            2198     SUBB A , R7 
06DA    FD            2199     MOV R5 , A 
                      2200     IF MODE >= 1	; Tail or multi
06DB    9208          2201     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2202     MOV R0 , # PGM_DIRECTION 
06DF    E6            2203     MOV A , @ R0 
06E0    B40322        2204     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2205     
06E3    A208          2206     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2207     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2208     
                      2209     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2210     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2211     
06EA    C2AF          2212     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2213     SETB FLAGS3 . 5 
06EE    C1F7          2214     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2215     
                      2216     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2217     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2218     
06F3    C2AF          2219     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2220     CLR FLAGS3 . 5 
                      2221     
                      2222     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2223     	ALL_NFETS_OFF
06F7    C292          2223+1   CLR P1 . 2 
06F9    C296          2223+1   CLR P1 . 6 
06FB    C295          2223+1   CLR P1 . 5 
                      2224     	ALL_PFETS_OFF
06FD    C293          2224+1   CLR P1 . 3 
06FF    C297          2224+1   CLR P1 . 7 
0701    C294          2224+1   CLR P1 . 4 
0703    D2AF          2225     	SETB	EA
                      2226     
                      2227     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2228     	MOV	C, BIT_ACCESS_INT.0
                      2229     ENDIF
0707    5017          2230     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2231     
                      2232     IF MODE >= 1	; Tail or multi
0709    E6            2233     MOV A , @ R0 
070A    B4030D        2234     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2235     
070D    EC            2236     MOV A , R4 
070E    F4            2237     	CPL	A
070F    2401          2238     	ADD	A, #1
0711    FC            2239     MOV R4 , A 
0712    ED            2240     MOV A , R5 
0713    F4            2241     	CPL	A
0714    3400          2242     	ADDC	A, #0
0716    FD            2243     MOV R5 , A 
0717    020720        2244     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2245     
                      2246     PCA_INT_PPM_UNIDIR_NEG: 
                      2247     ENDIF
071A    7800          2248     MOV R0 , # 0 
071C    7900          2249     MOV R1 , # 0 
071E    E16A          2250     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2251     
                      2252     PCA_INT_PPM_NEG_CHECKED: 
                      2253     IF MODE >= 1	; Tail or multi
0720    7888          2254     MOV R0 , # PGM_DIRECTION 
0722    E6            2255     MOV A , @ R0 
0723    B40315        2256     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2257     
0726    EC            2258     MOV A , R4 
0727    33            2259     	RLC	A
0728    FC            2260     MOV R4 A 
0729    ED            2261     MOV A , R5 
072A    33            2262     	RLC	A
072B    FD            2263     MOV R5 A 
072C    C3            2264     	CLR	C							; Subtract deadband
072D    EC            2265     MOV A , R4 
072E    9405          2266     	SUBB	A, #5		
0730    FC            2267     MOV R4 , A 
0731    ED            2268     MOV A , R5 
0732    9400          2269     	SUBB	A, #0
0734    FD            2270     MOV R5 , A 
0735    5004          2271     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2272     
0737    7C00          2273     MOV R4 , # 0 
0739    7D00          2274     MOV R5 , # 0 
                      2275     
                      2276     PCA_INT_PPM_BIDIR_DONE: 
                      2277     ENDIF
073B    C3            2278     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2279     MOV A , R4 
073D    94FF          2280     SUBB A , # 255 
073F    ED            2281     MOV A , R5 
0740    9400          2282     	SUBB	A, #0
0742    4006          2283     	JC	PCA_INT_PPM_MAX_CHECKED
                      2284     
0744    78FF          2285     MOV R0 , # 255 
0746    7900          2286     MOV R1 , # 0 
0748    E16A          2287     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2288     
                      2289     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2290     MOV A , R4 
074B    856EF0        2291     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2292     	MUL	AB
074F    C5F0          2293     	XCH	A, B
0751    A2F7          2294     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2295     	RLC	A
0754    F8            2296     MOV R0 , A 
0755    7900          2297     MOV R1 , # 0 
0757    4003          2298     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2299     	
0759    020786        2300     	JMP	PCA_INT_LIMITED			
                      2301     
                      2302     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2303     MOV R0 , # 255 
075E    7900          2304     MOV R1 , # 0 
0760    020786        2305     	JMP	PCA_INT_LIMITED			
                      2306     
                      2307     PCA_INT_PWM_DIVIDE: 
0763    E9            2308     MOV A , R1 
0764    C3            2309     	CLR	C
0765    13            2310     	RRC	A
0766    F9            2311     MOV R1 , A 
0767    E8            2312     MOV A , R0 
0768    13            2313     	RRC	A
0769    F8            2314     MOV R0 , A 
                      2315     
                      2316     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2317     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2318     MOV A , R1 
076E    6002          2319     	JZ	($+4)
                      2320     
0770    78FF          2321     MOV R0 , # 255 
                      2322     
0772    C3            2323     	CLR	C
0773    E8            2324     MOV A , R0 
0774    13            2325     	RRC	A
0775    38            2326     ADDC A , R0 
0776    F8            2327     MOV R0 , A 
0777    E4            2328     	CLR	A
0778    3400          2329     	ADDC	A, #0
077A    F9            2330     MOV R1 , A 
                      2331     
                      2332     PCA_INT_CHECK_LEGAL_RANGE: 
                      2333     	; Check that RC pulse is within legal range
077B    C3            2334     	CLR	C
077C    E8            2335     MOV A , R0 
077D    94FF          2336     SUBB A , # 255 
077F    E9            2337     MOV A , R1 
0780    9400          2338     	SUBB	A, #0
0782    4002          2339     	JC	PCA_INT_LIMITED
                      2340     
0784    78FF          2341     MOV R0 , # 255 
                      2342     
                      2343     PCA_INT_LIMITED: 
                      2344     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2345     ; 
                      2346     ; 对 RCP 信号处理
                      2347     ; 1 小于 1500us 最低油门
                      2348     ; 2 大于 1500us 正常处理
                      2349     ; 
0786    C3            2350     	CLR C
0787    E8            2351     MOV A , R0 
0788    94A0          2352     SUBB A , # 160 
078A    5002          2353     	JNC SKYPUP_03					; No 跳转
078C    7800          2354     MOV R0 , # 0 
                      2355     SKYPUP_03: 
                      2356     
078E    C3            2357     	CLR C
078F    E8            2358     MOV A , R0 
0790    9573          2359     	SUBB A, PREV_RCP				; 上一个 Rcp > 当前 Rcp ?
0792    400E          2360     	JC SKYPUP_04					; No
                      2361     
0794    9402          2362     SUBB A , # 2 
0796    400A          2363     	JC SKYPUP_04					; No
                      2364     
0798    C3            2365     	CLR C						; 这一句能否去掉? Skypup 2015.05.25
0799    E573          2366     	MOV A, PREV_RCP
079B    2402          2367     ADD A , # 2 
079D    F8            2368     MOV R0 , A 
079E    5002          2369     	JNC SKYPUP_04					; 没有发生进位溢出
                      2370     
07A0    78FF          2371     MOV R0 , # 0FFH 
                      2372     	
                      2373     SKYPUP_04: 
07A2    E559          2374     	MOV A, NEW_RCP
07A4    F573          2375     	MOV PREV_RCP, A
                      2376     
                      2377     ; **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****
                      2378     	; RC pulse value accepted
07A6    8859          2379     MOV NEW_RCP , R0 
07A8    D268          2380     SETB FLAGS2 . 0 
07AA    205902        2381     JB FLAGS0 . 1 , ( $+5 ) 
07AD    E1B7          2382     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2383     
07AF    741F          2384     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B1    F4            2385     	CPL	A
07B2    552E          2386     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07B4    4B            2387     ORL A , R3 
07B5    F52E          2388     	MOV	FLAGS3, A
                      2389     
                      2390     PCA_INT_SET_TIMEOUT: 
07B7    752818        2391     MOV RCP_TIMEOUT_CNT , # 24 
07BA    741F          2392     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07BC    552E          2393     	ANL	A, FLAGS3					; Check pwm frequency flags
07BE    7003          2394     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2395     
07C0    75280A        2396     MOV RCP_TIMEOUT_CNT , # 10 
                      2397     
                      2398     PCA_INT_PPM_TIMEOUT_SET: 
07C3    305902        2399     JNB FLAGS0 . 1 , ( $+5 ) 
07C6    E1D1          2400     	AJMP PCA_INT_EXIT				; Yes - exit
                      2401     
07C8    741F          2402     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07CA    552E          2403     	ANL	A, FLAGS3					; Check pwm frequency flags
07CC    6003          2404     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2405     
                      2406     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07CE    53DAFE        2406+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2407     
                      2408     PCA_INT_EXIT: 	; Exit interrupt routine	
07D1    752906        2409     MOV RCP_SKIP_CNT , # 6 
07D4    741F          2410     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07D6    552E          2411     	ANL	A, FLAGS3					; Check pwm frequency flags
07D8    7003          2412     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2413     
07DA    75290A        2414     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2415     
07DD    D0F0          2416     	POP	B			; Restore preserved registers
07DF    D0E0          2417     	POP	ACC			
07E1    D0D0          2418     	POP	PSW
07E3    C2D3          2419     	CLR	PSW.3		; Select register bank 0 for main program routines	
07E5    D2AD          2420     	SETB	ET2			; Enable timer2 interrupts
07E7    43E610        2421     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07EA    32            2422     	RETI
                      2423     
                      2424     
                      2425     
                      2426     
                      2427     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2428     ;
                      2429     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2430     ;
                      2431     ; No assumptions
                      2432     ;
                      2433     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2434     WAIT1MS: 	
07EB    7901          2435     MOV R1 , # 1 
07ED    020809        2436     	JMP	WAITXMS_O
                      2437     
                      2438     WAIT3MS: 	
07F0    7903          2439     MOV R1 , # 3 
07F2    020809        2440     	JMP	WAITXMS_O
                      2441     
                      2442     WAIT10MS: 	
07F5    790A          2443     MOV R1 , # 10 
07F7    020809        2444     	JMP	WAITXMS_O
                      2445     
                      2446     WAIT30MS: 	
07FA    791E          2447     MOV R1 , # 30 
07FC    020809        2448     	JMP	WAITXMS_O
                      2449     
                      2450     WAIT100MS: 	
07FF    7964          2451     MOV R1 , # 100 
0801    020809        2452     	JMP	WAITXMS_O
                      2453     
                      2454     WAIT200MS: 	
0804    79C8          2455     MOV R1 , # 200 
0806    020809        2456     	JMP	WAITXMS_O
                      2457     
                      2458     WAITXMS_O: 	; Outer loop
0809    7817          2459     MOV R0 , # 23 
                      2460     WAITXMS_M: 	; Middle loop
080B    E4            2461     	CLR	A
080C    D5E0FD        2462      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
080F    D8FA          2463     DJNZ R0 , WAITXMS_M 
0811    D9F6          2464     DJNZ R1 , WAITXMS_O 
0813    22            2465     	RET
                      2466     
                      2467     
                      2468     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2469     ;
                      2470     ; Beeper routines (4 different entry points) 
                      2471     ;
                      2472     ; No assumptions
                      2473     ;
                      2474     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2475     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0814    7A14          2476     MOV R2 , # 20 
0816    7B78          2477     MOV R3 , # 120 
0818    020830        2478     	JMP	BEEP
                      2479     
                      2480     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
081B    7A10          2481     MOV R2 , # 16 
081D    7B8C          2482     MOV R3 , # 140 
081F    020830        2483     	JMP	BEEP
                      2484     
                      2485     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0822    7A0D          2486     MOV R2 , # 13 
0824    7BB4          2487     MOV R3 , # 180 
0826    020830        2488     	JMP	BEEP
                      2489     
                      2490     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0829    7A0B          2491     MOV R2 , # 11 
082B    7BC8          2492     MOV R3 , # 200 
082D    020830        2493     	JMP	BEEP
                      2494     
                      2495     BEEP: 	; Beep loop start
0830    AC25          2496     MOV R4 , CURRENT_PWM_LIMITED 
0832    752501        2497     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0835    7902          2498     MOV R1 , # 2 
                      2499     BEEP_ONOFF: 
0837    B275          2500     CPL FLAGS3 . 5 
0839    E4            2501     	CLR	A
                      2502     	BPFET_OFF			; BpFET off
083A    C294          2502+1   CLR P1 . 4 
083C    D5E0FD        2503     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2504     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
083F    E525          2504+1   MOV A , CURRENT_PWM_LIMITED 
0841    6002          2504+1   JZ ( $+4 ) 
0843    D295          2504+1   SETB P1 . 5 
0845    D5E0FD        2505     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2506     	BNFET_OFF			; BnFET off again
0848    C295          2506+1   CLR P1 . 5 
084A    D5E0FD        2507     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2508     	BPFET_ON			; BpFET on
084D    D294          2508+1   SETB P1 . 4 
084F    D5E0FD        2509     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2510     	; Turn on nfet
                      2511     	ANFET_ON			; AnFET on
0852    E525          2511+1   MOV A , CURRENT_PWM_LIMITED 
0854    600A          2511+1   JZ ( $+12 ) 
0856    207502        2511+1   JB FLAGS3 . 5 , ( $+5 ) 
0859    D292          2511+1   SETB P1 . 2 
085B    307502        2511+1   JNB FLAGS3 . 5 , ( $+5 ) 
085E    D296          2511+1   SETB P1 . 6 
0860    E56F          2512     	MOV	A, BEEP_STRENGTH
0862    D5E0FD        2513     	DJNZ	ACC, $		
                      2514     	; Turn off nfet
                      2515     	ANFET_OFF			; AnFET off
0865    207502        2515+1   JB FLAGS3 . 5 , ( $+5 ) 
0868    C292          2515+1   CLR P1 . 2 
086A    307502        2515+1   JNB FLAGS3 . 5 , ( $+5 ) 
086D    C296          2515+1   CLR P1 . 6 
086F    7496          2516     	MOV	A, #150		; 25s off
0871    D5E0FD        2517     	DJNZ	ACC, $		
0874    D9C1          2518     DJNZ R1 , BEEP_ONOFF 
                      2519     	; Copy variable
0876    EA            2520     MOV A , R2 
0877    F8            2521     MOV R0 , A 
                      2522     BEEP_OFF: 		; Fets off loop
0878    D5E0FD        2523     	DJNZ	ACC, $
087B    D8FB          2524     DJNZ R0 , BEEP_OFF 
087D    DBB1          2525     DJNZ R3 , BEEP 
                      2526     	BPFET_OFF			; BpFET off
087F    C294          2526+1   CLR P1 . 4 
0881    8C25          2527     MOV CURRENT_PWM_LIMITED , R4 
0883    22            2528     	RET
                      2529     
                      2530     
                      2531     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2532     ;
                      2533     ; Division 16bit unsigned by 16bit unsigned
                      2534     ;
                      2535     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2536     ; Result will be in Temp2/Temp1
                      2537     ;
                      2538     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2539     DIV_U16_BY_U16: 	
0884    C3            2540     	CLR	C       
0885    7C00          2541     MOV R4 , # 0 
0887    7D00          2542     MOV R5 , # 0 
0889    75F000        2543     	MOV	B, #0
                      2544     DIV_U16_BY_U16_DIV1: 
088C    05F0          2545     	INC	B      			; Increment counter for each left shift
088E    EA            2546     MOV A , R2 
088F    33            2547     	RLC	A      		
0890    FA            2548     MOV R2 , A 
0891    EB            2549     MOV A , R3 
0892    33            2550     	RLC	A      	  	
0893    FB            2551     MOV R3 , A 
0894    50F6          2552     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2553     DIV_U16_BY_U16_DIV2:         
0896    EB            2554     MOV A , R3 
0897    13            2555     	RRC	A      
0898    FB            2556     MOV R3 , A 
0899    EA            2557     MOV A , R2 
089A    13            2558     	RRC	A      
089B    FA            2559     MOV R2 , A 
089C    C3            2560     	CLR	C      
089D    E9            2561     MOV A , R1 
089E    FF            2562     MOV R7 , A 
089F    E8            2563     MOV A , R0 
08A0    FE            2564     MOV R6 , A 
08A1    E8            2565     MOV A , R0 
08A2    9A            2566     SUBB A , R2 
08A3    F8            2567     MOV R0 , A 
08A4    E9            2568     MOV A , R1 
08A5    9B            2569     SUBB A , R3 
08A6    F9            2570     MOV R1 , A 
08A7    5004          2571     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08A9    EF            2572     MOV A , R7 
08AA    F9            2573     MOV R1 , A 
08AB    EE            2574     MOV A , R6 
08AC    F8            2575     MOV R0 , A 
                      2576     DIV_U16_BY_U16_DIV3: 
08AD    B3            2577     	CPL	C      			; Invert carry, so it can be directly copied into result
08AE    EC            2578     MOV A , R4 
08AF    33            2579     	RLC	A      			; Shift carry flag into temporary result
08B0    FC            2580     MOV R4 , A 
08B1    ED            2581     MOV A , R5 
08B2    33            2582     	RLC	A
08B3    FD            2583     MOV R5 , A 
08B4    D5F0DF        2584     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08B7    ED            2585     MOV A , R5 
08B8    F9            2586     MOV R1 , A 
08B9    EC            2587     MOV A , R4 
08BA    F8            2588     MOV R0 , A 
08BB    22            2589     	RET
                      2590     
                      2591     
                      2592     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2593     ;
                      2594     ; Multiplication 16bit signed by 8bit unsigned
                      2595     ;
                      2596     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2597     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2598     ;
                      2599     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2600     MULT_S16_BY_U8_DIV_16: 
08BC    E8            2601     MOV A , R0 
08BD    89F0          2602     MOV B , R1 
08BF    8A20          2603     MOV BIT_ACCESS , R2 
08C1    D2D4          2604     	SETB	PSW.4		; Select register bank 2 for math routines
08C3    F8            2605     MOV R0 , A 
08C4    A9F0          2606     MOV R1 , B 
08C6    7B00          2607     MOV R3 , # 0 
08C8    30F70B        2608     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2609     
08CB    7BFF          2610     MOV R3 , # 0FFH 
08CD    F4            2611     	CPL	A
08CE    2401          2612     	ADD	A, #1
08D0    F8            2613     MOV R0 , A 
08D1    E9            2614     MOV A , R1 
08D2    F4            2615     	CPL	A
08D3    3400          2616     	ADDC	A, #0
08D5    F9            2617     MOV R1 , A 
                      2618     MULT_S16_BY_U8_POSITIVE: 
08D6    E8            2619     MOV A , R0 
08D7    8520F0        2620     	MOV	B, BIT_ACCESS
08DA    A4            2621     	MUL	AB
08DB    ADF0          2622     MOV R5 , B 
08DD    F8            2623     MOV R0 , A 
08DE    E9            2624     MOV A , R1 
08DF    8520F0        2625     	MOV	B, BIT_ACCESS
08E2    A4            2626     	MUL	AB
08E3    AFF0          2627     MOV R7 , B 
08E5    FE            2628     MOV R6 , A 
08E6    ED            2629     MOV A , R5 
08E7    2E            2630     ADD A , R6 
08E8    F9            2631     MOV R1 , A 
08E9    7400          2632     	MOV	A, #0
08EB    3F            2633     ADDC A , R7 
08EC    FA            2634     MOV R2 , A 
08ED    7C04          2635     MOV R4 , # 4 
                      2636     MULT_S16_BY_U8_DIV_LOOP: 
08EF    C3            2637     	CLR	C			; Rotate right 
08F0    EA            2638     MOV A , R2 
08F1    13            2639     	RRC	A
08F2    FA            2640     MOV R2 , A 
08F3    E9            2641     MOV A , R1 
08F4    13            2642     	RRC	A
08F5    F9            2643     MOV R1 , A 
08F6    E8            2644     MOV A , R0 
08F7    13            2645     	RRC	A
08F8    F8            2646     MOV R0 , A 
08F9    DCF4          2647     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2648     
08FB    8BF0          2649     MOV B , R3 
08FD    30F70A        2650     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2651     
0900    E8            2652     MOV A , R0 
0901    F4            2653     	CPL	A
0902    2401          2654     	ADD	A, #1
0904    F8            2655     MOV R0 , A 
0905    E9            2656     MOV A , R1 
0906    F4            2657     	CPL	A
0907    3400          2658     	ADDC	A, #0
0909    F9            2659     MOV R1 , A 
                      2660     
                      2661     MULT_S16_BY_U8_EXIT: 
090A    E8            2662     MOV A , R0 
090B    89F0          2663     MOV B , R1 
090D    C2D4          2664     	CLR	PSW.4		; Select normal register bank
090F    F8            2665     MOV R0 , A 
0910    A9F0          2666     MOV R1 , B 
0912    22            2667     	RET
                      2668     
                      2669     
                      2670     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2671     ;
                      2672     ; Calculate governor routines
                      2673     ;
                      2674     ; No assumptions
                      2675     ;
                      2676     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2677     ; The governor task is split into several routines in order to distribute processing time
                      2678     ;
                      2679     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2680     ; First governor routine - calculate governor target
                      2681     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      2821     IF MODE == 2	; Multi
                      2822     CALC_GOVERNOR_TARGET: 
0913    7882          2823     MOV R0 , # PGM_GOV_MODE 
0915    B60403        2824     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0918    02096F        2825     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      2826     
                      2827     GOVERNOR_TARGET_CALC: 
                      2828     	; Stop governor for stop RC pulse	
091B    C3            2829     	CLR	C
091C    E559          2830     	MOV	A, NEW_RCP				; Check RC pulse against stop value
091E    9401          2831     SUBB A , # 1 
0920    4003          2832     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      2833     
0922    020938        2834     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      2835     
                      2836     GOVERNOR_DEACTIVATE: 
0925    852224        2837     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0928    E4            2838     	CLR	A
0929    F540          2839     	MOV	GOV_TARGET_L, A			; Set target to zero
092B    F541          2840     	MOV	GOV_TARGET_H, A
092D    F542          2841     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
092F    F543          2842     	MOV	GOV_INTEGRAL_H, A
0931    F544          2843     	MOV	GOV_INTEGRAL_X, A
0933    F549          2844     	MOV	GOV_ACTIVE, A
0935    02096F        2845     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      2846     
                      2847     GOVERNOR_ACTIVATE: 
0938    7882          2848     MOV R0 , # PGM_GOV_MODE 
093A    E6            2849     MOV A , @ R0 
093B    FC            2850     MOV R4 , A 
093C    754901        2851     	MOV	GOV_ACTIVE, #1
093F    E522          2852     	MOV	A, REQUESTED_PWM			; Load requested pwm
0941    F523          2853     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      2854     	; Calculate comm period target 2*(51000/Requested_Pwm)
0943    7838          2855     MOV R0 , # 38H 
0945    79C7          2856     MOV R1 , # 0C7H 
0947    AA3C          2857     MOV R2 , COMM_PERIOD4X_L 
0949    AB3D          2858     MOV R3 , COMM_PERIOD4X_H 
                      2859     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
094B    C3            2860     	CLR	C
094C    EB            2861     MOV A , R3 
094D    13            2862     	RRC	A
094E    FB            2863     MOV R3 , A 
094F    EA            2864     MOV A , R2 
0950    13            2865     	RRC	A
0951    FA            2866     MOV R2 , A 
                      2867     	; Check range
0952    EC            2868     MOV A , R4 
0953    14            2869     	DEC	A
0954    6013          2870     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      2871     GOVERNOR_ACTIVATE_100K: 
0956    C3            2872     	CLR	C
0957    EB            2873     MOV A , R3 
0958    13            2874     	RRC	A
0959    FB            2875     MOV R3 , A 
095A    EA            2876     MOV A , R2 
095B    13            2877     	RRC	A
095C    FA            2878     MOV R2 , A 
095D    EC            2879     MOV A , R4 
095E    14            2880     	DEC	A
095F    14            2881     	DEC	A
0960    6007          2882     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      2883     GOVERNOR_ACTIVATE_50K: 
0962    C3            2884     	CLR	C
0963    EB            2885     MOV A , R3 
0964    13            2886     	RRC	A
0965    FB            2887     MOV R3 , A 
0966    EA            2888     MOV A , R2 
0967    13            2889     	RRC	A
0968    FA            2890     MOV R2 , A 
                      2891     GOVERNOR_ACTIVATE_RANGE_SET: 
0969    1184          2892     	CALL	DIV_U16_BY_U16
                      2893     	; Store governor target
096B    8840          2894     MOV GOV_TARGET_L , R0 
096D    8941          2895     MOV GOV_TARGET_H , R1 
                      2896     CALC_GOVERNOR_TARGET_EXIT: 
096F    22            2897     	RET						
                      2898     ENDIF
                      2899     
                      2900     
                      2901     ; Second governor routine - calculate governor proportional error
                      2902     CALC_GOVERNOR_PROP_ERROR: 
                      2903     	; Exit if governor is inactive
0970    E549          2904     	MOV	A, GOV_ACTIVE
0972    6034          2905     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      2906     
                      2907     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      2925     IF MODE == 2	; Multi
                      2926     	; Calculate error
0974    C3            2927     	CLR	C
0975    E540          2928     	MOV	A, GOV_TARGET_L
0977    9523          2929     	SUBB	A, GOVERNOR_REQ_PWM
0979    F8            2930     MOV R0 , A 
097A    E541          2931     	MOV	A, GOV_TARGET_H
097C    9400          2932     	SUBB	A, #0
097E    F9            2933     MOV R1 , A 
                      2934     ENDIF
                      2935     	; Check error and limit
097F    500C          2936     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      2937     
0981    C3            2938     	CLR	C
0982    E8            2939     MOV A , R0 
0983    9480          2940     	SUBB	A, #80H					; Is error too negative?
0985    E9            2941     MOV A , R1 
0986    94FF          2942     	SUBB	A, #0FFH
0988    4016          2943     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
098A    0209A4        2944     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2945     
                      2946     GOVERNOR_CHECK_PROP_LIMIT_POS: 
098D    C3            2947     	CLR	C
098E    E8            2948     MOV A , R0 
098F    947F          2949     	SUBB	A, #7FH					; Is error too positive?
0991    E9            2950     MOV A , R1 
0992    9400          2951     	SUBB	A, #00H
0994    5003          2952     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0996    0209A4        2953     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2954     
                      2955     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0999    787F          2956     MOV R0 , # 7FH 
099B    7900          2957     MOV R1 , # 00H 
099D    0209A4        2958     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2959     
                      2960     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09A0    7880          2961     MOV R0 , # 80H 
09A2    79FF          2962     MOV R1 , # 0FFH 
                      2963     
                      2964     GOVERNOR_STORE_PROP_ERROR: 
                      2965     	; Store proportional
09A4    8845          2966     MOV GOV_PROPORTIONAL_L , R0 
09A6    8946          2967     MOV GOV_PROPORTIONAL_H , R1 
                      2968     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09A8    22            2969     	RET						
                      2970     
                      2971     
                      2972     ; Third governor routine - calculate governor integral error
                      2973     CALC_GOVERNOR_INT_ERROR: 
                      2974     	; Exit if governor is inactive
09A9    E549          2975     	MOV	A, GOV_ACTIVE
09AB    6058          2976     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      2977     
                      2978     	; Add proportional to integral
09AD    E545          2979     	MOV	A, GOV_PROPORTIONAL_L
09AF    2542          2980     	ADD	A, GOV_INTEGRAL_L
09B1    F8            2981     MOV R0 , A 
09B2    E546          2982     	MOV	A, GOV_PROPORTIONAL_H
09B4    3543          2983     	ADDC	A, GOV_INTEGRAL_H
09B6    F9            2984     MOV R1 , A 
09B7    854620        2985     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09BA    E4            2986     	CLR	A
09BB    300701        2987     	JNB	BIT_ACCESS.7, ($+4)			
09BE    F4            2988     	CPL	A
09BF    3544          2989     	ADDC	A, GOV_INTEGRAL_X
09C1    FA            2990     MOV R2 , A 
                      2991     	; Check integral and limit
09C2    30E709        2992     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      2993     
09C5    C3            2994     	CLR	C
09C6    EA            2995     MOV A , R2 
09C7    94F0          2996     	SUBB	A, #0F0H					; Is error too negative?
09C9    4015          2997     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09CB    0209E6        2998     	JMP	GOVERNOR_CHECK_PWM
                      2999     
                      3000     GOVERNOR_CHECK_INT_LIMIT_POS: 
09CE    C3            3001     	CLR	C
09CF    EA            3002     MOV A , R2 
09D0    940F          3003     	SUBB	A, #0FH					; Is error too positive?
09D2    5003          3004     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09D4    0209E6        3005     	JMP	GOVERNOR_CHECK_PWM
                      3006     
                      3007     GOVERNOR_LIMIT_INT_ERROR_POS: 
09D7    78FF          3008     MOV R0 , # 0FFH 
09D9    79FF          3009     MOV R1 , # 0FFH 
09DB    7A0F          3010     MOV R2 , # 0FH 
09DD    0209E6        3011     	JMP	GOVERNOR_CHECK_PWM
                      3012     
                      3013     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09E0    7800          3014     MOV R0 , # 00H 
09E2    7900          3015     MOV R1 , # 00H 
09E4    7AF0          3016     MOV R2 , # 0F0H 
                      3017     
                      3018     GOVERNOR_CHECK_PWM: 
                      3019     	; Check current pwm
09E6    C3            3020     	CLR	C
09E7    E524          3021     	MOV	A, CURRENT_PWM
09E9    955E          3022     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09EB    5006          3023     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3024     
09ED    E524          3025     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09EF    6009          3026     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3027     
09F1    21FF          3028     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3029     
                      3030     GOVERNOR_INT_MAX_PWM: 
09F3    E546          3031     	MOV	A, GOV_PROPORTIONAL_H
09F5    20E70D        3032     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3033     
09F8    21FF          3034     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3035     
                      3036     GOVERNOR_INT_MIN_PWM: 
09FA    E546          3037     	MOV	A, GOV_PROPORTIONAL_H
09FC    30E706        3038     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3039     
                      3040     GOVERNOR_STORE_INT_ERROR: 
                      3041     	; Store integral
09FF    8842          3042     MOV GOV_INTEGRAL_L , R0 
0A01    8943          3043     MOV GOV_INTEGRAL_H , R1 
0A03    8A44          3044     MOV GOV_INTEGRAL_X , R2 
                      3045     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A05    22            3046     	RET						
                      3047     
                      3048     
                      3049     ; Fourth governor routine - calculate governor proportional correction
                      3050     CALC_GOVERNOR_PROP_CORRECTION: 
                      3051     	; Exit if governor is inactive
0A06    E549          3052     	MOV	A, GOV_ACTIVE
0A08    7003          3053     	JNZ	CALC_GOVERNOR_PROP_CORR
0A0A    020A69        3054     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3055     
                      3056     CALC_GOVERNOR_PROP_CORR: 
                      3057     	; Load proportional gain
0A0D    789F          3058     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A0F    E6            3059     MOV A , @ R0 
0A10    FA            3060     MOV R2 , A 
                      3061     	; Load proportional
0A11    C3            3062     	CLR	C
0A12    E545          3063     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A14    33            3064     	RLC	A
0A15    F8            3065     MOV R0 , A 
0A16    E546          3066     	MOV	A, GOV_PROPORTIONAL_H
0A18    33            3067     	RLC	A
0A19    F9            3068     MOV R1 , A 
                      3069     	; Apply gain
0A1A    11BC          3070     	CALL	MULT_S16_BY_U8_DIV_16
                      3071     	; Check error and limit (to low byte)
0A1C    E9            3072     MOV A , R1 
0A1D    30E70B        3073     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3074     
0A20    C3            3075     	CLR	C
0A21    E8            3076     MOV A , R0 
0A22    9480          3077     	SUBB	A, #80H					; Is error too negative?
0A24    E9            3078     MOV A , R1 
0A25    94FF          3079     	SUBB	A, #0FFH
0A27    4013          3080     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A29    4140          3081     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3082     
                      3083     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A2B    C3            3084     	CLR	C
0A2C    E8            3085     MOV A , R0 
0A2D    947F          3086     	SUBB	A, #7FH					; Is error too positive?
0A2F    E9            3087     MOV A , R1 
0A30    9400          3088     	SUBB	A, #00H
0A32    5002          3089     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A34    4140          3090     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3091     
                      3092     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A36    787F          3093     MOV R0 , # 7FH 
0A38    7900          3094     MOV R1 , # 00H 
0A3A    4140          3095     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3096     
                      3097     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A3C    7880          3098     MOV R0 , # 80H 
0A3E    79FF          3099     MOV R1 , # 0FFH 
                      3100     
                      3101     GOVERNOR_APPLY_PROP_CORR: 
                      3102     	; Test proportional sign
0A40    E8            3103     MOV A , R0 
0A41    20E715        3104     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3105     
                      3106     	; Subtract positive proportional
0A44    C3            3107     	CLR	C
0A45    E523          3108     	MOV	A, GOVERNOR_REQ_PWM
0A47    98            3109     SUBB A , R0 
0A48    F8            3110     MOV R0 , A 
                      3111     	; Check result
0A49    4009          3112     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3113     
0A4B    C3            3114     	CLR	C
0A4C    E8            3115     MOV A , R0 
0A4D    9401          3116     	SUBB	A, #1
0A4F    4003          3117     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A51    020A67        3118     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3119     
                      3120     GOVERNOR_CORR_PROP_MIN_PWM: 
0A54    7801          3121     MOV R0 , # 1 
0A56    020A67        3122     	JMP	GOVERNOR_STORE_PROP_CORR
                      3123     
                      3124     GOVERNOR_CORR_NEG_PROP: 
                      3125     	; Add negative proportional
0A59    E8            3126     MOV A , R0 
0A5A    F4            3127     	CPL	A
0A5B    2401          3128     	ADD	A, #1
0A5D    2523          3129     	ADD	A, GOVERNOR_REQ_PWM
0A5F    F8            3130     MOV R0 , A 
                      3131     	; Check result
0A60    4003          3132     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A62    020A67        3133     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3134     
                      3135     GOVERNOR_CORR_PROP_MAX_PWM: 
0A65    78FF          3136     MOV R0 , # 255 
                      3137     GOVERNOR_STORE_PROP_CORR: 
                      3138     	; Store proportional pwm
0A67    8847          3139     MOV GOV_PROP_PWM , R0 
                      3140     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A69    22            3141     	RET
                      3142     
                      3143     
                      3144     ; Fifth governor routine - calculate governor integral correction
                      3145     CALC_GOVERNOR_INT_CORRECTION: 
                      3146     	; Exit if governor is inactive
0A6A    E549          3147     	MOV	A, GOV_ACTIVE
0A6C    7003          3148     	JNZ	CALC_GOVERNOR_INT_CORR
0A6E    020ACB        3149     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3150     
                      3151     CALC_GOVERNOR_INT_CORR: 
                      3152     	; Load integral gain
0A71    78A0          3153     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A73    E6            3154     MOV A , @ R0 
0A74    FA            3155     MOV R2 , A 
                      3156     	; Load integral
0A75    A843          3157     MOV R0 , GOV_INTEGRAL_H 
0A77    A944          3158     MOV R1 , GOV_INTEGRAL_X 
                      3159     	; Apply gain
0A79    11BC          3160     	CALL	MULT_S16_BY_U8_DIV_16
                      3161     	; Check integral and limit
0A7B    E9            3162     MOV A , R1 
0A7C    30E70C        3163     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3164     
0A7F    C3            3165     	CLR	C
0A80    E8            3166     MOV A , R0 
0A81    9401          3167     	SUBB	A, #01H					; Is integral too negative?
0A83    E9            3168     MOV A , R1 
0A84    94FF          3169     	SUBB	A, #0FFH
0A86    4016          3170     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A88    020AA2        3171     	JMP	GOVERNOR_APPLY_INT_CORR
                      3172     
                      3173     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A8B    C3            3174     	CLR	C
0A8C    E8            3175     MOV A , R0 
0A8D    94FF          3176     	SUBB	A, #0FFH					; Is integral too positive?
0A8F    E9            3177     MOV A , R1 
0A90    9400          3178     	SUBB	A, #00H
0A92    5003          3179     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A94    020AA2        3180     	JMP	GOVERNOR_APPLY_INT_CORR
                      3181     
                      3182     GOVERNOR_LIMIT_INT_CORR_POS: 
0A97    78FF          3183     MOV R0 , # 0FFH 
0A99    7900          3184     MOV R1 , # 00H 
0A9B    020AA2        3185     	JMP	GOVERNOR_APPLY_INT_CORR
                      3186     
                      3187     GOVERNOR_LIMIT_INT_CORR_NEG: 
0A9E    7801          3188     MOV R0 , # 01H 
0AA0    79FF          3189     MOV R1 , # 0FFH 
                      3190     
                      3191     GOVERNOR_APPLY_INT_CORR: 
                      3192     	; Test integral sign
0AA2    E9            3193     MOV A , R1 
0AA3    20E715        3194     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3195     
                      3196     	; Subtract positive integral
0AA6    C3            3197     	CLR	C
0AA7    E547          3198     	MOV	A, GOV_PROP_PWM
0AA9    98            3199     SUBB A , R0 
0AAA    F8            3200     MOV R0 , A 
                      3201     	; Check result
0AAB    4009          3202     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3203     
0AAD    C3            3204     	CLR	C
0AAE    E8            3205     MOV A , R0 
0AAF    9401          3206     	SUBB	A, #1
0AB1    4003          3207     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0AB3    020AC9        3208     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3209     
                      3210     GOVERNOR_CORR_INT_MIN_PWM: 
0AB6    7800          3211     MOV R0 , # 0 
0AB8    020AC9        3212     	JMP	GOVERNOR_STORE_INT_CORR
                      3213     
                      3214     GOVERNOR_CORR_NEG_INT: 
                      3215     	; Add negative integral
0ABB    E8            3216     MOV A , R0 
0ABC    F4            3217     	CPL	A
0ABD    2401          3218     	ADD	A, #1
0ABF    2547          3219     	ADD	A, GOV_PROP_PWM
0AC1    F8            3220     MOV R0 , A 
                      3221     	; Check result
0AC2    4003          3222     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AC4    020AC9        3223     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3224     
                      3225     GOVERNOR_CORR_INT_MAX_PWM: 
0AC7    78FF          3226     MOV R0 , # 255 
                      3227     GOVERNOR_STORE_INT_CORR: 
                      3228     	; Store current pwm
0AC9    8824          3229     MOV CURRENT_PWM , R0 
                      3230     CALC_GOVERNOR_INT_CORR_EXIT: 
0ACB    22            3231     	RET
                      3232     
                      3233     
                      3234     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3235     ;
                      3236     ; Measure lipo cells
                      3237     ;
                      3238     ; No assumptions
                      3239     ;
                      3240     ; Measure voltage and calculate lipo cells
                      3241     ;
                      3242     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3243     MEASURE_LIPO_CELLS: 
                      3244     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3248     MEASURE_LIPO_START: 
                      3249     	; Load programmed low voltage limit
0ACC    7883          3250     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0ACE    E6            3251     MOV A , @ R0 
0ACF    F520          3252     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3253     	; Set commutation to BpFET on
0AD1    120FEA        3254     	CALL	COMM5COMM6			
                      3255     	; Start adc
                      3256     	START_ADC 
0AD4    75E890        3256+1   MOV ADC0CN , # 90H  ; ADC START
                      3257     	; Wait for ADC reference to settle, and then start again
0AD7    1207EB        3258     	CALL	WAIT1MS
                      3259     	START_ADC
0ADA    75E890        3259+1   MOV ADC0CN , # 90H  ; ADC START
                      3260     	; Wait for ADC conversion to complete
                      3261     MEASURE_LIPO_WAIT_ADC: 
                      3262     	GET_ADC_STATUS 
0ADD    E5E8          3262+1   MOV A , ADC0CN 
0ADF    20ECFB        3263     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3264     	; Read ADC result
                      3265     	READ_ADC_RESULT
0AE2    A8BD          3265+1   MOV R0 , ADC0L 
0AE4    A9BE          3265+1   MOV R1 , ADC0H 
                      3266     	; Stop ADC
                      3267     	STOP_ADC
                      3268     	; Switch power off
0AE6    121090        3269     	CALL	SWITCH_POWER_OFF		
                      3270     	; Set limit step
0AE9    756A55        3271     MOV LIPO_ADC_LIMIT_L , # 85 
0AEC    756B00        3272     MOV LIPO_ADC_LIMIT_H , # 0 
0AEF    C3            3273     	CLR	C
0AF0    7400          3274     MOV A , # 0 
0AF2    13            3275     	RRC	A
0AF3    FD            3276     MOV R5 , A 
0AF4    7455          3277     MOV A , # 85 
0AF6    13            3278     	RRC	A
0AF7    FC            3279     MOV R4 , A 
0AF8    7455          3280     MOV A , # 85 
0AFA    2C            3281     ADD A , R4 
0AFB    FC            3282     MOV R4 , A 
0AFC    7400          3283     MOV A , # 0 
0AFE    3D            3284     ADDC A , R5 
0AFF    FD            3285     MOV R5 , A 
0B00    EC            3286     MOV A , R4 
0B01    FA            3287     MOV R2 , A 
0B02    ED            3288     MOV A , R5 
0B03    FB            3289     MOV R3 , A 
                      3290     MEASURE_LIPO_CELL_LOOP: 
                      3291     	; Check voltage against xS lower limit
0B04    C3            3292     	CLR	C
0B05    E8            3293     MOV A , R0 
0B06    9A            3294     SUBB A , R2 
0B07    E9            3295     MOV A , R1 
0B08    9B            3296     SUBB A , R3 
0B09    4014          3297     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3298     
                      3299     	; Set xS voltage limit
0B0B    E56A          3300     	MOV	A, LIPO_ADC_LIMIT_L		
0B0D    2455          3301     ADD A , # 85 
0B0F    F56A          3302     	MOV	LIPO_ADC_LIMIT_L, A
0B11    E56B          3303     	MOV	A, LIPO_ADC_LIMIT_H		
0B13    3400          3304     ADDC A , # 0 
0B15    F56B          3305     	MOV	LIPO_ADC_LIMIT_H, A
                      3306     	; Set (x+1)S lower limit
0B17    EA            3307     MOV A , R2 
0B18    2C            3308     ADD A , R4 
0B19    FA            3309     MOV R2 , A 
0B1A    EB            3310     MOV A , R3 
0B1B    3D            3311     ADDC A , R5 
0B1C    FB            3312     MOV R3 , A 
0B1D    80E5          3313     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3314     
                      3315     MEASURE_LIPO_ADJUST: 
0B1F    AE6A          3316     MOV R6 , LIPO_ADC_LIMIT_L 
0B21    AF6B          3317     MOV R7 , LIPO_ADC_LIMIT_H 
                      3318     	; Calculate 3.125%
0B23    C3            3319     	CLR	C
0B24    E56B          3320     	MOV	A, LIPO_ADC_LIMIT_H
0B26    13            3321     	RRC	A
0B27    F9            3322     MOV R1 , A 
0B28    E56A          3323     	MOV	A, LIPO_ADC_LIMIT_L	
0B2A    13            3324     	RRC	A
0B2B    F8            3325     MOV R0 , A 
0B2C    C3            3326     	CLR	C
0B2D    E9            3327     MOV A , R1 
0B2E    13            3328     	RRC	A
0B2F    F9            3329     MOV R1 , A 
0B30    E8            3330     MOV A , R0 
0B31    13            3331     	RRC	A
0B32    F8            3332     MOV R0 , A 
0B33    E56A          3333     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B35    28            3334     ADD A , R0 
0B36    F568          3335     	MOV	LIPO_ADC_REFERENCE_L, A
0B38    E56B          3336     	MOV	A, LIPO_ADC_LIMIT_H
0B3A    39            3337     ADDC A , R1 
0B3B    F569          3338     	MOV	LIPO_ADC_REFERENCE_H, A
                      3339     	; Divide three times to get to 3.125%
0B3D    7A03          3340     MOV R2 , # 3 
                      3341     MEASURE_LIPO_DIVIDE_LOOP: 
0B3F    C3            3342     	CLR	C
0B40    E9            3343     MOV A , R1 
0B41    13            3344     	RRC	A
0B42    F9            3345     MOV R1 , A 
0B43    E8            3346     MOV A , R0 
0B44    13            3347     	RRC	A
0B45    F8            3348     MOV R0 , A 
0B46    DAF7          3349     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3350     
                      3351     	; Add the programmed number of 0.1V (or 3.125% increments)
0B48    AA20          3352     MOV R2 , BIT_ACCESS 
0B4A    1A            3353     DEC R2 
0B4B    7009          3354     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3355     
0B4D    756A00        3356     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B50    756B00        3357     	MOV	LIPO_ADC_LIMIT_H, #0
0B53    020B66        3358     	JMP	MEASURE_LIPO_EXIT	
                      3359     
                      3360     MEASURE_LIPO_LIMIT_ON: 
0B56    1A            3361     DEC R2 
0B57    EA            3362     MOV A , R2 
0B58    6008          3363     	JZ	MEASURE_LIPO_UPDATE
                      3364     
                      3365     MEASURE_LIPO_ADD_LOOP: 
0B5A    EE            3366     MOV A , R6 
0B5B    28            3367     ADD A , R0 
0B5C    FE            3368     MOV R6 , A 
0B5D    EF            3369     MOV A , R7 
0B5E    39            3370     ADDC A , R1 
0B5F    FF            3371     MOV R7 , A 
0B60    DAF8          3372     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3373     
                      3374     MEASURE_LIPO_UPDATE: 
                      3375     	; Set ADC limit
0B62    8E6A          3376     MOV LIPO_ADC_LIMIT_L , R6 
0B64    8F6B          3377     MOV LIPO_ADC_LIMIT_H , R7 
                      3378     MEASURE_LIPO_EXIT: 
0B66    22            3379     	RET
                      3380     
                      3381     
                      3382     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3383     ;
                      3384     ; Start ADC conversion
                      3385     ;
                      3386     ; No assumptions
                      3387     ;
                      3388     ; Start conversion used for measuring power supply voltage
                      3389     ;
                      3390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3391     START_ADC_CONVERSION: 
                      3392     	; Start adc
                      3393     	START_ADC 
0B67    75E890        3393+1   MOV ADC0CN , # 90H  ; ADC START
0B6A    22            3394     	RET
                      3395     
                      3396     
                      3397     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3398     ;
                      3399     ; Check temperature, power supply voltage and limit power
                      3400     ;
                      3401     ; No assumptions
                      3402     ;
                      3403     ; Used to limit main motor power in order to maintain the required voltage
                      3404     ;
                      3405     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3406     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3407     	; Load programmed low voltage limit
0B6B    7883          3408     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B6D    E6            3409     MOV A , @ R0 
0B6E    FF            3410     MOV R7 , A 
                      3411     	; Wait for ADC conversion to complete
                      3412     	GET_ADC_STATUS 
0B6F    E5E8          3412+1   MOV A , ADC0CN 
0B71    20ECF7        3413     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3414     	; Read ADC result
                      3415     	READ_ADC_RESULT
0B74    A8BD          3415+1   MOV R0 , ADC0L 
0B76    A9BE          3415+1   MOV R1 , ADC0H 
                      3416     	; Stop ADC
                      3417     	STOP_ADC
                      3418     
0B78    056C          3419     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B7A    C3            3420     	CLR	C
0B7B    E56C          3421     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B7D    9408          3422     SUBB A , # 8 
0B7F    404B          3423     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3424     
0B81    756C00        3425     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B84    E9            3426     MOV A , R1 
0B85    7007          3427     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3428     
0B87    E56D          3429     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B89    601B          3430     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B8B    020B9A        3431     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3432     
                      3433     TEMP_AVERAGE_INC_DEC: 
0B8E    C3            3434     	CLR	C
0B8F    E8            3435     MOV A , R0 
0B90    956D          3436     	SUBB	A, CURRENT_AVERAGE_TEMP
0B92    6010          3437     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3438     
0B94    E56D          3439     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0B96    5006          3440     	JNC	TEMP_AVERAGE_INC				
                      3441     
0B98    600C          3442     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3443     TEMP_AVERAGE_DEC: 
0B9A    14            3444     	DEC	A						; Decrement average
0B9B    020BA6        3445     	JMP	TEMP_AVERAGE_UPDATED
                      3446     
                      3447     TEMP_AVERAGE_INC: 
0B9E    04            3448     	INC	A						; Increment average
0B9F    60F9          3449     	JZ	TEMP_AVERAGE_DEC
0BA1    020BA6        3450     	JMP	TEMP_AVERAGE_UPDATED
                      3451     
                      3452     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BA4    E56D          3453     	MOV	A, CURRENT_AVERAGE_TEMP
                      3454     TEMP_AVERAGE_UPDATED: 
0BA6    F56D          3455     	MOV	CURRENT_AVERAGE_TEMP, A
0BA8    C3            3456     	CLR	C
0BA9    9472          3457     SUBB A , # 114 
0BAB    401B          3458     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3459     
0BAD    755EC0        3460     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3461     
0BB0    C3            3462     	CLR	C
0BB1    9404          3463     SUBB A , # 4 
0BB3    4013          3464     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3465     
0BB5    755E80        3466     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3467     
0BB8    C3            3468     	CLR	C
0BB9    9404          3469     SUBB A , # 4 
0BBB    400B          3470     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3471     
0BBD    755E40        3472     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3473     
0BC0    C3            3474     	CLR	C
0BC1    9404          3475     SUBB A , # 4 
0BC3    4003          3476     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3477     
0BC5    755E00        3478     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3479     
                      3480     TEMP_CHECK_EXIT: 
                      3481     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BC8    75BB09        3481+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BCB    22            3482     	RET
                      3483     
                      3484     CHECK_VOLTAGE_START: 
                      3485     IF MODE == 0 OR MODE == 2	; Main or multi
                      3486     	; Check if low voltage limiting is enabled
0BCC    EF            3487     MOV A , R7 
0BCD    C3            3488     	CLR	C
0BCE    9401          3489     	SUBB	A, #1					; Is low voltage limit disabled?
0BD0    601B          3490     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3491     
                      3492     	; Check if ADC is saturated
0BD2    C3            3493     	CLR	C
0BD3    E8            3494     MOV A , R0 
0BD4    94FF          3495     	SUBB	A, #0FFH
0BD6    E9            3496     MOV A , R1 
0BD7    9403          3497     	SUBB	A, #03H
0BD9    5012          3498     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3499     
                      3500     	; Check voltage against limit
0BDB    C3            3501     	CLR	C
0BDC    E8            3502     MOV A , R0 
0BDD    956A          3503     	SUBB	A, LIPO_ADC_LIMIT_L
0BDF    E9            3504     MOV A , R1 
0BE0    956B          3505     	SUBB	A, LIPO_ADC_LIMIT_H
0BE2    5009          3506     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3507     
                      3508     	; Decrease pwm limit
0BE4    E55E          3509     	MOV  A, PWM_LIMIT
0BE6    600C          3510     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3511     
0BE8    155E          3512     	DEC	PWM_LIMIT					; Decrement limit
0BEA    020BF4        3513     	JMP	CHECK_VOLTAGE_LIM
                      3514     
                      3515     CHECK_VOLTAGE_GOOD: 
                      3516     	; Increase pwm limit
0BED    E55E          3517     	MOV  A, PWM_LIMIT
0BEF    F4            3518     	CPL	A			
0BF0    6002          3519     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3520     
0BF2    055E          3521     	INC	PWM_LIMIT					; Increment limit
                      3522     
                      3523     CHECK_VOLTAGE_LIM: 
0BF4    A85E          3524     MOV R0 , PWM_LIMIT 
0BF6    C3            3525     	CLR	C
0BF7    E524          3526     	MOV	A, CURRENT_PWM
0BF9    98            3527     SUBB A , R0 
0BFA    5002          3528     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3529     
0BFC    A824          3530     MOV R0 , CURRENT_PWM 
                      3531     
                      3532     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3533     	; Slow spoolup
0BFE    C3            3534     	CLR	C
0BFF    E8            3535     MOV A , R0 
0C00    955F          3536     	SUBB	A, PWM_LIMIT_SPOOLUP
0C02    400A          3537     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3538     
0C04    A85F          3539     MOV R0 , PWM_LIMIT_SPOOLUP 
0C06    E55F          3540     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C08    F4            3541     	CPL	A
0C09    6003          3542     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3543      
0C0B    855F5E        3544     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3545     
                      3546     CHECK_VOLTAGE_EXIT: 
0C0E    8825          3547     MOV CURRENT_PWM_LIMITED , R0 
                      3548     ENDIF
                      3549     	; Set adc mux for next conversion
0C10    C3            3550     	CLR	C
0C11    E56C          3551     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C13    B40703        3552     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3553     
                      3554     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C16    75BB10        3554+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3555     
                      3556     CHECK_VOLTAGE_RET: 
0C19    22            3557     	RET
                      3558     
                      3559     
                      3560     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3561     ;
                      3562     ; Set startup PWM routine
                      3563     ;
                      3564     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3565     ;
                      3566     ; Used for pwm control during startup
                      3567     ;
                      3568     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3569     SET_STARTUP_PWM: 	
                      3570     	; Set pwm values according to startup phase flags
0C1A    306102        3571     JNB FLAGS1 . 1 , ( $+5 ) 
0C1D    7832          3572     MOV R0 , # 50 
0C1F    306202        3573     JNB FLAGS1 . 2 , ( $+5 ) 
0C22    7878          3574     MOV R0 , # 120 
                      3575     
                      3576     	; Update pwm variables if any startup phase flag is set
0C24    E52C          3577     	MOV	A, FLAGS1
0C26    5406          3578     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C28    601F          3579     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3580     
                      3581     	; Adjust startup power
0C2A    E8            3582     MOV A , R0 
0C2B    79A2          3583     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C2D    87F0          3584     MOV B , @ R1 
0C2F    A4            3585     	MUL	AB
0C30    C5F0          3586     	XCH	A, B
0C32    A2F7          3587     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C34    33            3588     	RLC	A
0C35    F8            3589     MOV R0 , A 
0C36    C3            3590     	CLR	C
0C37    E8            3591     MOV A , R0 
0C38    955E          3592     	SUBB	A, PWM_LIMIT	
0C3A    4002          3593     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3594     
0C3C    A85E          3595     MOV R0 , PWM_LIMIT 
                      3596     
                      3597     STARTUP_PWM_SET_PWM: 
                      3598     	; Set pwm variables
0C3E    8822          3599     MOV REQUESTED_PWM , R0 
0C40    8824          3600     MOV CURRENT_PWM , R0 
0C42    8825          3601     MOV CURRENT_PWM_LIMITED , R0 
0C44    306102        3602     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3603     
0C47    8860          3604     MOV PWM_SPOOLUP_BEG , R0 
                      3605     
                      3606     STARTUP_PWM_EXIT: 
0C49    22            3607     	RET
                      3608     
                      3609     
                      3610     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3611     ;
                      3612     ; Initialize all timings routine
                      3613     ;
                      3614     ; No assumptions
                      3615     ;
                      3616     ; Part of initialization before motor start
                      3617     ;
                      3618     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3619     INITIALIZE_ALL_TIMINGS:  
                      3620     	; Load programmed startup rpm
0C4A    788F          3621     MOV R0 , # PGM_STARTUP_RPM 
0C4C    E6            3622     MOV A , @ R0 
0C4D    FF            3623     MOV R7 , A 
                      3624     	; Check startup rpm setting and set step accordingly
0C4E    C3            3625     	CLR	C
0C4F    EF            3626     MOV A , R7 
0C50    9405          3627     	SUBB	A, #5
0C52    5018          3628     	JNC	STEPPER_STEP_HIGH
0C54    C3            3629     	CLR	C
0C55    EF            3630     MOV A , R7 
0C56    9404          3631     	SUBB	A, #4
0C58    5020          3632     	JNC	STEPPER_STEP_MED_HIGH
0C5A    C3            3633     	CLR	C
0C5B    EF            3634     MOV A , R7 
0C5C    9403          3635     	SUBB	A, #3
0C5E    5028          3636     	JNC	STEPPER_STEP_MED
0C60    C3            3637     	CLR	C
0C61    EF            3638     MOV A , R7 
0C62    9402          3639     	SUBB	A, #2
0C64    5030          3640     	JNC	STEPPER_STEP_MED_LOW
0C66    C3            3641     	CLR	C
0C67    EF            3642     MOV A , R7 
0C68    9401          3643     	SUBB	A, #1
0C6A    5038          3644     	JNC	STEPPER_STEP_LOW
                      3645     
                      3646     STEPPER_STEP_HIGH: 
0C6C    7533A0        3647     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C6F    75340F        3648     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C72    75353C        3649     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C75    753605        3650     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C78    81B0          3651     	AJMP	STEPPER_STEP_SET
                      3652     STEPPER_STEP_MED_HIGH: 
0C7A    7533C0        3653     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C7D    753412        3654     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C80    753540        3655     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C83    753606        3656     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C86    81B0          3657     	AJMP	STEPPER_STEP_SET
                      3658     STEPPER_STEP_MED: 
0C88    753370        3659     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C8B    753417        3660     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C8E    7535D0        3661     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C91    753607        3662     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C94    81B0          3663     	AJMP	STEPPER_STEP_SET
                      3664     STEPPER_STEP_MED_LOW: 
0C96    75334C        3665     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C99    75341D        3666     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C9C    7535C4        3667     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C9F    753609        3668     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CA2    81B0          3669     	AJMP	STEPPER_STEP_SET
                      3670     STEPPER_STEP_LOW: 
0CA4    753328        3671     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CA7    753423        3672     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CAA    7535B8        3673     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CAD    75360B        3674     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3675     
                      3676     STEPPER_STEP_SET: 
0CB0    853350        3677     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CB3    853451        3678     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CB6    753C00        3679     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CB9    753D08        3680     	MOV	COMM_PERIOD4X_H, #08H
0CBC    22            3681     	RET
                      3682     
                      3683     
                      3684     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3685     ;
                      3686     ; Calculate next commutation timing routine
                      3687     ;
                      3688     ; No assumptions
                      3689     ;
                      3690     ; Called immediately after each commutation
                      3691     ; Also sets up timer 3 to wait advance timing
                      3692     ; Two entry points are used
                      3693     ;
                      3694     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3695     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CBD    A850          3696     MOV R0 , WT_STEPPER_STEP_L 
0CBF    A951          3697     MOV R1 , WT_STEPPER_STEP_H 
0CC1    020CC8        3698     	JMP	READ_TIMER
                      3699     
                      3700     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CC4    A84A          3701     MOV R0 , WT_ADVANCE_L 
0CC6    A94B          3702     MOV R1 , WT_ADVANCE_H 
                      3703     READ_TIMER: 
                      3704     	; Set up next wait
0CC8    759100        3705     	MOV	TMR3CN, #00H		; Timer3 disabled
0CCB    C3            3706     	CLR	C
0CCC    E4            3707     	CLR	A
0CCD    98            3708     SUBB A , R0 
0CCE    F594          3709     	MOV	TMR3L, A
0CD0    E4            3710     	CLR	A
0CD1    99            3711     SUBB A , R1 
0CD2    F595          3712     	MOV	TMR3H, A
0CD4    759104        3713     	MOV	TMR3CN, #04H		; Timer3 enabled
0CD7    D258          3714     SETB FLAGS0 . 0 
                      3715     	; Read commutation time
0CD9    75C820        3716     	MOV	TMR2CN, #20H		; Timer2 disabled
0CDC    A8CC          3717     MOV R0 , TMR2L 
0CDE    A9CD          3718     MOV R1 , TMR2H 
0CE0    75C824        3719     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3720     	; Calculate this commutation time
0CE3    AA3A          3721     MOV R2 , PREV_COMM_L 
0CE5    AB3B          3722     MOV R3 , PREV_COMM_H 
0CE7    883A          3723     MOV PREV_COMM_L , R0 
0CE9    893B          3724     MOV PREV_COMM_H , R1 
0CEB    C3            3725     	CLR	C
0CEC    E8            3726     MOV A , R0 
0CED    9A            3727     SUBB A , R2 
0CEE    F8            3728     MOV R0 , A 
0CEF    E9            3729     MOV A , R1 
0CF0    9B            3730     SUBB A , R3 
0CF1    F9            3731     MOV R1 , A 
                      3732     	; Calculate next zero cross scan timeout 
0CF2    AA3C          3733     MOV R2 , COMM_PERIOD4X_L 
0CF4    AB3D          3734     MOV R3 , COMM_PERIOD4X_H 
0CF6    C3            3735     	CLR	C
0CF7    EB            3736     MOV A , R3 
0CF8    13            3737     	RRC	A					; Divide by 2
0CF9    FD            3738     MOV R5 , A 
0CFA    EA            3739     MOV A , R2 
0CFB    13            3740     	RRC	A
0CFC    FC            3741     MOV R4 , A 
0CFD    C3            3742     	CLR	C
0CFE    ED            3743     MOV A , R5 
0CFF    13            3744     	RRC	A					; Divide by 2 again
0D00    FD            3745     MOV R5 , A 
0D01    EC            3746     MOV A , R4 
0D02    13            3747     	RRC	A
0D03    FC            3748     MOV R4 , A 
0D04    C3            3749     	CLR	C
0D05    EA            3750     MOV A , R2 
0D06    9C            3751     SUBB A , R4 
0D07    FA            3752     MOV R2 , A 
0D08    EB            3753     MOV A , R3 
0D09    9D            3754     SUBB A , R5 
0D0A    FB            3755     MOV R3 , A 
                      3756     
0D0B    EA            3757     MOV A , R2 
0D0C    28            3758     ADD A , R0 
0D0D    FA            3759     MOV R2 , A 
0D0E    EB            3760     MOV A , R3 
0D0F    39            3761     ADDC A , R1 
0D10    FB            3762     MOV R3 , A 
0D11    8A3C          3763     MOV COMM_PERIOD4X_L , R2 
0D13    8B3D          3764     MOV COMM_PERIOD4X_H , R3 
0D15    4001          3765     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3766     
0D17    22            3767     	RET
                      3768     
                      3769     CALC_NEXT_COMM_SLOW: 
0D18    753CFF        3770     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D1B    753DFF        3771     	MOV	COMM_PERIOD4X_H, #0FFH
0D1E    22            3772     	RET
                      3773     
                      3774     
                      3775     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3776     ;
                      3777     ; Setup zero cross scan wait
                      3778     ;
                      3779     ; No assumptions
                      3780     ;
                      3781     ; Sets up timer 3 to wait the zero cross scan wait time
                      3782     ;
                      3783     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3784     SETUP_ZC_SCAN_WAIT: 
0D1F    759100        3785     	MOV	TMR3CN, #00H		; Timer3 disabled
0D22    C3            3786     	CLR	C
0D23    E4            3787     	CLR	A
0D24    954C          3788     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D26    F594          3789     	MOV	TMR3L, A
0D28    E4            3790     	CLR	A
0D29    954D          3791     	SUBB	A, WT_ZC_SCAN_H		
0D2B    F595          3792     	MOV	TMR3H, A
0D2D    759104        3793     	MOV	TMR3CN, #04H		; Timer3 enabled
0D30    D258          3794     SETB FLAGS0 . 0 
0D32    22            3795     	RET
                      3796     
                      3797     
                      3798     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3799     ;
                      3800     ; Wait advance timing routine
                      3801     ;
                      3802     ; No assumptions
                      3803     ;
                      3804     ; Waits for the advance timing to elapse, waits one zero cross
                      3805     ; wait and sets up the next zero cross wait
                      3806     ;
                      3807     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3808     WAIT_ADVANCE_TIMING: 	
0D33    7F01          3809     MOV R7 , # 1 
0D35    789C          3810     MOV R0 , # PGM_DEMAG_COMP 
0D37    E6            3811     MOV A , @ R0 
0D38    14            3812     	DEC	A
0D39    6002          3813     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      3814     
0D3B    7F02          3815     MOV R7 , # 2 
                      3816     
                      3817     WAIT_ADVANCE_TIMING_WAIT: 
0D3D    305802        3818     JNB FLAGS0 . 0 , ( $+5 ) 
0D40    A13D          3819     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      3820     
0D42    B11F          3821     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D44    DFF7          3822     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      3823     
0D46    22            3824     	RET
                      3825     
                      3826     
                      3827     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3828     ;
                      3829     ; Calculate new wait times routine
                      3830     ;
                      3831     ; No assumptions
                      3832     ;
                      3833     ; Calculates new wait times
                      3834     ;
                      3835     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3836     CALC_NEW_WAIT_TIMES: 	
                      3837     	; Load programmed commutation timing
0D47    7892          3838     MOV R0 , # PGM_COMM_TIMING 
0D49    E6            3839     MOV A , @ R0 
0D4A    FF            3840     MOV R7 , A 
0D4B    7E14          3841     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      3842     IF MODE == 2
0D4D    A83D          3843     MOV R0 , COMM_PERIOD4X_H 
0D4F    C3            3844     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D50    E8            3845     MOV A , R0 
0D51    9404          3846     	SUBB	A, #4
0D53    4002          3847     	JC	CALC_NEW_WAIT_RED_SET
                      3848     
0D55    7804          3849     MOV R0 , # 4 
                      3850     
                      3851     CALC_NEW_WAIT_RED_SET: 
0D57    C3            3852     	CLR	C
0D58    E8            3853     MOV A , R0 
0D59    33            3854     	RLC	A
0D5A    F8            3855     MOV R0 , A 
0D5B    C3            3856     	CLR	C
0D5C    EE            3857     MOV A , R6 
0D5D    98            3858     SUBB A , R0 
0D5E    FE            3859     MOV R6 , A 
                      3860     ENDIF
0D5F    306304        3861     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      3862     
0D62    7F03          3863     MOV R7 , # 3 
0D64    7E00          3864     MOV R6 , # 0 
                      3865     
                      3866     CALC_NEW_WAIT_DIR_START_SET: 
                      3867     	; Load current commutation timing
0D66    A93D          3868     MOV R1 , COMM_PERIOD4X_H 
0D68    A83C          3869     MOV R0 , COMM_PERIOD4X_L 
0D6A    7A04          3870     MOV R2 , # 4 
                      3871     DIVIDE_WAIT_TIMES: 
0D6C    C3            3872     	CLR	C
0D6D    E9            3873     MOV A , R1 
0D6E    13            3874     	RRC	A					; Divide by 2
0D6F    F9            3875     MOV R1 , A 
0D70    E8            3876     MOV A , R0 
0D71    13            3877     	RRC	A
0D72    F8            3878     MOV R0 , A 
0D73    DAF7          3879     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      3880     
0D75    C3            3881     	CLR	C
0D76    E8            3882     MOV A , R0 
0D77    9E            3883     SUBB A , R6 
0D78    F8            3884     MOV R0 , A 
0D79    E9            3885     MOV A , R1 
0D7A    9400          3886     	SUBB	A, #0
0D7C    F9            3887     MOV R1 , A 
0D7D    4009          3888     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      3889     
0D7F    C3            3890     	CLR	C
0D80    E8            3891     MOV A , R0 
0D81    9402          3892     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D83    E9            3893     MOV A , R1 
0D84    9400          3894     	SUBB	A, #0
0D86    5004          3895     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      3896     
                      3897     LOAD_MIN_TIME: 
0D88    7802          3898     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D8A    E4            3899     	CLR	A
0D8B    F9            3900     MOV R1 , A 
                      3901     
                      3902     ADJUST_TIMING: 
0D8C    E9            3903     MOV A , R1 
0D8D    FB            3904     MOV R3 , A 
0D8E    E8            3905     MOV A , R0 
0D8F    FA            3906     MOV R2 , A 
0D90    C3            3907     	CLR	C
0D91    E9            3908     MOV A , R1 
0D92    13            3909     	RRC	A					; Divide by 2
0D93    FD            3910     MOV R5 , A 
0D94    E8            3911     MOV A , R0 
0D95    13            3912     	RRC	A
0D96    FC            3913     MOV R4 , A 
0D97    C3            3914     	CLR	C
0D98    EF            3915     MOV A , R7 
0D99    9403          3916     	SUBB	A, #3				; Is timing normal?
0D9B    602E          3917     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      3918     
0D9D    EF            3919     MOV A , R7 
0D9E    20E00D        3920     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      3921     
0DA1    E8            3922     MOV A , R0 
0DA2    2C            3923     ADD A , R4 
0DA3    F8            3924     MOV R0 , A 
0DA4    E9            3925     MOV A , R1 
0DA5    3D            3926     ADDC A , R5 
0DA6    F9            3927     MOV R1 , A 
0DA7    EC            3928     MOV A , R4 
0DA8    FA            3929     MOV R2 , A 
0DA9    ED            3930     MOV A , R5 
0DAA    FB            3931     MOV R3 , A 
0DAB    020DB8        3932     	JMP	STORE_TIMES_UP_OR_DOWN
                      3933     
                      3934     ADJUST_TIMING_TWO_STEPS: 
0DAE    E8            3935     MOV A , R0 
0DAF    28            3936     ADD A , R0 
0DB0    F8            3937     MOV R0 , A 
0DB1    E9            3938     MOV A , R1 
0DB2    39            3939     ADDC A , R1 
0DB3    F9            3940     MOV R1 , A 
0DB4    7A02          3941     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DB6    E4            3942     	CLR	A
0DB7    FB            3943     MOV R3 , A 
                      3944     
                      3945     STORE_TIMES_UP_OR_DOWN: 
0DB8    C3            3946     	CLR	C
0DB9    EF            3947     MOV A , R7 
0DBA    9403          3948     	SUBB	A, #3				; Is timing higher than normal?
0DBC    400D          3949     	JC	STORE_TIMES_DECREASE	; No - branch
                      3950     
                      3951     STORE_TIMES_INCREASE: 
0DBE    8A4E          3952     MOV WT_COMM_L , R2 
0DC0    8B4F          3953     MOV WT_COMM_H , R3 
0DC2    884A          3954     MOV WT_ADVANCE_L , R0 
0DC4    894B          3955     MOV WT_ADVANCE_H , R1 
0DC6    8C4C          3956     MOV WT_ZC_SCAN_L , R4 
0DC8    8D4D          3957     MOV WT_ZC_SCAN_H , R5 
0DCA    22            3958     	RET
                      3959     
                      3960     STORE_TIMES_DECREASE: 
0DCB    884E          3961     MOV WT_COMM_L , R0 
0DCD    894F          3962     MOV WT_COMM_H , R1 
0DCF    8A4A          3963     MOV WT_ADVANCE_L , R2 
0DD1    8B4B          3964     MOV WT_ADVANCE_H , R3 
0DD3    8C4C          3965     MOV WT_ZC_SCAN_L , R4 
0DD5    8D4D          3966     MOV WT_ZC_SCAN_H , R5 
0DD7    22            3967     	RET
                      3968     
                      3969     
                      3970     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3971     ;
                      3972     ; Wait before zero cross scan routine
                      3973     ;
                      3974     ; No assumptions
                      3975     ;
                      3976     ; Waits for the zero cross scan wait time to elapse
                      3977     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      3978     ;
                      3979     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3980     WAIT_BEFORE_ZC_SCAN: 	
0DD8    305802        3981     JNB FLAGS0 . 0 , ( $+5 ) 
0DDB    A1D8          3982     	AJMP	WAIT_BEFORE_ZC_SCAN
                      3983     
0DDD    759100        3984     	MOV	TMR3CN, #00H		; Timer3 disabled
0DE0    C3            3985     	CLR	C
0DE1    E4            3986     	CLR	A
0DE2    953C          3987     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DE4    F594          3988     	MOV	TMR3L, A
0DE6    E4            3989     	CLR	A
0DE7    953D          3990     	SUBB	A, COMM_PERIOD4X_H		
0DE9    F595          3991     	MOV	TMR3H, A
0DEB    759104        3992     	MOV	TMR3CN, #04H		; Timer3 enabled
0DEE    D258          3993     SETB FLAGS0 . 0 
0DF0    22            3994     	RET
                      3995     
                      3996     
                      3997     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3998     ;
                      3999     ; Wait for comparator to go low/high routines
                      4000     ;
                      4001     ; No assumptions
                      4002     ;
                      4003     ; Waits for the zero cross scan wait time to elapse
                      4004     ; Then scans for comparator going low/high
                      4005     ;
                      4006     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4007     WAIT_FOR_COMP_OUT_LOW: 
0DF1    753F00        4008     	MOV	COMP_WAIT_READS, #0
0DF4    752000        4009     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0DF7    020E00        4010     	JMP	WAIT_FOR_COMP_OUT_START
                      4011     
                      4012     WAIT_FOR_COMP_OUT_HIGH: 
0DFA    753F00        4013     	MOV	COMP_WAIT_READS, #0
0DFD    752040        4014     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4015     
                      4016     WAIT_FOR_COMP_OUT_START: 
0E00    D2AF          4017     	SETB	EA						; Enable interrupts
0E02    053F          4018     	INC	COMP_WAIT_READS
0E04    205801        4019     JB FLAGS0 . 0 , ( $+4 ) 
0E07    22            4020     	RET							; Yes - return
                      4021     
                      4022     	; Set default comparator response times
0E08    759D00        4023     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4024     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4027     	; Select number of comparator readings based upon current rotation speed
0E0B    E53D          4028     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E0D    C3            4029     	CLR	C
0E0E    13            4030     	RRC	A						; Divide by 4
0E0F    C3            4031     	CLR	C
0E10    13            4032     	RRC	A
0E11    F8            4033     MOV R0 , A 
0E12    08            4034     INC R0 
0E13    6030          4035     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4036     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E15    306A06        4037     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4038     
0E18    C3            4039     	CLR	C
0E19    13            4040     	RRC	A						; Divide by 4 again
0E1A    C3            4041     	CLR	C
0E1B    13            4042     	RRC	A
0E1C    F8            4043     MOV R0 , A 
0E1D    08            4044     INC R0 
                      4045     
                      4046     COMP_WAIT_SET_MAX_READINGS: 
0E1E    C3            4047     	CLR	C
0E1F    E8            4048     MOV A , R0 
0E20    940A          4049     	SUBB	A, #10
0E22    4002          4050     	JC	($+4)
                      4051     
0E24    780A          4052     MOV R0 , # 10 
                      4053     
0E26    306D08        4054     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4055     
0E29    C3            4056     	CLR	C
0E2A    E8            4057     MOV A , R0 
0E2B    9404          4058     	SUBB	A, #4
0E2D    4002          4059     	JC	($+4)
                      4060     
0E2F    7804          4061     MOV R0 , # 4 
                      4062     
                      4063     COMP_WAIT_SET_RESPONSE_TIME: 
0E31    C3            4064     	CLR	C
0E32    E53D          4065     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E34    9408          4066     	SUBB	A, #8
0E36    400D          4067     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4068     
0E38    759D02        4069     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4070     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E3B    C3            4073     	CLR	C
0E3C    E53D          4074     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E3E    9410          4075     	SUBB	A, #16
0E40    4003          4076     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4077     
0E42    759D03        4078     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4079     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4082     
                      4083     COMP_WAIT_ON_COMP_ABLE: 
0E45    205803        4084     JB FLAGS0 . 0 , ( $+6 ) 
0E48    D2AF          4085     	SETB	EA							; Enable interrupts
0E4A    22            4086     	RET								; Yes - return
                      4087     
0E4B    791E          4088     MOV R1 , # 30 
0E4D    206D02        4089     JB FLAGS2 . 5 , ( $+5 ) 
0E50    790A          4090     MOV R1 , # 10 
0E52    D2AF          4091     	SETB	EA							; Enable interrupts
0E54    00            4092     	NOP								; Allocate only just enough time to capture interrupt
0E55    00            4093     	NOP
0E56    C2AF          4094     	CLR	EA							; Disable interrupts
0E58    205A0A        4095     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4096     
0E5B    793C          4097     MOV R1 , # 60 
0E5D    206D02        4098     JB FLAGS2 . 5 , ( $+5 ) 
0E60    7914          4099     MOV R1 , # 20 
0E62    3066E0        4100     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4101     
                      4102     PWM_WAIT_STARTUP: 						
0E65    306302        4103     JNB FLAGS1 . 3 , PWM_WAIT 
                      4104     
0E68    7978          4105     MOV R1 , # 120 
                      4106     PWM_WAIT: 						
0E6A    C3            4107     	CLR	C
0E6B    E58B          4108     	MOV	A, TL1
0E6D    99            4109     SUBB A , R1 
                      4110     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E6E    40D5          4115     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4116     ENDIF
                      4117     
                      4118     COMP_READ: 
                      4119     	READ_COMP_OUT 					; Read comparator output
0E70    E59B          4119+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E72    F4            4120     	CPL	A
0E73    5440          4121     	ANL	A, #40H
0E75    B52002        4122     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4123     
0E78    C100          4124     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4125     
0E7A    D8C9          4126     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4127     
0E7C    D2AF          4128     	SETB	EA						; Enable interrupts
0E7E    22            4129     	RET							
                      4130     
                      4131     
                      4132     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4133     ;
                      4134     ; Evaluate comparator integrity
                      4135     ;
                      4136     ; No assumptions
                      4137     ;
                      4138     ; Checks comparator signal behaviour versus expected behaviour
                      4139     ;
                      4140     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4141     EVALUATE_COMPARATOR_INTEGRITY: 
0E7F    C25B          4142     CLR FLAGS0 . 3 
                      4143     	; Check if demag compensation is enabled
0E81    789C          4144     MOV R0 , # PGM_DEMAG_COMP 
0E83    E6            4145     MOV A , @ R0 
0E84    14            4146     	DEC	A
0E85    600A          4147     	JZ	EVAL_COMP_NO_DEMAG
                      4148     
                      4149     	; Check if a demag situation has occurred
0E87    E53F          4150     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E89    14            4151     	DEC	A
0E8A    7005          4152     	JNZ	EVAL_COMP_NO_DEMAG
                      4153     
0E8C    206302        4154     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4155     
0E8F    D25B          4156     SETB FLAGS0 . 3 
                      4157     
                      4158     EVAL_COMP_NO_DEMAG: 
0E91    30630B        4159     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4160     
0E94    0538          4161     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0E96    205810        4162     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4163     
0E99    753800        4164     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0E9C    020EA9        4165     	JMP	EVAL_COMP_EXIT
                      4166     
                      4167     EVAL_COMP_CHECK_TIMEOUT: 
0E9F    205807        4168     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EA2    1581          4169     	DEC	SP							; Routine exit without "ret" command
0EA4    1581          4170     	DEC	SP
0EA6    021830        4171     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4172     
                      4173     EVAL_COMP_EXIT: 
0EA9    22            4174     	RET
                      4175     
                      4176     
                      4177     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4178     ;
                      4179     ; Setup commutation timing routine
                      4180     ;
                      4181     ; No assumptions
                      4182     ;
                      4183     ; Sets up and starts wait from commutation to zero cross
                      4184     ;
                      4185     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4186     SETUP_COMM_WAIT:  
0EAA    759100        4187     	MOV	TMR3CN, #00H		; Timer3 disabled
0EAD    C3            4188     	CLR	C
0EAE    E4            4189     	CLR	A
0EAF    954E          4190     	SUBB	A, WT_COMM_L		; Set wait commutation value
0EB1    F594          4191     	MOV	TMR3L, A
0EB3    E4            4192     	CLR	A
0EB4    954F          4193     	SUBB	A, WT_COMM_H		
0EB6    F595          4194     	MOV	TMR3H, A
0EB8    759104        4195     	MOV	TMR3CN, #04H		; Timer3 enabled
0EBB    D258          4196     SETB FLAGS0 . 0 
0EBD    22            4197     	RET
                      4198     
                      4199     
                      4200     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4201     ;
                      4202     ; Wait for commutation routine
                      4203     ;
                      4204     ; No assumptions
                      4205     ;
                      4206     ; Waits from zero cross to commutation 
                      4207     ;
                      4208     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4209     WAIT_FOR_COMM:  
                      4210     	; Increment or reset consecutive count
0EBE    0539          4211     	INC	DEMAG_CONSECUTIVE_CNT
0EC0    205B03        4212     JB FLAGS0 . 3 , ( $+6 ) 
                      4213     
0EC3    753900        4214     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4215     
                      4216     	; Check if a demag situation has occurred
0EC6    305B23        4217     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4218     
                      4219     	; Load programmed demag compensation
0EC9    78A3          4220     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0ECB    E6            4221     MOV A , @ R0 
0ECC    FF            4222     MOV R7 , A 
                      4223     
                      4224     	; Check for power off
0ECD    BF0108        4225     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4226     
0ED0    D25C          4227     SETB FLAGS0 . 4 
                      4228     	ALL_NFETS_OFF
0ED2    C292          4228+1   CLR P1 . 2 
0ED4    C296          4228+1   CLR P1 . 6 
0ED6    C295          4228+1   CLR P1 . 5 
                      4229     
                      4230     	; Wait a blind wait
                      4231     WAIT_FOR_COMM_BLIND: 
0ED8    B11F          4232     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4233     WAIT_DEMAG_DEFAULT_ZC: 	
0EDA    305802        4234     JNB FLAGS0 . 0 , ( $+5 ) 
0EDD    C1DA          4235     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4236     
                      4237     	; Check for power off
0EDF    BF0208        4238     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4239     
0EE2    D25C          4240     SETB FLAGS0 . 4 
                      4241     	ALL_NFETS_OFF
0EE4    C292          4241+1   CLR P1 . 2 
0EE6    C296          4241+1   CLR P1 . 6 
0EE8    C295          4241+1   CLR P1 . 5 
                      4242     
                      4243     WAIT_FOR_COMM_SETUP: 
0EEA    D1AA          4244     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4245     WAIT_FOR_COMM_WAIT: 
0EEC    305802        4246     JNB FLAGS0 . 0 , ( $+5 ) 
0EEF    C1EC          4247     	AJMP	WAIT_FOR_COMM_WAIT					
                      4248     
0EF1    22            4249     	RET
                      4250     
                      4251     
                      4252     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4253     ;
                      4254     ; Commutation routines
                      4255     ;
                      4256     ; No assumptions
                      4257     ;
                      4258     ; Performs commutation switching 
                      4259     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4260     ;
                      4261     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4262     COMM1COMM2: 	
0EF2    C2AF          4263     	CLR 	EA					; Disable all interrupts
                      4264     	BPFET_OFF					; Bp off
0EF4    C294          4264+1   CLR P1 . 4 
0EF6    206A03        4265     JB FLAGS2 . 2 , COMM12_DAMP 
0EF9    020F11        4266     	JMP	COMM12_NONDAMP
                      4267     COMM12_DAMP: 
                      4268     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4272     IF DAMPED_MODE_ENABLE == 1
0EFC    900347        4273     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4274     ENDIF
0EFF    30650F        4275     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4276     	CPFET_OFF				
0F02    207502        4276+1   JB FLAGS3 . 5 , ( $+5 ) 
0F05    C297          4276+1   CLR P1 . 7 
0F07    307502        4276+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F0A    C293          4276+1   CLR P1 . 3 
0F0C    7406          4277     MOV A , # 6 
0F0E    D5E0FD        4278     	DJNZ ACC,	$
                      4279     COMM12_NONDAMP: 
                      4280     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4288     	APFET_ON					; Ap on
0F11    207502        4288+1   JB FLAGS3 . 5 , ( $+5 ) 
0F14    D293          4288+1   SETB P1 . 3 
0F16    307502        4288+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F19    D297          4288+1   SETB P1 . 7 
                      4289     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F1B    759F80        4289+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F1E    753E02        4290     	MOV	COMM_PHASE, #2
0F21    02107C        4291     	JMP	COMM_EXIT
                      4292     
                      4293     COMM2COMM3: 	
0F24    C2AF          4294     	CLR 	EA					; Disable all interrupts
0F26    206A03        4295     JB FLAGS2 . 2 , COMM23_DAMP 
0F29    020F46        4296     	JMP	COMM23_NONDAMP
                      4297     COMM23_DAMP: 
                      4298     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4301     IF DAMPED_MODE_ENABLE == 1
0F2C    9002FE        4302     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4303     ENDIF
0F2F    306517        4304     JNB FLAGS1 . 5 , COMM23_NFET 
                      4305     	BPFET_OFF				
0F32    C294          4305+1   CLR P1 . 4 
                      4306     	CPFET_OFF				
0F34    207502        4306+1   JB FLAGS3 . 5 , ( $+5 ) 
0F37    C297          4306+1   CLR P1 . 7 
0F39    307502        4306+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F3C    C293          4306+1   CLR P1 . 3 
0F3E    7406          4307     MOV A , # 6 
0F40    D5E0FD        4308     	DJNZ ACC,	$
0F43    020F49        4309     	JMP	COMM23_NFET
                      4310     COMM23_NONDAMP: 
0F46    9001E1        4311     	MOV	DPTR, #PWM_BFET_ON	
                      4312     COMM23_NFET: 
                      4313     	CNFET_OFF					; Cn off
0F49    207502        4313+1   JB FLAGS3 . 5 , ( $+5 ) 
0F4C    C296          4313+1   CLR P1 . 6 
0F4E    307502        4313+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F51    C292          4313+1   CLR P1 . 2 
0F53    305A06        4314     JNB FLAGS0 . 2 , COMM23_CP 
                      4315     	BNFET_ON					; Yes - Bn on
0F56    E525          4315+1   MOV A , CURRENT_PWM_LIMITED 
0F58    6002          4315+1   JZ ( $+4 ) 
0F5A    D295          4315+1   SETB P1 . 5 
                      4316     COMM23_CP: 
                      4317     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F5C    207503        4317+1   JB FLAGS3 . 5 , ( $+6 ) 
0F5F    759F89        4317+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F62    307503        4317+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F65    759F81        4317+1   MOV CPT0MX , # 81H 
0F68    753E03        4318     	MOV	COMM_PHASE, #3
0F6B    02107C        4319     	JMP	COMM_EXIT
                      4320     
                      4321     COMM3COMM4: 	
0F6E    C2AF          4322     	CLR 	EA					; Disable all interrupts
                      4323     	APFET_OFF					; Ap off
0F70    207502        4323+1   JB FLAGS3 . 5 , ( $+5 ) 
0F73    C293          4323+1   CLR P1 . 3 
0F75    307502        4323+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F78    C297          4323+1   CLR P1 . 7 
0F7A    206A03        4324     JB FLAGS2 . 2 , COMM34_DAMP 
0F7D    020F8D        4325     	JMP	COMM34_NONDAMP
                      4326     COMM34_DAMP: 
                      4327     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4331     IF DAMPED_MODE_ENABLE == 1
0F80    9002BD        4332     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4333     ENDIF
0F83    306507        4334     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4335     	BPFET_OFF				
0F86    C294          4335+1   CLR P1 . 4 
0F88    7406          4336     MOV A , # 6 
0F8A    D5E0FD        4337     	DJNZ ACC,	$
                      4338     COMM34_NONDAMP: 
                      4339     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4347     	CPFET_ON					; Cp on
0F8D    207502        4347+1   JB FLAGS3 . 5 , ( $+5 ) 
0F90    D297          4347+1   SETB P1 . 7 
0F92    307502        4347+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F95    D293          4347+1   SETB P1 . 3 
                      4348     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F97    207503        4348+1   JB FLAGS3 . 5 , ( $+6 ) 
0F9A    759F81        4348+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F9D    307503        4348+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FA0    759F89        4348+1   MOV CPT0MX , # 89H 
0FA3    753E04        4349     	MOV	COMM_PHASE, #4
0FA6    02107C        4350     	JMP	COMM_EXIT
                      4351     
                      4352     COMM4COMM5: 	
0FA9    C2AF          4353     	CLR 	EA					; Disable all interrupts
0FAB    206A03        4354     JB FLAGS2 . 2 , COMM45_DAMP 
0FAE    020FCB        4355     	JMP	COMM45_NONDAMP
                      4356     COMM45_DAMP: 
                      4357     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4360     IF DAMPED_MODE_ENABLE == 1
0FB1    90027C        4361     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4362     ENDIF
0FB4    306517        4363     JNB FLAGS1 . 5 , COMM45_NFET 
                      4364     	APFET_OFF				
0FB7    207502        4364+1   JB FLAGS3 . 5 , ( $+5 ) 
0FBA    C293          4364+1   CLR P1 . 3 
0FBC    307502        4364+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FBF    C297          4364+1   CLR P1 . 7 
                      4365     	BPFET_OFF				
0FC1    C294          4365+1   CLR P1 . 4 
0FC3    7406          4366     MOV A , # 6 
0FC5    D5E0FD        4367     	DJNZ ACC,	$
0FC8    020FCE        4368     	JMP	COMM45_NFET
                      4369     COMM45_NONDAMP: 
0FCB    9001CF        4370     	MOV	DPTR, #PWM_AFET_ON
                      4371     COMM45_NFET: 
                      4372     	BNFET_OFF					; Bn off
0FCE    C295          4372+1   CLR P1 . 5 
0FD0    305A0E        4373     JNB FLAGS0 . 2 , COMM45_CP 
                      4374     	ANFET_ON					; Yes - An on
0FD3    E525          4374+1   MOV A , CURRENT_PWM_LIMITED 
0FD5    600A          4374+1   JZ ( $+12 ) 
0FD7    207502        4374+1   JB FLAGS3 . 5 , ( $+5 ) 
0FDA    D292          4374+1   SETB P1 . 2 
0FDC    307502        4374+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FDF    D296          4374+1   SETB P1 . 6 
                      4375     COMM45_CP: 
                      4376     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FE1    759F80        4376+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FE4    753E05        4377     	MOV	COMM_PHASE, #5
0FE7    02107C        4378     	JMP	COMM_EXIT
                      4379     
                      4380     COMM5COMM6: 	
0FEA    C2AF          4381     	CLR 	EA					; Disable all interrupts
                      4382     	CPFET_OFF					; Cp off
0FEC    207502        4382+1   JB FLAGS3 . 5 , ( $+5 ) 
0FEF    C297          4382+1   CLR P1 . 7 
0FF1    307502        4382+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF4    C293          4382+1   CLR P1 . 3 
0FF6    206A03        4383     JB FLAGS2 . 2 , COMM56_DAMP 
0FF9    021011        4384     	JMP	COMM56_NONDAMP
                      4385     COMM56_DAMP: 
                      4386     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4390     IF DAMPED_MODE_ENABLE == 1
0FFC    900233        4391     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4392     ENDIF
0FFF    30650F        4393     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4394     	APFET_OFF				
1002    207502        4394+1   JB FLAGS3 . 5 , ( $+5 ) 
1005    C293          4394+1   CLR P1 . 3 
1007    307502        4394+1   JNB FLAGS3 . 5 , ( $+5 ) 
100A    C297          4394+1   CLR P1 . 7 
100C    7406          4395     MOV A , # 6 
100E    D5E0FD        4396     	DJNZ ACC,	$
                      4397     COMM56_NONDAMP: 
                      4398     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4406     	BPFET_ON					; Bp on
1011    D294          4406+1   SETB P1 . 4 
                      4407     	SET_COMP_PHASE_C 			; Set comparator to phase C
1013    207503        4407+1   JB FLAGS3 . 5 , ( $+6 ) 
1016    759F89        4407+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1019    307503        4407+1   JNB FLAGS3 . 5 , ( $+6 ) 
101C    759F81        4407+1   MOV CPT0MX , # 81H 
101F    753E06        4408     	MOV	COMM_PHASE, #6
1022    02107C        4409     	JMP	COMM_EXIT
                      4410     
                      4411     COMM6COMM1: 	
1025    C2AF          4412     	CLR 	EA					; Disable all interrupts
1027    206A03        4413     JB FLAGS2 . 2 , COMM61_DAMP 
102A    02104F        4414     	JMP	COMM61_NONDAMP
                      4415     COMM61_DAMP: 
                      4416     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4419     IF DAMPED_MODE_ENABLE == 1
102D    9003A0        4420     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4421     ENDIF
1030    30651F        4422     JNB FLAGS1 . 5 , COMM61_NFET 
                      4423     	APFET_OFF				
1033    207502        4423+1   JB FLAGS3 . 5 , ( $+5 ) 
1036    C293          4423+1   CLR P1 . 3 
1038    307502        4423+1   JNB FLAGS3 . 5 , ( $+5 ) 
103B    C297          4423+1   CLR P1 . 7 
                      4424     	CPFET_OFF				
103D    207502        4424+1   JB FLAGS3 . 5 , ( $+5 ) 
1040    C297          4424+1   CLR P1 . 7 
1042    307502        4424+1   JNB FLAGS3 . 5 , ( $+5 ) 
1045    C293          4424+1   CLR P1 . 3 
1047    7406          4425     MOV A , # 6 
1049    D5E0FD        4426     	DJNZ ACC,	$
104C    021052        4427     	JMP	COMM61_NFET
                      4428     COMM61_NONDAMP: 
104F    9001F3        4429     	MOV	DPTR, #PWM_CFET_ON
                      4430     COMM61_NFET: 
                      4431     	ANFET_OFF					; An off
1052    207502        4431+1   JB FLAGS3 . 5 , ( $+5 ) 
1055    C292          4431+1   CLR P1 . 2 
1057    307502        4431+1   JNB FLAGS3 . 5 , ( $+5 ) 
105A    C296          4431+1   CLR P1 . 6 
105C    305A0E        4432     JNB FLAGS0 . 2 , COMM61_CP 
                      4433     	CNFET_ON					; Yes - Cn on
105F    E525          4433+1   MOV A , CURRENT_PWM_LIMITED 
1061    600A          4433+1   JZ ( $+12 ) 
1063    207502        4433+1   JB FLAGS3 . 5 , ( $+5 ) 
1066    D296          4433+1   SETB P1 . 6 
1068    307502        4433+1   JNB FLAGS3 . 5 , ( $+5 ) 
106B    D292          4433+1   SETB P1 . 2 
                      4434     COMM61_CP: 
                      4435     	SET_COMP_PHASE_A 			; Set comparator to phase A
106D    207503        4435+1   JB FLAGS3 . 5 , ( $+6 ) 
1070    759F81        4435+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1073    307503        4435+1   JNB FLAGS3 . 5 , ( $+6 ) 
1076    759F89        4435+1   MOV CPT0MX , # 89H 
1079    753E01        4436     	MOV	COMM_PHASE, #1
                      4437     
                      4438     COMM_EXIT: 
107C    D2AF          4439     	SETB	EA					; Enable all interrupts
107E    789C          4440     MOV R0 , # PGM_DEMAG_COMP 
1080    E6            4441     MOV A , @ R0 
1081    C3            4442     	CLR	C
1082    9402          4443     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
1084    4007          4444     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4445     
1086    C3            4446     	CLR	C
1087    E539          4447     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1089    9403          4448     	SUBB	A, #3
108B    5002          4449     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4450     
                      4451     COMM_RESTORE_POWER: 
108D    C25C          4452     CLR FLAGS0 . 4 
                      4453     
                      4454     COMM_RETURN: 
108F    22            4455     	RET
                      4456     
                      4457     
                      4458     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4459     ;
                      4460     ; Switch power off routine
                      4461     ;
                      4462     ; No assumptions
                      4463     ;
                      4464     ; Switches all fets off 
                      4465     ;
                      4466     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4467     SWITCH_POWER_OFF: 
1090    9001CD        4468     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4469     	ALL_NFETS_OFF			; Turn off all nfets
1093    C292          4469+1   CLR P1 . 2 
1095    C296          4469+1   CLR P1 . 6 
1097    C295          4469+1   CLR P1 . 5 
                      4470     	ALL_PFETS_OFF			; Turn off all pfets
1099    C293          4470+1   CLR P1 . 3 
109B    C297          4470+1   CLR P1 . 7 
109D    C294          4470+1   CLR P1 . 4 
109F    C25A          4471     CLR FLAGS0 . 2 
10A1    22            4472     	RET			
                      4473     
                      4474     
                      4475     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4476     ;
                      4477     ; Decrement stepper step routine
                      4478     ;
                      4479     ; No assumptions
                      4480     ;
                      4481     ; Decrements the stepper step 
                      4482     ;
                      4483     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4484     DECREMENT_STEPPER_STEP: 
10A2    C3            4485     	CLR	C
10A3    E550          4486     	MOV	A, WT_STEPPER_STEP_L
10A5    9535          4487     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
10A7    E551          4488     	MOV	A, WT_STEPPER_STEP_H
10A9    9536          4489     	SUBB	A, STEPPER_STEP_END_H	
10AB    5001          4490     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
10AD    22            4491     	RET
                      4492     
                      4493     DECREMENT_STEP: 
                      4494     	; Load programmed startup acceleration
10AE    7890          4495     MOV R0 , # PGM_STARTUP_ACCEL 
10B0    E6            4496     MOV A , @ R0 
10B1    FF            4497     MOV R7 , A 
                      4498     	; Check acceleration setting and set step size accordingly
10B2    C3            4499     	CLR	C
10B3    EF            4500     MOV A , R7 
10B4    9405          4501     	SUBB	A, #5
10B6    5018          4502     	JNC	DEC_STEP_HIGH
10B8    C3            4503     	CLR	C
10B9    EF            4504     MOV A , R7 
10BA    9404          4505     	SUBB	A, #4
10BC    501B          4506     	JNC	DEC_STEP_MED_HIGH
10BE    C3            4507     	CLR	C
10BF    EF            4508     MOV A , R7 
10C0    9403          4509     	SUBB	A, #3
10C2    501E          4510     	JNC	DEC_STEP_MED
10C4    C3            4511     	CLR	C
10C5    EF            4512     MOV A , R7 
10C6    9402          4513     	SUBB	A, #2
10C8    5021          4514     	JNC	DEC_STEP_MED_LOW
10CA    C3            4515     	CLR	C
10CB    EF            4516     MOV A , R7 
10CC    9401          4517     	SUBB	A, #1
10CE    5024          4518     	JNC	DEC_STEP_LOW
                      4519     
                      4520     DEC_STEP_HIGH: 
10D0    C3            4521     	CLR	C
10D1    E550          4522     	MOV	A, WT_STEPPER_STEP_L
10D3    943C          4523     	SUBB	A, #LOW(30 SHL 1)		
10D5    F8            4524     MOV R0 , A 
10D6    0210FD        4525     	JMP	DECREMENT_STEP_EXIT
                      4526     DEC_STEP_MED_HIGH: 
10D9    C3            4527     	CLR	C
10DA    E550          4528     	MOV	A, WT_STEPPER_STEP_L
10DC    9428          4529     	SUBB	A, #LOW(20 SHL 1)		
10DE    F8            4530     MOV R0 , A 
10DF    0210FD        4531     	JMP	DECREMENT_STEP_EXIT
                      4532     DEC_STEP_MED: 
10E2    C3            4533     	CLR	C
10E3    E550          4534     	MOV	A, WT_STEPPER_STEP_L
10E5    941A          4535     	SUBB	A, #LOW(13 SHL 1)		
10E7    F8            4536     MOV R0 , A 
10E8    0210FD        4537     	JMP	DECREMENT_STEP_EXIT
                      4538     DEC_STEP_MED_LOW: 
10EB    C3            4539     	CLR	C
10EC    E550          4540     	MOV	A, WT_STEPPER_STEP_L
10EE    9412          4541     	SUBB	A, #LOW(9 SHL 1)		
10F0    F8            4542     MOV R0 , A 
10F1    0210FD        4543     	JMP	DECREMENT_STEP_EXIT
                      4544     DEC_STEP_LOW: 
10F4    C3            4545     	CLR	C
10F5    E550          4546     	MOV	A, WT_STEPPER_STEP_L
10F7    940A          4547     	SUBB	A, #LOW(5 SHL 1)		
10F9    F8            4548     MOV R0 , A 
10FA    0210FD        4549     	JMP	DECREMENT_STEP_EXIT
                      4550     
                      4551     DECREMENT_STEP_EXIT: 
10FD    E551          4552     	MOV	A, WT_STEPPER_STEP_H
10FF    9400          4553     	SUBB	A, #0		
1101    F9            4554     MOV R1 , A 
1102    8850          4555     MOV WT_STEPPER_STEP_L , R0 
1104    8951          4556     MOV WT_STEPPER_STEP_H , R1 
1106    22            4557     	RET
                      4558     
                      4559     
                      4560     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4561     ;
                      4562     ; Stepper timer wait
                      4563     ;
                      4564     ; No assumptions
                      4565     ;
                      4566     ; Waits for the stepper step timer to elapse
                      4567     ;
                      4568     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4569     STEPPER_TIMER_WAIT: 
1107    305802        4570     JNB FLAGS0 . 0 , ( $+5 ) 
110A    2107          4571     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
110C    22            4572     	RET
                      4573     
                      4574     
                      4575     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4576     ;
                      4577     ; Set default parameters
                      4578     ;
                      4579     ; No assumptions
                      4580     ;
                      4581     ; Sets default programming parameters
                      4582     ;
                      4583     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4584     SET_DEFAULT_PARAMETERS: 
                      4585     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4646     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4707     IF MODE == 2	; Multi
110D    7880          4708     MOV R0 , # PGM_GOV_P_GAIN 
110F    7609          4709     MOV @ R0 , # 9 
1111    08            4710     INC R0 
1112    7609          4711     MOV @ R0 , # 9 
1114    08            4712     INC R0 
1115    7604          4713     MOV @ R0 , # 4 
1117    08            4714     INC R0 
1118    7601          4715     MOV @ R0 , # 1 
111A    08            4716     INC R0 
111B    7603          4717     MOV @ R0 , # 3 
111D    08            4718     INC R0 
111E    76FF          4719     MOV @ R0 , # 0XFF 
1120    08            4720     INC R0 
1121    7609          4721     MOV @ R0 , # 9 
1123    08            4722     INC R0 
1124    7601          4723     MOV @ R0 , # 1 
1126    08            4724     INC R0 
1127    7601          4725     MOV @ R0 , # 1 
1129    08            4726     INC R0 
112A    7601          4727     MOV @ R0 , # 1 
                      4728     
112C    788C          4729     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
112E    7600          4730     MOV @ R0 , # 0 
1130    08            4731     INC R0 
1131    76FF          4732     MOV @ R0 , # 0XFF 
1133    08            4733     INC R0 
1134    76FF          4734     MOV @ R0 , # 0XFF 
1136    08            4735     INC R0 
1137    7601          4736     MOV @ R0 , # 1 
1139    08            4737     INC R0 
113A    7605          4738     MOV @ R0 , # 5 
113C    08            4739     INC R0 
113D    76FF          4740     MOV @ R0 , # 0XFF 
113F    08            4741     INC R0 
1140    7603          4742     MOV @ R0 , # 3 
1142    08            4743     INC R0 
1143    7606          4744     MOV @ R0 , # 6 
1145    08            4745     INC R0 
1146    76FF          4746     MOV @ R0 , # 0XFF 
1148    08            4747     INC R0 
1149    7602          4748     MOV @ R0 , # 2 
114B    08            4749     INC R0 
114C    7603          4750     MOV @ R0 , # 3 
114E    08            4751     INC R0 
114F    76FA          4752     MOV @ R0 , # 250 
1151    08            4753     INC R0 
1152    7628          4754     MOV @ R0 , # 40 
1154    08            4755     INC R0 
1155    7628          4756     MOV @ R0 , # 40 
1157    08            4757     INC R0 
1158    7605          4758     MOV @ R0 , # 5 
115A    08            4759     INC R0 
115B    760D          4760     MOV @ R0 , # 13 
115D    08            4761     INC R0 
115E    7602          4762     MOV @ R0 , # 2 
1160    08            4763     INC R0 
1161    7600          4764     MOV @ R0 , # 0 
1163    08            4765     INC R0 
1164    767D          4766     MOV @ R0 , # 125 
                      4767     ENDIF
1166    22            4768     	RET
                      4769     
                      4770     
                      4771     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4772     ;
                      4773     ; Decode parameters
                      4774     ;
                      4775     ; No assumptions
                      4776     ;
                      4777     ; Decodes programming parameters
                      4778     ;
                      4779     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4780     DECODE_PARAMETERS: 
                      4781     	; Load programmed damping force
1167    7893          4782     MOV R0 , # PGM_DAMPING_FORCE 
1169    E6            4783     MOV A , @ R0 
116A    FF            4784     MOV R7 , A 
                      4785     	; Decode damping
116B    756609        4786     	MOV	DAMPING_PERIOD, #9		; Set default
116E    756701        4787     	MOV	DAMPING_ON, #1
1171    C3            4788     	CLR	C
1172    BF0206        4789     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      4790     
1175    756605        4791     	MOV	DAMPING_PERIOD, #5
1178    756701        4792     	MOV	DAMPING_ON, #1
                      4793     
                      4794     DECODE_DAMPING_3: 
117B    C3            4795     	CLR	C
117C    BF0306        4796     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      4797     
117F    756605        4798     	MOV	DAMPING_PERIOD, #5
1182    756702        4799     	MOV	DAMPING_ON, #2
                      4800     
                      4801     DECODE_DAMPING_4: 
1185    C3            4802     	CLR	C
1186    BF0406        4803     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      4804     
1189    756605        4805     	MOV	DAMPING_PERIOD, #5
118C    756703        4806     	MOV	DAMPING_ON, #3
                      4807     
                      4808     DECODE_DAMPING_5: 
118F    C3            4809     	CLR	C
1190    BF0506        4810     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      4811     
1193    756609        4812     	MOV	DAMPING_PERIOD, #9
1196    756707        4813     	MOV	DAMPING_ON, #7
                      4814     
                      4815     DECODE_DAMPING_6: 
1199    C3            4816     	CLR	C
119A    BF0606        4817     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      4818     
119D    756600        4819     	MOV	DAMPING_PERIOD, #0
11A0    756700        4820     	MOV	DAMPING_ON, #0
                      4821     
                      4822     DECODE_DAMPING_DONE: 
                      4823     	; Load programmed pwm frequency
11A3    7887          4824     MOV R0 , # PGM_PWM_FREQ 
11A5    E6            4825     MOV A , @ R0 
11A6    FF            4826     MOV R7 , A 
                      4827     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      4834     IF MODE >= 1	; Tail or multi
11A7    C26C          4835     CLR FLAGS2 . 4 
11A9    C3            4836     	CLR	C
11AA    BF0302        4837     CJNE R7 , # 3 , ( $+5 ) 
11AD    D26C          4838     SETB FLAGS2 . 4 
11AF    C26B          4839     CLR FLAGS2 . 3 
11B1    C3            4840     	CLR	C
11B2    BF0402        4841     CJNE R7 , # 4 , ( $+5 ) 
11B5    D26B          4842     SETB FLAGS2 . 3 
                      4843     ENDIF
11B7    C26A          4844     CLR FLAGS2 . 2 
11B9    7418          4845     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11BB    552D          4846     	ANL	A, FLAGS2					; Check if any damped mode is set
11BD    6002          4847     	JZ	($+4)
11BF    D26A          4848     SETB FLAGS2 . 2 
11C1    C265          4849     CLR FLAGS1 . 5 
11C3    6002          4850     	JZ	($+4)
11C5    D265          4851     SETB FLAGS1 . 5 
11C7    D266          4852     SETB FLAGS1 . 6 
11C9    6002          4853     	JZ	($+4)
11CB    C266          4854     CLR FLAGS1 . 6 
                      4855     	; Load programmed direction
11CD    7888          4856     MOV R0 , # PGM_DIRECTION 
                      4857     IF MODE >= 1	; Tail or multi
11CF    E6            4858     MOV A , @ R0 
11D0    C3            4859     	CLR	C
11D1    9403          4860     	SUBB	A, #3
11D3    6008          4861     	JZ	DECODE_PARAMS_DIR_SET
                      4862     ENDIF
                      4863     
11D5    C275          4864     CLR FLAGS3 . 5 
11D7    E6            4865     MOV A , @ R0 
11D8    30E102        4866     	JNB	ACC.1, ($+5)
11DB    D275          4867     SETB FLAGS3 . 5 
                      4868     DECODE_PARAMS_DIR_SET: 
11DD    C276          4869     CLR FLAGS3 . 6 
11DF    7889          4870     MOV R0 , # PGM_INPUT_POL 
11E1    E6            4871     MOV A , @ R0 
11E2    30E102        4872     	JNB	ACC.1, ($+5)
11E5    D276          4873     SETB FLAGS3 . 6 
11E7    C3            4874     	CLR	C
11E8    EF            4875     MOV A , R7 
11E9    9402          4876     	SUBB	A, #2
11EB    6008          4877     	JZ	DECODE_PWM_FREQ_LOW
                      4878     
11ED    758E01        4879     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
11F0    D26D          4880     SETB FLAGS2 . 5 
11F2    0211FA        4881     	JMP	DECODE_PWM_FREQ_END
                      4882     
                      4883     DECODE_PWM_FREQ_LOW: 
11F5    758E00        4884     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
11F8    C26D          4885     CLR FLAGS2 . 5 
                      4886     
                      4887     DECODE_PWM_FREQ_END: 
11FA    22            4888     	RET
                      4889     
                      4890     
                      4891     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4892     ;
                      4893     ; Decode governor gain
                      4894     ;
                      4895     ; No assumptions
                      4896     ;
                      4897     ; Decodes governor gains
                      4898     ;
                      4899     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4900     DECODE_GOVERNOR_GAINS: 
                      4901     	; Decode governor gains
11FB    7880          4902     MOV R0 , # PGM_GOV_P_GAIN 
11FD    E6            4903     MOV A , @ R0 
11FE    14            4904     	DEC	A	
11FF    900080        4905     	MOV	DPTR, #GOV_GAIN_TABLE
1202    93            4906     	MOVC A, @A+DPTR	
1203    789F          4907     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
1205    F6            4908     MOV @ R0 , A 
1206    7881          4909     MOV R0 , # PGM_GOV_I_GAIN 
1208    E6            4910     MOV A , @ R0 
1209    14            4911     	DEC	A	
120A    900080        4912     	MOV	DPTR, #GOV_GAIN_TABLE
120D    93            4913     	MOVC A, @A+DPTR	
120E    78A0          4914     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1210    F6            4915     MOV @ R0 , A 
1211    1190          4916     	CALL	SWITCH_POWER_OFF		; Reset DPTR
1213    22            4917     	RET
                      4918     
                      4919     
                      4920     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4921     ;
                      4922     ; Decode throttle rate
                      4923     ;
                      4924     ; No assumptions
                      4925     ;
                      4926     ; Decodes throttle rate
                      4927     ;
                      4928     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4929     DECODE_THROTTLE_RATE: 
                      4930     	; Decode throttle rate
1214    789B          4931     MOV R0 , # PGM_THROTTLE_RATE 
1216    E6            4932     MOV A , @ R0 
1217    14            4933     	DEC	A	
1218    90008D        4934     	MOV	DPTR, #THROTTLE_RATE_TABLE
121B    93            4935     	MOVC A, @A+DPTR	
121C    78A1          4936     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
121E    F6            4937     MOV @ R0 , A 
121F    1190          4938     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1221    22            4939     	RET
                      4940     
                      4941     
                      4942     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4943     ;
                      4944     ; Decode startup power
                      4945     ;
                      4946     ; No assumptions
                      4947     ;
                      4948     ; Decodes startup power
                      4949     ;
                      4950     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4951     DECODE_STARTUP_POWER: 
                      4952     	; Decode startup power
1222    7886          4953     MOV R0 , # PGM_STARTUP_PWR 
1224    E6            4954     MOV A , @ R0 
1225    14            4955     	DEC	A	
1226    90009A        4956     	MOV	DPTR, #STARTUP_POWER_TABLE
1229    93            4957     	MOVC A, @A+DPTR	
122A    78A2          4958     MOV R0 , # PGM_STARTUP_PWR_DECODED 
122C    F6            4959     MOV @ R0 , A 
122D    1190          4960     	CALL	SWITCH_POWER_OFF			; Reset DPTR
122F    22            4961     	RET
                      4962     
                      4963     
                      4964     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4965     ;
                      4966     ; Decode demag compensation
                      4967     ;
                      4968     ; No assumptions
                      4969     ;
                      4970     ; Decodes throttle rate
                      4971     ;
                      4972     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4973     DECODE_DEMAG_COMP: 
                      4974     	; Decode demag compensation
1230    789C          4975     MOV R0 , # PGM_DEMAG_COMP 
1232    E6            4976     MOV A , @ R0 
1233    14            4977     	DEC	A	
1234    9000A7        4978     	MOV	DPTR, #DEMAG_POWER_TABLE
1237    93            4979     	MOVC A, @A+DPTR	
1238    78A3          4980     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
123A    F6            4981     MOV @ R0 , A 
123B    1190          4982     	CALL	SWITCH_POWER_OFF			; Reset DPTR
123D    22            4983     	RET
                      4984     
                      4985     
                      4986     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4987     ;
                      4988     ; Set BEC voltage
                      4989     ;
                      4990     ; No assumptions
                      4991     ;
                      4992     ; Sets the BEC output voltage low or high
                      4993     ;
                      4994     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4995     SET_BEC_VOLTAGE: 
                      4996     	; Set bec voltage
                      4997     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
123E    22            5007     	RET
                      5008     
                      5009     
                      5010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5011     ;
                      5012     ; Find throttle gain
                      5013     ;
                      5014     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5015     ;
                      5016     ; Finds throttle gain from throttle calibration values
                      5017     ;
                      5018     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5019     FIND_THROTTLE_GAIN: 
                      5020     	; Load programmed minimum and maximum throttle
123F    7896          5021     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1241    E6            5022     MOV A , @ R0 
1242    FA            5023     MOV R2 , A 
1243    7897          5024     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1245    E6            5025     MOV A , @ R0 
1246    FB            5026     MOV R3 , A 
                      5027     	; Check if full range is chosen
1247    307704        5028     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5029     
124A    7A00          5030     MOV R2 , # 0 
124C    7BFF          5031     MOV R3 , # 255 
                      5032     
                      5033     FIND_THROTTLE_GAIN_CALCULATE: 
                      5034     	; Calculate difference
124E    C3            5035     	CLR	C
124F    EB            5036     MOV A , R3 
1250    9A            5037     SUBB A , R2 
1251    FC            5038     MOV R4 , A 
                      5039     	; Check that difference is minimum 130
1252    C3            5040     	CLR	C
1253    9482          5041     	SUBB	A, #130
1255    5002          5042     	JNC	($+4)
                      5043     
1257    7C82          5044     MOV R4 , # 130 
                      5045     
                      5046     	; Find gain
1259    756E00        5047     	MOV	PPM_THROTTLE_GAIN, #0
                      5048     TEST_THROTTLE_GAIN: 
125C    056E          5049     	INC	PPM_THROTTLE_GAIN
125E    EC            5050     MOV A , R4 
125F    856EF0        5051     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1262    A4            5052     	MUL	AB
1263    C3            5053     	CLR	C
1264    E5F0          5054     	MOV	A, B
1266    9480          5055     	SUBB	A, #128
1268    40F2          5056     	JC	TEST_THROTTLE_GAIN
126A    22            5057     	RET
                      5058     
                      5059     
                      5060     
                      5061     
                      5062     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5063     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5064     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5065     ;
                      5066     ; Main program start
                      5067     ;
                      5068     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5069     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5070     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5071     
                      5072     RESET: 
                      5073     	; Check flash lock byte
126B    E5EF          5074     	MOV	A, RSTSRC			
126D    20E603        5075     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5076     
1270    752000        5077     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5078     
1273    0520          5079     	INC	BIT_ACCESS
1275    903FFF        5080     MOV DPTR , # 16383 
1278    E520          5081     	MOV	A, BIT_ACCESS
127A    14            5082     	DEC	A
127B    6006          5083     	JZ	LOCK_BYTE_TEST
                      5084     
127D    901FFF        5085     MOV DPTR , # 8191 
1280    14            5086     	DEC	A
1281    6000          5087     	JZ	LOCK_BYTE_TEST
                      5088     
                      5089     LOCK_BYTE_TEST: 
1283    93            5090     	MOVC A, @A+DPTR		; Read lock byte
1284    04            5091     	INC	A				
1285    6003          5092     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5093     
                      5094     IF ONE_S_CAPABLE == 0		
1287    75EF12        5095     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5096     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5099     
                      5100     LOCK_BYTE_OK: 
                      5101     	; Select register bank 0 for main program routines
128A    C2D3          5102     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5103     	; Disable the WDT.
128C    53D9BF        5104     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5105     	; Initialize stack
128F    7581C0        5106     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5107     	; Initialize VDD monitor
1292    43FF80        5108     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1295    1207EB        5109     	CALL	WAIT1MS			; Wait at least 100us
                      5110     IF ONE_S_CAPABLE == 0		
1298    75EF02        5111     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5112     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5115     	; Set clock frequency
129B    43B203        5116     	ORL	OSCICN, #03H		; Set clock divider to 1
129E    E5B3          5117     	MOV	A, OSCICL				
12A0    2404          5118     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
12A2    4002          5119     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5120     
12A4    F5B3          5121     	MOV	OSCICL, A
                      5122     
                      5123     RESET_CAL_DONE: 
                      5124     	; Switch power off
12A6    1190          5125     	CALL	SWITCH_POWER_OFF
                      5126     	; Ports initialization
12A8    7580FF        5127     MOV P0 , # 255 
12AB    75A400        5128     MOV P0MDOUT , # 0 
12AE    75F1F0        5129     MOV P0MDIN , # -16 
12B1    75D4DF        5130     MOV P0SKIP , # -33 
12B4    759002        5131     MOV P1 , # 2 
12B7    75A5FC        5132     MOV P1MDOUT , # 252 
12BA    75F2FD        5133     MOV P1MDIN , # -3 
12BD    75D502        5134     MOV P1SKIP , # 2 
                      5135     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12C0    75A610        5138     MOV P2MDOUT , # 16 
                      5139     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5146     	; Initialize the XBAR and related functionality
                      5147     	INITIALIZE_XBAR		
12C3    75A0FF        5147+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12C6    75F3F1        5147+1   MOV P2MDIN , # -15 
12C9    75E241        5147+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5148     	; Clear RAM
12CC    E4            5149     	CLR	A				; Clear accumulator
12CD    F8            5150     MOV R0 , A 
                      5151     CLEAR_RAM: 	
12CE    F6            5152     MOV @ R0 , A 
12CF    D8FD          5153     DJNZ R0 , CLEAR_RAM 
                      5154     	; Set default programmed parameters
12D1    310D          5155     	CALL	SET_DEFAULT_PARAMETERS
                      5156     	; EEPROM 还原为默认值
12D3    1218A9        5157     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      5158     	; Decode parameters
12D6    3167          5159     	CALL	DECODE_PARAMETERS
                      5160     	; Decode governor gains
12D8    31FB          5161     	CALL	DECODE_GOVERNOR_GAINS
                      5162     	; Decode throttle rate
12DA    5114          5163     	CALL	DECODE_THROTTLE_RATE
                      5164     	; Decode startup power
12DC    5122          5165     	CALL	DECODE_STARTUP_POWER
                      5166     	; Decode demag compensation
12DE    5130          5167     	CALL	DECODE_DEMAG_COMP
                      5168     	; Set BEC voltage
12E0    513E          5169     	CALL	SET_BEC_VOLTAGE
                      5170     	; Find throttle gain from stored min and max settings
12E2    513F          5171     	CALL	FIND_THROTTLE_GAIN
                      5172     	; Set beep strength
12E4    7898          5173     MOV R0 , # PGM_BEEP_STRENGTH 
12E6    866F          5174     MOV BEEP_STRENGTH , @ R0 
                      5175     	; Switch power off
12E8    1190          5176     	CALL	SWITCH_POWER_OFF
                      5177     	; Timer control
12EA    758850        5178     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5179     	; Timer mode
12ED    758902        5180     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5181     	; Timer2: clk/12 for 128us and 32ms interrupts
12F0    75C824        5182     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5183     	; Timer3: clk/12 for commutation timing
12F3    759104        5184     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5185     	; PCA
12F6    75D840        5186     	MOV	PCA0CN, #40H		; PCA enabled
                      5187     	; Initializing beep
12F9    C2AF          5188     	CLR	EA				; Disable interrupts explicitly
12FB    120804        5189     	CALL WAIT200MS	
12FE    120814        5190     	CALL BEEP_F1
1301    1207FA        5191     	CALL WAIT30MS
1304    12081B        5192     	CALL BEEP_F2
1307    1207FA        5193     	CALL WAIT30MS
130A    120822        5194     	CALL BEEP_F3
130D    1207FA        5195     	CALL WAIT30MS
                      5196     
                      5197     	; Wait for receiver to initialize
1310    121CB8        5198     	CALL	WAIT1S
1313    120804        5199     	CALL	WAIT200MS
1316    120804        5200     	CALL	WAIT200MS
1319    1207FF        5201     	CALL	WAIT100MS
                      5202     
                      5203     	; Enable interrupts
131C    75A822        5204     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
131F    75B802        5205     	MOV	IP, #02H			; High priority to timer0 interrupts
1322    75E690        5206     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5207     	; Initialize comparator
1325    759B80        5208     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1328    759D03        5209     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5210     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5214     	; Initialize ADC
                      5215     	INITIALIZE_ADC			; Initialize ADC operation
132B    75D10E        5215+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
132E    75BC58        5215+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1331    75BB09        5215+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1334    75BA11        5215+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1337    75E880        5215+1   MOV ADC0CN , # 80H  ; ADC ENABLED
133A    1207EB        5216     	CALL	WAIT1MS
133D    D2AF          5217     	SETB	EA				; Enable all interrupts
                      5218     	; Measure number of lipo cells
133F    120ACC        5219     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5220     	; Initialize rc pulse
                      5221     	RCP_INT_ENABLE		 			; Enable interrupt
1342    43DA01        5221+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5222     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1345    C2D8          5222+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1347    C269          5223     CLR FLAGS2 . 1 
1349    120804        5224     	CALL WAIT200MS
                      5225     	; Set initial arm variable
134C    753001        5226     	MOV	INITIAL_ARM, #1
                      5227     
                      5228     	; Measure PWM frequency
                      5229     MEASURE_PWM_FREQ_INIT: 	
134F    D259          5230     SETB FLAGS0 . 1 
                      5231     MEASURE_PWM_FREQ_START: 	
1351    7A05          5232     MOV R2 , # 5 
                      5233     MEASURE_PWM_FREQ_LOOP: 	
                      5234     	; Check if period diff was accepted
1353    E558          5235     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1355    7002          5236     	JNZ	($+4)
                      5237     
1357    7A05          5238     MOV R2 , # 5 
                      5239     
1359    1207F0        5240     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
135C    E559          5241     	MOV	A, NEW_RCP					; Load value
135E    C3            5242     	CLR	C
135F    9402          5243     SUBB A , # 2 
1361    40EE          5244     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5245     
1363    E52E          5246     	MOV	A, FLAGS3						; Check pwm frequency flags
1365    541F          5247     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1367    855B5A        5248     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
136A    F55B          5249     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
136C    B55AE2        5250     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5251     
136F    DAE2          5252     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5253     
                      5254     	; Clear measure pwm frequency flag
1371    C259          5255     CLR FLAGS0 . 1 
                      5256     	; Set up RC pulse interrupts after pwm frequency measurement
                      5257     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1373    53DACF        5257+1   ANL PCA0CPM0 , # 0CFH 
1376    207603        5257+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1379    43DA20        5257+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
137C    307603        5257+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
137F    43DA10        5257+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5258     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1382    C2D8          5258+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1384    C269          5259     CLR FLAGS2 . 1 
1386    1207FF        5260     	CALL WAIT100MS						; Wait for new RC pulse
                      5261     
                      5262     	; Validate RC pulse
                      5263     VALIDATE_RCP_START: 	
1389    1207F0        5264     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
138C    7802          5265     MOV R0 , # 2 
138E    741F          5266     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1390    552E          5267     	ANL	A, FLAGS3						; Check pwm frequency flags
1392    7002          5268     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5269     
1394    7800          5270     MOV R0 , # 0 
                      5271     
1396    C3            5272     	CLR	C
1397    E559          5273     	MOV	A, NEW_RCP					; Load value
1399    98            5274     SUBB A , R0 
139A    40ED          5275     	JC	VALIDATE_RCP_START				; No - start over
                      5276     
                      5277     	; Beep arm sequence start signal
139C    C2AF          5278     	CLR 	EA							; Disable all interrupts
139E    120814        5279     	CALL BEEP_F1
13A1    1207FA        5280     	CALL WAIT30MS
13A4    120814        5281     	CALL BEEP_F1
13A7    1207FA        5282     	CALL WAIT30MS
13AA    12081B        5283     	CALL BEEP_F2
13AD    1207FA        5284     	CALL WAIT30MS
13B0    12081B        5285     	CALL BEEP_F2
13B3    1207FA        5286     	CALL WAIT30MS
13B6    D2AF          5287     	SETB	EA							; Enable all interrupts
13B8    120804        5288     	CALL WAIT200MS	
                      5289     
                      5290     	; Arming sequence start
13BB    754800        5291     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5292     ARMING_START: 
                      5293     IF MODE >= 1	; Tail or multi
13BE    7888          5294     MOV R0 , # PGM_DIRECTION 
13C0    E6            5295     MOV A , @ R0 
13C1    B40302        5296     	CJNE	A, #3, ($+5)
                      5297     
13C4    8199          5298     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      5299     ENDIF
                      5300     
13C6    1207F0        5301     	CALL WAIT3MS
13C9    788C          5302     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
13CB    E6            5303     MOV A , @ R0 
13CC    C3            5304     	CLR	C
13CD    9401          5305     	SUBB	A, #1				; Is TX programming enabled?
13CF    5003          5306     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5307     
13D1    021499        5308     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5309     
                      5310     ARMING_INITIAL_ARM_CHECK: 
13D4    E530          5311     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
13D6    C3            5312     	CLR	C
13D7    9401          5313     	SUBB	A, #1				; Is it the initial arm sequence?
13D9    5003          5314     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5315     
13DB    021499        5316     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5317     
                      5318     ARMING_PPM_CHECK: 
13DE    741F          5319     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13E0    552E          5320     	ANL	A, FLAGS3				; Check pwm frequency flags
13E2    6035          5321     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5322     
                      5323     	; PWM tx program entry
13E4    C3            5324     	CLR	C
13E5    E559          5325     	MOV	A, NEW_RCP			; Load new RC pulse value
13E7    94FF          5326     SUBB A , # 255 
13E9    5003          5327     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5328     
13EB    021499        5329     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5330     
                      5331     PROGRAM_BY_TX_ENTRY_PWM: 	
13EE    C2AF          5332     	CLR	EA					; Disable all interrupts
13F0    120829        5333     	CALL BEEP_F4
13F3    D2AF          5334     	SETB	EA					; Enable all interrupts
13F5    1207FF        5335     	CALL WAIT100MS
13F8    C3            5336     	CLR	C
13F9    E559          5337     	MOV	A, NEW_RCP			; Load new RC pulse value
13FB    9401          5338     SUBB A , # 1 
13FD    50EF          5339     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5340     
                      5341     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13FF    C2AF          5342     	CLR	EA					; Disable all interrupts
1401    120814        5343     	CALL BEEP_F1
1404    1207F5        5344     	CALL WAIT10MS
1407    120814        5345     	CALL BEEP_F1
140A    D2AF          5346     	SETB	EA					; Enable all interrupts
140C    1207FF        5347     	CALL WAIT100MS
140F    C3            5348     	CLR	C
1410    E559          5349     	MOV	A, NEW_RCP			; Load new RC pulse value
1412    94FF          5350     SUBB A , # 255 
1414    40E9          5351     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5352     
1416    021D3D        5353     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5354     
                      5355     	; PPM throttle calibration and tx program entry
                      5356     THROTTLE_HIGH_CAL_START: 
1419    7F05          5357     MOV R7 , # 5 
                      5358     THROTTLE_HIGH_CAL: 			
141B    D277          5359     SETB FLAGS3 . 7 
141D    513F          5360     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
141F    1207FF        5361     	CALL WAIT100MS				; Wait for new throttle value
1422    C2AF          5362     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1424    C277          5363     CLR FLAGS3 . 7 
1426    513F          5364     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1428    AE59          5365     MOV R6 , NEW_RCP 
142A    C3            5366     	CLR	C
142B    E559          5367     	MOV	A, NEW_RCP			; Load new RC pulse value
142D    947F          5368     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
142F    D2AF          5369     	SETB	EA					; Enable interrupts
1431    4070          5370     	JC	ARM_TARGET_UPDATED		; No - branch
                      5371     
1433    1207EB        5372     	CALL WAIT1MS		
1436    C2AF          5373     	CLR	EA					; Disable all interrupts
1438    120829        5374     	CALL BEEP_F4
143B    D2AF          5375     	SETB	EA					; Enable all interrupts
143D    DFDC          5376     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5377     
143F    C3            5378     	CLR	C
1440    EE            5379     MOV A , R6 
1441    9405          5380     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1443    7897          5381     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1445    F6            5382     MOV @ R0 , A 
1446    120804        5383     	CALL WAIT200MS				
1449    1218A9        5384     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
144C    121CC0        5385     	CALL	SUCCESS_BEEP
                      5386     
                      5387     THROTTLE_LOW_CAL_START: 
144F    7F0A          5388     MOV R7 , # 10 
                      5389     THROTTLE_LOW_CAL: 			
1451    D277          5390     SETB FLAGS3 . 7 
1453    513F          5391     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1455    1207FF        5392     	CALL WAIT100MS
1458    C2AF          5393     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
145A    C277          5394     CLR FLAGS3 . 7 
145C    513F          5395     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
145E    AE59          5396     MOV R6 , NEW_RCP 
1460    C3            5397     	CLR	C
1461    E559          5398     	MOV	A, NEW_RCP			; Load new RC pulse value
1463    947F          5399     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1465    D2AF          5400     	SETB	EA					; Enable interrupts
1467    50E6          5401     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5402     
1469    1207EB        5403     	CALL WAIT1MS		
146C    C2AF          5404     	CLR	EA					; Disable all interrupts
146E    120814        5405     	CALL BEEP_F1
1471    1207F5        5406     	CALL WAIT10MS
1474    120814        5407     	CALL BEEP_F1
1477    D2AF          5408     	SETB	EA					; Enable all interrupts
1479    DFD6          5409     DJNZ R7 , THROTTLE_LOW_CAL 
                      5410     
147B    EE            5411     MOV A , R6 
147C    2405          5412     	ADD	A, #5				; Add about 2%
147E    7896          5413     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1480    F6            5414     MOV @ R0 , A 
1481    120804        5415     	CALL WAIT200MS				
1484    1218A9        5416     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1487    121CEF        5417     	CALL	SUCCESS_BEEP_INVERTED
                      5418     
                      5419     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
148A    1207FF        5420     	CALL WAIT100MS
148D    513F          5421     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
148F    C3            5422     	CLR	C
1490    E559          5423     	MOV	A, NEW_RCP			; Load new RC pulse value
1492    94FF          5424     SUBB A , # 255 
1494    40F4          5425     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5426     
1496    021D3D        5427     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5428     
                      5429     PROGRAM_BY_TX_CHECKED: 
1499    C3            5430     	CLR	C
149A    E559          5431     	MOV	A, NEW_RCP			; Load new RC pulse value
149C    9548          5432     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
149E    4003          5433     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5434     
14A0    855948        5435     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5436     
                      5437     ARM_TARGET_UPDATED: 
14A3    1207FF        5438     	CALL WAIT100MS				; Wait for new throttle value
14A6    C3            5439     	CLR	C
14A7    E559          5440     	MOV	A, NEW_RCP			; Load new RC pulse value
14A9    9401          5441     SUBB A , # 1 
14AB    4002          5442     	JC	ARM_END_BEEP			; Yes - proceed
                      5443     
14AD    61BE          5444     	JMP	ARMING_START			; No - start over
                      5445     
                      5446     ARM_END_BEEP: 
                      5447     	; Beep arm sequence end signal
14AF    C2AF          5448     	CLR 	EA					; Disable all interrupts
14B1    120829        5449     	CALL BEEP_F4
14B4    1207FA        5450     	CALL WAIT30MS
14B7    120829        5451     	CALL BEEP_F4
14BA    1207FA        5452     	CALL WAIT30MS
14BD    120822        5453     	CALL BEEP_F3
14C0    1207FA        5454     	CALL WAIT30MS
14C3    120822        5455     	CALL BEEP_F3
14C6    1207FA        5456     	CALL WAIT30MS
14C9    D2AF          5457     	SETB	EA					; Enable all interrupts
14CB    120804        5458     	CALL WAIT200MS
                      5459     
                      5460     	; Clear initial arm variable
14CE    753000        5461     	MOV	INITIAL_ARM, #0
                      5462     
                      5463     	; Armed and waiting for power on
                      5464     WAIT_FOR_POWER_ON: 
14D1    E4            5465     	CLR	A
14D2    F531          5466     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
14D4    F532          5467     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5468     WAIT_FOR_POWER_ON_LOOP: 
14D6    0531          5469     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
14D8    E531          5470     	MOV	A, POWER_ON_WAIT_CNT_L
14DA    F4            5471     	CPL	A
14DB    7039          5472     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5473     
14DD    0532          5474     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
14DF    789A          5475     MOV R0 , # PGM_BEACON_DELAY 
14E1    E6            5476     MOV A , @ R0 
14E2    7819          5477     MOV R0 , # 25 
14E4    14            5478     	DEC	A
14E5    6012          5479     	JZ	BEEP_DELAY_SET
                      5480     
14E7    7832          5481     MOV R0 , # 50 
14E9    14            5482     	DEC	A
14EA    600D          5483     	JZ	BEEP_DELAY_SET
                      5484     
14EC    787D          5485     MOV R0 , # 125 
14EE    14            5486     	DEC	A
14EF    6008          5487     	JZ	BEEP_DELAY_SET
                      5488     
14F1    78FA          5489     MOV R0 , # 250 
14F3    14            5490     	DEC	A
14F4    6003          5491     	JZ	BEEP_DELAY_SET
                      5492     
14F6    753200        5493     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5494     
                      5495     BEEP_DELAY_SET: 
14F9    C3            5496     	CLR	C
14FA    E532          5497     	MOV	A, POWER_ON_WAIT_CNT_H
14FC    98            5498     SUBB A , R0 
14FD    4017          5499     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5500     
14FF    1532          5501     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1501    7531B4        5502     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
1504    7899          5503     MOV R0 , # PGM_BEACON_STRENGTH 
1506    866F          5504     MOV BEEP_STRENGTH , @ R0 
1508    C2AF          5505     	CLR 	EA					; Disable all interrupts
150A    120829        5506     	CALL BEEP_F4				; Signal that there is no signal
150D    D2AF          5507     	SETB	EA					; Enable all interrupts
150F    7898          5508     MOV R0 , # PGM_BEEP_STRENGTH 
1511    866F          5509     MOV BEEP_STRENGTH , @ R0 
1513    1207FF        5510     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5511     
                      5512     WAIT_FOR_POWER_ON_NO_BEEP: 
1516    1207F5        5513     	CALL WAIT10MS
1519    E528          5514     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
151B    7008          5515     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5516     
151D    741F          5517     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
151F    552E          5518     	ANL	A, FLAGS3						; Check pwm frequency flags
1521    7002          5519     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5520     
1523    614F          5521     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5522     
                      5523     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1525    C3            5524     	CLR	C
1526    E559          5525     	MOV	A, NEW_RCP			; Load new RC pulse value
1528    9406          5526     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
152A    40AA          5527     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5528     
                      5529     IF MODE >= 1	; Tail or multi
152C    7888          5530     MOV R0 , # PGM_DIRECTION 
152E    E6            5531     MOV A , @ R0 
152F    C3            5532     	CLR	C
1530    9403          5533     	SUBB	A, #3
1532    6003          5534     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5535     ENDIF
                      5536     
1534    1207FF        5537     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5538     
1537    E528          5539     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1539    7003          5540     	JNZ	($+5)				; If it is not zero - proceed
                      5541     
153B    02134F        5542     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5543     
                      5544     
                      5545     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5546     ;
                      5547     ; Start entry point
                      5548     ;
                      5549     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5550     INIT_START: 
153E    C2AF          5551     	CLR	EA
1540    1190          5552     	CALL SWITCH_POWER_OFF
1542    E4            5553     	CLR	A
1543    F522          5554     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1545    F523          5555     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1547    F524          5556     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1549    F525          5557     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
154B    D2AF          5558     	SETB	EA
154D    7885          5559     MOV R0 , # PGM_MOTOR_IDLE 
154F    8661          5560     MOV PWM_MOTOR_IDLE , @ R0 
1551    F540          5561     	MOV	GOV_TARGET_L, A		; Set target to zero
1553    F541          5562     	MOV	GOV_TARGET_H, A
1555    F542          5563     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1557    F543          5564     	MOV	GOV_INTEGRAL_H, A
1559    F544          5565     	MOV	GOV_INTEGRAL_X, A
155B    F56C          5566     	MOV	ADC_CONVERSION_CNT, A
155D    F549          5567     	MOV	GOV_ACTIVE, A
155F    F52B          5568     	MOV	FLAGS0, A				; Clear flags0
1561    F52C          5569     	MOV	FLAGS1, A				; Clear flags1
1563    F539          5570     	MOV	DEMAG_CONSECUTIVE_CNT, A
1565    120C4A        5571     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5572     	;**** **** **** **** ****
                      5573     	; Motor start beginning
                      5574     	;**** **** **** **** **** 
1568    756C08        5575     MOV ADC_CONVERSION_CNT , # 8 
                      5576     	SET_ADC_IP_TEMP
156B    75BB10        5576+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
156E    1207EB        5577     	CALL WAIT1MS
1571    120B67        5578     	CALL START_ADC_CONVERSION
                      5579     READ_INITIAL_TEMP: 
                      5580     	GET_ADC_STATUS 
1574    E5E8          5580+1   MOV A , ADC0CN 
1576    20ECFB        5581     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5582     	READ_ADC_RESULT						; Read initial temperature
1579    A8BD          5582+1   MOV R0 , ADC0L 
157B    A9BE          5582+1   MOV R1 , ADC0H 
157D    E9            5583     MOV A , R1 
157E    7001          5584     	JNZ	($+3)							; Is reading below 256?
                      5585     
1580    F8            5586     MOV R0 , A 
                      5587     
1581    886D          5588     MOV CURRENT_AVERAGE_TEMP , R0 
1583    120B6B        5589     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1586    756C08        5590     MOV ADC_CONVERSION_CNT , # 8 
                      5591     	SET_ADC_IP_TEMP
1589    75BB10        5591+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5592     
                      5593     	; Go to the desired startup mode
158C    7895          5594     MOV R0 , # PGM_STARTUP_METHOD 
158E    E6            5595     MOV A , @ R0 
158F    30E003        5596     	JNB	ACC.0, DIRECT_METHOD_START
                      5597     
1592    0215D6        5598     	JMP	STEPPER_METHOD_START
                      5599     
                      5600     DIRECT_METHOD_START: 
                      5601     	; Set up start operating conditions
1595    7887          5602     MOV R0 , # PGM_PWM_FREQ 
1597    E6            5603     MOV A , @ R0 
1598    FE            5604     MOV R6 , A 
1599    7602          5605     MOV @ R0 , # 2 
159B    3167          5606     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
159D    7887          5607     MOV R0 , # PGM_PWM_FREQ 
159F    EE            5608     MOV A , R6 
15A0    F6            5609     MOV @ R0 , A 
                      5610     	; Set max allowed power
15A1    D261          5611     SETB FLAGS1 . 1 
15A3    C2AF          5612     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
15A5    755EFF        5613     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15A8    120C1A        5614     	CALL SET_STARTUP_PWM
15AB    85225E        5615     	MOV	PWM_LIMIT, REQUESTED_PWM
15AE    85225F        5616     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
15B1    D2AF          5617     	SETB	EA
15B3    C261          5618     CLR FLAGS1 . 1 
15B5    752501        5619     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
15B8    855D64        5620     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15BB    756501        5621     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5622     	; Begin startup sequence
15BE    D260          5623     SETB FLAGS1 . 0 
15C0    D263          5624     SETB FLAGS1 . 3 
15C2    753800        5625     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15C5    120FEA        5626     	CALL COMM5COMM6				; Initialize commutation
15C8    1125          5627     	CALL COMM6COMM1				
15CA    120CC4        5628     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
15CD    120C4A        5629     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
15D0    120D47        5630     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15D3    0216FE        5631     	JMP	RUN1
                      5632     
                      5633     
                      5634     STEPPER_METHOD_START: 
                      5635     	; Set up start operating conditions
15D6    7887          5636     MOV R0 , # PGM_PWM_FREQ 
15D8    E6            5637     MOV A , @ R0 
15D9    FE            5638     MOV R6 , A 
15DA    7603          5639     MOV @ R0 , # 3 
15DC    7893          5640     MOV R0 , # PGM_DAMPING_FORCE 
15DE    E6            5641     MOV A , @ R0 
15DF    FD            5642     MOV R5 , A 
15E0    7605          5643     MOV @ R0 , # 5 
15E2    3167          5644     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15E4    7887          5645     MOV R0 , # PGM_PWM_FREQ 
15E6    EE            5646     MOV A , R6 
15E7    F6            5647     MOV @ R0 , A 
15E8    7893          5648     MOV R0 , # PGM_DAMPING_FORCE 
15EA    ED            5649     MOV A , R5 
15EB    F6            5650     MOV @ R0 , A 
                      5651     	; Begin startup sequence
15EC    D260          5652     SETB FLAGS1 . 0 
15EE    D261          5653     SETB FLAGS1 . 1 
15F0    D265          5654     SETB FLAGS1 . 5 
15F2    120FEA        5655     	CALL COMM5COMM6			; Initialize commutation
15F5    1125          5656     	CALL COMM6COMM1			
15F7    755EFF        5657     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15FA    120C1A        5658     	CALL SET_STARTUP_PWM
15FD    1207EB        5659     	CALL WAIT1MS
1600    120EF2        5660     	CALL COMM1COMM2
1603    1207EB        5661     	CALL WAIT1MS
1606    1207EB        5662     	CALL WAIT1MS
1609    120F24        5663     	CALL COMM2COMM3
160C    1207F0        5664     	CALL WAIT3MS			
160F    120F6E        5665     	CALL COMM3COMM4
1612    1207F0        5666     	CALL WAIT3MS			
1615    1207F0        5667     	CALL WAIT3MS			
1618    120FA9        5668     	CALL COMM4COMM5
161B    1207F5        5669     	CALL WAIT10MS				; Settle rotor
161E    120FEA        5670     	CALL COMM5COMM6
1621    1207F0        5671     	CALL WAIT3MS				
1624    1207EB        5672     	CALL WAIT1MS			
1627    C261          5673     CLR FLAGS1 . 1 
1629    D262          5674     SETB FLAGS1 . 2 
                      5675     
                      5676     	;**** **** **** **** ****
                      5677     	; Stepper phase beginning
                      5678     	;**** **** **** **** **** 
                      5679     STEPPER_ROT_BEG: 
162B    120B67        5680     	CALL START_ADC_CONVERSION
162E    120B6B        5681     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1631    120C1A        5682     	CALL SET_STARTUP_PWM
1634    756C08        5683     MOV ADC_CONVERSION_CNT , # 8 
                      5684     	SET_ADC_IP_TEMP
1637    75BB10        5684+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5685     
163A    1125          5686     	CALL COMM6COMM1				; Commutate
163C    120CBD        5687     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
163F    120D47        5688     	CALL CALC_NEW_WAIT_TIMES
1642    11A2          5689     	CALL DECREMENT_STEPPER_STEP
1644    3107          5690     	CALL STEPPER_TIMER_WAIT
                      5691     
1646    120EF2        5692     	CALL COMM1COMM2			
1649    120CBD        5693     	CALL CALC_NEXT_COMM_TIMING_START	
164C    120D47        5694     	CALL CALC_NEW_WAIT_TIMES
164F    11A2          5695     	CALL DECREMENT_STEPPER_STEP
1651    3107          5696     	CALL STEPPER_TIMER_WAIT
                      5697     
1653    120F24        5698     	CALL COMM2COMM3			
1656    120CBD        5699     	CALL CALC_NEXT_COMM_TIMING_START	
1659    120D47        5700     	CALL CALC_NEW_WAIT_TIMES
165C    11A2          5701     	CALL DECREMENT_STEPPER_STEP
165E    3107          5702     	CALL STEPPER_TIMER_WAIT
                      5703     
1660    120F6E        5704     	CALL COMM3COMM4			
1663    120CBD        5705     	CALL CALC_NEXT_COMM_TIMING_START	
1666    120D47        5706     	CALL CALC_NEW_WAIT_TIMES
1669    11A2          5707     	CALL DECREMENT_STEPPER_STEP
166B    3107          5708     	CALL STEPPER_TIMER_WAIT
                      5709     
166D    120FA9        5710     	CALL COMM4COMM5			
1670    120CBD        5711     	CALL CALC_NEXT_COMM_TIMING_START	
1673    120D47        5712     	CALL CALC_NEW_WAIT_TIMES
1676    11A2          5713     	CALL DECREMENT_STEPPER_STEP
1678    3107          5714     	CALL STEPPER_TIMER_WAIT
                      5715     
167A    120FEA        5716     	CALL COMM5COMM6			
167D    120CBD        5717     	CALL CALC_NEXT_COMM_TIMING_START	
1680    120D47        5718     	CALL CALC_NEW_WAIT_TIMES
1683    11A2          5719     	CALL DECREMENT_STEPPER_STEP	
                      5720     	; Check stepper step versus end criteria
1685    C3            5721     	CLR	C
1686    E550          5722     	MOV	A, WT_STEPPER_STEP_L
1688    9535          5723     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
168A    E551          5724     	MOV	A, WT_STEPPER_STEP_H
168C    9536          5725     	SUBB	A, STEPPER_STEP_END_H
168E    400C          5726     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5727     
                      5728     	; Wait for step
1690    3107          5729     	CALL STEPPER_TIMER_WAIT
1692    C3            5730     	CLR	C
1693    E559          5731     	MOV	A, NEW_RCP				; Load new pulse value
1695    9401          5732     SUBB A , # 1 
1697    5092          5733     	JNC	STEPPER_ROT_BEG
                      5734     
1699    021830        5735     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5736     
                      5737     STEPPER_ROT_EXIT: 
                      5738     	; Wait for step
169C    3107          5739     	CALL STEPPER_TIMER_WAIT
                      5740     	; Clear stepper phase
169E    C262          5741     CLR FLAGS1 . 2 
                      5742     	; Set dondamped low pwm frequency
16A0    7887          5743     MOV R0 , # PGM_PWM_FREQ 
16A2    E6            5744     MOV A , @ R0 
16A3    FE            5745     MOV R6 , A 
16A4    7602          5746     MOV @ R0 , # 2 
16A6    3167          5747     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
16A8    7887          5748     MOV R0 , # PGM_PWM_FREQ 
16AA    EE            5749     MOV A , R6 
16AB    F6            5750     MOV @ R0 , A 
                      5751     	; Set spoolup power variables (power is now controlled from RCP)
16AC    85225E        5752     	MOV	PWM_LIMIT, REQUESTED_PWM
16AF    85605F        5753     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
16B2    856025        5754     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
16B5    855D64        5755     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
16B8    756501        5756     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5757     	; Set direct startup phase to acquire sync quickly
16BB    D263          5758     SETB FLAGS1 . 3 
16BD    753800        5759     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
16C0    C2AF          5760     	CLR	EA						; Disable interrupts
                      5761     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
16C2    207502        5761+1   JB FLAGS3 . 5 , ( $+5 ) 
16C5    C293          5761+1   CLR P1 . 3 
16C7    307502        5761+1   JNB FLAGS3 . 5 , ( $+5 ) 
16CA    C297          5761+1   CLR P1 . 7 
                      5762     	CPFET_OFF						; Cp off
16CC    207502        5762+1   JB FLAGS3 . 5 , ( $+5 ) 
16CF    C297          5762+1   CLR P1 . 7 
16D1    307502        5762+1   JNB FLAGS3 . 5 , ( $+5 ) 
16D4    C293          5762+1   CLR P1 . 3 
16D6    742D          5763     	MOV	A, #45					; 8us delay for pfets to go off
16D8    D5E0FD        5764     	DJNZ	ACC, $
16DB    D2AF          5765     	SETB	EA						; Enable interrupts
16DD    1125          5766     	CALL COMM6COMM1				
16DF    120CC4        5767     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16E2    120D33        5768     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16E5    120D47        5769     	CALL CALC_NEW_WAIT_TIMES
16E8    120DD8        5770     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16EB    756C00        5771     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5772     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16EE    75BB09        5772+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16F1    0216FE        5773     	JMP	RUN1
                      5774     
                      5775     
                      5776     
                      5777     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5778     ;
                      5779     ; Run entry point
                      5780     ;
                      5781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5782     DAMPED_TRANSITION: 
                      5783     	; Transition from nondamped to damped if applicable
16F4    3167          5784     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16F6    1125          5785     	CALL	COMM6COMM1
16F8    756C00        5786     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5787     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16FB    75BB09        5787+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5788     
                      5789     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5790     ; Out_cA changes from low to high
                      5791     RUN1: 
16FE    120DFA        5792     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
1701    120E7F        5793     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1704    120EAA        5794     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1707    120913        5795     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
170A    120EBE        5796     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
170D    120EF2        5797     	CALL COMM1COMM2			; Commutate
1710    120CC4        5798     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1713    120D33        5799     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1716    120D47        5800     	CALL CALC_NEW_WAIT_TIMES
1719    120DD8        5801     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5802     
                      5803     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5804     ; Out_cB changes from high to low
                      5805     RUN2: 
171C    120DF1        5806     	CALL WAIT_FOR_COMP_OUT_LOW
171F    120E7F        5807     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1722    120EAA        5808     	CALL SETUP_COMM_WAIT	
1725    120970        5809     	CALL CALC_GOVERNOR_PROP_ERROR
1728    120EBE        5810     	CALL WAIT_FOR_COMM
172B    120F24        5811     	CALL COMM2COMM3
172E    120CC4        5812     	CALL CALC_NEXT_COMM_TIMING
1731    120D33        5813     	CALL WAIT_ADVANCE_TIMING
1734    120D47        5814     	CALL CALC_NEW_WAIT_TIMES
1737    120DD8        5815     	CALL WAIT_BEFORE_ZC_SCAN	
                      5816     
                      5817     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5818     ; Out_cC changes from low to high
                      5819     RUN3: 
173A    120DFA        5820     	CALL WAIT_FOR_COMP_OUT_HIGH
173D    120E7F        5821     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1740    120EAA        5822     	CALL SETUP_COMM_WAIT	
1743    1209A9        5823     	CALL CALC_GOVERNOR_INT_ERROR
1746    120EBE        5824     	CALL WAIT_FOR_COMM
1749    120F6E        5825     	CALL COMM3COMM4
174C    120CC4        5826     	CALL CALC_NEXT_COMM_TIMING
174F    120D33        5827     	CALL WAIT_ADVANCE_TIMING
1752    120D47        5828     	CALL CALC_NEW_WAIT_TIMES
1755    120DD8        5829     	CALL WAIT_BEFORE_ZC_SCAN	
                      5830     
                      5831     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5832     ; Out_cA changes from high to low
                      5833     RUN4: 
1758    120DF1        5834     	CALL WAIT_FOR_COMP_OUT_LOW
175B    120E7F        5835     	CALL	EVALUATE_COMPARATOR_INTEGRITY
175E    120EAA        5836     	CALL SETUP_COMM_WAIT	
1761    120A06        5837     	CALL CALC_GOVERNOR_PROP_CORRECTION
1764    120EBE        5838     	CALL WAIT_FOR_COMM
1767    120FA9        5839     	CALL COMM4COMM5
176A    120CC4        5840     	CALL CALC_NEXT_COMM_TIMING
176D    120D33        5841     	CALL WAIT_ADVANCE_TIMING
1770    120D47        5842     	CALL CALC_NEW_WAIT_TIMES
1773    120DD8        5843     	CALL WAIT_BEFORE_ZC_SCAN	
                      5844     
                      5845     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5846     ; Out_cB changes from low to high
                      5847     RUN5: 
1776    120DFA        5848     	CALL WAIT_FOR_COMP_OUT_HIGH
1779    120E7F        5849     	CALL	EVALUATE_COMPARATOR_INTEGRITY
177C    120EAA        5850     	CALL SETUP_COMM_WAIT	
177F    120A6A        5851     	CALL CALC_GOVERNOR_INT_CORRECTION
1782    120EBE        5852     	CALL WAIT_FOR_COMM
1785    120FEA        5853     	CALL COMM5COMM6
1788    120CC4        5854     	CALL CALC_NEXT_COMM_TIMING
178B    120D33        5855     	CALL WAIT_ADVANCE_TIMING
178E    120D47        5856     	CALL CALC_NEW_WAIT_TIMES
1791    120DD8        5857     	CALL WAIT_BEFORE_ZC_SCAN	
                      5858     
                      5859     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5860     ; Out_cC changes from high to low
                      5861     RUN6: 
1794    120DF1        5862     	CALL WAIT_FOR_COMP_OUT_LOW
1797    120B67        5863     	CALL START_ADC_CONVERSION
179A    120E7F        5864     	CALL	EVALUATE_COMPARATOR_INTEGRITY
179D    120EAA        5865     	CALL SETUP_COMM_WAIT	
17A0    120B6B        5866     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
17A3    120EBE        5867     	CALL WAIT_FOR_COMM
17A6    1125          5868     	CALL COMM6COMM1
17A8    120CC4        5869     	CALL CALC_NEXT_COMM_TIMING
17AB    120D33        5870     	CALL WAIT_ADVANCE_TIMING
17AE    120D47        5871     	CALL CALC_NEW_WAIT_TIMES
17B1    120DD8        5872     	CALL WAIT_BEFORE_ZC_SCAN	
                      5873     
                      5874     	; Check if it is direct startup
17B4    306342        5875     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      5876     
                      5877     	; Set spoolup power variables
17B7    85605E        5878     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
17BA    85605F        5879     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
17BD    855D64        5880     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
17C0    756501        5881     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5882     	; Check startup ok counter
17C3    7964          5883     MOV R1 , # 100 
17C5    7A14          5884     MOV R2 , # 20 
                      5885     IF MODE >= 1	; Tail or multi
17C7    7888          5886     MOV R0 , # PGM_DIRECTION 
17C9    E6            5887     MOV A , @ R0 
17CA    B40304        5888     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      5889     
17CD    791E          5890     MOV R1 , # 30 
17CF    7A05          5891     MOV R2 , # 5 
                      5892     
                      5893     DIRECT_START_PARAMS_SET: 
                      5894     ENDIF
17D1    C3            5895     	CLR	C
17D2    E538          5896     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
17D4    99            5897     SUBB A , R1 
17D5    4015          5898     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5899     
17D7    C263          5900     CLR FLAGS1 . 3 
17D9    D264          5901     SETB FLAGS1 . 4 
17DB    8A37          5902     MOV STARTUP_ROT_CNT , R2 
                      5903     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      5907     IF MODE == 2	; Multi
17DD    7888          5908     MOV R0 , # PGM_DIRECTION 
17DF    E6            5909     MOV A , @ R0 
17E0    B40306        5910     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      5911     
17E3    755EFF        5912     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17E6    755FFF        5913     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      5914     
                      5915     DIRECT_START_PWM_LIM_SET: 
                      5916     ENDIF
17E9    0217F9        5917     	JMP	NORMAL_RUN_CHECKS
                      5918     
                      5919     DIRECT_START_CHECK_RCP: 
17EC    C3            5920     	CLR	C
17ED    E559          5921     	MOV	A, NEW_RCP				; Load new pulse value
17EF    9401          5922     SUBB A , # 1 
17F1    4003          5923     	JC	($+5)
                      5924     
17F3    0216FE        5925     	LJMP	RUN1						; Continue to run 
                      5926     
17F6    021830        5927     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5928     
                      5929     
                      5930     NORMAL_RUN_CHECKS: 
                      5931     	; Check if it is initial run phase
17F9    306419        5932     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      5933     
                      5934     	; Decrement startup rotaton count
17FC    E537          5935     	MOV	A, STARTUP_ROT_CNT
17FE    14            5936     	DEC	A
                      5937     	; Check number of nondamped rotations
17FF    7005          5938     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      5939     
1801    C264          5940     CLR FLAGS1 . 4 
1803    0216F4        5941     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      5942     
                      5943     NORMAL_RUN_CHECK_STARTUP_ROT: 
1806    F537          5944     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      5945     
1808    C3            5946     	CLR	C
1809    E559          5947     	MOV	A, NEW_RCP				; Load new pulse value
180B    9401          5948     SUBB A , # 1 
180D    4003          5949     	JC	($+5)
                      5950     
180F    0216FE        5951     	LJMP	RUN1						; Continue to run 
                      5952     
1812    021830        5953     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5954     
                      5955     
                      5956     INITIAL_RUN_PHASE_DONE: 
                      5957     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      5970     	; Exit run loop after a given time
1815    C3            5971     	CLR	C
1816    E55C          5972     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1818    94FA          5973     SUBB A , # 250 
181A    5014          5974     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      5975     
                      5976     RUN6_CHECK_RCP_TIMEOUT: 
181C    741F          5977     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
181E    552E          5978     	ANL	A, FLAGS3					; Check pwm frequency flags
1820    7004          5979     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      5980     
1822    E528          5981     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1824    600A          5982     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      5983     
                      5984     RUN6_CHECK_SPEED: 
1826    C3            5985     	CLR	C
1827    E53D          5986     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1829    94F0          5987     	SUBB	A, #0F0H
182B    5003          5988     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
182D    0216FE        5989     	JMP	RUN1						; Go back to run 1
                      5990     
                      5991     
                      5992     RUN_TO_WAIT_FOR_POWER_ON: 	
1830    C2AF          5993     	CLR	EA
1832    121090        5994     	CALL SWITCH_POWER_OFF
1835    7887          5995     MOV R0 , # PGM_PWM_FREQ 
1837    E6            5996     MOV A , @ R0 
1838    FE            5997     MOV R6 , A 
1839    7602          5998     MOV @ R0 , # 2 
183B    121167        5999     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
183E    7887          6000     MOV R0 , # PGM_PWM_FREQ 
1840    EE            6001     MOV A , R6 
1841    F6            6002     MOV @ R0 , A 
1842    E4            6003     	CLR	A
1843    F522          6004     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1845    F523          6005     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1847    F524          6006     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1849    F525          6007     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
184B    F561          6008     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
184D    C260          6009     CLR FLAGS1 . 0 
184F    D2AF          6010     	SETB	EA
1851    1207EB        6011     	CALL	WAIT1MS					; Wait for pwm to be stopped
1854    121090        6012     	CALL SWITCH_POWER_OFF
                      6013     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6044     IF MODE >= 1	; Tail or multi
1857    741F          6045     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1859    552E          6046     	ANL	A, FLAGS3					; Check pwm frequency flags
185B    7007          6047     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6048     
185D    E528          6049     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
185F    7003          6050     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6051     
1861    02134F        6052     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6053     
                      6054     JMP_WAIT_FOR_POWER_ON: 
1864    0214D1        6055     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6056     ENDIF
                      6057     
                      6058     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6059     
                      6060     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      6780     
                      6781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6782     
                      6783     
                      6784     
                      6785     
                      6786     END
MACRO ASSEMBLER BLHELI                                      05/25/15 17:18:21 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1806H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E45H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D18H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B6BH   A 
MEASURE_LIPO_WAIT~  C ADDR   0ADDH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A97H   A 
GOVERNOR_CORR_NEG~  C ADDR   0A59H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
FUNCTION_BEEP. . .  C ADDR   1D24H   A 
INIT_START . . . .  C ADDR   153EH   A 
PROGRAM_BY_TX_ENT~  C ADDR   13EEH   A 
FIND_THROTTLE_GAI~  C ADDR   124EH   A 
COMM45_NFET. . . .  C ADDR   0FCEH   A 
COMM45_NONDAMP . .  C ADDR   0FCBH   A 
COMM4COMM5 . . . .  C ADDR   0FA9H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D3DH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0BFEH   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
TEMP_SKYPUP. . . .  D ADDR   0076H   A 
PREV_RCP . . . . .  D ADDR   0073H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PARAVAL_BEEP . . .  C ADDR   1D32H   A 
STORE_MULTI_FUNC_~  C ADDR   1C92H   A 
DECODE_STARTUP_PO~  C ADDR   1222H   A 
GOVERNOR_CHECK_PWM  C ADDR   09E6H   A 
GOVERNOR_ACTIVATE.  C ADDR   0938H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
STORE_MULTI_FUNC_~  C ADDR   1C97H   A 
WRITE_EEPROM_SIGN~  C ADDR   1C30H   A 
WAIT_FOR_POWER_ON.  C ADDR   14D1H   A 
THROTTLE_LOW_CAL_~  C ADDR   144FH   A 
ARMING_INITIAL_AR~  C ADDR   13D4H   A 
PROGRAM_BY_TX_CHE~  C ADDR   1499H   A 
ERASE_AND_STORE_A~  C ADDR   18A9H   A 
SET_DEFAULT_PARAM~  C ADDR   110DH   A 
COMM56_NONDAMP . .  C ADDR   1011H   A 
COMM23_CP. . . . .  C ADDR   0F5CH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CC4H   A 
COMM5COMM6 . . . .  C ADDR   0FEAH   A 
CALC_GOVERNOR_INT~  C ADDR   0A71H   A 
CALC_GOVERNOR_TAR~  C ADDR   096FH   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   126BH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FUNCTION_NEXT. . .  C ADDR   1D9BH   A 
STORE_MULTI_FUNC_~  C ADDR   1C9CH   A 
STEPPER_ROT_BEG. .  C ADDR   162BH   A 
THROTTLE_HIGH_CAL.  C ADDR   141BH   A 
DECODE_THROTTLE_R~  C ADDR   1214H   A 
STEPPER_STEP_MED_~  C ADDR   0C96H   A 
INITIALIZE_ALL_TI~  C ADDR   0C4AH   A 
STARTUP_PWM_SET_P~  C ADDR   0C3EH   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
RUN_COUNT_H. . . .  D ADDR   0075H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
PARAVAL_NEXT . . .  C ADDR   1D86H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA1H   A 
WRITE_EEPROM_BYTE.  C ADDR   1C04H   A 
MEASURE_PWM_FREQ_~  C ADDR   134FH   A 
COMM61_CP. . . . .  C ADDR   106DH   A 
COMM_EXIT. . . . .  C ADDR   107CH   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D1FH   A 
CALC_GOVERNOR_INT~  C ADDR   0A6AH   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
FUNC_PARAVAL_WAIT.  C ADDR   1D50H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA6H   A 
WRITE_TAG. . . . .  C ADDR   1C59H   A 
READ_EEPROM_STORE~  C ADDR   1880H   A 
RUN1 . . . . . . .  C ADDR   16FEH   A 
CLEAR_RAM. . . . .  C ADDR   12CEH   A 
SET_BEC_VOLTAGE. .  C ADDR   123EH   A 
DECODE_GOVERNOR_G~  C ADDR   11FBH   A 
DEC_STEP_HIGH. . .  C ADDR   10D0H   A 
WAIT_FOR_COMM. . .  C ADDR   0EBEH   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D66H   A 
MEASURE_LIPO_ADD_~  C ADDR   0B5AH   A 
CALC_GOVERNOR_PRO~  C ADDR   09A8H   A 
DIV_U16_BY_U16_DI~  C ADDR   088CH   A 
WAIT100MS. . . . .  C ADDR   07FFH   A 
WAIT1MS. . . . . .  C ADDR   07EBH   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
FUNCTION_PARAVAL_~  C ADDR   1D1EH   A 
STORE_MULTI_FUNC_~  C ADDR   1CABH   A 
STORE_NEW_VALUE_I~  C ADDR   1C61H   A 
DIRECT_START_PWM_~  C ADDR   17E9H   A 
RUN2 . . . . . . .  C ADDR   171CH   A 
ARMING_PPM_CHECK .  C ADDR   13DEH   A 
COMM45_CP. . . . .  C ADDR   0FE1H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DD8H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B62H   A 
GOVERNOR_CORR_INT~  C ADDR   0AB6H   A 
GOVERNOR_STORE_PR~  C ADDR   09A4H   A 
DIV_U16_BY_U16_DI~  C ADDR   0896H   A 
WAIT200MS. . . . .  C ADDR   0804H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
STORE_MULTI_FUNC_~  C ADDR   1CB0H   A 
RUN3 . . . . . . .  C ADDR   173AH   A 
DIRECT_METHOD_STA~  C ADDR   1595H   A 
DECODE_DAMPING_DO~  C ADDR   11A3H   A 
PWM_WAIT . . . . .  C ADDR   0E6AH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C0EH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A9EH   A 
GOVERNOR_CHECK_IN~  C ADDR   09CEH   A 
DIV_U16_BY_U16_DI~  C ADDR   08ADH   A 
WAIT3MS. . . . . .  C ADDR   07F0H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
RUN_COUNT_L. . . .  D ADDR   0074H   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
BEEP_NO_ENTRY. . .  C ADDR   1D49H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1864H   A 
DIRECT_START_CHEC~  C ADDR   17ECH   A 
RUN4 . . . . . . .  C ADDR   1758H   A 
STORE_TIMES_UP_OR~  C ADDR   0DB8H   A 
STORE_TIMES_DECRE~  C ADDR   0DCBH   A 
STEPPER_STEP_SET .  C ADDR   0CB0H   A 
TEMP_AVERAGE_INC .  C ADDR   0B9EH   A 
GOVERNOR_CORR_INT~  C ADDR   0AC7H   A 
MULT_S16_BY_U8_DI~  C ADDR   08BCH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
READ_TAGS. . . . .  C ADDR   1C3FH   A 
RUN5 . . . . . . .  C ADDR   1776H   A 
COMP_READ. . . . .  C ADDR   0E70H   A 
COMP_WAIT_SET_RES~  C ADDR   0E31H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D6CH   A 
GOVERNOR_CORR_NEG~  C ADDR   0ABBH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0999H   A 
GOVERNOR_TARGET_C~  C ADDR   091BH   A 
CALC_GOVERNOR_TAR~  C ADDR   0913H   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
RUN6 . . . . . . .  C ADDR   1794H   A 
ARMING_START . . .  C ADDR   13BEH   A 
MEASURE_PWM_FREQ_~  C ADDR   1353H   A 
DECREMENT_STEP_EX~  C ADDR   10FDH   A 
COMM_RETURN. . . .  C ADDR   108FH   A 
GOVERNOR_DEACTIVA~  C ADDR   0925H   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
ARM_TARGET_UPDATED  C ADDR   14A3H   A 
EVALUATE_COMPARAT~  C ADDR   0E7FH   A 
TEMP_CHECK_EXIT. .  C ADDR   0BC8H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A40H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
WRITE_EEPROM_BLOC~  C ADDR   18CCH   A 
NORMAL_RUN_CHECKS.  C ADDR   17F9H   A 
DEC_STEP_MED_LOW .  C ADDR   10EBH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E00H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D33H   A 
CALC_GOVERNOR_PRO~  C ADDR   0970H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WRITE_EEPROM_BLOC~  C ADDR   18DAH   A 
READ_ALL_EEPROM_P~  C ADDR   1867H   A 
PROGRAM_BY_TX_ENT~  C ADDR   148AH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0ED8H   A 
SKYPUP_03. . . . .  C ADDR   078EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1230H   A 
EVAL_COMP_EXIT . .  C ADDR   0EA9H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E91H   A 
STEPPER_STEP_LOW .  C ADDR   0CA4H   A 
MEASURE_LIPO_ADJU~  C ADDR   0B1FH   A 
SKYPUP_04. . . . .  C ADDR   07A2H   A 
PCA_INT_SET_TIMEO~  C ADDR   07B7H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   169CH   A 
STEPPER_METHOD_ST~  C ADDR   15D6H   A 
DECODE_PARAMS_DIR~  C ADDR   11DDH   A 
COMM12_DAMP. . . .  C ADDR   0EFCH   A 
SETUP_COMM_WAIT. .  C ADDR   0EAAH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CBDH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BF4H   A 
CALC_GOVERNOR_INT~  C ADDR   0A05H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
ARM_END_BEEP . . .  C ADDR   14AFH   A 
THROTTLE_HIGH_CAL~  C ADDR   1419H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DF1H   A 
LOAD_MIN_TIME. . .  C ADDR   0D88H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D47H   A 
SET_STARTUP_PWM. .  C ADDR   0C1AH   A 
GOVERNOR_STORE_IN~  C ADDR   09FFH   A 
GOVERNOR_ACTIVATE~  C ADDR   0962H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
FUNC_PARAVAL . . .  C ADDR   1D4CH   A 
WAIT1S_LOOP. . . .  C ADDR   1CBAH   A 
STORE_MULTI_FUNC_1  C ADDR   1C65H   A 
RUN6_CHECK_RCP_TI~  C ADDR   181CH   A 
DECREMENT_STEP . .  C ADDR   10AEH   A 
COMM23_DAMP. . . .  C ADDR   0F2CH   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EDAH   A 
ADJUST_TIMING. . .  C ADDR   0D8CH   A 
STEPPER_STEP_MED_~  C ADDR   0C7AH   A 
MEASURE_LIPO_DIVI~  C ADDR   0B3FH   A 
MEASURE_LIPO_START  C ADDR   0ACCH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A69H   A 
GOVERNOR_INT_MIN_~  C ADDR   09FAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A0H   A 
BEEP_F1. . . . . .  C ADDR   0814H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Dh            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
STORE_MULTI_FUNC_2  C ADDR   1C6AH   A 
INITIAL_RUN_PHASE~  C ADDR   1815H   A 
TEST_THROTTLE_GAIN  C ADDR   125CH   A 
STEPPER_STEP_MED .  C ADDR   0C88H   A 
GOVERNOR_STORE_PR~  C ADDR   0A67H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A2BH   A 
MULT_S16_BY_U8_PO~  C ADDR   08D6H   A 
DIV_U16_BY_U16 . .  C ADDR   0884H   A 
BEEP_ONOFF . . . .  C ADDR   0837H   A 
BEEP_F2. . . . . .  C ADDR   081BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1D46H   A 
STORE_MULTI_FUNC_3  C ADDR   1C6FH   A 
SUCCESS_BEEP_INVE~  C ADDR   1CEFH   A 
SUCCESS_BEEP . . .  C ADDR   1CC0H   A 
FIND_THROTTLE_GAIN  C ADDR   123FH   A 
DECREMENT_STEPPER~  C ADDR   10A2H   A 
COMM61_DAMP. . . .  C ADDR   102DH   A 
COMM34_DAMP. . . .  C ADDR   0F80H   A 
TEMP_AVERAGE_INC_~  C ADDR   0B8EH   A 
GOVERNOR_INT_MAX_~  C ADDR   09F3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09D7H   A 
BEEP_F3. . . . . .  C ADDR   0822H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
STORE_MULTI_FUNC_4  C ADDR   1C74H   A 
DAMPED_TRANSITION.  C ADDR   16F4H   A 
BEEP_DELAY_SET . .  C ADDR   14F9H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13FFH   A 
LOCK_BYTE_OK . . .  C ADDR   128AH   A 
DECODE_PWM_FREQ_L~  C ADDR   11F5H   A 
DECODE_DAMPING_3 .  C ADDR   117BH   A 
CALC_NEW_WAIT_RED~  C ADDR   0D57H   A 
BEEP_F4. . . . . .  C ADDR   0829H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
PROGRAM_BY_TX_EXIT  C ADDR   1DAAH   A 
STORE_MULTI_FUNC_5  C ADDR   1C79H   A 
READ_EEPROM_BYTE .  C ADDR   1C00H   A 
DIRECT_START_PARA~  C ADDR   17D1H   A 
THROTTLE_LOW_CAL .  C ADDR   1451H   A 
DECODE_DAMPING_4 .  C ADDR   1185H   A 
COMM45_DAMP. . . .  C ADDR   0FB1H   A 
WAIT_FOR_COMM_SET~  C ADDR   0EEAH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BA6H   A 
GOVERNOR_APPLY_IN~  C ADDR   0AA2H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A36H   A 
BEEP_OFF . . . . .  C ADDR   0878H   A 
WAIT10MS . . . . .  C ADDR   07F5H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
STORE_MULTI_FUNC_6  C ADDR   1C7EH   A 
READ_TAG . . . . .  C ADDR   1C48H   A 
RESET_CAL_DONE . .  C ADDR   12A6H   A 
DECODE_DAMPING_5 .  C ADDR   118FH   A 
DECODE_PARAMETERS.  C ADDR   1167H   A 
STEPPER_TIMER_WAIT  C ADDR   1107H   A 
STORE_TIMES_INCRE~  C ADDR   0DBEH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BEDH   A 
MEASURE_LIPO_CELLS  C ADDR   0ACCH   A 
CALC_GOVERNOR_INT~  C ADDR   09A9H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07D1H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
STORE_MULTI_FUNC_7  C ADDR   1C83H   A 
RUN6_CHECK_SPEED .  C ADDR   1826H   A 
WAIT_FOR_POWER_ON~  C ADDR   1525H   A 
DECODE_DAMPING_6 .  C ADDR   1199H   A 
DEC_STEP_LOW . . .  C ADDR   10F4H   A 
COMM56_DAMP. . . .  C ADDR   0FFCH   A 
SWITCH_POWER_OFF .  C ADDR   1090H   A 
WAIT30MS . . . . .  C ADDR   07FAH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FUNC_PARAVAL_CONT~  C ADDR   1D79H   A 
STORE_MULTI_FUNC_8  C ADDR   1C88H   A 
WRITE_TAGS . . . .  C ADDR   1C52H   A 
WAIT1S . . . . . .  C ADDR   1CB8H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   1830H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E9FH   A 
ADJUST_TIMING_TWO~  C ADDR   0DAEH   A 
CHECK_VOLTAGE_RET.  C ADDR   0C19H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A0DH   A 
GOVERNOR_ACTIVATE~  C ADDR   0969H   A 
WAITXMS_M. . . . .  C ADDR   080BH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
STORE_MULTI_FUNC_9  C ADDR   1C8DH   A 
READ_INITIAL_TEMP.  C ADDR   1574H   A 
WAIT_FOR_POWER_ON~  C ADDR   1516H   A 
DECODE_PWM_FREQ_E~  C ADDR   11FAH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0EECH   A 
PWM_WAIT_STARTUP .  C ADDR   0E65H   A 
START_ADC_CONVERS~  C ADDR   0B67H   A 
MULT_S16_BY_U8_EX~  C ADDR   090AH   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
STORE_IN_RAM_EXIT.  C ADDR   1CB5H   A 
VALIDATE_RCP_START  C ADDR   1389H   A 
LOCK_BYTE_TEST . .  C ADDR   1283H   A 
DEC_STEP_MED_HIGH.  C ADDR   10D9H   A 
COMM_RESTORE_POWER  C ADDR   108DH   A 
COMM12_NONDAMP . .  C ADDR   0F11H   A 
COMM1COMM2 . . . .  C ADDR   0EF2H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BA4H   A 
TEMP_AVERAGE_DEC .  C ADDR   0B9AH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A06H   A 
WAITXMS_O. . . . .  C ADDR   0809H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07C3H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
READ_EEPROM_EXIT .  C ADDR   18A8H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D6H   A 
DEC_STEP_MED . . .  C ADDR   10E2H   A 
READ_TIMER . . . .  C ADDR   0CC8H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BCCH   A 
CALC_GOVERNOR_INT~  C ADDR   0ACBH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09E0H   A 
MULT_S16_BY_U8_DI~  C ADDR   08EFH   A 
BEEP . . . . . . .  C ADDR   0830H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
ERASE_FLASH. . . .  C ADDR   1C19H   A 
PROGRAM_BY_TX. . .  C ADDR   1D3DH   A 
COMM23_NFET. . . .  C ADDR   0F49H   A 
COMM23_NONDAMP . .  C ADDR   0F46H   A 
COMM2COMM3 . . . .  C ADDR   0F24H   A 
STEPPER_STEP_HIGH.  C ADDR   0C6CH   A 
MEASURE_LIPO_CELL~  C ADDR   0B04H   A 
GOVERNOR_STORE_IN~  C ADDR   0AC9H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A8BH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A54H   A 
GOVERNOR_ACTIVATE~  C ADDR   0956H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
FUNC_PARAVAL_STORE  C ADDR   1D6BH   A 
WRITE_EEPROM_BYTE~  C ADDR   1C05H   A 
READ_EEPROM_BLOCK1  C ADDR   1890H   A 
READ_EEPROM_READ .  C ADDR   1889H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B66H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A3CH   A 
GOVERNOR_CHECK_PR~  C ADDR   098DH   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
READ_EEPROM_BLOCK2  C ADDR   189EH   A 
MEASURE_PWM_FREQ_~  C ADDR   1351H   A 
COMM61_NFET. . . .  C ADDR   1052H   A 
COMM61_NONDAMP . .  C ADDR   104FH   A 
COMM6COMM1 . . . .  C ADDR   1025H   A 
COMM34_NONDAMP . .  C ADDR   0F8DH   A 
COMM3COMM4 . . . .  C ADDR   0F6EH   A 
COMP_WAIT_SET_MAX~  C ADDR   0E1EH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DFAH   A 
STARTUP_PWM_EXIT .  C ADDR   0C49H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B56H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A65H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6788    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     86    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
