MACRO ASSEMBLER BLHELI                                      05/25/15 23:44:33 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC;C:\PROGRA~1\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       145     
                       146     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       150     
                       151     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       155     
                       156     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                 157     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       158     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       768     ENDIF
                       769     
                       770     
                       771     ;**** **** **** **** ****
                       772     ; TX programming defaults
                       773     ;
                       774     ; Parameter dependencies:
                       775     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       776     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       777     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       778     ; - Damping force is only used if DampedLight or Damped is selected
                       779     ;
                       780     ; Main
  0007                 781     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 782     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 783     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 784     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 785     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 786     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 787     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 788     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 789     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 790     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 791     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 792     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 793     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 794     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 795     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 796     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 797     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 798     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 799     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       800     ; Tail
  0003                 801     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 802     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 803     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 804     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 805     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 806     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 807     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       808     IF DAMPED_MODE_ENABLE == 1
  0004                 809     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       810     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 813     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 814     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 815     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 816     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 817     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 818     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       819     ; Multi
  0009                 820     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 821     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 822     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 823     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 824     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 825     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 826     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 827     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 828     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 829     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       830     IF DAMPED_MODE_ENABLE == 1
  0001                 831     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       832     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 835     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 836     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 837     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0050                 838     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 80	; Beep strength
  0050                 839     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0005                 840     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       841     ; Common
  0000                 842     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 843     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 844     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 845     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 846     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       847     
                       848     ;**** **** **** **** ****
                       849     ; Constant definitions for main
                       850     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       872     ; Constant definitions for tail
                       873     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       894     ; Constant definitions for multi
                       895     IF MODE == 2
                       896     
  0001                 897     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       898     
  000A                 899     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 900     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 901     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 902     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 903     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 904     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 905     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 906     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       907     
  0032                 908     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 909     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       910     
  000A                 911     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 912     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       913     
  0008                 914     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       915     
                       916     ENDIF
                       917     
                       918     ;**** **** **** **** ****
                       919     ; Temporary register definitions
  REG                  920     TEMP1		EQU	R0
  REG                  921     TEMP2		EQU	R1
  REG                  922     TEMP3		EQU	R2
  REG                  923     TEMP4		EQU	R3
  REG                  924     TEMP5		EQU	R4
  REG                  925     TEMP6		EQU	R5
  REG                  926     TEMP7		EQU	R6
  REG                  927     TEMP8		EQU	R7
                       928     
                       929     ;**** **** **** **** ****
                       930     ; Register definitions
------                 931     DSEG AT 20H					; Variables segment 
                       932     
0020                   933     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   934     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       935     
0022                   936     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   937     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   938     CURRENT_PWM: 				DS	1		; Current pwm
0025                   939     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   940     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   941     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   942     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   943     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   944     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       945     
002B                   946     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 947     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 948     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 949     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 950     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 951     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       952     ;						EQU 	5
                       953     ;						EQU 	6
                       954     ;						EQU 	7
                       955     
002C                   956     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 957     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 958     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 959     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 960     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 961     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 962     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 963     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       964     ;						EQU 	7
                       965     
002D                   966     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 967     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 968     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 969     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 970     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 971     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 972     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       973     ;						EQU 	6	
                       974     ;						EQU 	7	
                       975     
002E                   976     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 977     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 978     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 979     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 980     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 981     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 982     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 983     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 984     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       985     
                       986     ;**** **** **** **** ****
                       987     ; RAM definitions
------                 988     DSEG AT 30H						; Ram data segment, direct addressing
                       989     
0030                   990     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       991     
0031                   992     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   993     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       994     
0033                   995     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   996     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   997     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   998     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   999     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                  1000     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                  1001     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                      1002     
003A                  1003     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                  1004     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                  1005     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                  1006     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                  1007     COMM_PHASE: 				DS	1		; Current commutation phase
003F                  1008     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                      1009     
0040                  1010     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                  1011     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                  1012     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                  1013     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                  1014     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                  1015     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                  1016     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                  1017     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                  1018     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                  1019     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                      1020     
004A                  1021     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                  1022     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                  1023     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                  1024     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                  1025     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                  1026     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                  1027     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                  1028     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                      1029     
0052                  1030     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                  1031     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                  1032     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                  1033     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                  1034     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                  1035     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                  1036     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                  1037     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                  1038     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  1039     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  1040     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                  1041     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                      1042     
005E                  1043     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                  1044     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                  1045     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                  1046     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                  1047     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                  1048     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      1049     
0064                  1050     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                  1051     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                      1052     
0066                  1053     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                  1054     DAMPING_ON: 				DS	1		; Damping on part of damping period
                      1055     
0068                  1056     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                  1057     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                  1058     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                  1059     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                  1060     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      1061     
006D                  1062     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      1063     
006E                  1064     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                  1065     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      1066     
0070                  1067     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                  1068     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                  1069     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      1070     
                      1071     
                      1072     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1073     ;
                      1074     ; Skypup 2015.05.25
                      1075     ; 宏定义
                      1076     ;
                      1077     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1078     ;
  0002                1079     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                1080     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                      1081     ;
  00FF                1082     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                1083     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                      1084     ;
  00EE                1085     HOLD_FULL_L		EQU	0EEH	; 750 0x02EE 低位
  0002                1086     HOLD_FULL_H		EQU	2H	; 750 0x02EE 高位
  0030                1087     HOLD_CRUISE_L		EQU	30H	; 30000 0x7530 低位
  0075                1088     HOLD_CRUISE_H		EQU	75H	; 30000 0x7530 高位
                      1089     
                      1090     
                      1091     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1092     ;
                      1093     ; Skypup 2015.05.25
                      1094     ; 变量定义
                      1095     ;
                      1096     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1097     ;
0073                  1098     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                      1099     ;
0074                  1100     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                1101     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1102     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1103     ;
0075                  1104     NHOLD_L: 					DS	1		; nHold 低位
0076                  1105     NHOLD_H: 					DS	1		; nHold 高位
                      1106     ;
0077                  1107     CSTATE: 					DS	1		; 状态
                      1108     ;
                      1109     ;	State 状态矩阵
                      1110     ; 
                      1111     ;	00   ->   10   ->   20   ->   00
                      1112     ; 
                      1113     ;	00:Wait          -> 10
                      1114     ;	10:Full          -> 20
                      1115     ;	20:Cruise        -> 00
  0000                1116     STATE_WAIT		EQU	0X00
  0010                1117     STATE_FULL		EQU	0X10
  0020                1118     STATE_CRUISE		EQU	0X20
                      1119     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1120     
                      1121     ; Indirect addressing data segment. The variables below must be in this sequence
------                1122     ISEG AT 080H					
0080                  1123     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1124     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1125     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1126     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1127     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1128     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1129     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1130     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1131     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1132     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1133     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1134     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1135     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1136     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1137     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1138     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1139     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1140     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1141     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1142     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1143     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1144     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1145     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1146     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1147     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1148     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1149     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1150     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1151     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1152     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1153     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1154     
                      1155     ; The sequence of the variables below is no longer of importance
009F                  1156     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1157     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1158     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1159     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1160     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1161     
                      1162     
                      1163     ; Indirect addressing data segment
------                1164     ISEG AT 0D0H					
00D0                  1165     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1166     
                      1167     
                      1168     ;**** **** **** **** ****
------                1169     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1170     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1171     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1172     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1173     
1A00    0B            1174     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1175     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1176     EEP_LAYOUT_REVISION:  DB 17 
                      1177     
                      1178     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1211     
                      1212     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1245     
                      1246     IF MODE == 2
1A03    09            1247     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1248     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1249     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1250     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1251     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1252     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1253     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1254     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1255     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1256     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1257     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1258     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1259     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1260     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1261     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1262     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1263     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1264     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1265     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1266     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1267     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1268     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1269     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1270     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    50            1271     EEP_PGM_BEEP_STRENGTH:  DB 80 
1A1C    50            1272     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    05            1273     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1274     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1275     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1276     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1277     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1278     ENDIF
                      1279     
                      1280     
1A22    FF            1281     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1282     
------                1283     CSEG AT 1A60H
1A60    6F72672E      1284     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1285     
                      1286     ;**** **** **** **** ****
                      1287             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1287+1   CSEG AT 0  ; CODE SEGMENT START
0000    021282        1287+1   JMP RESET 
------                1287+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1287+1   JMP T0_INT 
------                1287+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1287+1   JMP T2_INT 
------                1287+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1287+1   JMP PCA_INT 
------                1287+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1287+1   JMP T3_INT 
------                1288     CSEG AT 80H			; Code segment after interrupt vectors 
                      1289     
                      1290     ;**** **** **** **** ****
                      1291     
                      1292     ; Table definitions
0080    02030406      1293     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1294     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1295     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1296     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1297     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1300     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1308     IF MODE == 2
                      1309       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1310     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1311       ENDIF
                      1312       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1315     ENDIF
                      1316     
                      1317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1318     ;
                      1319     ; Timer0 interrupt routine
                      1320     ;
                      1321     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1322     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1323     ;
                      1324     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1325     T0_INT: 	; Used for pwm control
00BA    C2AF          1326     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1327     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1328     	PUSH	ACC		
                      1329     	; Check if pwm is on
00C0    205A10        1330     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1331     
                      1332     	; Do not execute pwm when stopped
00C3    30600A        1333     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1334     	; Do not execute pwm on during demag recovery
00C6    205C07        1335     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1336     	; Pwm on cycle. 
00C9    302F02        1337     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1338     
                      1339     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1340     	CLR	A					
00CD    73            1341     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1342     
                      1343     T0_INT_PWM_ON_LOW_PWM: 
                      1344     
                      1345     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1346     	JMP	T0_INT_PWM_ON_EXECUTE
                      1347     ENDIF
                      1348     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1365     
                      1366     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1367     	JMP	T0_INT_PWM_ON_EXIT
                      1368     
                      1369     
                      1370     T0_INT_PWM_OFF: 
00D3    306306        1371     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1372     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1372+1   CLR P1 . 2 
00D8    C296          1372+1   CLR P1 . 6 
00DA    C295          1372+1   CLR P1 . 5 
                      1373     T0_INT_PWM_OFF_START_CHECKED: 
                      1374     	; Pwm off cycle
00DC    85258A        1375     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1376     	; Clear pwm on flag
00DF    C25A          1377     CLR FLAGS0 . 2 
                      1378     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1379     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1380     	CPL	A						; Full pwm?
00E4    7002          1381     	JNZ	($+4)					; No - branch
00E6    21C6          1382     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1383     
00E8    0563          1384     	INC	PWM_OFF_CNT				; Increment event counter
                      1385     	; Do not execute pwm when stopped
00EA    306013        1386     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1387     
                      1388     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1389     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1390     
                      1391     	; Separate exit commands here for minimum delay
00F0    758B00        1392     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1393     	POP	ACC			; Restore preserved registers
00F5    D0D0          1394     	POP	PSW
                      1395     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1395+1   CLR P1 . 2 
00F9    C296          1395+1   CLR P1 . 6 
00FB    C295          1395+1   CLR P1 . 5 
00FD    D2AF          1396     	SETB	EA			; Enable all interrupts
00FF    32            1397     	RETI
                      1398     
                      1399     T0_INT_PWM_OFF_STOPPED: 
                      1400     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1400+1   CLR P1 . 2 
0102    C296          1400+1   CLR P1 . 6 
0104    C295          1400+1   CLR P1 . 5 
0106    0201B6        1401     	JMP	T0_INT_PWM_OFF_EXIT
                      1402     
                      1403     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1404     SETB FLAGS1 . 5 
010B    C266          1405     CLR FLAGS1 . 6 
010D    E567          1406     	MOV	A, DAMPING_ON
010F    601C          1407     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1408     
0111    C3            1409     	CLR	C
0112    E563          1410     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1411     	DEC	A
0115    9567          1412     	SUBB	A, DAMPING_ON
0117    4014          1413     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1414     
0119    C265          1415     CLR FLAGS1 . 5 
011B    D266          1416     SETB FLAGS1 . 6 
011D    C3            1417     	CLR	C
011E    E563          1418     	MOV	A, PWM_OFF_CNT					
0120    9566          1419     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1420     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1421     
0124    0201B6        1422     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1423     
                      1424     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1425     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1426     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1427     
                      1428     T0_INT_PWM_OFF_DO_DAMPED: 
                      1429     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1430     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1431     
                      1432     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1432+1   CLR P1 . 2 
0132    C296          1432+1   CLR P1 . 6 
0134    C295          1432+1   CLR P1 . 5 
0136    7406          1433     MOV A , # 6 
0138    D5E0FD        1434     	DJNZ	ACC, $	
                      1435     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1435+1   SETB P1 . 3 
013D    D297          1435+1   SETB P1 . 7 
013F    D294          1435+1   SETB P1 . 4 
0141    0201B6        1436     	JMP	T0_INT_PWM_OFF_EXIT
                      1437     
                      1438     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1439     IF DAMPED_MODE_ENABLE == 1
0144    D266          1440     SETB FLAGS1 . 6 
                      1441     ENDIF
                      1442     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1442+1   CLR P1 . 2 
0148    C296          1442+1   CLR P1 . 6 
014A    C295          1442+1   CLR P1 . 5 
014C    E53E          1443     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1444     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1445     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1446     
                      1447     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1450     MOV A , # 6 
0156    D5E0FD        1451     	DJNZ	ACC, $	
                      1452     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1452+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1452+1   SETB P1 . 7 
015E    307502        1452+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1452+1   SETB P1 . 3 
                      1453     ENDIF
0163    0201B6        1454     	JMP	T0_INT_PWM_OFF_EXIT
                      1455     
                      1456     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1457     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1458     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1461     MOV A , # 6 
016B    D5E0FD        1462     	DJNZ	ACC, $	
                      1463     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1463+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1463+1   SETB P1 . 7 
0173    307502        1463+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1463+1   SETB P1 . 3 
                      1464     ENDIF
0178    0201B6        1465     	JMP	T0_INT_PWM_OFF_EXIT
                      1466     
                      1467     T0_INT_PWM_OFF_COMM_3: 
                      1468     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1471     MOV A , # 6 
017D    D5E0FD        1472     	DJNZ	ACC, $	
                      1473     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1473+1   SETB P1 . 4 
                      1474     ENDIF
0182    0201B6        1475     	JMP	T0_INT_PWM_OFF_EXIT
                      1476     
                      1477     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1478     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1479     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1480     
                      1481     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1484     MOV A , # 6 
018D    D5E0FD        1485     	DJNZ	ACC, $	
                      1486     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1486+1   SETB P1 . 4 
                      1487     ENDIF
0192    0201B6        1488     	JMP	T0_INT_PWM_OFF_EXIT
                      1489     
                      1490     T0_INT_PWM_OFF_COMM_5: 
                      1491     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1494     MOV A , # 6 
0197    D5E0FD        1495     	DJNZ	ACC, $	
                      1496     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1496+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1496+1   SETB P1 . 3 
019F    307502        1496+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1496+1   SETB P1 . 7 
                      1497     ENDIF
01A4    0201B6        1498     	JMP	T0_INT_PWM_OFF_EXIT
                      1499     
                      1500     T0_INT_PWM_OFF_COMM_6: 
                      1501     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1504     MOV A , # 6 
01A9    D5E0FD        1505     	DJNZ	ACC, $	
                      1506     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1506+1   SETB P1 . 3 
01B1    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1506+1   SETB P1 . 7 
                      1507     ENDIF
                      1508     
                      1509     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1510     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1511     	POP	ACC			; Restore preserved registers
01BB    D0D0          1512     	POP	PSW
                      1513     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1513+1   CLR P1 . 2 
01BF    C296          1513+1   CLR P1 . 6 
01C1    C295          1513+1   CLR P1 . 5 
01C3    D2AF          1514     	SETB	EA			; Enable all interrupts
01C5    32            1515     	RETI
                      1516     
                      1517     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1518     	POP	ACC			; Restore preserved registers
01C8    D0D0          1519     	POP	PSW
01CA    D2AF          1520     	SETB	EA			; Enable all interrupts
01CC    32            1521     	RETI
                      1522     
                      1523     
                      1524     
                      1525     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1526     	AJMP	T0_INT_PWM_ON_EXIT
                      1527     
                      1528     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1529     	ANFET_ON	
01CF    E525          1529+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1529+1   JZ ( $+12 ) 
01D3    207502        1529+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1529+1   SETB P1 . 2 
01D8    307502        1529+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1529+1   SETB P1 . 6 
                      1530     	BNFET_OFF
01DD    C295          1530+1   CLR P1 . 5 
01DF    61D3          1531     	AJMP	T0_INT_PWM_ON_EXIT
                      1532     
                      1533     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1534     	BNFET_ON
01E1    E525          1534+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1534+1   JZ ( $+4 ) 
01E5    D295          1534+1   SETB P1 . 5 
                      1535     	CNFET_OFF
01E7    207502        1535+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1535+1   CLR P1 . 6 
01EC    307502        1535+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1535+1   CLR P1 . 2 
01F1    61D3          1536     	AJMP	T0_INT_PWM_ON_EXIT
                      1537     
                      1538     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1539     	CNFET_ON
01F3    E525          1539+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1539+1   JZ ( $+12 ) 
01F7    207502        1539+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1539+1   SETB P1 . 6 
01FC    307502        1539+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1539+1   SETB P1 . 2 
                      1540     	ANFET_OFF
0201    207502        1540+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1540+1   CLR P1 . 2 
0206    307502        1540+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1540+1   CLR P1 . 6 
020B    61D3          1541     	AJMP	T0_INT_PWM_ON_EXIT
                      1542     
                      1543     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1544     	APFET_OFF
020D    207502        1544+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1544+1   CLR P1 . 3 
0212    307502        1544+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1544+1   CLR P1 . 7 
                      1545     	ANFET_ON								; Switch nFETs
0217    E525          1545+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1545+1   JZ ( $+12 ) 
021B    207502        1545+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1545+1   SETB P1 . 2 
0220    307502        1545+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1545+1   SETB P1 . 6 
                      1546     	CPFET_OFF
0225    207502        1546+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1546+1   CLR P1 . 7 
022A    307502        1546+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1546+1   CLR P1 . 3 
                      1547     	BNFET_OFF 							
022F    C295          1547+1   CLR P1 . 5 
0231    61D3          1548     	AJMP	T0_INT_PWM_ON_EXIT
                      1549     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1550     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1551     	APFET_OFF
0233    207502        1551+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1551+1   CLR P1 . 3 
0238    307502        1551+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1551+1   CLR P1 . 7 
                      1552     	CPFET_OFF
023D    207502        1552+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1552+1   CLR P1 . 7 
0242    307502        1552+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1552+1   CLR P1 . 3 
0247    7406          1553     MOV A , # 6 
0249    D5E0FD        1554     	DJNZ ACC,	$
                      1555     	ANFET_ON								; Switch nFETs
024C    E525          1555+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1555+1   JZ ( $+12 ) 
0250    207502        1555+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1555+1   SETB P1 . 2 
0255    307502        1555+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1555+1   SETB P1 . 6 
                      1556     	BNFET_OFF 							
025A    C295          1556+1   CLR P1 . 5 
025C    61D3          1557     	AJMP	T0_INT_PWM_ON_EXIT
                      1558     
                      1559     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1560     	APFET_OFF
025E    207502        1560+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1560+1   CLR P1 . 3 
0263    307502        1560+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1560+1   CLR P1 . 7 
                      1561     	ANFET_ON								; Switch nFETs
0268    E525          1561+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1561+1   JZ ( $+12 ) 
026C    207502        1561+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1561+1   SETB P1 . 2 
0271    307502        1561+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1561+1   SETB P1 . 6 
                      1562     	BPFET_OFF
0276    C294          1562+1   CLR P1 . 4 
                      1563     	BNFET_OFF								
0278    C295          1563+1   CLR P1 . 5 
027A    61D3          1564     	AJMP	T0_INT_PWM_ON_EXIT
                      1565     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1566     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1567     	APFET_OFF
027C    207502        1567+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1567+1   CLR P1 . 3 
0281    307502        1567+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1567+1   CLR P1 . 7 
                      1568     	BPFET_OFF
0286    C294          1568+1   CLR P1 . 4 
0288    7406          1569     MOV A , # 6 
028A    D5E0FD        1570     	DJNZ ACC,	$
                      1571     	ANFET_ON								; Switch nFETs
028D    E525          1571+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1571+1   JZ ( $+12 ) 
0291    207502        1571+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1571+1   SETB P1 . 2 
0296    307502        1571+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1571+1   SETB P1 . 6 
                      1572     	BNFET_OFF								
029B    C295          1572+1   CLR P1 . 5 
029D    61D3          1573     	AJMP	T0_INT_PWM_ON_EXIT
                      1574     
                      1575     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1576     	BPFET_OFF
029F    C294          1576+1   CLR P1 . 4 
                      1577     	BNFET_ON								; Switch nFETs
02A1    E525          1577+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1577+1   JZ ( $+4 ) 
02A5    D295          1577+1   SETB P1 . 5 
                      1578     	APFET_OFF
02A7    207502        1578+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1578+1   CLR P1 . 3 
02AC    307502        1578+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1578+1   CLR P1 . 7 
                      1579     	CNFET_OFF								
02B1    207502        1579+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1579+1   CLR P1 . 6 
02B6    307502        1579+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1579+1   CLR P1 . 2 
02BB    61D3          1580     	AJMP	T0_INT_PWM_ON_EXIT
                      1581     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1582     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1583     	BPFET_OFF
02BD    C294          1583+1   CLR P1 . 4 
                      1584     	APFET_OFF
02BF    207502        1584+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1584+1   CLR P1 . 3 
02C4    307502        1584+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1584+1   CLR P1 . 7 
02C9    7406          1585     MOV A , # 6 
02CB    D5E0FD        1586     	DJNZ ACC,	$
                      1587     	BNFET_ON								; Switch nFETs
02CE    E525          1587+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1587+1   JZ ( $+4 ) 
02D2    D295          1587+1   SETB P1 . 5 
                      1588     	CNFET_OFF								
02D4    207502        1588+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1588+1   CLR P1 . 6 
02D9    307502        1588+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1588+1   CLR P1 . 2 
02DE    61D3          1589     	AJMP	T0_INT_PWM_ON_EXIT
                      1590     
                      1591     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1592     	BPFET_OFF
02E0    C294          1592+1   CLR P1 . 4 
                      1593     	BNFET_ON								; Switch nFETs
02E2    E525          1593+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1593+1   JZ ( $+4 ) 
02E6    D295          1593+1   SETB P1 . 5 
                      1594     	CPFET_OFF
02E8    207502        1594+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1594+1   CLR P1 . 7 
02ED    307502        1594+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1594+1   CLR P1 . 3 
                      1595     	CNFET_OFF								
02F2    207502        1595+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1595+1   CLR P1 . 6 
02F7    307502        1595+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1595+1   CLR P1 . 2 
02FC    61D3          1596     	AJMP	T0_INT_PWM_ON_EXIT
                      1597     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1598     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1599     	BPFET_OFF
02FE    C294          1599+1   CLR P1 . 4 
                      1600     	CPFET_OFF
0300    207502        1600+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1600+1   CLR P1 . 7 
0305    307502        1600+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1600+1   CLR P1 . 3 
030A    7406          1601     MOV A , # 6 
030C    D5E0FD        1602     	DJNZ ACC,	$
                      1603     	BNFET_ON								; Switch nFETs
030F    E525          1603+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1603+1   JZ ( $+4 ) 
0313    D295          1603+1   SETB P1 . 5 
                      1604     	CNFET_OFF								
0315    207502        1604+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1604+1   CLR P1 . 6 
031A    307502        1604+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1604+1   CLR P1 . 2 
031F    61D3          1605     	AJMP	T0_INT_PWM_ON_EXIT
                      1606     
                      1607     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1608     	CPFET_OFF
0321    207502        1608+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1608+1   CLR P1 . 7 
0326    307502        1608+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1608+1   CLR P1 . 3 
                      1609     	CNFET_ON								; Switch nFETs
032B    E525          1609+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1609+1   JZ ( $+12 ) 
032F    207502        1609+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1609+1   SETB P1 . 6 
0334    307502        1609+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1609+1   SETB P1 . 2 
                      1610     	BPFET_OFF
0339    C294          1610+1   CLR P1 . 4 
                      1611     	ANFET_OFF								
033B    207502        1611+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1611+1   CLR P1 . 2 
0340    307502        1611+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1611+1   CLR P1 . 6 
0345    61D3          1612     	AJMP	T0_INT_PWM_ON_EXIT
                      1613     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1614     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1615     	CPFET_OFF
0347    207502        1615+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1615+1   CLR P1 . 7 
034C    307502        1615+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1615+1   CLR P1 . 3 
                      1616     	BPFET_OFF
0351    C294          1616+1   CLR P1 . 4 
0353    7406          1617     MOV A , # 6 
0355    D5E0FD        1618     	DJNZ ACC,	$
                      1619     	CNFET_ON								; Switch nFETs
0358    E525          1619+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1619+1   JZ ( $+12 ) 
035C    207502        1619+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1619+1   SETB P1 . 6 
0361    307502        1619+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1619+1   SETB P1 . 2 
                      1620     	ANFET_OFF								
0366    207502        1620+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1620+1   CLR P1 . 2 
036B    307502        1620+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1620+1   CLR P1 . 6 
0370    61D3          1621     	AJMP	T0_INT_PWM_ON_EXIT
                      1622     
                      1623     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1624     	CPFET_OFF
0372    207502        1624+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1624+1   CLR P1 . 7 
0377    307502        1624+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1624+1   CLR P1 . 3 
                      1625     	CNFET_ON								; Switch nFETs
037C    E525          1625+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1625+1   JZ ( $+12 ) 
0380    207502        1625+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1625+1   SETB P1 . 6 
0385    307502        1625+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1625+1   SETB P1 . 2 
                      1626     	APFET_OFF
038A    207502        1626+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1626+1   CLR P1 . 3 
038F    307502        1626+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1626+1   CLR P1 . 7 
                      1627     	ANFET_OFF								
0394    207502        1627+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1627+1   CLR P1 . 2 
0399    307502        1627+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1627+1   CLR P1 . 6 
039E    61D3          1628     	AJMP	T0_INT_PWM_ON_EXIT
                      1629     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1630     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1631     	CPFET_OFF
03A0    207502        1631+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1631+1   CLR P1 . 7 
03A5    307502        1631+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1631+1   CLR P1 . 3 
                      1632     	APFET_OFF
03AA    207502        1632+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1632+1   CLR P1 . 3 
03AF    307502        1632+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1632+1   CLR P1 . 7 
03B4    7406          1633     MOV A , # 6 
03B6    D5E0FD        1634     	DJNZ ACC,	$
                      1635     	CNFET_ON								; Switch nFETs
03B9    E525          1635+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1635+1   JZ ( $+12 ) 
03BD    207502        1635+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1635+1   SETB P1 . 6 
03C2    307502        1635+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1635+1   SETB P1 . 2 
                      1636     	ANFET_OFF								
03C7    207502        1636+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1636+1   CLR P1 . 2 
03CC    307502        1636+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1636+1   CLR P1 . 6 
03D1    61D3          1637     	AJMP	T0_INT_PWM_ON_EXIT
                      1638     
                      1639     T0_INT_PWM_ON_EXIT: 
                      1640     	; Set timer for coming on cycle length
03D3    E525          1641     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1642     	CPL	A						; cpl is 255-x
03D6    F58A          1643     	MOV	TL0, A					; Write start point for timer
                      1644     	; Set other variables
03D8    758B00        1645     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1646     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1647     SETB FLAGS0 . 2 
                      1648     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1649     	; Exit interrupt
03E0    D0E0          1650     	POP	ACC			; Restore preserved registers
03E2    D0D0          1651     	POP	PSW
03E4    D2AF          1652     	SETB	EA			; Enable all interrupts
03E6    32            1653     	RETI
                      1654     
                      1655     
                      1656     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1657     ;
                      1658     ; Timer2 interrupt routine
                      1659     ;
                      1660     ; No assumptions
                      1661     ;
                      1662     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1663     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1664     	CLR	EA
03E9    C2AD          1665     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1666     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1667     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1668     	PUSH	ACC
03F2    D2D3          1669     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1670     	SETB	EA
                      1671     	; Clear low byte interrupt flag
03F6    C2CE          1672     	CLR	TF2L						; Clear interrupt flag
                      1673     	; Check RC pulse timeout counter
03F8    E528          1674     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1675     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1676     
                      1677     	; Decrement timeout counter (if PWM)
03FC    741F          1678     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1679     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1680     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1681     
0402    1528          1682     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1683     	AJMP	T2_INT_SKIP_START
                      1684     
                      1685     T2_INT_PULSES_ABSENT: 
                      1686     	; Timeout counter has reached zero, pulses are absent
0406    7800          1687     MOV R0 , # 0 
0408    7900          1688     MOV R1 , # 0 
                      1689     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1689+1   MOV A , P0 
040C    307601        1689+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1689+1   CPL A  ; YES - INVERT
0410    30E502        1690     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1691     MOV R0 , # 255 
                      1692     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1692+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1692+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1692+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1692+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1692+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1693     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1693+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1694     CLR FLAGS2 . 1 
                      1695     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1695+1   MOV A , P0 
042A    307601        1695+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1695+1   CPL A  ; YES - INVERT
042E    30E502        1696     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1697     MOV R1 , # 255 
0433    C3            1698     	CLR	C
0434    E8            1699     MOV A , R0 
0435    99            1700     SUBB A , R1 
0436    70CE          1701     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1702     
0438    305903        1703     JNB FLAGS0 . 1 , ( $+6 ) 
                      1704     
043B    752818        1705     MOV RCP_TIMEOUT_CNT , # 24 
                      1706     
043E    741F          1707     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1708     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1709     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1710     
0444    752818        1711     MOV RCP_TIMEOUT_CNT , # 24 
                      1712     
                      1713     
                      1714     T2_INT_PPM_TIMEOUT_SET: 
                      1715     
                      1716     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1717     ; 
                      1718     ; 对 RCP 信号处理
                      1719     ; 1 小于 1500us 最低油门
                      1720     ; 2 大于 1500us 正常处理
                      1721     ; 
                      1722     ;	clr C
                      1723     ;	mov A, Temp1
                      1724     ;	subb A, #80h
                      1725     ;	jnc skypup_01
                      1726     ;	mov	Temp1, #RCP_MIN
                      1727     ; skypup_01:
                      1728     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1729     MOV NEW_RCP , R0 
0449    D268          1730     SETB FLAGS2 . 0 
                      1731     
                      1732     T2_INT_SKIP_START: 
                      1733     	; Check RC pulse skip counter
044B    E529          1734     	MOV	A, RCP_SKIP_CNT			
044D    6004          1735     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1736     	
                      1737     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1738     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1739     	AJMP	T2_INT_RCP_UPDATE_START
                      1740     
                      1741     T2_INT_SKIP_END: 
0453    741F          1742     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1743     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1744     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1745     
                      1746     	; Skip counter has reached zero, start looking for RC pulses again
                      1747     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1747+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1748     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1748+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1749     	
                      1750     T2_INT_RCP_UPDATE_START: 
                      1751     	; Process updated RC pulse
045E    206802        1752     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1753     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1754     
0463    E559          1755     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1756     MOV R0 , A 
0466    C268          1757     CLR FLAGS2 . 0 
                      1758     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1759     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1760     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1761     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1762     
                      1763     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1766     
                      1767     IF MODE == 2	; Multi
046E    7982          1768     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1769     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1770     ENDIF
                      1771     
                      1772     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1773     	CLR	C
0474    E8            1774     MOV A , R0 
0475    94F0          1775     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1776     	JC	T2_INT_RCP_UPDATE_MULT
                      1777     
0479    74F0          1778     	MOV	A, #240			; Set requested pwm to max
047B    F8            1779     MOV R0 , A 
                      1780     
                      1781     T2_INT_RCP_UPDATE_MULT: 	
                      1782     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1783     MOV A , R0 
047D    C4            1784     	SWAP	A			; After this "0.0625"
047E    540F          1785     	ANL	A, #0FH
0480    28            1786     ADD A , R0 
0481    F8            1787     MOV R0 , A 
                      1788     	; Adjust tail gain
0482    7984          1789     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1790     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1791     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1792     
0489    C3            1793     	CLR	C
048A    13            1794     	RRC	A			; After this "0.5"
048B    C3            1795     	CLR	C
048C    13            1796     	RRC	A			; After this "0.25"
048D    8721          1797     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1798     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1799     
0492    C3            1800     	CLR	C
0493    13            1801     	RRC	A			; After this "0.125"
                      1802     
                      1803     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1804     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1805     
0497    C3            1806     	CLR	C
0498    C8            1807     XCH A , R0 
0499    98            1808     SUBB A , R0 
049A    F8            1809     MOV R0 , A 
049B    81A4          1810     	AJMP	T2_INT_PWM_MIN_RUN
                      1811     
                      1812     T2_INT_RCP_GAIN_POS: 
049D    28            1813     ADD A , R0 
049E    F8            1814     MOV R0 , A 
049F    5003          1815     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1816     
04A1    74FF          1817     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1818     MOV R0 , A 
                      1819     
                      1820     T2_INT_PWM_MIN_RUN:  
                      1821     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1831     
                      1832     T2_INT_PWM_UPDATE:  
                      1833     	; Check if any startup phase flags are set
04A4    E52C          1834     	MOV	A, FLAGS1
04A6    5406          1835     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1836     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1837     
                      1838     	; Update requested_pwm
04AA    8822          1839     MOV REQUESTED_PWM , R0 
                      1840     	; Limit pwm during direct start
04AC    30630A        1841     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1842     
04AF    C3            1843     	CLR	C
04B0    E522          1844     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1845     	SUBB	A, PWM_LIMIT
04B4    4003          1846     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1847     
04B6    855E22        1848     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1849     
                      1850     T2_INT_CURRENT_PWM_UPDATE:  
                      1851     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1852     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1853     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1854     ENDIF
                      1855     
                      1856     	; Update current pwm, with limited throttle change rate
04BE    C3            1857     	CLR	C
04BF    E522          1858     	MOV	A, REQUESTED_PWM	 
04C1    9524          1859     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1860     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1861     
                      1862     	; 缓启动
04C5    78A1          1863     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1864     	;mov	Temp1, #1
04C7    96            1865     SUBB A , @ R0 
                      1866     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1867     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1868     
04CA    E524          1869     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1870     ADD A , @ R0 
                      1871     	; add	A, Temp1
04CD    F524          1872     	MOV	CURRENT_PWM, A
04CF    5009          1873     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1874     
04D1    7524FF        1875     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1876     	JMP	T2_INT_CURRENT_PWM_DONE
                      1877     
                      1878     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1879     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1880     T2_INT_CURRENT_PWM_DONE: 
                      1881     IF MODE >= 1	; Tail or multi
                      1882     	; Set current_pwm_limited
04DA    A824          1883     MOV R0 , CURRENT_PWM 
04DC    C3            1884     	CLR	C
04DD    E524          1885     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1886     	SUBB	A, PWM_LIMIT
04E1    4002          1887     	JC	($+4)					; If current pwm below limit - branch
                      1888     
04E3    A85E          1889     MOV R0 , PWM_LIMIT 
                      1890     
04E5    8825          1891     MOV CURRENT_PWM_LIMITED , R0 
                      1892     ENDIF
                      1893     T2_INT_PWM_EXIT: 	
                      1894     	; Check if high byte flag is set
04E7    20CF0C        1895     	JB	TF2H, T2H_INT		
04EA    D0E0          1896     	POP	ACC			; Restore preserved registers
04EC    D0D0          1897     	POP	PSW
04EE    C2D3          1898     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1899     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1900     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1901     	RETI
                      1902     
                      1903     T2H_INT: 
                      1904     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1905     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1906     MOV R0 , # 1 
                      1907     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1908     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1909     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1910     
                      1911     	; Decrement timeout counter (if PPM)
04FE    741F          1912     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1913     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1914     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1915     
0504    1528          1916     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1917     
                      1918     T2H_INT_RCP_STOP_CHECK: 
                      1919     	; Check RC pulse against stop value
0506    C3            1920     	CLR	C
0507    E559          1921     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1922     SUBB A , # 1 
050B    4005          1923     	JC	T2H_INT_RCP_STOP
                      1924     
                      1925     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1926     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1927     	AJMP	T2H_INT_RCP_GOV_PWM
                      1928     
                      1929     T2H_INT_RCP_STOP: 	
                      1930     	; RC pulse less than stop value
0512    755D00        1931     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1932     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1933     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1934     	ADD	A, #1
051C    F55C          1935     	MOV	RCP_STOP_CNT, A
051E    5003          1936     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1937     
0520    755CFF        1938     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1939     
                      1940     T2H_INT_RCP_GOV_PWM: 
                      1941     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      2070     IF MODE == 2	; Multi
0523    E55F          2071     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          2072     	ADD	A, #10
0527    5005          2073     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      2074     
0529    755FFF        2075     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          2076     	AJMP	T2H_INT_RCP_EXIT
                      2077     
                      2078     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          2079     	MOV	PWM_LIMIT_SPOOLUP, A
                      2080     ENDIF
                      2081     
                      2082     T2H_INT_RCP_EXIT: 
0530    D0E0          2083     	POP	ACC			; Restore preserved registers
0532    D0D0          2084     	POP	PSW
0534    C2D3          2085     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        2086     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          2087     	SETB	ET2			; Enable timer2 interrupts
053B    32            2088     	RETI
                      2089     
                      2090     
                      2091     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2092     ;
                      2093     ; Timer3 interrupt routine
                      2094     ;
                      2095     ; No assumptions
                      2096     ;
                      2097     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2098     T3_INT: 	; Used for commutation timing
053C    C2AF          2099     	CLR 	EA			; Disable all interrupts
053E    53917F        2100     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          2101     CLR FLAGS0 . 0 
0543    D2AF          2102     	SETB	EA			; Enable all interrupts
0545    32            2103     	RETI
                      2104     
                      2105     
                      2106     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2107     ;
                      2108     ; PCA interrupt routine
                      2109     ;
                      2110     ; No assumptions
                      2111     ;
                      2112     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2113     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2114     	CLR	EA
0548    53E6EF        2115     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2116     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2117     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2118     	PUSH	ACC
0551    C0F0          2119     	PUSH	B
0553    D2D3          2120     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2121     	SETB	EA
                      2122     	; Get the PCA counter values
                      2123     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2123+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2123+1   MOV R1 , PCA0CPH0 
                      2124     	; Clear interrupt flag
                      2125     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2125+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2126     	; Check which edge it is
055D    306902        2127     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          2128     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2129     
                      2130     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2130+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2130+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2130+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2130+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2130+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2131     SETB FLAGS2 . 1 
                      2132     	; Read RC signal level
                      2133     	READ_RCP_INT			
0573    E580          2133+1   MOV A , P0 
0575    307601        2133+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2133+1   CPL A  ; YES - INVERT
                      2134     	; Test RC signal level
0579    20E502        2135     JB ACC . 5 , ( $+5 ) 
057C    A185          2136     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2137     
                      2138     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2139     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2140     MOV RCP_PREV_EDGE_H , R1 
0582    0207D5        2141     	LJMP	PCA_INT_EXIT				; Exit
                      2142     
                      2143     PCA_INT_FAIL_MINIMUM: 
                      2144     	; Prepare for next interrupt
                      2145     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2145+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2145+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2145+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2145+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2145+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2146     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2146+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2147     CLR FLAGS2 . 1 
0598    741F          2148     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2149     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          2150     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      2151     
059E    E1BB          2152     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      2153     
05A0    7800          2154     MOV R0 , # 0 
                      2155     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          2155+1   MOV A , P0 
05A4    307601        2155+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            2155+1   CPL A  ; YES - INVERT
05A8    30E502        2156     JNB ACC . 5 , ( $+5 ) 
05AB    E1BB          2157     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      2158     
                      2159     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2160     ; 
                      2161     ; 对 RCP 信号处理
                      2162     ; 1 小于 1500us 最低油门
                      2163     ; 2 大于 1500us 正常处理
                      2164     ; 
                      2165     ;	clr C
                      2166     ;	mov A, Temp1
                      2167     ;	subb A, #80h
                      2168     ;	jnc skypup_02
                      2169     ;	mov	Temp1, #RCP_MIN
                      2170     ; skypup_02:
                      2171     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2172     
05AD    8859          2173     MOV NEW_RCP , R0 
05AF    E186          2174     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2175     
                      2176     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2177     	; Prepare for next interrupt
                      2178     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        2178+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        2178+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        2178+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        2178+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        2178+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          2179     CLR FLAGS2 . 1 
                      2180     	; Check if pwm frequency shall be measured
05C2    205902        2181     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          2182     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2183     
                      2184     	; Set second edge trig only during pwm frequency measurement
                      2185     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        2185+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        2185+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        2185+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        2185+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        2185+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2186     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          2186+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          2187     SETB FLAGS2 . 1 
                      2188     	; Store edge data to RAM
05DA    8854          2189     MOV RCP_EDGE_L , R0 
05DC    8955          2190     MOV RCP_EDGE_H , R1 
                      2191     	; Calculate pwm frequency
05DE    C3            2192     	CLR	C
05DF    E8            2193     MOV A , R0 
05E0    9552          2194     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            2195     MOV R0 , A 
05E3    E9            2196     MOV A , R1 
05E4    9553          2197     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            2198     MOV R1 , A 
05E7    E4            2199     	CLR	A
05E8    FB            2200     MOV R3 , A 
05E9    7AFA          2201     MOV R2 , # 250 
                      2202     	; Check if pwm frequency is 12kHz
05EB    C3            2203     	CLR	C
05EC    E8            2204     MOV A , R0 
05ED    94C8          2205     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            2206     MOV A , R1 
05F0    9400          2207     	SUBB	A, #HIGH(200)
05F2    5008          2208     	JNC	PCA_INT_CHECK_8KHZ
                      2209     
05F4    E4            2210     	CLR	A
05F5    D2E4          2211     SETB ACC . 4 
05F7    FB            2212     MOV R3 , A 
05F8    7A0A          2213     MOV R2 , # 10 
05FA    C13E          2214     	AJMP	PCA_INT_RESTORE_EDGE
                      2215     
                      2216     PCA_INT_CHECK_8KHZ: 
                      2217     	; Check if pwm frequency is 8kHz
05FC    C3            2218     	CLR	C
05FD    E8            2219     MOV A , R0 
05FE    9468          2220     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            2221     MOV A , R1 
0601    9401          2222     	SUBB	A, #HIGH(360)
0603    5008          2223     	JNC	PCA_INT_CHECK_4KHZ
                      2224     
0605    E4            2225     	CLR	A
0606    D2E3          2226     SETB ACC . 3 
0608    FB            2227     MOV R3 , A 
0609    7A0F          2228     MOV R2 , # 15 
060B    C13E          2229     	AJMP	PCA_INT_RESTORE_EDGE
                      2230     
                      2231     PCA_INT_CHECK_4KHZ: 
                      2232     	; Check if pwm frequency is 4kHz
060D    C3            2233     	CLR	C
060E    E8            2234     MOV A , R0 
060F    94D0          2235     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            2236     MOV A , R1 
0612    9402          2237     	SUBB	A, #HIGH(720)
0614    5008          2238     	JNC	PCA_INT_CHECK_2KHZ
                      2239     
0616    E4            2240     	CLR	A
0617    D2E2          2241     SETB ACC . 2 
0619    FB            2242     MOV R3 , A 
061A    7A1E          2243     MOV R2 , # 30 
061C    C13E          2244     	AJMP	PCA_INT_RESTORE_EDGE
                      2245     
                      2246     PCA_INT_CHECK_2KHZ: 
                      2247     	; Check if pwm frequency is 2kHz
061E    C3            2248     	CLR	C
061F    E8            2249     MOV A , R0 
0620    94A0          2250     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            2251     MOV A , R1 
0623    9405          2252     	SUBB	A, #HIGH(1440)
0625    5008          2253     	JNC	PCA_INT_CHECK_1KHZ
                      2254     
0627    E4            2255     	CLR	A
0628    D2E1          2256     SETB ACC . 1 
062A    FB            2257     MOV R3 , A 
062B    7A3C          2258     MOV R2 , # 60 
062D    C13E          2259     	AJMP	PCA_INT_RESTORE_EDGE
                      2260     
                      2261     PCA_INT_CHECK_1KHZ: 
                      2262     	; Check if pwm frequency is 1kHz
062F    C3            2263     	CLR	C
0630    E8            2264     MOV A , R0 
0631    9498          2265     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            2266     MOV A , R1 
0634    9408          2267     	SUBB	A, #HIGH(2200)
0636    5006          2268     	JNC	PCA_INT_RESTORE_EDGE
                      2269     
0638    E4            2270     	CLR	A
0639    D2E0          2271     SETB ACC . 0 
063B    FB            2272     MOV R3 , A 
063C    7A78          2273     MOV R2 , # 120 
                      2274     
                      2275     PCA_INT_RESTORE_EDGE: 
                      2276     	; Calculate difference between this period and previous period
063E    C3            2277     	CLR	C
063F    E8            2278     MOV A , R0 
0640    9556          2279     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2280     MOV R4 , A 
0643    E9            2281     MOV A , R1 
0644    9557          2282     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2283     MOV R5 , A 
                      2284     	; Make positive
0647    30E708        2285     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2286     MOV A , R4 
064B    F4            2287     	CPL	A
064C    2401          2288     	ADD	A, #1
064E    FC            2289     MOV R4 , A 
064F    ED            2290     MOV A , R5 
0650    F4            2291     	CPL	A
0651    FD            2292     MOV R5 , A 
                      2293     
                      2294     PCA_INT_CHECK_DIFF: 
                      2295     	; Check difference
0652    755800        2296     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2297     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2298     
0657    C3            2299     	CLR	C
0658    EC            2300     MOV A , R4 
0659    9A            2301     SUBB A , R2 
065A    5003          2302     	JNC	PCA_INT_STORE_DATA
                      2303     
065C    755801        2304     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2305     
                      2306     PCA_INT_STORE_DATA: 
                      2307     	; Store previous period
065F    8856          2308     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2309     MOV RCP_PREV_PERIOD_H , R1 
                      2310     	; Restore edge data from RAM
0663    A854          2311     MOV R0 , RCP_EDGE_L 
0665    A955          2312     MOV R1 , RCP_EDGE_H 
                      2313     	; Store pre previous edge
0667    8852          2314     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2315     MOV RCP_PREPREV_EDGE_H , R1 
                      2316     
                      2317     PCA_INT_FALL: 
                      2318     	; RC pulse edge was second, calculate new pulse length
066B    C3            2319     	CLR	C
066C    E8            2320     MOV A , R0 
066D    9526          2321     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2322     MOV R0 , A 
0670    E9            2323     MOV A , R1 
0671    9527          2324     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2325     MOV R1 , A 
0674    307402        2326     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2327     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2328     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2329     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2330     
067E    307202        2331     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2332     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2333     
0683    E9            2334     MOV A , R1 
0684    C3            2335     	CLR	C
0685    13            2336     	RRC	A
0686    F9            2337     MOV R1 , A 
0687    E8            2338     MOV A , R0 
0688    13            2339     	RRC	A
0689    F8            2340     MOV R0 , A 
                      2341     
068A    307102        2342     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2343     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2344     
068F    E9            2345     MOV A , R1 
0690    C3            2346     	CLR	C
0691    13            2347     	RRC	A
0692    F9            2348     MOV R1 , A 
0693    E8            2349     MOV A , R0 
0694    13            2350     	RRC	A
0695    F8            2351     MOV R0 , A 
                      2352     
0696    307002        2353     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2354     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2355     
069B    E9            2356     MOV A , R1 
069C    C3            2357     	CLR	C
069D    13            2358     	RRC	A
069E    FD            2359     MOV R5 , A 
069F    E8            2360     MOV A , R0 
06A0    13            2361     	RRC	A
06A1    FC            2362     MOV R4 , A 
                      2363     	; Skip range limitation if pwm frequency measurement
06A2    205918        2364     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2365     
                      2366     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2367     	CLR	C
06A6    EC            2368     MOV A , R4 
06A7    941C          2369     	SUBB	A, #28
06A9    ED            2370     MOV A , R5 
06AA    9402          2371     	SUBB A, #2
06AC    4003          2372     	JC	($+5)						; No - proceed
                      2373     
06AE    0207BB        2374     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2375     
                      2376     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2377     MOV A , R5 
06B2    7009          2378     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2379     
06B4    C3            2380     	CLR	C
06B5    EC            2381     MOV A , R4 
06B6    94C8          2382     	SUBB	A, #200
06B8    5003          2383     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2384     
06BA    0207BB        2385     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2386     
                      2387     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2388     	; Calculate "1000us" plus throttle minimum
06BD    7400          2389     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2390     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2391     
                      2392     IF MODE >= 1	; Tail or multi
06C2    7888          2393     MOV R0 , # PGM_DIRECTION 
06C4    E6            2394     MOV A , @ R0 
                      2395     ENDIF
06C5    7896          2396     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2397     IF MODE >= 1	; Tail or multi
06C7    B40302        2398     	CJNE	A, #3, ($+5)
                      2399     
06CA    789E          2400     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2401     ENDIF
06CC    E6            2402     MOV A , @ R0 
                      2403     
                      2404     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2405     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2406     MOV R6 , A 
06D0    E4            2407     	CLR	A
06D1    3400          2408     	ADDC	A, #0
06D3    FF            2409     MOV R7 , A 
                      2410     
06D4    C3            2411     	CLR	C
06D5    EC            2412     MOV A , R4 
06D6    9E            2413     SUBB A , R6 
06D7    FC            2414     MOV R4 , A 
06D8    ED            2415     MOV A , R5 
06D9    9F            2416     SUBB A , R7 
06DA    FD            2417     MOV R5 , A 
                      2418     IF MODE >= 1	; Tail or multi
06DB    9208          2419     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2420     MOV R0 , # PGM_DIRECTION 
06DF    E6            2421     MOV A , @ R0 
06E0    B40322        2422     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2423     
06E3    A208          2424     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2425     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2426     
                      2427     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2428     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2429     
06EA    C2AF          2430     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2431     SETB FLAGS3 . 5 
06EE    C1F7          2432     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2433     
                      2434     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2435     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2436     
06F3    C2AF          2437     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2438     CLR FLAGS3 . 5 
                      2439     
                      2440     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2441     	ALL_NFETS_OFF
06F7    C292          2441+1   CLR P1 . 2 
06F9    C296          2441+1   CLR P1 . 6 
06FB    C295          2441+1   CLR P1 . 5 
                      2442     	ALL_PFETS_OFF
06FD    C293          2442+1   CLR P1 . 3 
06FF    C297          2442+1   CLR P1 . 7 
0701    C294          2442+1   CLR P1 . 4 
0703    D2AF          2443     	SETB	EA
                      2444     
                      2445     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2446     	MOV	C, BIT_ACCESS_INT.0
                      2447     ENDIF
0707    5017          2448     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2449     
                      2450     IF MODE >= 1	; Tail or multi
0709    E6            2451     MOV A , @ R0 
070A    B4030D        2452     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2453     
070D    EC            2454     MOV A , R4 
070E    F4            2455     	CPL	A
070F    2401          2456     	ADD	A, #1
0711    FC            2457     MOV R4 , A 
0712    ED            2458     MOV A , R5 
0713    F4            2459     	CPL	A
0714    3400          2460     	ADDC	A, #0
0716    FD            2461     MOV R5 , A 
0717    020720        2462     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2463     
                      2464     PCA_INT_PPM_UNIDIR_NEG: 
                      2465     ENDIF
071A    7800          2466     MOV R0 , # 0 
071C    7900          2467     MOV R1 , # 0 
071E    E16A          2468     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2469     
                      2470     PCA_INT_PPM_NEG_CHECKED: 
                      2471     IF MODE >= 1	; Tail or multi
0720    7888          2472     MOV R0 , # PGM_DIRECTION 
0722    E6            2473     MOV A , @ R0 
0723    B40315        2474     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2475     
0726    EC            2476     MOV A , R4 
0727    33            2477     	RLC	A
0728    FC            2478     MOV R4 A 
0729    ED            2479     MOV A , R5 
072A    33            2480     	RLC	A
072B    FD            2481     MOV R5 A 
072C    C3            2482     	CLR	C							; Subtract deadband
072D    EC            2483     MOV A , R4 
072E    9405          2484     	SUBB	A, #5		
0730    FC            2485     MOV R4 , A 
0731    ED            2486     MOV A , R5 
0732    9400          2487     	SUBB	A, #0
0734    FD            2488     MOV R5 , A 
0735    5004          2489     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2490     
0737    7C00          2491     MOV R4 , # 0 
0739    7D00          2492     MOV R5 , # 0 
                      2493     
                      2494     PCA_INT_PPM_BIDIR_DONE: 
                      2495     ENDIF
073B    C3            2496     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2497     MOV A , R4 
073D    94FF          2498     SUBB A , # 255 
073F    ED            2499     MOV A , R5 
0740    9400          2500     	SUBB	A, #0
0742    4006          2501     	JC	PCA_INT_PPM_MAX_CHECKED
                      2502     
0744    78FF          2503     MOV R0 , # 255 
0746    7900          2504     MOV R1 , # 0 
0748    E16A          2505     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2506     
                      2507     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2508     MOV A , R4 
074B    856EF0        2509     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2510     	MUL	AB
074F    C5F0          2511     	XCH	A, B
0751    A2F7          2512     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2513     	RLC	A
0754    F8            2514     MOV R0 , A 
0755    7900          2515     MOV R1 , # 0 
0757    4003          2516     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2517     	
0759    020786        2518     	JMP	PCA_INT_LIMITED			
                      2519     
                      2520     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2521     MOV R0 , # 255 
075E    7900          2522     MOV R1 , # 0 
0760    020786        2523     	JMP	PCA_INT_LIMITED			
                      2524     
                      2525     PCA_INT_PWM_DIVIDE: 
0763    E9            2526     MOV A , R1 
0764    C3            2527     	CLR	C
0765    13            2528     	RRC	A
0766    F9            2529     MOV R1 , A 
0767    E8            2530     MOV A , R0 
0768    13            2531     	RRC	A
0769    F8            2532     MOV R0 , A 
                      2533     
                      2534     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2535     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2536     MOV A , R1 
076E    6002          2537     	JZ	($+4)
                      2538     
0770    78FF          2539     MOV R0 , # 255 
                      2540     
0772    C3            2541     	CLR	C
0773    E8            2542     MOV A , R0 
0774    13            2543     	RRC	A
0775    38            2544     ADDC A , R0 
0776    F8            2545     MOV R0 , A 
0777    E4            2546     	CLR	A
0778    3400          2547     	ADDC	A, #0
077A    F9            2548     MOV R1 , A 
                      2549     
                      2550     PCA_INT_CHECK_LEGAL_RANGE: 
                      2551     	; Check that RC pulse is within legal range
077B    C3            2552     	CLR	C
077C    E8            2553     MOV A , R0 
077D    94FF          2554     SUBB A , # 255 
077F    E9            2555     MOV A , R1 
0780    9400          2556     	SUBB	A, #0
0782    4002          2557     	JC	PCA_INT_LIMITED
                      2558     
0784    78FF          2559     MOV R0 , # 255 
                      2560     
                      2561     PCA_INT_LIMITED: 
                      2562     
                      2563     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2564     ; 
                      2565     ; Skypup 2015.05.25
                      2566     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2567     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2568     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2569     ; 
0786    C3            2570     	CLR	C
0787    E8            2571     MOV A , R0 
0788    94A0          2572     SUBB A , # 160 
078A    5005          2573     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
078C    7800          2574     MOV R0 , # 0 
078E    020793        2575     	JMP	SET_PWM_IN
                      2576     SET_PWM_IN_HIGH: 
0791    7801          2577     MOV R0 , # 1 
                      2578     SET_PWM_IN: 
0793    8874          2579     MOV NPWMIN , R0 
                      2580     
                      2581     
                      2582     
                      2583     
                      2584     	; 
                      2585     	; 判断是否 PWM_IN_HIGH
0795    A874          2586     MOV R0 , NPWMIN 
0797    B80107        2587     CJNE R0 , # 1 , LSSS 
079A    787F          2588     MOV R0 , # 127 
079C    8859          2589     MOV NEW_RCP , R0 
079E    0207A8        2590     	JMP	ENDIF_STATE
                      2591     LSSS: 
                      2592     	; 最低油门
07A1    7800          2593     MOV R0 , # 0 
07A3    8859          2594     MOV NEW_RCP , R0 
                      2595     
07A5    0207A8        2596     	JMP	ENDIF_STATE
                      2597     
                      2598     
                      2599     
                      2600     
                      2601     
                      2602     ;
                      2603     ; 判断 cState 状态
                      2604     ;
                      2605     ; 	mov	Temp1, cState				; 状态
                      2606     ; 	cjne	Temp1, #STATE_FULL, eles_state_full
                      2607     ; if_state_full:
                      2608     ; 	; STATE_FULL 状态
                      2609     ; 	; 以下是 StateFull(); 的代码
                      2610     ; 	;
                      2611     ; 	; 全油门
                      2612     ; 	mov	Temp1, #PWM_FULL
                      2613     ; 	mov	Temp1, #RCP_MIN
                      2614     ; 	mov	New_Rcp, Temp1	
                      2615     ; 	; 
                      2616     ; 	jmp endif_state
                      2617     ; 
                      2618     ; eles_state_full:
                      2619     ; 	mov	Temp1, cState
                      2620     ; 	cjne	Temp1, #STATE_CRUISE, else_state_cruise
                      2621     ; 
                      2622     ; if_state_cruise:
                      2623     ; 	; STATE_FULL 状态
                      2624     ; 	; 以下是 StateCruise(); 的代码
                      2625     ; 	;
                      2626     ; 	; 巡航油门
                      2627     ; 	mov	Temp1, #PWM_CRUISE
                      2628     ; 	mov	Temp1, #RCP_MIN
                      2629     ; 	mov	New_Rcp, Temp1	
                      2630     ; 	; 
                      2631     ; 	jmp endif_state
                      2632     ; 
                      2633     ; else_state_cruise:
                      2634     ; 	; STATE_FULL 状态
                      2635     ; 	; 以下是 StateWait(); 的代码
                      2636     ; 	;
                      2637     ; 	; 最低油门
                      2638     ; 	mov	Temp1, #RCP_MIN
                      2639     ; 	mov	New_Rcp, Temp1	
                      2640     ; 	; 
                      2641     ; 	; 判断是否 PWM_IN_HIGH
                      2642     ; 	mov	Temp1, nPWMIn
                      2643     ; 	cjne	Temp1, #PWM_IN_HIGH, endif_state
                      2644     ; 	mov	Temp1, #STATE_FULL		; 状态切换为 STATE_FULL
                      2645     ; 	mov	cState, Temp1
                      2646     ; 	jmp	endif_state
                      2647     ; 
                      2648     ENDIF_STATE: 
                      2649     
                      2650     ; skypup_03:
                      2651     ; 
                      2652     ; 	clr C
                      2653     ; 	mov A, Temp1
                      2654     ; 	subb A, Prev_Rcp				; 上一个 Rcp > 当前 Rcp ?
                      2655     ; 	jc skypup_04					; No
                      2656     ; 
                      2657     ; 	subb A, #THR_DELTA				; 油门缓启动增量 > Rcp 增加值 ?
                      2658     ; 	jc skypup_04					; No
                      2659     ; 
                      2660     ; 	clr C						; 这一句能否去掉? Skypup 2015.05.25
                      2661     ; 	mov A, Prev_Rcp
                      2662     ; 	add A, #THR_DELTA
                      2663     ; 	mov Temp1, A
                      2664     ; 	jnc skypup_04					; 没有发生进位溢出
                      2665     ; 
                      2666     ; 	mov Temp1, #0FFh	
                      2667     ; 	
                      2668     ; skypup_04:
                      2669     
                      2670     	; 记录 New_Rcp 值
07A8    E559          2671     	MOV A, NEW_RCP
07AA    F573          2672     	MOV PREV_RCP, A
                      2673     
                      2674     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2675     	; RC pulse value accepted
                      2676     	; mov	New_Rcp, Temp1				; Store new pulse length
07AC    D268          2677     SETB FLAGS2 . 0 
07AE    205902        2678     JB FLAGS0 . 1 , ( $+5 ) 
07B1    E1BB          2679     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2680     
07B3    741F          2681     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B5    F4            2682     	CPL	A
07B6    552E          2683     	ANL	A, FLAGS3					; Clear all pwm frequency flags
07B8    4B            2684     ORL A , R3 
07B9    F52E          2685     	MOV	FLAGS3, A
                      2686     
                      2687     PCA_INT_SET_TIMEOUT: 
07BB    752818        2688     MOV RCP_TIMEOUT_CNT , # 24 
07BE    741F          2689     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07C0    552E          2690     	ANL	A, FLAGS3					; Check pwm frequency flags
07C2    7003          2691     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2692     
07C4    75280A        2693     MOV RCP_TIMEOUT_CNT , # 10 
                      2694     
                      2695     PCA_INT_PPM_TIMEOUT_SET: 
07C7    305902        2696     JNB FLAGS0 . 1 , ( $+5 ) 
07CA    E1D5          2697     	AJMP PCA_INT_EXIT				; Yes - exit
                      2698     
07CC    741F          2699     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07CE    552E          2700     	ANL	A, FLAGS3					; Check pwm frequency flags
07D0    6003          2701     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2702     
                      2703     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07D2    53DAFE        2703+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2704     
                      2705     PCA_INT_EXIT: 	; Exit interrupt routine	
07D5    752906        2706     MOV RCP_SKIP_CNT , # 6 
07D8    741F          2707     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07DA    552E          2708     	ANL	A, FLAGS3					; Check pwm frequency flags
07DC    7003          2709     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2710     
07DE    75290A        2711     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2712     
07E1    D0F0          2713     	POP	B			; Restore preserved registers
07E3    D0E0          2714     	POP	ACC			
07E5    D0D0          2715     	POP	PSW
07E7    C2D3          2716     	CLR	PSW.3		; Select register bank 0 for main program routines	
07E9    D2AD          2717     	SETB	ET2			; Enable timer2 interrupts
07EB    43E610        2718     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07EE    32            2719     	RETI
                      2720     
                      2721     
                      2722     
                      2723     
                      2724     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2725     ;
                      2726     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2727     ;
                      2728     ; No assumptions
                      2729     ;
                      2730     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2731     WAIT1MS: 	
07EF    7901          2732     MOV R1 , # 1 
07F1    02080D        2733     	JMP	WAITXMS_O
                      2734     
                      2735     WAIT3MS: 	
07F4    7903          2736     MOV R1 , # 3 
07F6    02080D        2737     	JMP	WAITXMS_O
                      2738     
                      2739     WAIT10MS: 	
07F9    790A          2740     MOV R1 , # 10 
07FB    02080D        2741     	JMP	WAITXMS_O
                      2742     
                      2743     WAIT30MS: 	
07FE    791E          2744     MOV R1 , # 30 
0800    02080D        2745     	JMP	WAITXMS_O
                      2746     
                      2747     WAIT100MS: 	
0803    7964          2748     MOV R1 , # 100 
0805    02080D        2749     	JMP	WAITXMS_O
                      2750     
                      2751     WAIT200MS: 	
0808    79C8          2752     MOV R1 , # 200 
080A    02080D        2753     	JMP	WAITXMS_O
                      2754     
                      2755     WAITXMS_O: 	; Outer loop
080D    7817          2756     MOV R0 , # 23 
                      2757     WAITXMS_M: 	; Middle loop
080F    E4            2758     	CLR	A
0810    D5E0FD        2759      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0813    D8FA          2760     DJNZ R0 , WAITXMS_M 
0815    D9F6          2761     DJNZ R1 , WAITXMS_O 
0817    22            2762     	RET
                      2763     
                      2764     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2765     ;
                      2766     ; Wait 1 second routine
                      2767     ;
                      2768     ; No assumptions
                      2769     ;
                      2770     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2771     WAIT1S: 
0818    7C05          2772     MOV R4 , # 5 
                      2773     WAIT1S_LOOP: 
081A    1108          2774     	CALL WAIT200MS
081C    DCFC          2775     DJNZ R4 , WAIT1S_LOOP 
081E    22            2776     	RET
                      2777     
                      2778     
                      2779     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2780     ;
                      2781     ; Beeper routines (4 different entry points) 
                      2782     ;
                      2783     ; No assumptions
                      2784     ;
                      2785     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2786     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
081F    7A14          2787     MOV R2 , # 20 
0821    7B78          2788     MOV R3 , # 120 
0823    02083B        2789     	JMP	BEEP
                      2790     
                      2791     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0826    7A10          2792     MOV R2 , # 16 
0828    7B8C          2793     MOV R3 , # 140 
082A    02083B        2794     	JMP	BEEP
                      2795     
                      2796     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
082D    7A0D          2797     MOV R2 , # 13 
082F    7BB4          2798     MOV R3 , # 180 
0831    02083B        2799     	JMP	BEEP
                      2800     
                      2801     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0834    7A0B          2802     MOV R2 , # 11 
0836    7BC8          2803     MOV R3 , # 200 
0838    02083B        2804     	JMP	BEEP
                      2805     
                      2806     BEEP: 	; Beep loop start
083B    AC25          2807     MOV R4 , CURRENT_PWM_LIMITED 
083D    752501        2808     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0840    7902          2809     MOV R1 , # 2 
                      2810     BEEP_ONOFF: 
0842    B275          2811     CPL FLAGS3 . 5 
0844    E4            2812     	CLR	A
                      2813     	BPFET_OFF			; BpFET off
0845    C294          2813+1   CLR P1 . 4 
0847    D5E0FD        2814     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2815     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
084A    E525          2815+1   MOV A , CURRENT_PWM_LIMITED 
084C    6002          2815+1   JZ ( $+4 ) 
084E    D295          2815+1   SETB P1 . 5 
0850    D5E0FD        2816     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2817     	BNFET_OFF			; BnFET off again
0853    C295          2817+1   CLR P1 . 5 
0855    D5E0FD        2818     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2819     	BPFET_ON			; BpFET on
0858    D294          2819+1   SETB P1 . 4 
085A    D5E0FD        2820     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2821     	; Turn on nfet
                      2822     	ANFET_ON			; AnFET on
085D    E525          2822+1   MOV A , CURRENT_PWM_LIMITED 
085F    600A          2822+1   JZ ( $+12 ) 
0861    207502        2822+1   JB FLAGS3 . 5 , ( $+5 ) 
0864    D292          2822+1   SETB P1 . 2 
0866    307502        2822+1   JNB FLAGS3 . 5 , ( $+5 ) 
0869    D296          2822+1   SETB P1 . 6 
086B    E56F          2823     	MOV	A, BEEP_STRENGTH
086D    D5E0FD        2824     	DJNZ	ACC, $		
                      2825     	; Turn off nfet
                      2826     	ANFET_OFF			; AnFET off
0870    207502        2826+1   JB FLAGS3 . 5 , ( $+5 ) 
0873    C292          2826+1   CLR P1 . 2 
0875    307502        2826+1   JNB FLAGS3 . 5 , ( $+5 ) 
0878    C296          2826+1   CLR P1 . 6 
087A    7496          2827     	MOV	A, #150		; 25s off
087C    D5E0FD        2828     	DJNZ	ACC, $		
087F    D9C1          2829     DJNZ R1 , BEEP_ONOFF 
                      2830     	; Copy variable
0881    EA            2831     MOV A , R2 
0882    F8            2832     MOV R0 , A 
                      2833     BEEP_OFF: 		; Fets off loop
0883    D5E0FD        2834     	DJNZ	ACC, $
0886    D8FB          2835     DJNZ R0 , BEEP_OFF 
0888    DBB1          2836     DJNZ R3 , BEEP 
                      2837     	BPFET_OFF			; BpFET off
088A    C294          2837+1   CLR P1 . 4 
088C    8C25          2838     MOV CURRENT_PWM_LIMITED , R4 
088E    22            2839     	RET
                      2840     
                      2841     
                      2842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2843     ;
                      2844     ; Division 16bit unsigned by 16bit unsigned
                      2845     ;
                      2846     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2847     ; Result will be in Temp2/Temp1
                      2848     ;
                      2849     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2850     DIV_U16_BY_U16: 	
088F    C3            2851     	CLR	C       
0890    7C00          2852     MOV R4 , # 0 
0892    7D00          2853     MOV R5 , # 0 
0894    75F000        2854     	MOV	B, #0
                      2855     DIV_U16_BY_U16_DIV1: 
0897    05F0          2856     	INC	B      			; Increment counter for each left shift
0899    EA            2857     MOV A , R2 
089A    33            2858     	RLC	A      		
089B    FA            2859     MOV R2 , A 
089C    EB            2860     MOV A , R3 
089D    33            2861     	RLC	A      	  	
089E    FB            2862     MOV R3 , A 
089F    50F6          2863     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2864     DIV_U16_BY_U16_DIV2:         
08A1    EB            2865     MOV A , R3 
08A2    13            2866     	RRC	A      
08A3    FB            2867     MOV R3 , A 
08A4    EA            2868     MOV A , R2 
08A5    13            2869     	RRC	A      
08A6    FA            2870     MOV R2 , A 
08A7    C3            2871     	CLR	C      
08A8    E9            2872     MOV A , R1 
08A9    FF            2873     MOV R7 , A 
08AA    E8            2874     MOV A , R0 
08AB    FE            2875     MOV R6 , A 
08AC    E8            2876     MOV A , R0 
08AD    9A            2877     SUBB A , R2 
08AE    F8            2878     MOV R0 , A 
08AF    E9            2879     MOV A , R1 
08B0    9B            2880     SUBB A , R3 
08B1    F9            2881     MOV R1 , A 
08B2    5004          2882     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
08B4    EF            2883     MOV A , R7 
08B5    F9            2884     MOV R1 , A 
08B6    EE            2885     MOV A , R6 
08B7    F8            2886     MOV R0 , A 
                      2887     DIV_U16_BY_U16_DIV3: 
08B8    B3            2888     	CPL	C      			; Invert carry, so it can be directly copied into result
08B9    EC            2889     MOV A , R4 
08BA    33            2890     	RLC	A      			; Shift carry flag into temporary result
08BB    FC            2891     MOV R4 , A 
08BC    ED            2892     MOV A , R5 
08BD    33            2893     	RLC	A
08BE    FD            2894     MOV R5 , A 
08BF    D5F0DF        2895     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
08C2    ED            2896     MOV A , R5 
08C3    F9            2897     MOV R1 , A 
08C4    EC            2898     MOV A , R4 
08C5    F8            2899     MOV R0 , A 
08C6    22            2900     	RET
                      2901     
                      2902     
                      2903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2904     ;
                      2905     ; Multiplication 16bit signed by 8bit unsigned
                      2906     ;
                      2907     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2908     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2909     ;
                      2910     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2911     MULT_S16_BY_U8_DIV_16: 
08C7    E8            2912     MOV A , R0 
08C8    89F0          2913     MOV B , R1 
08CA    8A20          2914     MOV BIT_ACCESS , R2 
08CC    D2D4          2915     	SETB	PSW.4		; Select register bank 2 for math routines
08CE    F8            2916     MOV R0 , A 
08CF    A9F0          2917     MOV R1 , B 
08D1    7B00          2918     MOV R3 , # 0 
08D3    30F70B        2919     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2920     
08D6    7BFF          2921     MOV R3 , # 0FFH 
08D8    F4            2922     	CPL	A
08D9    2401          2923     	ADD	A, #1
08DB    F8            2924     MOV R0 , A 
08DC    E9            2925     MOV A , R1 
08DD    F4            2926     	CPL	A
08DE    3400          2927     	ADDC	A, #0
08E0    F9            2928     MOV R1 , A 
                      2929     MULT_S16_BY_U8_POSITIVE: 
08E1    E8            2930     MOV A , R0 
08E2    8520F0        2931     	MOV	B, BIT_ACCESS
08E5    A4            2932     	MUL	AB
08E6    ADF0          2933     MOV R5 , B 
08E8    F8            2934     MOV R0 , A 
08E9    E9            2935     MOV A , R1 
08EA    8520F0        2936     	MOV	B, BIT_ACCESS
08ED    A4            2937     	MUL	AB
08EE    AFF0          2938     MOV R7 , B 
08F0    FE            2939     MOV R6 , A 
08F1    ED            2940     MOV A , R5 
08F2    2E            2941     ADD A , R6 
08F3    F9            2942     MOV R1 , A 
08F4    7400          2943     	MOV	A, #0
08F6    3F            2944     ADDC A , R7 
08F7    FA            2945     MOV R2 , A 
08F8    7C04          2946     MOV R4 , # 4 
                      2947     MULT_S16_BY_U8_DIV_LOOP: 
08FA    C3            2948     	CLR	C			; Rotate right 
08FB    EA            2949     MOV A , R2 
08FC    13            2950     	RRC	A
08FD    FA            2951     MOV R2 , A 
08FE    E9            2952     MOV A , R1 
08FF    13            2953     	RRC	A
0900    F9            2954     MOV R1 , A 
0901    E8            2955     MOV A , R0 
0902    13            2956     	RRC	A
0903    F8            2957     MOV R0 , A 
0904    DCF4          2958     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2959     
0906    8BF0          2960     MOV B , R3 
0908    30F70A        2961     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2962     
090B    E8            2963     MOV A , R0 
090C    F4            2964     	CPL	A
090D    2401          2965     	ADD	A, #1
090F    F8            2966     MOV R0 , A 
0910    E9            2967     MOV A , R1 
0911    F4            2968     	CPL	A
0912    3400          2969     	ADDC	A, #0
0914    F9            2970     MOV R1 , A 
                      2971     
                      2972     MULT_S16_BY_U8_EXIT: 
0915    E8            2973     MOV A , R0 
0916    89F0          2974     MOV B , R1 
0918    C2D4          2975     	CLR	PSW.4		; Select normal register bank
091A    F8            2976     MOV R0 , A 
091B    A9F0          2977     MOV R1 , B 
091D    22            2978     	RET
                      2979     
                      2980     
                      2981     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2982     ;
                      2983     ; Calculate governor routines
                      2984     ;
                      2985     ; No assumptions
                      2986     ;
                      2987     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2988     ; The governor task is split into several routines in order to distribute processing time
                      2989     ;
                      2990     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2991     ; First governor routine - calculate governor target
                      2992     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3132     IF MODE == 2	; Multi
                      3133     CALC_GOVERNOR_TARGET: 
091E    7882          3134     MOV R0 , # PGM_GOV_MODE 
0920    B60403        3135     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0923    02097A        3136     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3137     
                      3138     GOVERNOR_TARGET_CALC: 
                      3139     	; Stop governor for stop RC pulse	
0926    C3            3140     	CLR	C
0927    E559          3141     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0929    9401          3142     SUBB A , # 1 
092B    4003          3143     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3144     
092D    020943        3145     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3146     
                      3147     GOVERNOR_DEACTIVATE: 
0930    852224        3148     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0933    E4            3149     	CLR	A
0934    F540          3150     	MOV	GOV_TARGET_L, A			; Set target to zero
0936    F541          3151     	MOV	GOV_TARGET_H, A
0938    F542          3152     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
093A    F543          3153     	MOV	GOV_INTEGRAL_H, A
093C    F544          3154     	MOV	GOV_INTEGRAL_X, A
093E    F549          3155     	MOV	GOV_ACTIVE, A
0940    02097A        3156     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3157     
                      3158     GOVERNOR_ACTIVATE: 
0943    7882          3159     MOV R0 , # PGM_GOV_MODE 
0945    E6            3160     MOV A , @ R0 
0946    FC            3161     MOV R4 , A 
0947    754901        3162     	MOV	GOV_ACTIVE, #1
094A    E522          3163     	MOV	A, REQUESTED_PWM			; Load requested pwm
094C    F523          3164     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3165     	; Calculate comm period target 2*(51000/Requested_Pwm)
094E    7838          3166     MOV R0 , # 38H 
0950    79C7          3167     MOV R1 , # 0C7H 
0952    AA3C          3168     MOV R2 , COMM_PERIOD4X_L 
0954    AB3D          3169     MOV R3 , COMM_PERIOD4X_H 
                      3170     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
0956    C3            3171     	CLR	C
0957    EB            3172     MOV A , R3 
0958    13            3173     	RRC	A
0959    FB            3174     MOV R3 , A 
095A    EA            3175     MOV A , R2 
095B    13            3176     	RRC	A
095C    FA            3177     MOV R2 , A 
                      3178     	; Check range
095D    EC            3179     MOV A , R4 
095E    14            3180     	DEC	A
095F    6013          3181     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3182     GOVERNOR_ACTIVATE_100K: 
0961    C3            3183     	CLR	C
0962    EB            3184     MOV A , R3 
0963    13            3185     	RRC	A
0964    FB            3186     MOV R3 , A 
0965    EA            3187     MOV A , R2 
0966    13            3188     	RRC	A
0967    FA            3189     MOV R2 , A 
0968    EC            3190     MOV A , R4 
0969    14            3191     	DEC	A
096A    14            3192     	DEC	A
096B    6007          3193     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3194     GOVERNOR_ACTIVATE_50K: 
096D    C3            3195     	CLR	C
096E    EB            3196     MOV A , R3 
096F    13            3197     	RRC	A
0970    FB            3198     MOV R3 , A 
0971    EA            3199     MOV A , R2 
0972    13            3200     	RRC	A
0973    FA            3201     MOV R2 , A 
                      3202     GOVERNOR_ACTIVATE_RANGE_SET: 
0974    118F          3203     	CALL	DIV_U16_BY_U16
                      3204     	; Store governor target
0976    8840          3205     MOV GOV_TARGET_L , R0 
0978    8941          3206     MOV GOV_TARGET_H , R1 
                      3207     CALC_GOVERNOR_TARGET_EXIT: 
097A    22            3208     	RET						
                      3209     ENDIF
                      3210     
                      3211     
                      3212     ; Second governor routine - calculate governor proportional error
                      3213     CALC_GOVERNOR_PROP_ERROR: 
                      3214     	; Exit if governor is inactive
097B    E549          3215     	MOV	A, GOV_ACTIVE
097D    6034          3216     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3217     
                      3218     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3236     IF MODE == 2	; Multi
                      3237     	; Calculate error
097F    C3            3238     	CLR	C
0980    E540          3239     	MOV	A, GOV_TARGET_L
0982    9523          3240     	SUBB	A, GOVERNOR_REQ_PWM
0984    F8            3241     MOV R0 , A 
0985    E541          3242     	MOV	A, GOV_TARGET_H
0987    9400          3243     	SUBB	A, #0
0989    F9            3244     MOV R1 , A 
                      3245     ENDIF
                      3246     	; Check error and limit
098A    500C          3247     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3248     
098C    C3            3249     	CLR	C
098D    E8            3250     MOV A , R0 
098E    9480          3251     	SUBB	A, #80H					; Is error too negative?
0990    E9            3252     MOV A , R1 
0991    94FF          3253     	SUBB	A, #0FFH
0993    4016          3254     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0995    0209AF        3255     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3256     
                      3257     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0998    C3            3258     	CLR	C
0999    E8            3259     MOV A , R0 
099A    947F          3260     	SUBB	A, #7FH					; Is error too positive?
099C    E9            3261     MOV A , R1 
099D    9400          3262     	SUBB	A, #00H
099F    5003          3263     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
09A1    0209AF        3264     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3265     
                      3266     GOVERNOR_LIMIT_PROP_ERROR_POS: 
09A4    787F          3267     MOV R0 , # 7FH 
09A6    7900          3268     MOV R1 , # 00H 
09A8    0209AF        3269     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3270     
                      3271     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
09AB    7880          3272     MOV R0 , # 80H 
09AD    79FF          3273     MOV R1 , # 0FFH 
                      3274     
                      3275     GOVERNOR_STORE_PROP_ERROR: 
                      3276     	; Store proportional
09AF    8845          3277     MOV GOV_PROPORTIONAL_L , R0 
09B1    8946          3278     MOV GOV_PROPORTIONAL_H , R1 
                      3279     CALC_GOVERNOR_PROP_ERROR_EXIT: 
09B3    22            3280     	RET						
                      3281     
                      3282     
                      3283     ; Third governor routine - calculate governor integral error
                      3284     CALC_GOVERNOR_INT_ERROR: 
                      3285     	; Exit if governor is inactive
09B4    E549          3286     	MOV	A, GOV_ACTIVE
09B6    6058          3287     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3288     
                      3289     	; Add proportional to integral
09B8    E545          3290     	MOV	A, GOV_PROPORTIONAL_L
09BA    2542          3291     	ADD	A, GOV_INTEGRAL_L
09BC    F8            3292     MOV R0 , A 
09BD    E546          3293     	MOV	A, GOV_PROPORTIONAL_H
09BF    3543          3294     	ADDC	A, GOV_INTEGRAL_H
09C1    F9            3295     MOV R1 , A 
09C2    854620        3296     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
09C5    E4            3297     	CLR	A
09C6    300701        3298     	JNB	BIT_ACCESS.7, ($+4)			
09C9    F4            3299     	CPL	A
09CA    3544          3300     	ADDC	A, GOV_INTEGRAL_X
09CC    FA            3301     MOV R2 , A 
                      3302     	; Check integral and limit
09CD    30E709        3303     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3304     
09D0    C3            3305     	CLR	C
09D1    EA            3306     MOV A , R2 
09D2    94F0          3307     	SUBB	A, #0F0H					; Is error too negative?
09D4    4015          3308     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09D6    0209F1        3309     	JMP	GOVERNOR_CHECK_PWM
                      3310     
                      3311     GOVERNOR_CHECK_INT_LIMIT_POS: 
09D9    C3            3312     	CLR	C
09DA    EA            3313     MOV A , R2 
09DB    940F          3314     	SUBB	A, #0FH					; Is error too positive?
09DD    5003          3315     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09DF    0209F1        3316     	JMP	GOVERNOR_CHECK_PWM
                      3317     
                      3318     GOVERNOR_LIMIT_INT_ERROR_POS: 
09E2    78FF          3319     MOV R0 , # 0FFH 
09E4    79FF          3320     MOV R1 , # 0FFH 
09E6    7A0F          3321     MOV R2 , # 0FH 
09E8    0209F1        3322     	JMP	GOVERNOR_CHECK_PWM
                      3323     
                      3324     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09EB    7800          3325     MOV R0 , # 00H 
09ED    7900          3326     MOV R1 , # 00H 
09EF    7AF0          3327     MOV R2 , # 0F0H 
                      3328     
                      3329     GOVERNOR_CHECK_PWM: 
                      3330     	; Check current pwm
09F1    C3            3331     	CLR	C
09F2    E524          3332     	MOV	A, CURRENT_PWM
09F4    955E          3333     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09F6    5006          3334     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3335     
09F8    E524          3336     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09FA    6009          3337     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3338     
09FC    410A          3339     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3340     
                      3341     GOVERNOR_INT_MAX_PWM: 
09FE    E546          3342     	MOV	A, GOV_PROPORTIONAL_H
0A00    20E70D        3343     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3344     
0A03    410A          3345     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3346     
                      3347     GOVERNOR_INT_MIN_PWM: 
0A05    E546          3348     	MOV	A, GOV_PROPORTIONAL_H
0A07    30E706        3349     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3350     
                      3351     GOVERNOR_STORE_INT_ERROR: 
                      3352     	; Store integral
0A0A    8842          3353     MOV GOV_INTEGRAL_L , R0 
0A0C    8943          3354     MOV GOV_INTEGRAL_H , R1 
0A0E    8A44          3355     MOV GOV_INTEGRAL_X , R2 
                      3356     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A10    22            3357     	RET						
                      3358     
                      3359     
                      3360     ; Fourth governor routine - calculate governor proportional correction
                      3361     CALC_GOVERNOR_PROP_CORRECTION: 
                      3362     	; Exit if governor is inactive
0A11    E549          3363     	MOV	A, GOV_ACTIVE
0A13    7003          3364     	JNZ	CALC_GOVERNOR_PROP_CORR
0A15    020A74        3365     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3366     
                      3367     CALC_GOVERNOR_PROP_CORR: 
                      3368     	; Load proportional gain
0A18    789F          3369     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A1A    E6            3370     MOV A , @ R0 
0A1B    FA            3371     MOV R2 , A 
                      3372     	; Load proportional
0A1C    C3            3373     	CLR	C
0A1D    E545          3374     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A1F    33            3375     	RLC	A
0A20    F8            3376     MOV R0 , A 
0A21    E546          3377     	MOV	A, GOV_PROPORTIONAL_H
0A23    33            3378     	RLC	A
0A24    F9            3379     MOV R1 , A 
                      3380     	; Apply gain
0A25    11C7          3381     	CALL	MULT_S16_BY_U8_DIV_16
                      3382     	; Check error and limit (to low byte)
0A27    E9            3383     MOV A , R1 
0A28    30E70B        3384     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3385     
0A2B    C3            3386     	CLR	C
0A2C    E8            3387     MOV A , R0 
0A2D    9480          3388     	SUBB	A, #80H					; Is error too negative?
0A2F    E9            3389     MOV A , R1 
0A30    94FF          3390     	SUBB	A, #0FFH
0A32    4013          3391     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A34    414B          3392     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3393     
                      3394     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A36    C3            3395     	CLR	C
0A37    E8            3396     MOV A , R0 
0A38    947F          3397     	SUBB	A, #7FH					; Is error too positive?
0A3A    E9            3398     MOV A , R1 
0A3B    9400          3399     	SUBB	A, #00H
0A3D    5002          3400     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A3F    414B          3401     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3402     
                      3403     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A41    787F          3404     MOV R0 , # 7FH 
0A43    7900          3405     MOV R1 , # 00H 
0A45    414B          3406     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3407     
                      3408     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A47    7880          3409     MOV R0 , # 80H 
0A49    79FF          3410     MOV R1 , # 0FFH 
                      3411     
                      3412     GOVERNOR_APPLY_PROP_CORR: 
                      3413     	; Test proportional sign
0A4B    E8            3414     MOV A , R0 
0A4C    20E715        3415     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3416     
                      3417     	; Subtract positive proportional
0A4F    C3            3418     	CLR	C
0A50    E523          3419     	MOV	A, GOVERNOR_REQ_PWM
0A52    98            3420     SUBB A , R0 
0A53    F8            3421     MOV R0 , A 
                      3422     	; Check result
0A54    4009          3423     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3424     
0A56    C3            3425     	CLR	C
0A57    E8            3426     MOV A , R0 
0A58    9401          3427     	SUBB	A, #1
0A5A    4003          3428     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A5C    020A72        3429     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3430     
                      3431     GOVERNOR_CORR_PROP_MIN_PWM: 
0A5F    7801          3432     MOV R0 , # 1 
0A61    020A72        3433     	JMP	GOVERNOR_STORE_PROP_CORR
                      3434     
                      3435     GOVERNOR_CORR_NEG_PROP: 
                      3436     	; Add negative proportional
0A64    E8            3437     MOV A , R0 
0A65    F4            3438     	CPL	A
0A66    2401          3439     	ADD	A, #1
0A68    2523          3440     	ADD	A, GOVERNOR_REQ_PWM
0A6A    F8            3441     MOV R0 , A 
                      3442     	; Check result
0A6B    4003          3443     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A6D    020A72        3444     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3445     
                      3446     GOVERNOR_CORR_PROP_MAX_PWM: 
0A70    78FF          3447     MOV R0 , # 255 
                      3448     GOVERNOR_STORE_PROP_CORR: 
                      3449     	; Store proportional pwm
0A72    8847          3450     MOV GOV_PROP_PWM , R0 
                      3451     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A74    22            3452     	RET
                      3453     
                      3454     
                      3455     ; Fifth governor routine - calculate governor integral correction
                      3456     CALC_GOVERNOR_INT_CORRECTION: 
                      3457     	; Exit if governor is inactive
0A75    E549          3458     	MOV	A, GOV_ACTIVE
0A77    7003          3459     	JNZ	CALC_GOVERNOR_INT_CORR
0A79    020AD6        3460     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3461     
                      3462     CALC_GOVERNOR_INT_CORR: 
                      3463     	; Load integral gain
0A7C    78A0          3464     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A7E    E6            3465     MOV A , @ R0 
0A7F    FA            3466     MOV R2 , A 
                      3467     	; Load integral
0A80    A843          3468     MOV R0 , GOV_INTEGRAL_H 
0A82    A944          3469     MOV R1 , GOV_INTEGRAL_X 
                      3470     	; Apply gain
0A84    11C7          3471     	CALL	MULT_S16_BY_U8_DIV_16
                      3472     	; Check integral and limit
0A86    E9            3473     MOV A , R1 
0A87    30E70C        3474     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3475     
0A8A    C3            3476     	CLR	C
0A8B    E8            3477     MOV A , R0 
0A8C    9401          3478     	SUBB	A, #01H					; Is integral too negative?
0A8E    E9            3479     MOV A , R1 
0A8F    94FF          3480     	SUBB	A, #0FFH
0A91    4016          3481     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A93    020AAD        3482     	JMP	GOVERNOR_APPLY_INT_CORR
                      3483     
                      3484     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A96    C3            3485     	CLR	C
0A97    E8            3486     MOV A , R0 
0A98    94FF          3487     	SUBB	A, #0FFH					; Is integral too positive?
0A9A    E9            3488     MOV A , R1 
0A9B    9400          3489     	SUBB	A, #00H
0A9D    5003          3490     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A9F    020AAD        3491     	JMP	GOVERNOR_APPLY_INT_CORR
                      3492     
                      3493     GOVERNOR_LIMIT_INT_CORR_POS: 
0AA2    78FF          3494     MOV R0 , # 0FFH 
0AA4    7900          3495     MOV R1 , # 00H 
0AA6    020AAD        3496     	JMP	GOVERNOR_APPLY_INT_CORR
                      3497     
                      3498     GOVERNOR_LIMIT_INT_CORR_NEG: 
0AA9    7801          3499     MOV R0 , # 01H 
0AAB    79FF          3500     MOV R1 , # 0FFH 
                      3501     
                      3502     GOVERNOR_APPLY_INT_CORR: 
                      3503     	; Test integral sign
0AAD    E9            3504     MOV A , R1 
0AAE    20E715        3505     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3506     
                      3507     	; Subtract positive integral
0AB1    C3            3508     	CLR	C
0AB2    E547          3509     	MOV	A, GOV_PROP_PWM
0AB4    98            3510     SUBB A , R0 
0AB5    F8            3511     MOV R0 , A 
                      3512     	; Check result
0AB6    4009          3513     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3514     
0AB8    C3            3515     	CLR	C
0AB9    E8            3516     MOV A , R0 
0ABA    9401          3517     	SUBB	A, #1
0ABC    4003          3518     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0ABE    020AD4        3519     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3520     
                      3521     GOVERNOR_CORR_INT_MIN_PWM: 
0AC1    7800          3522     MOV R0 , # 0 
0AC3    020AD4        3523     	JMP	GOVERNOR_STORE_INT_CORR
                      3524     
                      3525     GOVERNOR_CORR_NEG_INT: 
                      3526     	; Add negative integral
0AC6    E8            3527     MOV A , R0 
0AC7    F4            3528     	CPL	A
0AC8    2401          3529     	ADD	A, #1
0ACA    2547          3530     	ADD	A, GOV_PROP_PWM
0ACC    F8            3531     MOV R0 , A 
                      3532     	; Check result
0ACD    4003          3533     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0ACF    020AD4        3534     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3535     
                      3536     GOVERNOR_CORR_INT_MAX_PWM: 
0AD2    78FF          3537     MOV R0 , # 255 
                      3538     GOVERNOR_STORE_INT_CORR: 
                      3539     	; Store current pwm
0AD4    8824          3540     MOV CURRENT_PWM , R0 
                      3541     CALC_GOVERNOR_INT_CORR_EXIT: 
0AD6    22            3542     	RET
                      3543     
                      3544     
                      3545     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3546     ;
                      3547     ; Measure lipo cells
                      3548     ;
                      3549     ; No assumptions
                      3550     ;
                      3551     ; Measure voltage and calculate lipo cells
                      3552     ;
                      3553     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3554     MEASURE_LIPO_CELLS: 
                      3555     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3559     MEASURE_LIPO_START: 
                      3560     	; Load programmed low voltage limit
0AD7    7883          3561     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AD9    E6            3562     MOV A , @ R0 
0ADA    F520          3563     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3564     	; Set commutation to BpFET on
0ADC    120FF5        3565     	CALL	COMM5COMM6			
                      3566     	; Start adc
                      3567     	START_ADC 
0ADF    75E890        3567+1   MOV ADC0CN , # 90H  ; ADC START
                      3568     	; Wait for ADC reference to settle, and then start again
0AE2    1207EF        3569     	CALL	WAIT1MS
                      3570     	START_ADC
0AE5    75E890        3570+1   MOV ADC0CN , # 90H  ; ADC START
                      3571     	; Wait for ADC conversion to complete
                      3572     MEASURE_LIPO_WAIT_ADC: 
                      3573     	GET_ADC_STATUS 
0AE8    E5E8          3573+1   MOV A , ADC0CN 
0AEA    20ECFB        3574     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3575     	; Read ADC result
                      3576     	READ_ADC_RESULT
0AED    A8BD          3576+1   MOV R0 , ADC0L 
0AEF    A9BE          3576+1   MOV R1 , ADC0H 
                      3577     	; Stop ADC
                      3578     	STOP_ADC
                      3579     	; Switch power off
0AF1    12109B        3580     	CALL	SWITCH_POWER_OFF		
                      3581     	; Set limit step
0AF4    756A55        3582     MOV LIPO_ADC_LIMIT_L , # 85 
0AF7    756B00        3583     MOV LIPO_ADC_LIMIT_H , # 0 
0AFA    C3            3584     	CLR	C
0AFB    7400          3585     MOV A , # 0 
0AFD    13            3586     	RRC	A
0AFE    FD            3587     MOV R5 , A 
0AFF    7455          3588     MOV A , # 85 
0B01    13            3589     	RRC	A
0B02    FC            3590     MOV R4 , A 
0B03    7455          3591     MOV A , # 85 
0B05    2C            3592     ADD A , R4 
0B06    FC            3593     MOV R4 , A 
0B07    7400          3594     MOV A , # 0 
0B09    3D            3595     ADDC A , R5 
0B0A    FD            3596     MOV R5 , A 
0B0B    EC            3597     MOV A , R4 
0B0C    FA            3598     MOV R2 , A 
0B0D    ED            3599     MOV A , R5 
0B0E    FB            3600     MOV R3 , A 
                      3601     MEASURE_LIPO_CELL_LOOP: 
                      3602     	; Check voltage against xS lower limit
0B0F    C3            3603     	CLR	C
0B10    E8            3604     MOV A , R0 
0B11    9A            3605     SUBB A , R2 
0B12    E9            3606     MOV A , R1 
0B13    9B            3607     SUBB A , R3 
0B14    4014          3608     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3609     
                      3610     	; Set xS voltage limit
0B16    E56A          3611     	MOV	A, LIPO_ADC_LIMIT_L		
0B18    2455          3612     ADD A , # 85 
0B1A    F56A          3613     	MOV	LIPO_ADC_LIMIT_L, A
0B1C    E56B          3614     	MOV	A, LIPO_ADC_LIMIT_H		
0B1E    3400          3615     ADDC A , # 0 
0B20    F56B          3616     	MOV	LIPO_ADC_LIMIT_H, A
                      3617     	; Set (x+1)S lower limit
0B22    EA            3618     MOV A , R2 
0B23    2C            3619     ADD A , R4 
0B24    FA            3620     MOV R2 , A 
0B25    EB            3621     MOV A , R3 
0B26    3D            3622     ADDC A , R5 
0B27    FB            3623     MOV R3 , A 
0B28    80E5          3624     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3625     
                      3626     MEASURE_LIPO_ADJUST: 
0B2A    AE6A          3627     MOV R6 , LIPO_ADC_LIMIT_L 
0B2C    AF6B          3628     MOV R7 , LIPO_ADC_LIMIT_H 
                      3629     	; Calculate 3.125%
0B2E    C3            3630     	CLR	C
0B2F    E56B          3631     	MOV	A, LIPO_ADC_LIMIT_H
0B31    13            3632     	RRC	A
0B32    F9            3633     MOV R1 , A 
0B33    E56A          3634     	MOV	A, LIPO_ADC_LIMIT_L	
0B35    13            3635     	RRC	A
0B36    F8            3636     MOV R0 , A 
0B37    C3            3637     	CLR	C
0B38    E9            3638     MOV A , R1 
0B39    13            3639     	RRC	A
0B3A    F9            3640     MOV R1 , A 
0B3B    E8            3641     MOV A , R0 
0B3C    13            3642     	RRC	A
0B3D    F8            3643     MOV R0 , A 
0B3E    E56A          3644     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B40    28            3645     ADD A , R0 
0B41    F568          3646     	MOV	LIPO_ADC_REFERENCE_L, A
0B43    E56B          3647     	MOV	A, LIPO_ADC_LIMIT_H
0B45    39            3648     ADDC A , R1 
0B46    F569          3649     	MOV	LIPO_ADC_REFERENCE_H, A
                      3650     	; Divide three times to get to 3.125%
0B48    7A03          3651     MOV R2 , # 3 
                      3652     MEASURE_LIPO_DIVIDE_LOOP: 
0B4A    C3            3653     	CLR	C
0B4B    E9            3654     MOV A , R1 
0B4C    13            3655     	RRC	A
0B4D    F9            3656     MOV R1 , A 
0B4E    E8            3657     MOV A , R0 
0B4F    13            3658     	RRC	A
0B50    F8            3659     MOV R0 , A 
0B51    DAF7          3660     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3661     
                      3662     	; Add the programmed number of 0.1V (or 3.125% increments)
0B53    AA20          3663     MOV R2 , BIT_ACCESS 
0B55    1A            3664     DEC R2 
0B56    7009          3665     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3666     
0B58    756A00        3667     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B5B    756B00        3668     	MOV	LIPO_ADC_LIMIT_H, #0
0B5E    020B71        3669     	JMP	MEASURE_LIPO_EXIT	
                      3670     
                      3671     MEASURE_LIPO_LIMIT_ON: 
0B61    1A            3672     DEC R2 
0B62    EA            3673     MOV A , R2 
0B63    6008          3674     	JZ	MEASURE_LIPO_UPDATE
                      3675     
                      3676     MEASURE_LIPO_ADD_LOOP: 
0B65    EE            3677     MOV A , R6 
0B66    28            3678     ADD A , R0 
0B67    FE            3679     MOV R6 , A 
0B68    EF            3680     MOV A , R7 
0B69    39            3681     ADDC A , R1 
0B6A    FF            3682     MOV R7 , A 
0B6B    DAF8          3683     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3684     
                      3685     MEASURE_LIPO_UPDATE: 
                      3686     	; Set ADC limit
0B6D    8E6A          3687     MOV LIPO_ADC_LIMIT_L , R6 
0B6F    8F6B          3688     MOV LIPO_ADC_LIMIT_H , R7 
                      3689     MEASURE_LIPO_EXIT: 
0B71    22            3690     	RET
                      3691     
                      3692     
                      3693     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3694     ;
                      3695     ; Start ADC conversion
                      3696     ;
                      3697     ; No assumptions
                      3698     ;
                      3699     ; Start conversion used for measuring power supply voltage
                      3700     ;
                      3701     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3702     START_ADC_CONVERSION: 
                      3703     	; Start adc
                      3704     	START_ADC 
0B72    75E890        3704+1   MOV ADC0CN , # 90H  ; ADC START
0B75    22            3705     	RET
                      3706     
                      3707     
                      3708     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3709     ;
                      3710     ; Check temperature, power supply voltage and limit power
                      3711     ;
                      3712     ; No assumptions
                      3713     ;
                      3714     ; Used to limit main motor power in order to maintain the required voltage
                      3715     ;
                      3716     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3717     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3718     	; Load programmed low voltage limit
0B76    7883          3719     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B78    E6            3720     MOV A , @ R0 
0B79    FF            3721     MOV R7 , A 
                      3722     	; Wait for ADC conversion to complete
                      3723     	GET_ADC_STATUS 
0B7A    E5E8          3723+1   MOV A , ADC0CN 
0B7C    20ECF7        3724     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3725     	; Read ADC result
                      3726     	READ_ADC_RESULT
0B7F    A8BD          3726+1   MOV R0 , ADC0L 
0B81    A9BE          3726+1   MOV R1 , ADC0H 
                      3727     	; Stop ADC
                      3728     	STOP_ADC
                      3729     
0B83    056C          3730     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B85    C3            3731     	CLR	C
0B86    E56C          3732     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B88    9408          3733     SUBB A , # 8 
0B8A    404B          3734     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3735     
0B8C    756C00        3736     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B8F    E9            3737     MOV A , R1 
0B90    7007          3738     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3739     
0B92    E56D          3740     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B94    601B          3741     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B96    020BA5        3742     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3743     
                      3744     TEMP_AVERAGE_INC_DEC: 
0B99    C3            3745     	CLR	C
0B9A    E8            3746     MOV A , R0 
0B9B    956D          3747     	SUBB	A, CURRENT_AVERAGE_TEMP
0B9D    6010          3748     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3749     
0B9F    E56D          3750     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0BA1    5006          3751     	JNC	TEMP_AVERAGE_INC				
                      3752     
0BA3    600C          3753     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3754     TEMP_AVERAGE_DEC: 
0BA5    14            3755     	DEC	A						; Decrement average
0BA6    020BB1        3756     	JMP	TEMP_AVERAGE_UPDATED
                      3757     
                      3758     TEMP_AVERAGE_INC: 
0BA9    04            3759     	INC	A						; Increment average
0BAA    60F9          3760     	JZ	TEMP_AVERAGE_DEC
0BAC    020BB1        3761     	JMP	TEMP_AVERAGE_UPDATED
                      3762     
                      3763     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0BAF    E56D          3764     	MOV	A, CURRENT_AVERAGE_TEMP
                      3765     TEMP_AVERAGE_UPDATED: 
0BB1    F56D          3766     	MOV	CURRENT_AVERAGE_TEMP, A
0BB3    C3            3767     	CLR	C
0BB4    9472          3768     SUBB A , # 114 
0BB6    401B          3769     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3770     
0BB8    755EC0        3771     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3772     
0BBB    C3            3773     	CLR	C
0BBC    9404          3774     SUBB A , # 4 
0BBE    4013          3775     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3776     
0BC0    755E80        3777     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3778     
0BC3    C3            3779     	CLR	C
0BC4    9404          3780     SUBB A , # 4 
0BC6    400B          3781     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3782     
0BC8    755E40        3783     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3784     
0BCB    C3            3785     	CLR	C
0BCC    9404          3786     SUBB A , # 4 
0BCE    4003          3787     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3788     
0BD0    755E00        3789     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3790     
                      3791     TEMP_CHECK_EXIT: 
                      3792     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BD3    75BB09        3792+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BD6    22            3793     	RET
                      3794     
                      3795     CHECK_VOLTAGE_START: 
                      3796     IF MODE == 0 OR MODE == 2	; Main or multi
                      3797     	; Check if low voltage limiting is enabled
0BD7    EF            3798     MOV A , R7 
0BD8    C3            3799     	CLR	C
0BD9    9401          3800     	SUBB	A, #1					; Is low voltage limit disabled?
0BDB    601B          3801     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3802     
                      3803     	; Check if ADC is saturated
0BDD    C3            3804     	CLR	C
0BDE    E8            3805     MOV A , R0 
0BDF    94FF          3806     	SUBB	A, #0FFH
0BE1    E9            3807     MOV A , R1 
0BE2    9403          3808     	SUBB	A, #03H
0BE4    5012          3809     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3810     
                      3811     	; Check voltage against limit
0BE6    C3            3812     	CLR	C
0BE7    E8            3813     MOV A , R0 
0BE8    956A          3814     	SUBB	A, LIPO_ADC_LIMIT_L
0BEA    E9            3815     MOV A , R1 
0BEB    956B          3816     	SUBB	A, LIPO_ADC_LIMIT_H
0BED    5009          3817     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3818     
                      3819     	; Decrease pwm limit
0BEF    E55E          3820     	MOV  A, PWM_LIMIT
0BF1    600C          3821     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3822     
0BF3    155E          3823     	DEC	PWM_LIMIT					; Decrement limit
0BF5    020BFF        3824     	JMP	CHECK_VOLTAGE_LIM
                      3825     
                      3826     CHECK_VOLTAGE_GOOD: 
                      3827     	; Increase pwm limit
0BF8    E55E          3828     	MOV  A, PWM_LIMIT
0BFA    F4            3829     	CPL	A			
0BFB    6002          3830     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3831     
0BFD    055E          3832     	INC	PWM_LIMIT					; Increment limit
                      3833     
                      3834     CHECK_VOLTAGE_LIM: 
0BFF    A85E          3835     MOV R0 , PWM_LIMIT 
0C01    C3            3836     	CLR	C
0C02    E524          3837     	MOV	A, CURRENT_PWM
0C04    98            3838     SUBB A , R0 
0C05    5002          3839     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3840     
0C07    A824          3841     MOV R0 , CURRENT_PWM 
                      3842     
                      3843     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3844     	; Slow spoolup
0C09    C3            3845     	CLR	C
0C0A    E8            3846     MOV A , R0 
0C0B    955F          3847     	SUBB	A, PWM_LIMIT_SPOOLUP
0C0D    400A          3848     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3849     
0C0F    A85F          3850     MOV R0 , PWM_LIMIT_SPOOLUP 
0C11    E55F          3851     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C13    F4            3852     	CPL	A
0C14    6003          3853     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3854      
0C16    855F5E        3855     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3856     
                      3857     CHECK_VOLTAGE_EXIT: 
0C19    8825          3858     MOV CURRENT_PWM_LIMITED , R0 
                      3859     ENDIF
                      3860     	; Set adc mux for next conversion
0C1B    C3            3861     	CLR	C
0C1C    E56C          3862     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C1E    B40703        3863     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3864     
                      3865     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C21    75BB10        3865+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3866     
                      3867     CHECK_VOLTAGE_RET: 
0C24    22            3868     	RET
                      3869     
                      3870     
                      3871     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3872     ;
                      3873     ; Set startup PWM routine
                      3874     ;
                      3875     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3876     ;
                      3877     ; Used for pwm control during startup
                      3878     ;
                      3879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3880     SET_STARTUP_PWM: 	
                      3881     	; Set pwm values according to startup phase flags
0C25    306102        3882     JNB FLAGS1 . 1 , ( $+5 ) 
0C28    7832          3883     MOV R0 , # 50 
0C2A    306202        3884     JNB FLAGS1 . 2 , ( $+5 ) 
0C2D    7878          3885     MOV R0 , # 120 
                      3886     
                      3887     	; Update pwm variables if any startup phase flag is set
0C2F    E52C          3888     	MOV	A, FLAGS1
0C31    5406          3889     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C33    601F          3890     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3891     
                      3892     	; Adjust startup power
0C35    E8            3893     MOV A , R0 
0C36    79A2          3894     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C38    87F0          3895     MOV B , @ R1 
0C3A    A4            3896     	MUL	AB
0C3B    C5F0          3897     	XCH	A, B
0C3D    A2F7          3898     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C3F    33            3899     	RLC	A
0C40    F8            3900     MOV R0 , A 
0C41    C3            3901     	CLR	C
0C42    E8            3902     MOV A , R0 
0C43    955E          3903     	SUBB	A, PWM_LIMIT	
0C45    4002          3904     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3905     
0C47    A85E          3906     MOV R0 , PWM_LIMIT 
                      3907     
                      3908     STARTUP_PWM_SET_PWM: 
                      3909     	; Set pwm variables
0C49    8822          3910     MOV REQUESTED_PWM , R0 
0C4B    8824          3911     MOV CURRENT_PWM , R0 
0C4D    8825          3912     MOV CURRENT_PWM_LIMITED , R0 
0C4F    306102        3913     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3914     
0C52    8860          3915     MOV PWM_SPOOLUP_BEG , R0 
                      3916     
                      3917     STARTUP_PWM_EXIT: 
0C54    22            3918     	RET
                      3919     
                      3920     
                      3921     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3922     ;
                      3923     ; Initialize all timings routine
                      3924     ;
                      3925     ; No assumptions
                      3926     ;
                      3927     ; Part of initialization before motor start
                      3928     ;
                      3929     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3930     INITIALIZE_ALL_TIMINGS:  
                      3931     	; Load programmed startup rpm
0C55    788F          3932     MOV R0 , # PGM_STARTUP_RPM 
0C57    E6            3933     MOV A , @ R0 
0C58    FF            3934     MOV R7 , A 
                      3935     	; Check startup rpm setting and set step accordingly
0C59    C3            3936     	CLR	C
0C5A    EF            3937     MOV A , R7 
0C5B    9405          3938     	SUBB	A, #5
0C5D    5018          3939     	JNC	STEPPER_STEP_HIGH
0C5F    C3            3940     	CLR	C
0C60    EF            3941     MOV A , R7 
0C61    9404          3942     	SUBB	A, #4
0C63    5020          3943     	JNC	STEPPER_STEP_MED_HIGH
0C65    C3            3944     	CLR	C
0C66    EF            3945     MOV A , R7 
0C67    9403          3946     	SUBB	A, #3
0C69    5028          3947     	JNC	STEPPER_STEP_MED
0C6B    C3            3948     	CLR	C
0C6C    EF            3949     MOV A , R7 
0C6D    9402          3950     	SUBB	A, #2
0C6F    5030          3951     	JNC	STEPPER_STEP_MED_LOW
0C71    C3            3952     	CLR	C
0C72    EF            3953     MOV A , R7 
0C73    9401          3954     	SUBB	A, #1
0C75    5038          3955     	JNC	STEPPER_STEP_LOW
                      3956     
                      3957     STEPPER_STEP_HIGH: 
0C77    7533A0        3958     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C7A    75340F        3959     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C7D    75353C        3960     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C80    753605        3961     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C83    81BB          3962     	AJMP	STEPPER_STEP_SET
                      3963     STEPPER_STEP_MED_HIGH: 
0C85    7533C0        3964     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C88    753412        3965     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C8B    753540        3966     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C8E    753606        3967     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C91    81BB          3968     	AJMP	STEPPER_STEP_SET
                      3969     STEPPER_STEP_MED: 
0C93    753370        3970     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C96    753417        3971     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C99    7535D0        3972     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C9C    753607        3973     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C9F    81BB          3974     	AJMP	STEPPER_STEP_SET
                      3975     STEPPER_STEP_MED_LOW: 
0CA1    75334C        3976     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0CA4    75341D        3977     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0CA7    7535C4        3978     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0CAA    753609        3979     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0CAD    81BB          3980     	AJMP	STEPPER_STEP_SET
                      3981     STEPPER_STEP_LOW: 
0CAF    753328        3982     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0CB2    753423        3983     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0CB5    7535B8        3984     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0CB8    75360B        3985     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3986     
                      3987     STEPPER_STEP_SET: 
0CBB    853350        3988     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0CBE    853451        3989     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0CC1    753C00        3990     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0CC4    753D08        3991     	MOV	COMM_PERIOD4X_H, #08H
0CC7    22            3992     	RET
                      3993     
                      3994     
                      3995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3996     ;
                      3997     ; Calculate next commutation timing routine
                      3998     ;
                      3999     ; No assumptions
                      4000     ;
                      4001     ; Called immediately after each commutation
                      4002     ; Also sets up timer 3 to wait advance timing
                      4003     ; Two entry points are used
                      4004     ;
                      4005     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4006     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0CC8    A850          4007     MOV R0 , WT_STEPPER_STEP_L 
0CCA    A951          4008     MOV R1 , WT_STEPPER_STEP_H 
0CCC    020CD3        4009     	JMP	READ_TIMER
                      4010     
                      4011     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CCF    A84A          4012     MOV R0 , WT_ADVANCE_L 
0CD1    A94B          4013     MOV R1 , WT_ADVANCE_H 
                      4014     READ_TIMER: 
                      4015     	; Set up next wait
0CD3    759100        4016     	MOV	TMR3CN, #00H		; Timer3 disabled
0CD6    C3            4017     	CLR	C
0CD7    E4            4018     	CLR	A
0CD8    98            4019     SUBB A , R0 
0CD9    F594          4020     	MOV	TMR3L, A
0CDB    E4            4021     	CLR	A
0CDC    99            4022     SUBB A , R1 
0CDD    F595          4023     	MOV	TMR3H, A
0CDF    759104        4024     	MOV	TMR3CN, #04H		; Timer3 enabled
0CE2    D258          4025     SETB FLAGS0 . 0 
                      4026     	; Read commutation time
0CE4    75C820        4027     	MOV	TMR2CN, #20H		; Timer2 disabled
0CE7    A8CC          4028     MOV R0 , TMR2L 
0CE9    A9CD          4029     MOV R1 , TMR2H 
0CEB    75C824        4030     	MOV	TMR2CN, #24H		; Timer2 enabled
                      4031     	; Calculate this commutation time
0CEE    AA3A          4032     MOV R2 , PREV_COMM_L 
0CF0    AB3B          4033     MOV R3 , PREV_COMM_H 
0CF2    883A          4034     MOV PREV_COMM_L , R0 
0CF4    893B          4035     MOV PREV_COMM_H , R1 
0CF6    C3            4036     	CLR	C
0CF7    E8            4037     MOV A , R0 
0CF8    9A            4038     SUBB A , R2 
0CF9    F8            4039     MOV R0 , A 
0CFA    E9            4040     MOV A , R1 
0CFB    9B            4041     SUBB A , R3 
0CFC    F9            4042     MOV R1 , A 
                      4043     	; Calculate next zero cross scan timeout 
0CFD    AA3C          4044     MOV R2 , COMM_PERIOD4X_L 
0CFF    AB3D          4045     MOV R3 , COMM_PERIOD4X_H 
0D01    C3            4046     	CLR	C
0D02    EB            4047     MOV A , R3 
0D03    13            4048     	RRC	A					; Divide by 2
0D04    FD            4049     MOV R5 , A 
0D05    EA            4050     MOV A , R2 
0D06    13            4051     	RRC	A
0D07    FC            4052     MOV R4 , A 
0D08    C3            4053     	CLR	C
0D09    ED            4054     MOV A , R5 
0D0A    13            4055     	RRC	A					; Divide by 2 again
0D0B    FD            4056     MOV R5 , A 
0D0C    EC            4057     MOV A , R4 
0D0D    13            4058     	RRC	A
0D0E    FC            4059     MOV R4 , A 
0D0F    C3            4060     	CLR	C
0D10    EA            4061     MOV A , R2 
0D11    9C            4062     SUBB A , R4 
0D12    FA            4063     MOV R2 , A 
0D13    EB            4064     MOV A , R3 
0D14    9D            4065     SUBB A , R5 
0D15    FB            4066     MOV R3 , A 
                      4067     
0D16    EA            4068     MOV A , R2 
0D17    28            4069     ADD A , R0 
0D18    FA            4070     MOV R2 , A 
0D19    EB            4071     MOV A , R3 
0D1A    39            4072     ADDC A , R1 
0D1B    FB            4073     MOV R3 , A 
0D1C    8A3C          4074     MOV COMM_PERIOD4X_L , R2 
0D1E    8B3D          4075     MOV COMM_PERIOD4X_H , R3 
0D20    4001          4076     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4077     
0D22    22            4078     	RET
                      4079     
                      4080     CALC_NEXT_COMM_SLOW: 
0D23    753CFF        4081     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D26    753DFF        4082     	MOV	COMM_PERIOD4X_H, #0FFH
0D29    22            4083     	RET
                      4084     
                      4085     
                      4086     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4087     ;
                      4088     ; Setup zero cross scan wait
                      4089     ;
                      4090     ; No assumptions
                      4091     ;
                      4092     ; Sets up timer 3 to wait the zero cross scan wait time
                      4093     ;
                      4094     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4095     SETUP_ZC_SCAN_WAIT: 
0D2A    759100        4096     	MOV	TMR3CN, #00H		; Timer3 disabled
0D2D    C3            4097     	CLR	C
0D2E    E4            4098     	CLR	A
0D2F    954C          4099     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D31    F594          4100     	MOV	TMR3L, A
0D33    E4            4101     	CLR	A
0D34    954D          4102     	SUBB	A, WT_ZC_SCAN_H		
0D36    F595          4103     	MOV	TMR3H, A
0D38    759104        4104     	MOV	TMR3CN, #04H		; Timer3 enabled
0D3B    D258          4105     SETB FLAGS0 . 0 
0D3D    22            4106     	RET
                      4107     
                      4108     
                      4109     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4110     ;
                      4111     ; Wait advance timing routine
                      4112     ;
                      4113     ; No assumptions
                      4114     ;
                      4115     ; Waits for the advance timing to elapse, waits one zero cross
                      4116     ; wait and sets up the next zero cross wait
                      4117     ;
                      4118     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4119     WAIT_ADVANCE_TIMING: 	
0D3E    7F01          4120     MOV R7 , # 1 
0D40    789C          4121     MOV R0 , # PGM_DEMAG_COMP 
0D42    E6            4122     MOV A , @ R0 
0D43    14            4123     	DEC	A
0D44    6002          4124     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4125     
0D46    7F02          4126     MOV R7 , # 2 
                      4127     
                      4128     WAIT_ADVANCE_TIMING_WAIT: 
0D48    305802        4129     JNB FLAGS0 . 0 , ( $+5 ) 
0D4B    A148          4130     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4131     
0D4D    B12A          4132     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D4F    DFF7          4133     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4134     
0D51    22            4135     	RET
                      4136     
                      4137     
                      4138     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4139     ;
                      4140     ; Calculate new wait times routine
                      4141     ;
                      4142     ; No assumptions
                      4143     ;
                      4144     ; Calculates new wait times
                      4145     ;
                      4146     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4147     CALC_NEW_WAIT_TIMES: 	
                      4148     	; Load programmed commutation timing
0D52    7892          4149     MOV R0 , # PGM_COMM_TIMING 
0D54    E6            4150     MOV A , @ R0 
0D55    FF            4151     MOV R7 , A 
0D56    7E14          4152     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4153     IF MODE == 2
0D58    A83D          4154     MOV R0 , COMM_PERIOD4X_H 
0D5A    C3            4155     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D5B    E8            4156     MOV A , R0 
0D5C    9404          4157     	SUBB	A, #4
0D5E    4002          4158     	JC	CALC_NEW_WAIT_RED_SET
                      4159     
0D60    7804          4160     MOV R0 , # 4 
                      4161     
                      4162     CALC_NEW_WAIT_RED_SET: 
0D62    C3            4163     	CLR	C
0D63    E8            4164     MOV A , R0 
0D64    33            4165     	RLC	A
0D65    F8            4166     MOV R0 , A 
0D66    C3            4167     	CLR	C
0D67    EE            4168     MOV A , R6 
0D68    98            4169     SUBB A , R0 
0D69    FE            4170     MOV R6 , A 
                      4171     ENDIF
0D6A    306304        4172     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4173     
0D6D    7F03          4174     MOV R7 , # 3 
0D6F    7E00          4175     MOV R6 , # 0 
                      4176     
                      4177     CALC_NEW_WAIT_DIR_START_SET: 
                      4178     	; Load current commutation timing
0D71    A93D          4179     MOV R1 , COMM_PERIOD4X_H 
0D73    A83C          4180     MOV R0 , COMM_PERIOD4X_L 
0D75    7A04          4181     MOV R2 , # 4 
                      4182     DIVIDE_WAIT_TIMES: 
0D77    C3            4183     	CLR	C
0D78    E9            4184     MOV A , R1 
0D79    13            4185     	RRC	A					; Divide by 2
0D7A    F9            4186     MOV R1 , A 
0D7B    E8            4187     MOV A , R0 
0D7C    13            4188     	RRC	A
0D7D    F8            4189     MOV R0 , A 
0D7E    DAF7          4190     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4191     
0D80    C3            4192     	CLR	C
0D81    E8            4193     MOV A , R0 
0D82    9E            4194     SUBB A , R6 
0D83    F8            4195     MOV R0 , A 
0D84    E9            4196     MOV A , R1 
0D85    9400          4197     	SUBB	A, #0
0D87    F9            4198     MOV R1 , A 
0D88    4009          4199     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4200     
0D8A    C3            4201     	CLR	C
0D8B    E8            4202     MOV A , R0 
0D8C    9402          4203     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D8E    E9            4204     MOV A , R1 
0D8F    9400          4205     	SUBB	A, #0
0D91    5004          4206     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4207     
                      4208     LOAD_MIN_TIME: 
0D93    7802          4209     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D95    E4            4210     	CLR	A
0D96    F9            4211     MOV R1 , A 
                      4212     
                      4213     ADJUST_TIMING: 
0D97    E9            4214     MOV A , R1 
0D98    FB            4215     MOV R3 , A 
0D99    E8            4216     MOV A , R0 
0D9A    FA            4217     MOV R2 , A 
0D9B    C3            4218     	CLR	C
0D9C    E9            4219     MOV A , R1 
0D9D    13            4220     	RRC	A					; Divide by 2
0D9E    FD            4221     MOV R5 , A 
0D9F    E8            4222     MOV A , R0 
0DA0    13            4223     	RRC	A
0DA1    FC            4224     MOV R4 , A 
0DA2    C3            4225     	CLR	C
0DA3    EF            4226     MOV A , R7 
0DA4    9403          4227     	SUBB	A, #3				; Is timing normal?
0DA6    602E          4228     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4229     
0DA8    EF            4230     MOV A , R7 
0DA9    20E00D        4231     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4232     
0DAC    E8            4233     MOV A , R0 
0DAD    2C            4234     ADD A , R4 
0DAE    F8            4235     MOV R0 , A 
0DAF    E9            4236     MOV A , R1 
0DB0    3D            4237     ADDC A , R5 
0DB1    F9            4238     MOV R1 , A 
0DB2    EC            4239     MOV A , R4 
0DB3    FA            4240     MOV R2 , A 
0DB4    ED            4241     MOV A , R5 
0DB5    FB            4242     MOV R3 , A 
0DB6    020DC3        4243     	JMP	STORE_TIMES_UP_OR_DOWN
                      4244     
                      4245     ADJUST_TIMING_TWO_STEPS: 
0DB9    E8            4246     MOV A , R0 
0DBA    28            4247     ADD A , R0 
0DBB    F8            4248     MOV R0 , A 
0DBC    E9            4249     MOV A , R1 
0DBD    39            4250     ADDC A , R1 
0DBE    F9            4251     MOV R1 , A 
0DBF    7A02          4252     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0DC1    E4            4253     	CLR	A
0DC2    FB            4254     MOV R3 , A 
                      4255     
                      4256     STORE_TIMES_UP_OR_DOWN: 
0DC3    C3            4257     	CLR	C
0DC4    EF            4258     MOV A , R7 
0DC5    9403          4259     	SUBB	A, #3				; Is timing higher than normal?
0DC7    400D          4260     	JC	STORE_TIMES_DECREASE	; No - branch
                      4261     
                      4262     STORE_TIMES_INCREASE: 
0DC9    8A4E          4263     MOV WT_COMM_L , R2 
0DCB    8B4F          4264     MOV WT_COMM_H , R3 
0DCD    884A          4265     MOV WT_ADVANCE_L , R0 
0DCF    894B          4266     MOV WT_ADVANCE_H , R1 
0DD1    8C4C          4267     MOV WT_ZC_SCAN_L , R4 
0DD3    8D4D          4268     MOV WT_ZC_SCAN_H , R5 
0DD5    22            4269     	RET
                      4270     
                      4271     STORE_TIMES_DECREASE: 
0DD6    884E          4272     MOV WT_COMM_L , R0 
0DD8    894F          4273     MOV WT_COMM_H , R1 
0DDA    8A4A          4274     MOV WT_ADVANCE_L , R2 
0DDC    8B4B          4275     MOV WT_ADVANCE_H , R3 
0DDE    8C4C          4276     MOV WT_ZC_SCAN_L , R4 
0DE0    8D4D          4277     MOV WT_ZC_SCAN_H , R5 
0DE2    22            4278     	RET
                      4279     
                      4280     
                      4281     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4282     ;
                      4283     ; Wait before zero cross scan routine
                      4284     ;
                      4285     ; No assumptions
                      4286     ;
                      4287     ; Waits for the zero cross scan wait time to elapse
                      4288     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4289     ;
                      4290     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4291     WAIT_BEFORE_ZC_SCAN: 	
0DE3    305802        4292     JNB FLAGS0 . 0 , ( $+5 ) 
0DE6    A1E3          4293     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4294     
0DE8    759100        4295     	MOV	TMR3CN, #00H		; Timer3 disabled
0DEB    C3            4296     	CLR	C
0DEC    E4            4297     	CLR	A
0DED    953C          4298     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DEF    F594          4299     	MOV	TMR3L, A
0DF1    E4            4300     	CLR	A
0DF2    953D          4301     	SUBB	A, COMM_PERIOD4X_H		
0DF4    F595          4302     	MOV	TMR3H, A
0DF6    759104        4303     	MOV	TMR3CN, #04H		; Timer3 enabled
0DF9    D258          4304     SETB FLAGS0 . 0 
0DFB    22            4305     	RET
                      4306     
                      4307     
                      4308     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4309     ;
                      4310     ; Wait for comparator to go low/high routines
                      4311     ;
                      4312     ; No assumptions
                      4313     ;
                      4314     ; Waits for the zero cross scan wait time to elapse
                      4315     ; Then scans for comparator going low/high
                      4316     ;
                      4317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4318     WAIT_FOR_COMP_OUT_LOW: 
0DFC    753F00        4319     	MOV	COMP_WAIT_READS, #0
0DFF    752000        4320     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E02    020E0B        4321     	JMP	WAIT_FOR_COMP_OUT_START
                      4322     
                      4323     WAIT_FOR_COMP_OUT_HIGH: 
0E05    753F00        4324     	MOV	COMP_WAIT_READS, #0
0E08    752040        4325     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4326     
                      4327     WAIT_FOR_COMP_OUT_START: 
0E0B    D2AF          4328     	SETB	EA						; Enable interrupts
0E0D    053F          4329     	INC	COMP_WAIT_READS
0E0F    205801        4330     JB FLAGS0 . 0 , ( $+4 ) 
0E12    22            4331     	RET							; Yes - return
                      4332     
                      4333     	; Set default comparator response times
0E13    759D00        4334     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4335     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4338     	; Select number of comparator readings based upon current rotation speed
0E16    E53D          4339     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E18    C3            4340     	CLR	C
0E19    13            4341     	RRC	A						; Divide by 4
0E1A    C3            4342     	CLR	C
0E1B    13            4343     	RRC	A
0E1C    F8            4344     MOV R0 , A 
0E1D    08            4345     INC R0 
0E1E    6030          4346     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4347     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E20    306A06        4348     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4349     
0E23    C3            4350     	CLR	C
0E24    13            4351     	RRC	A						; Divide by 4 again
0E25    C3            4352     	CLR	C
0E26    13            4353     	RRC	A
0E27    F8            4354     MOV R0 , A 
0E28    08            4355     INC R0 
                      4356     
                      4357     COMP_WAIT_SET_MAX_READINGS: 
0E29    C3            4358     	CLR	C
0E2A    E8            4359     MOV A , R0 
0E2B    940A          4360     	SUBB	A, #10
0E2D    4002          4361     	JC	($+4)
                      4362     
0E2F    780A          4363     MOV R0 , # 10 
                      4364     
0E31    306D08        4365     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4366     
0E34    C3            4367     	CLR	C
0E35    E8            4368     MOV A , R0 
0E36    9404          4369     	SUBB	A, #4
0E38    4002          4370     	JC	($+4)
                      4371     
0E3A    7804          4372     MOV R0 , # 4 
                      4373     
                      4374     COMP_WAIT_SET_RESPONSE_TIME: 
0E3C    C3            4375     	CLR	C
0E3D    E53D          4376     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E3F    9408          4377     	SUBB	A, #8
0E41    400D          4378     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4379     
0E43    759D02        4380     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4381     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E46    C3            4384     	CLR	C
0E47    E53D          4385     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E49    9410          4386     	SUBB	A, #16
0E4B    4003          4387     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4388     
0E4D    759D03        4389     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4390     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4393     
                      4394     COMP_WAIT_ON_COMP_ABLE: 
0E50    205803        4395     JB FLAGS0 . 0 , ( $+6 ) 
0E53    D2AF          4396     	SETB	EA							; Enable interrupts
0E55    22            4397     	RET								; Yes - return
                      4398     
0E56    791E          4399     MOV R1 , # 30 
0E58    206D02        4400     JB FLAGS2 . 5 , ( $+5 ) 
0E5B    790A          4401     MOV R1 , # 10 
0E5D    D2AF          4402     	SETB	EA							; Enable interrupts
0E5F    00            4403     	NOP								; Allocate only just enough time to capture interrupt
0E60    00            4404     	NOP
0E61    C2AF          4405     	CLR	EA							; Disable interrupts
0E63    205A0A        4406     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4407     
0E66    793C          4408     MOV R1 , # 60 
0E68    206D02        4409     JB FLAGS2 . 5 , ( $+5 ) 
0E6B    7914          4410     MOV R1 , # 20 
0E6D    3066E0        4411     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4412     
                      4413     PWM_WAIT_STARTUP: 						
0E70    306302        4414     JNB FLAGS1 . 3 , PWM_WAIT 
                      4415     
0E73    7978          4416     MOV R1 , # 120 
                      4417     PWM_WAIT: 						
0E75    C3            4418     	CLR	C
0E76    E58B          4419     	MOV	A, TL1
0E78    99            4420     SUBB A , R1 
                      4421     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E79    40D5          4426     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4427     ENDIF
                      4428     
                      4429     COMP_READ: 
                      4430     	READ_COMP_OUT 					; Read comparator output
0E7B    E59B          4430+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E7D    F4            4431     	CPL	A
0E7E    5440          4432     	ANL	A, #40H
0E80    B52002        4433     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4434     
0E83    C10B          4435     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4436     
0E85    D8C9          4437     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4438     
0E87    D2AF          4439     	SETB	EA						; Enable interrupts
0E89    22            4440     	RET							
                      4441     
                      4442     
                      4443     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4444     ;
                      4445     ; Evaluate comparator integrity
                      4446     ;
                      4447     ; No assumptions
                      4448     ;
                      4449     ; Checks comparator signal behaviour versus expected behaviour
                      4450     ;
                      4451     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4452     EVALUATE_COMPARATOR_INTEGRITY: 
0E8A    C25B          4453     CLR FLAGS0 . 3 
                      4454     	; Check if demag compensation is enabled
0E8C    789C          4455     MOV R0 , # PGM_DEMAG_COMP 
0E8E    E6            4456     MOV A , @ R0 
0E8F    14            4457     	DEC	A
0E90    600A          4458     	JZ	EVAL_COMP_NO_DEMAG
                      4459     
                      4460     	; Check if a demag situation has occurred
0E92    E53F          4461     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E94    14            4462     	DEC	A
0E95    7005          4463     	JNZ	EVAL_COMP_NO_DEMAG
                      4464     
0E97    206302        4465     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4466     
0E9A    D25B          4467     SETB FLAGS0 . 3 
                      4468     
                      4469     EVAL_COMP_NO_DEMAG: 
0E9C    30630B        4470     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4471     
0E9F    0538          4472     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0EA1    205810        4473     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4474     
0EA4    753800        4475     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0EA7    020EB4        4476     	JMP	EVAL_COMP_EXIT
                      4477     
                      4478     EVAL_COMP_CHECK_TIMEOUT: 
0EAA    205807        4479     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0EAD    1581          4480     	DEC	SP							; Routine exit without "ret" command
0EAF    1581          4481     	DEC	SP
0EB1    02176E        4482     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4483     
                      4484     EVAL_COMP_EXIT: 
0EB4    22            4485     	RET
                      4486     
                      4487     
                      4488     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4489     ;
                      4490     ; Setup commutation timing routine
                      4491     ;
                      4492     ; No assumptions
                      4493     ;
                      4494     ; Sets up and starts wait from commutation to zero cross
                      4495     ;
                      4496     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4497     SETUP_COMM_WAIT:  
0EB5    759100        4498     	MOV	TMR3CN, #00H		; Timer3 disabled
0EB8    C3            4499     	CLR	C
0EB9    E4            4500     	CLR	A
0EBA    954E          4501     	SUBB	A, WT_COMM_L		; Set wait commutation value
0EBC    F594          4502     	MOV	TMR3L, A
0EBE    E4            4503     	CLR	A
0EBF    954F          4504     	SUBB	A, WT_COMM_H		
0EC1    F595          4505     	MOV	TMR3H, A
0EC3    759104        4506     	MOV	TMR3CN, #04H		; Timer3 enabled
0EC6    D258          4507     SETB FLAGS0 . 0 
0EC8    22            4508     	RET
                      4509     
                      4510     
                      4511     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4512     ;
                      4513     ; Wait for commutation routine
                      4514     ;
                      4515     ; No assumptions
                      4516     ;
                      4517     ; Waits from zero cross to commutation 
                      4518     ;
                      4519     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4520     WAIT_FOR_COMM:  
                      4521     	; Increment or reset consecutive count
0EC9    0539          4522     	INC	DEMAG_CONSECUTIVE_CNT
0ECB    205B03        4523     JB FLAGS0 . 3 , ( $+6 ) 
                      4524     
0ECE    753900        4525     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4526     
                      4527     	; Check if a demag situation has occurred
0ED1    305B23        4528     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4529     
                      4530     	; Load programmed demag compensation
0ED4    78A3          4531     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0ED6    E6            4532     MOV A , @ R0 
0ED7    FF            4533     MOV R7 , A 
                      4534     
                      4535     	; Check for power off
0ED8    BF0108        4536     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4537     
0EDB    D25C          4538     SETB FLAGS0 . 4 
                      4539     	ALL_NFETS_OFF
0EDD    C292          4539+1   CLR P1 . 2 
0EDF    C296          4539+1   CLR P1 . 6 
0EE1    C295          4539+1   CLR P1 . 5 
                      4540     
                      4541     	; Wait a blind wait
                      4542     WAIT_FOR_COMM_BLIND: 
0EE3    B12A          4543     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4544     WAIT_DEMAG_DEFAULT_ZC: 	
0EE5    305802        4545     JNB FLAGS0 . 0 , ( $+5 ) 
0EE8    C1E5          4546     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4547     
                      4548     	; Check for power off
0EEA    BF0208        4549     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4550     
0EED    D25C          4551     SETB FLAGS0 . 4 
                      4552     	ALL_NFETS_OFF
0EEF    C292          4552+1   CLR P1 . 2 
0EF1    C296          4552+1   CLR P1 . 6 
0EF3    C295          4552+1   CLR P1 . 5 
                      4553     
                      4554     WAIT_FOR_COMM_SETUP: 
0EF5    D1B5          4555     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4556     WAIT_FOR_COMM_WAIT: 
0EF7    305802        4557     JNB FLAGS0 . 0 , ( $+5 ) 
0EFA    C1F7          4558     	AJMP	WAIT_FOR_COMM_WAIT					
                      4559     
0EFC    22            4560     	RET
                      4561     
                      4562     
                      4563     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4564     ;
                      4565     ; Commutation routines
                      4566     ;
                      4567     ; No assumptions
                      4568     ;
                      4569     ; Performs commutation switching 
                      4570     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4571     ;
                      4572     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4573     COMM1COMM2: 	
0EFD    C2AF          4574     	CLR 	EA					; Disable all interrupts
                      4575     	BPFET_OFF					; Bp off
0EFF    C294          4575+1   CLR P1 . 4 
0F01    206A03        4576     JB FLAGS2 . 2 , COMM12_DAMP 
0F04    020F1C        4577     	JMP	COMM12_NONDAMP
                      4578     COMM12_DAMP: 
                      4579     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4583     IF DAMPED_MODE_ENABLE == 1
0F07    900347        4584     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4585     ENDIF
0F0A    30650F        4586     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4587     	CPFET_OFF				
0F0D    207502        4587+1   JB FLAGS3 . 5 , ( $+5 ) 
0F10    C297          4587+1   CLR P1 . 7 
0F12    307502        4587+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F15    C293          4587+1   CLR P1 . 3 
0F17    7406          4588     MOV A , # 6 
0F19    D5E0FD        4589     	DJNZ ACC,	$
                      4590     COMM12_NONDAMP: 
                      4591     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4599     	APFET_ON					; Ap on
0F1C    207502        4599+1   JB FLAGS3 . 5 , ( $+5 ) 
0F1F    D293          4599+1   SETB P1 . 3 
0F21    307502        4599+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F24    D297          4599+1   SETB P1 . 7 
                      4600     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F26    759F80        4600+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F29    753E02        4601     	MOV	COMM_PHASE, #2
0F2C    021087        4602     	JMP	COMM_EXIT
                      4603     
                      4604     COMM2COMM3: 	
0F2F    C2AF          4605     	CLR 	EA					; Disable all interrupts
0F31    206A03        4606     JB FLAGS2 . 2 , COMM23_DAMP 
0F34    020F51        4607     	JMP	COMM23_NONDAMP
                      4608     COMM23_DAMP: 
                      4609     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4612     IF DAMPED_MODE_ENABLE == 1
0F37    9002FE        4613     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4614     ENDIF
0F3A    306517        4615     JNB FLAGS1 . 5 , COMM23_NFET 
                      4616     	BPFET_OFF				
0F3D    C294          4616+1   CLR P1 . 4 
                      4617     	CPFET_OFF				
0F3F    207502        4617+1   JB FLAGS3 . 5 , ( $+5 ) 
0F42    C297          4617+1   CLR P1 . 7 
0F44    307502        4617+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F47    C293          4617+1   CLR P1 . 3 
0F49    7406          4618     MOV A , # 6 
0F4B    D5E0FD        4619     	DJNZ ACC,	$
0F4E    020F54        4620     	JMP	COMM23_NFET
                      4621     COMM23_NONDAMP: 
0F51    9001E1        4622     	MOV	DPTR, #PWM_BFET_ON	
                      4623     COMM23_NFET: 
                      4624     	CNFET_OFF					; Cn off
0F54    207502        4624+1   JB FLAGS3 . 5 , ( $+5 ) 
0F57    C296          4624+1   CLR P1 . 6 
0F59    307502        4624+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F5C    C292          4624+1   CLR P1 . 2 
0F5E    305A06        4625     JNB FLAGS0 . 2 , COMM23_CP 
                      4626     	BNFET_ON					; Yes - Bn on
0F61    E525          4626+1   MOV A , CURRENT_PWM_LIMITED 
0F63    6002          4626+1   JZ ( $+4 ) 
0F65    D295          4626+1   SETB P1 . 5 
                      4627     COMM23_CP: 
                      4628     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F67    207503        4628+1   JB FLAGS3 . 5 , ( $+6 ) 
0F6A    759F89        4628+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F6D    307503        4628+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F70    759F81        4628+1   MOV CPT0MX , # 81H 
0F73    753E03        4629     	MOV	COMM_PHASE, #3
0F76    021087        4630     	JMP	COMM_EXIT
                      4631     
                      4632     COMM3COMM4: 	
0F79    C2AF          4633     	CLR 	EA					; Disable all interrupts
                      4634     	APFET_OFF					; Ap off
0F7B    207502        4634+1   JB FLAGS3 . 5 , ( $+5 ) 
0F7E    C293          4634+1   CLR P1 . 3 
0F80    307502        4634+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F83    C297          4634+1   CLR P1 . 7 
0F85    206A03        4635     JB FLAGS2 . 2 , COMM34_DAMP 
0F88    020F98        4636     	JMP	COMM34_NONDAMP
                      4637     COMM34_DAMP: 
                      4638     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4642     IF DAMPED_MODE_ENABLE == 1
0F8B    9002BD        4643     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4644     ENDIF
0F8E    306507        4645     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4646     	BPFET_OFF				
0F91    C294          4646+1   CLR P1 . 4 
0F93    7406          4647     MOV A , # 6 
0F95    D5E0FD        4648     	DJNZ ACC,	$
                      4649     COMM34_NONDAMP: 
                      4650     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4658     	CPFET_ON					; Cp on
0F98    207502        4658+1   JB FLAGS3 . 5 , ( $+5 ) 
0F9B    D297          4658+1   SETB P1 . 7 
0F9D    307502        4658+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FA0    D293          4658+1   SETB P1 . 3 
                      4659     	SET_COMP_PHASE_A 			; Set comparator to phase A
0FA2    207503        4659+1   JB FLAGS3 . 5 , ( $+6 ) 
0FA5    759F81        4659+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FA8    307503        4659+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FAB    759F89        4659+1   MOV CPT0MX , # 89H 
0FAE    753E04        4660     	MOV	COMM_PHASE, #4
0FB1    021087        4661     	JMP	COMM_EXIT
                      4662     
                      4663     COMM4COMM5: 	
0FB4    C2AF          4664     	CLR 	EA					; Disable all interrupts
0FB6    206A03        4665     JB FLAGS2 . 2 , COMM45_DAMP 
0FB9    020FD6        4666     	JMP	COMM45_NONDAMP
                      4667     COMM45_DAMP: 
                      4668     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4671     IF DAMPED_MODE_ENABLE == 1
0FBC    90027C        4672     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4673     ENDIF
0FBF    306517        4674     JNB FLAGS1 . 5 , COMM45_NFET 
                      4675     	APFET_OFF				
0FC2    207502        4675+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC5    C293          4675+1   CLR P1 . 3 
0FC7    307502        4675+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FCA    C297          4675+1   CLR P1 . 7 
                      4676     	BPFET_OFF				
0FCC    C294          4676+1   CLR P1 . 4 
0FCE    7406          4677     MOV A , # 6 
0FD0    D5E0FD        4678     	DJNZ ACC,	$
0FD3    020FD9        4679     	JMP	COMM45_NFET
                      4680     COMM45_NONDAMP: 
0FD6    9001CF        4681     	MOV	DPTR, #PWM_AFET_ON
                      4682     COMM45_NFET: 
                      4683     	BNFET_OFF					; Bn off
0FD9    C295          4683+1   CLR P1 . 5 
0FDB    305A0E        4684     JNB FLAGS0 . 2 , COMM45_CP 
                      4685     	ANFET_ON					; Yes - An on
0FDE    E525          4685+1   MOV A , CURRENT_PWM_LIMITED 
0FE0    600A          4685+1   JZ ( $+12 ) 
0FE2    207502        4685+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE5    D292          4685+1   SETB P1 . 2 
0FE7    307502        4685+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FEA    D296          4685+1   SETB P1 . 6 
                      4686     COMM45_CP: 
                      4687     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FEC    759F80        4687+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FEF    753E05        4688     	MOV	COMM_PHASE, #5
0FF2    021087        4689     	JMP	COMM_EXIT
                      4690     
                      4691     COMM5COMM6: 	
0FF5    C2AF          4692     	CLR 	EA					; Disable all interrupts
                      4693     	CPFET_OFF					; Cp off
0FF7    207502        4693+1   JB FLAGS3 . 5 , ( $+5 ) 
0FFA    C297          4693+1   CLR P1 . 7 
0FFC    307502        4693+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FFF    C293          4693+1   CLR P1 . 3 
1001    206A03        4694     JB FLAGS2 . 2 , COMM56_DAMP 
1004    02101C        4695     	JMP	COMM56_NONDAMP
                      4696     COMM56_DAMP: 
                      4697     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4701     IF DAMPED_MODE_ENABLE == 1
1007    900233        4702     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4703     ENDIF
100A    30650F        4704     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4705     	APFET_OFF				
100D    207502        4705+1   JB FLAGS3 . 5 , ( $+5 ) 
1010    C293          4705+1   CLR P1 . 3 
1012    307502        4705+1   JNB FLAGS3 . 5 , ( $+5 ) 
1015    C297          4705+1   CLR P1 . 7 
1017    7406          4706     MOV A , # 6 
1019    D5E0FD        4707     	DJNZ ACC,	$
                      4708     COMM56_NONDAMP: 
                      4709     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4717     	BPFET_ON					; Bp on
101C    D294          4717+1   SETB P1 . 4 
                      4718     	SET_COMP_PHASE_C 			; Set comparator to phase C
101E    207503        4718+1   JB FLAGS3 . 5 , ( $+6 ) 
1021    759F89        4718+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
1024    307503        4718+1   JNB FLAGS3 . 5 , ( $+6 ) 
1027    759F81        4718+1   MOV CPT0MX , # 81H 
102A    753E06        4719     	MOV	COMM_PHASE, #6
102D    021087        4720     	JMP	COMM_EXIT
                      4721     
                      4722     COMM6COMM1: 	
1030    C2AF          4723     	CLR 	EA					; Disable all interrupts
1032    206A03        4724     JB FLAGS2 . 2 , COMM61_DAMP 
1035    02105A        4725     	JMP	COMM61_NONDAMP
                      4726     COMM61_DAMP: 
                      4727     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4730     IF DAMPED_MODE_ENABLE == 1
1038    9003A0        4731     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4732     ENDIF
103B    30651F        4733     JNB FLAGS1 . 5 , COMM61_NFET 
                      4734     	APFET_OFF				
103E    207502        4734+1   JB FLAGS3 . 5 , ( $+5 ) 
1041    C293          4734+1   CLR P1 . 3 
1043    307502        4734+1   JNB FLAGS3 . 5 , ( $+5 ) 
1046    C297          4734+1   CLR P1 . 7 
                      4735     	CPFET_OFF				
1048    207502        4735+1   JB FLAGS3 . 5 , ( $+5 ) 
104B    C297          4735+1   CLR P1 . 7 
104D    307502        4735+1   JNB FLAGS3 . 5 , ( $+5 ) 
1050    C293          4735+1   CLR P1 . 3 
1052    7406          4736     MOV A , # 6 
1054    D5E0FD        4737     	DJNZ ACC,	$
1057    02105D        4738     	JMP	COMM61_NFET
                      4739     COMM61_NONDAMP: 
105A    9001F3        4740     	MOV	DPTR, #PWM_CFET_ON
                      4741     COMM61_NFET: 
                      4742     	ANFET_OFF					; An off
105D    207502        4742+1   JB FLAGS3 . 5 , ( $+5 ) 
1060    C292          4742+1   CLR P1 . 2 
1062    307502        4742+1   JNB FLAGS3 . 5 , ( $+5 ) 
1065    C296          4742+1   CLR P1 . 6 
1067    305A0E        4743     JNB FLAGS0 . 2 , COMM61_CP 
                      4744     	CNFET_ON					; Yes - Cn on
106A    E525          4744+1   MOV A , CURRENT_PWM_LIMITED 
106C    600A          4744+1   JZ ( $+12 ) 
106E    207502        4744+1   JB FLAGS3 . 5 , ( $+5 ) 
1071    D296          4744+1   SETB P1 . 6 
1073    307502        4744+1   JNB FLAGS3 . 5 , ( $+5 ) 
1076    D292          4744+1   SETB P1 . 2 
                      4745     COMM61_CP: 
                      4746     	SET_COMP_PHASE_A 			; Set comparator to phase A
1078    207503        4746+1   JB FLAGS3 . 5 , ( $+6 ) 
107B    759F81        4746+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
107E    307503        4746+1   JNB FLAGS3 . 5 , ( $+6 ) 
1081    759F89        4746+1   MOV CPT0MX , # 89H 
1084    753E01        4747     	MOV	COMM_PHASE, #1
                      4748     
                      4749     COMM_EXIT: 
1087    D2AF          4750     	SETB	EA					; Enable all interrupts
1089    789C          4751     MOV R0 , # PGM_DEMAG_COMP 
108B    E6            4752     MOV A , @ R0 
108C    C3            4753     	CLR	C
108D    9402          4754     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
108F    4007          4755     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4756     
1091    C3            4757     	CLR	C
1092    E539          4758     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1094    9403          4759     	SUBB	A, #3
1096    5002          4760     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4761     
                      4762     COMM_RESTORE_POWER: 
1098    C25C          4763     CLR FLAGS0 . 4 
                      4764     
                      4765     COMM_RETURN: 
109A    22            4766     	RET
                      4767     
                      4768     
                      4769     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4770     ;
                      4771     ; Switch power off routine
                      4772     ;
                      4773     ; No assumptions
                      4774     ;
                      4775     ; Switches all fets off 
                      4776     ;
                      4777     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4778     SWITCH_POWER_OFF: 
109B    9001CD        4779     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4780     	ALL_NFETS_OFF			; Turn off all nfets
109E    C292          4780+1   CLR P1 . 2 
10A0    C296          4780+1   CLR P1 . 6 
10A2    C295          4780+1   CLR P1 . 5 
                      4781     	ALL_PFETS_OFF			; Turn off all pfets
10A4    C293          4781+1   CLR P1 . 3 
10A6    C297          4781+1   CLR P1 . 7 
10A8    C294          4781+1   CLR P1 . 4 
10AA    C25A          4782     CLR FLAGS0 . 2 
10AC    22            4783     	RET			
                      4784     
                      4785     
                      4786     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4787     ;
                      4788     ; Decrement stepper step routine
                      4789     ;
                      4790     ; No assumptions
                      4791     ;
                      4792     ; Decrements the stepper step 
                      4793     ;
                      4794     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4795     DECREMENT_STEPPER_STEP: 
10AD    C3            4796     	CLR	C
10AE    E550          4797     	MOV	A, WT_STEPPER_STEP_L
10B0    9535          4798     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
10B2    E551          4799     	MOV	A, WT_STEPPER_STEP_H
10B4    9536          4800     	SUBB	A, STEPPER_STEP_END_H	
10B6    5001          4801     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
10B8    22            4802     	RET
                      4803     
                      4804     DECREMENT_STEP: 
                      4805     	; Load programmed startup acceleration
10B9    7890          4806     MOV R0 , # PGM_STARTUP_ACCEL 
10BB    E6            4807     MOV A , @ R0 
10BC    FF            4808     MOV R7 , A 
                      4809     	; Check acceleration setting and set step size accordingly
10BD    C3            4810     	CLR	C
10BE    EF            4811     MOV A , R7 
10BF    9405          4812     	SUBB	A, #5
10C1    5018          4813     	JNC	DEC_STEP_HIGH
10C3    C3            4814     	CLR	C
10C4    EF            4815     MOV A , R7 
10C5    9404          4816     	SUBB	A, #4
10C7    501B          4817     	JNC	DEC_STEP_MED_HIGH
10C9    C3            4818     	CLR	C
10CA    EF            4819     MOV A , R7 
10CB    9403          4820     	SUBB	A, #3
10CD    501E          4821     	JNC	DEC_STEP_MED
10CF    C3            4822     	CLR	C
10D0    EF            4823     MOV A , R7 
10D1    9402          4824     	SUBB	A, #2
10D3    5021          4825     	JNC	DEC_STEP_MED_LOW
10D5    C3            4826     	CLR	C
10D6    EF            4827     MOV A , R7 
10D7    9401          4828     	SUBB	A, #1
10D9    5024          4829     	JNC	DEC_STEP_LOW
                      4830     
                      4831     DEC_STEP_HIGH: 
10DB    C3            4832     	CLR	C
10DC    E550          4833     	MOV	A, WT_STEPPER_STEP_L
10DE    943C          4834     	SUBB	A, #LOW(30 SHL 1)		
10E0    F8            4835     MOV R0 , A 
10E1    021108        4836     	JMP	DECREMENT_STEP_EXIT
                      4837     DEC_STEP_MED_HIGH: 
10E4    C3            4838     	CLR	C
10E5    E550          4839     	MOV	A, WT_STEPPER_STEP_L
10E7    9428          4840     	SUBB	A, #LOW(20 SHL 1)		
10E9    F8            4841     MOV R0 , A 
10EA    021108        4842     	JMP	DECREMENT_STEP_EXIT
                      4843     DEC_STEP_MED: 
10ED    C3            4844     	CLR	C
10EE    E550          4845     	MOV	A, WT_STEPPER_STEP_L
10F0    941A          4846     	SUBB	A, #LOW(13 SHL 1)		
10F2    F8            4847     MOV R0 , A 
10F3    021108        4848     	JMP	DECREMENT_STEP_EXIT
                      4849     DEC_STEP_MED_LOW: 
10F6    C3            4850     	CLR	C
10F7    E550          4851     	MOV	A, WT_STEPPER_STEP_L
10F9    9412          4852     	SUBB	A, #LOW(9 SHL 1)		
10FB    F8            4853     MOV R0 , A 
10FC    021108        4854     	JMP	DECREMENT_STEP_EXIT
                      4855     DEC_STEP_LOW: 
10FF    C3            4856     	CLR	C
1100    E550          4857     	MOV	A, WT_STEPPER_STEP_L
1102    940A          4858     	SUBB	A, #LOW(5 SHL 1)		
1104    F8            4859     MOV R0 , A 
1105    021108        4860     	JMP	DECREMENT_STEP_EXIT
                      4861     
                      4862     DECREMENT_STEP_EXIT: 
1108    E551          4863     	MOV	A, WT_STEPPER_STEP_H
110A    9400          4864     	SUBB	A, #0		
110C    F9            4865     MOV R1 , A 
110D    8850          4866     MOV WT_STEPPER_STEP_L , R0 
110F    8951          4867     MOV WT_STEPPER_STEP_H , R1 
1111    22            4868     	RET
                      4869     
                      4870     
                      4871     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4872     ;
                      4873     ; Stepper timer wait
                      4874     ;
                      4875     ; No assumptions
                      4876     ;
                      4877     ; Waits for the stepper step timer to elapse
                      4878     ;
                      4879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4880     STEPPER_TIMER_WAIT: 
1112    305802        4881     JNB FLAGS0 . 0 , ( $+5 ) 
1115    2112          4882     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
1117    22            4883     	RET
                      4884     
                      4885     
                      4886     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4887     ;
                      4888     ; Set default parameters
                      4889     ;
                      4890     ; No assumptions
                      4891     ;
                      4892     ; Sets default programming parameters
                      4893     ;
                      4894     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4895     SET_DEFAULT_PARAMETERS: 
                      4896     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4957     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      5018     IF MODE == 2	; Multi
1118    7880          5019     MOV R0 , # PGM_GOV_P_GAIN 
111A    7609          5020     MOV @ R0 , # 9 
111C    08            5021     INC R0 
111D    7609          5022     MOV @ R0 , # 9 
111F    08            5023     INC R0 
1120    7604          5024     MOV @ R0 , # 4 
1122    08            5025     INC R0 
1123    7601          5026     MOV @ R0 , # 1 
1125    08            5027     INC R0 
1126    7603          5028     MOV @ R0 , # 3 
1128    08            5029     INC R0 
1129    76FF          5030     MOV @ R0 , # 0XFF 
112B    08            5031     INC R0 
112C    7609          5032     MOV @ R0 , # 9 
112E    08            5033     INC R0 
112F    7601          5034     MOV @ R0 , # 1 
1131    08            5035     INC R0 
1132    7601          5036     MOV @ R0 , # 1 
1134    08            5037     INC R0 
1135    7601          5038     MOV @ R0 , # 1 
                      5039     
1137    788C          5040     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1139    7600          5041     MOV @ R0 , # 0 
113B    08            5042     INC R0 
113C    76FF          5043     MOV @ R0 , # 0XFF 
113E    08            5044     INC R0 
113F    76FF          5045     MOV @ R0 , # 0XFF 
1141    08            5046     INC R0 
1142    7601          5047     MOV @ R0 , # 1 
1144    08            5048     INC R0 
1145    7605          5049     MOV @ R0 , # 5 
1147    08            5050     INC R0 
1148    76FF          5051     MOV @ R0 , # 0XFF 
114A    08            5052     INC R0 
114B    7603          5053     MOV @ R0 , # 3 
114D    08            5054     INC R0 
114E    7606          5055     MOV @ R0 , # 6 
1150    08            5056     INC R0 
1151    76FF          5057     MOV @ R0 , # 0XFF 
1153    08            5058     INC R0 
1154    7602          5059     MOV @ R0 , # 2 
1156    08            5060     INC R0 
1157    7603          5061     MOV @ R0 , # 3 
1159    08            5062     INC R0 
115A    76FA          5063     MOV @ R0 , # 250 
115C    08            5064     INC R0 
115D    7650          5065     MOV @ R0 , # 80 
115F    08            5066     INC R0 
1160    7650          5067     MOV @ R0 , # 80 
1162    08            5068     INC R0 
1163    7605          5069     MOV @ R0 , # 5 
1165    08            5070     INC R0 
1166    7601          5071     MOV @ R0 , # 1 
1168    08            5072     INC R0 
1169    7602          5073     MOV @ R0 , # 2 
116B    08            5074     INC R0 
116C    7600          5075     MOV @ R0 , # 0 
116E    08            5076     INC R0 
116F    767D          5077     MOV @ R0 , # 125 
                      5078     ENDIF
                      5079     
                      5080     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5081     ;
                      5082     ; 初始化变量 
                      5083     ; Skypup 2015.05.25
1171    757300        5084     	MOV	PREV_RCP,	#0
1174    757500        5085     	MOV	NHOLD_L,	#0
1177    757600        5086     	MOV	NHOLD_H,	#0
117A    757700        5087     MOV CSTATE , # 0 
                      5088     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
117D    22            5089     	RET
                      5090     
                      5091     
                      5092     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5093     ;
                      5094     ; Decode parameters
                      5095     ;
                      5096     ; No assumptions
                      5097     ;
                      5098     ; Decodes programming parameters
                      5099     ;
                      5100     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5101     DECODE_PARAMETERS: 
                      5102     	; Load programmed damping force
117E    7893          5103     MOV R0 , # PGM_DAMPING_FORCE 
1180    E6            5104     MOV A , @ R0 
1181    FF            5105     MOV R7 , A 
                      5106     	; Decode damping
1182    756609        5107     	MOV	DAMPING_PERIOD, #9		; Set default
1185    756701        5108     	MOV	DAMPING_ON, #1
1188    C3            5109     	CLR	C
1189    BF0206        5110     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5111     
118C    756605        5112     	MOV	DAMPING_PERIOD, #5
118F    756701        5113     	MOV	DAMPING_ON, #1
                      5114     
                      5115     DECODE_DAMPING_3: 
1192    C3            5116     	CLR	C
1193    BF0306        5117     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5118     
1196    756605        5119     	MOV	DAMPING_PERIOD, #5
1199    756702        5120     	MOV	DAMPING_ON, #2
                      5121     
                      5122     DECODE_DAMPING_4: 
119C    C3            5123     	CLR	C
119D    BF0406        5124     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5125     
11A0    756605        5126     	MOV	DAMPING_PERIOD, #5
11A3    756703        5127     	MOV	DAMPING_ON, #3
                      5128     
                      5129     DECODE_DAMPING_5: 
11A6    C3            5130     	CLR	C
11A7    BF0506        5131     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5132     
11AA    756609        5133     	MOV	DAMPING_PERIOD, #9
11AD    756707        5134     	MOV	DAMPING_ON, #7
                      5135     
                      5136     DECODE_DAMPING_6: 
11B0    C3            5137     	CLR	C
11B1    BF0606        5138     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5139     
11B4    756600        5140     	MOV	DAMPING_PERIOD, #0
11B7    756700        5141     	MOV	DAMPING_ON, #0
                      5142     
                      5143     DECODE_DAMPING_DONE: 
                      5144     	; Load programmed pwm frequency
11BA    7887          5145     MOV R0 , # PGM_PWM_FREQ 
11BC    E6            5146     MOV A , @ R0 
11BD    FF            5147     MOV R7 , A 
                      5148     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5155     IF MODE >= 1	; Tail or multi
11BE    C26C          5156     CLR FLAGS2 . 4 
11C0    C3            5157     	CLR	C
11C1    BF0302        5158     CJNE R7 , # 3 , ( $+5 ) 
11C4    D26C          5159     SETB FLAGS2 . 4 
11C6    C26B          5160     CLR FLAGS2 . 3 
11C8    C3            5161     	CLR	C
11C9    BF0402        5162     CJNE R7 , # 4 , ( $+5 ) 
11CC    D26B          5163     SETB FLAGS2 . 3 
                      5164     ENDIF
11CE    C26A          5165     CLR FLAGS2 . 2 
11D0    7418          5166     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
11D2    552D          5167     	ANL	A, FLAGS2					; Check if any damped mode is set
11D4    6002          5168     	JZ	($+4)
11D6    D26A          5169     SETB FLAGS2 . 2 
11D8    C265          5170     CLR FLAGS1 . 5 
11DA    6002          5171     	JZ	($+4)
11DC    D265          5172     SETB FLAGS1 . 5 
11DE    D266          5173     SETB FLAGS1 . 6 
11E0    6002          5174     	JZ	($+4)
11E2    C266          5175     CLR FLAGS1 . 6 
                      5176     	; Load programmed direction
11E4    7888          5177     MOV R0 , # PGM_DIRECTION 
                      5178     IF MODE >= 1	; Tail or multi
11E6    E6            5179     MOV A , @ R0 
11E7    C3            5180     	CLR	C
11E8    9403          5181     	SUBB	A, #3
11EA    6008          5182     	JZ	DECODE_PARAMS_DIR_SET
                      5183     ENDIF
                      5184     
11EC    C275          5185     CLR FLAGS3 . 5 
11EE    E6            5186     MOV A , @ R0 
11EF    30E102        5187     	JNB	ACC.1, ($+5)
11F2    D275          5188     SETB FLAGS3 . 5 
                      5189     DECODE_PARAMS_DIR_SET: 
11F4    C276          5190     CLR FLAGS3 . 6 
11F6    7889          5191     MOV R0 , # PGM_INPUT_POL 
11F8    E6            5192     MOV A , @ R0 
11F9    30E102        5193     	JNB	ACC.1, ($+5)
11FC    D276          5194     SETB FLAGS3 . 6 
11FE    C3            5195     	CLR	C
11FF    EF            5196     MOV A , R7 
1200    9402          5197     	SUBB	A, #2
1202    6008          5198     	JZ	DECODE_PWM_FREQ_LOW
                      5199     
1204    758E01        5200     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1207    D26D          5201     SETB FLAGS2 . 5 
1209    021211        5202     	JMP	DECODE_PWM_FREQ_END
                      5203     
                      5204     DECODE_PWM_FREQ_LOW: 
120C    758E00        5205     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
120F    C26D          5206     CLR FLAGS2 . 5 
                      5207     
                      5208     DECODE_PWM_FREQ_END: 
1211    22            5209     	RET
                      5210     
                      5211     
                      5212     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5213     ;
                      5214     ; Decode governor gain
                      5215     ;
                      5216     ; No assumptions
                      5217     ;
                      5218     ; Decodes governor gains
                      5219     ;
                      5220     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5221     DECODE_GOVERNOR_GAINS: 
                      5222     	; Decode governor gains
1212    7880          5223     MOV R0 , # PGM_GOV_P_GAIN 
1214    E6            5224     MOV A , @ R0 
1215    14            5225     	DEC	A	
1216    900080        5226     	MOV	DPTR, #GOV_GAIN_TABLE
1219    93            5227     	MOVC A, @A+DPTR	
121A    789F          5228     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
121C    F6            5229     MOV @ R0 , A 
121D    7881          5230     MOV R0 , # PGM_GOV_I_GAIN 
121F    E6            5231     MOV A , @ R0 
1220    14            5232     	DEC	A	
1221    900080        5233     	MOV	DPTR, #GOV_GAIN_TABLE
1224    93            5234     	MOVC A, @A+DPTR	
1225    78A0          5235     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1227    F6            5236     MOV @ R0 , A 
1228    119B          5237     	CALL	SWITCH_POWER_OFF		; Reset DPTR
122A    22            5238     	RET
                      5239     
                      5240     
                      5241     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5242     ;
                      5243     ; Decode throttle rate
                      5244     ;
                      5245     ; No assumptions
                      5246     ;
                      5247     ; Decodes throttle rate
                      5248     ;
                      5249     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5250     DECODE_THROTTLE_RATE: 
                      5251     	; Decode throttle rate
122B    789B          5252     MOV R0 , # PGM_THROTTLE_RATE 
122D    E6            5253     MOV A , @ R0 
122E    14            5254     	DEC	A	
122F    90008D        5255     	MOV	DPTR, #THROTTLE_RATE_TABLE
1232    93            5256     	MOVC A, @A+DPTR	
1233    78A1          5257     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
1235    F6            5258     MOV @ R0 , A 
1236    119B          5259     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1238    22            5260     	RET
                      5261     
                      5262     
                      5263     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5264     ;
                      5265     ; Decode startup power
                      5266     ;
                      5267     ; No assumptions
                      5268     ;
                      5269     ; Decodes startup power
                      5270     ;
                      5271     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5272     DECODE_STARTUP_POWER: 
                      5273     	; Decode startup power
1239    7886          5274     MOV R0 , # PGM_STARTUP_PWR 
123B    E6            5275     MOV A , @ R0 
123C    14            5276     	DEC	A	
123D    90009A        5277     	MOV	DPTR, #STARTUP_POWER_TABLE
1240    93            5278     	MOVC A, @A+DPTR	
1241    78A2          5279     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1243    F6            5280     MOV @ R0 , A 
1244    119B          5281     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1246    22            5282     	RET
                      5283     
                      5284     
                      5285     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5286     ;
                      5287     ; Decode demag compensation
                      5288     ;
                      5289     ; No assumptions
                      5290     ;
                      5291     ; Decodes throttle rate
                      5292     ;
                      5293     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5294     DECODE_DEMAG_COMP: 
                      5295     	; Decode demag compensation
1247    789C          5296     MOV R0 , # PGM_DEMAG_COMP 
1249    E6            5297     MOV A , @ R0 
124A    14            5298     	DEC	A	
124B    9000A7        5299     	MOV	DPTR, #DEMAG_POWER_TABLE
124E    93            5300     	MOVC A, @A+DPTR	
124F    78A3          5301     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
1251    F6            5302     MOV @ R0 , A 
1252    119B          5303     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1254    22            5304     	RET
                      5305     
                      5306     
                      5307     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5308     ;
                      5309     ; Set BEC voltage
                      5310     ;
                      5311     ; No assumptions
                      5312     ;
                      5313     ; Sets the BEC output voltage low or high
                      5314     ;
                      5315     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5316     SET_BEC_VOLTAGE: 
                      5317     	; Set bec voltage
                      5318     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
1255    22            5328     	RET
                      5329     
                      5330     
                      5331     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5332     ;
                      5333     ; Find throttle gain
                      5334     ;
                      5335     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5336     ;
                      5337     ; Finds throttle gain from throttle calibration values
                      5338     ;
                      5339     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5340     FIND_THROTTLE_GAIN: 
                      5341     	; Load programmed minimum and maximum throttle
1256    7896          5342     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1258    E6            5343     MOV A , @ R0 
1259    FA            5344     MOV R2 , A 
125A    7897          5345     MOV R0 , # PGM_PPM_MAX_THROTTLE 
125C    E6            5346     MOV A , @ R0 
125D    FB            5347     MOV R3 , A 
                      5348     	; Check if full range is chosen
125E    307704        5349     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5350     
1261    7A00          5351     MOV R2 , # 0 
1263    7BFF          5352     MOV R3 , # 255 
                      5353     
                      5354     FIND_THROTTLE_GAIN_CALCULATE: 
                      5355     	; Calculate difference
1265    C3            5356     	CLR	C
1266    EB            5357     MOV A , R3 
1267    9A            5358     SUBB A , R2 
1268    FC            5359     MOV R4 , A 
                      5360     	; Check that difference is minimum 130
1269    C3            5361     	CLR	C
126A    9482          5362     	SUBB	A, #130
126C    5002          5363     	JNC	($+4)
                      5364     
126E    7C82          5365     MOV R4 , # 130 
                      5366     
                      5367     	; Find gain
1270    756E00        5368     	MOV	PPM_THROTTLE_GAIN, #0
                      5369     TEST_THROTTLE_GAIN: 
1273    056E          5370     	INC	PPM_THROTTLE_GAIN
1275    EC            5371     MOV A , R4 
1276    856EF0        5372     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1279    A4            5373     	MUL	AB
127A    C3            5374     	CLR	C
127B    E5F0          5375     	MOV	A, B
127D    9480          5376     	SUBB	A, #128
127F    40F2          5377     	JC	TEST_THROTTLE_GAIN
1281    22            5378     	RET
                      5379     
                      5380     
                      5381     
                      5382     
                      5383     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5384     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5385     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5386     ;
                      5387     ; Main program start
                      5388     ;
                      5389     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5391     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5392     
                      5393     RESET: 
                      5394     	; Check flash lock byte
1282    E5EF          5395     	MOV	A, RSTSRC			
1284    20E603        5396     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5397     
1287    752000        5398     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5399     
128A    0520          5400     	INC	BIT_ACCESS
128C    903FFF        5401     MOV DPTR , # 16383 
128F    E520          5402     	MOV	A, BIT_ACCESS
1291    14            5403     	DEC	A
1292    6006          5404     	JZ	LOCK_BYTE_TEST
                      5405     
1294    901FFF        5406     MOV DPTR , # 8191 
1297    14            5407     	DEC	A
1298    6000          5408     	JZ	LOCK_BYTE_TEST
                      5409     
                      5410     LOCK_BYTE_TEST: 
129A    93            5411     	MOVC A, @A+DPTR		; Read lock byte
129B    04            5412     	INC	A				
129C    6003          5413     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5414     
                      5415     IF ONE_S_CAPABLE == 0		
129E    75EF12        5416     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5417     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5420     
                      5421     LOCK_BYTE_OK: 
                      5422     	; Select register bank 0 for main program routines
12A1    C2D3          5423     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5424     	; Disable the WDT.
12A3    53D9BF        5425     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5426     	; Initialize stack
12A6    7581C0        5427     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5428     	; Initialize VDD monitor
12A9    43FF80        5429     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
12AC    1207EF        5430     	CALL	WAIT1MS			; Wait at least 100us
                      5431     IF ONE_S_CAPABLE == 0		
12AF    75EF02        5432     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5433     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5436     	; Set clock frequency
12B2    43B203        5437     	ORL	OSCICN, #03H		; Set clock divider to 1
12B5    E5B3          5438     	MOV	A, OSCICL				
12B7    2404          5439     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
12B9    4002          5440     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5441     
12BB    F5B3          5442     	MOV	OSCICL, A
                      5443     
                      5444     RESET_CAL_DONE: 
                      5445     	; Switch power off
12BD    119B          5446     	CALL	SWITCH_POWER_OFF
                      5447     	; Ports initialization
12BF    7580FF        5448     MOV P0 , # 255 
12C2    75A400        5449     MOV P0MDOUT , # 0 
12C5    75F1F0        5450     MOV P0MDIN , # -16 
12C8    75D4DF        5451     MOV P0SKIP , # -33 
12CB    759002        5452     MOV P1 , # 2 
12CE    75A5FC        5453     MOV P1MDOUT , # 252 
12D1    75F2FD        5454     MOV P1MDIN , # -3 
12D4    75D502        5455     MOV P1SKIP , # 2 
                      5456     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12D7    75A610        5459     MOV P2MDOUT , # 16 
                      5460     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5467     	; Initialize the XBAR and related functionality
                      5468     	INITIALIZE_XBAR		
12DA    75A0FF        5468+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12DD    75F3F1        5468+1   MOV P2MDIN , # -15 
12E0    75E241        5468+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5469     	; Clear RAM
12E3    E4            5470     	CLR	A				; Clear accumulator
12E4    F8            5471     MOV R0 , A 
                      5472     CLEAR_RAM: 	
12E5    F6            5473     MOV @ R0 , A 
12E6    D8FD          5474     DJNZ R0 , CLEAR_RAM 
                      5475     	; Set default programmed parameters
12E8    3118          5476     	CALL	SET_DEFAULT_PARAMETERS
                      5477     	; Decode parameters
12EA    317E          5478     	CALL	DECODE_PARAMETERS
                      5479     	; Decode governor gains
12EC    5112          5480     	CALL	DECODE_GOVERNOR_GAINS
                      5481     	; Decode throttle rate
12EE    512B          5482     	CALL	DECODE_THROTTLE_RATE
                      5483     	; Decode startup power
12F0    5139          5484     	CALL	DECODE_STARTUP_POWER
                      5485     	; Decode demag compensation
12F2    5147          5486     	CALL	DECODE_DEMAG_COMP
                      5487     	; Set BEC voltage
12F4    5155          5488     	CALL	SET_BEC_VOLTAGE
                      5489     	; Find throttle gain from stored min and max settings
12F6    5156          5490     	CALL	FIND_THROTTLE_GAIN
                      5491     	; Set beep strength
12F8    7898          5492     MOV R0 , # PGM_BEEP_STRENGTH 
12FA    866F          5493     MOV BEEP_STRENGTH , @ R0 
                      5494     	; Switch power off
12FC    119B          5495     	CALL	SWITCH_POWER_OFF
                      5496     	; Timer control
12FE    758850        5497     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5498     	; Timer mode
1301    758902        5499     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5500     	; Timer2: clk/12 for 128us and 32ms interrupts
1304    75C824        5501     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5502     	; Timer3: clk/12 for commutation timing
1307    759104        5503     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5504     	; PCA
130A    75D840        5505     	MOV	PCA0CN, #40H		; PCA enabled
                      5506     	; Initializing beep
130D    C2AF          5507     	CLR	EA				; Disable interrupts explicitly
130F    120808        5508     	CALL WAIT200MS	
1312    12081F        5509     	CALL BEEP_F1
1315    1207FE        5510     	CALL WAIT30MS
1318    120826        5511     	CALL BEEP_F2
131B    1207FE        5512     	CALL WAIT30MS
131E    12082D        5513     	CALL BEEP_F3
1321    1207FE        5514     	CALL WAIT30MS
1324    120834        5515     	CALL BEEP_F4
1327    1207FE        5516     	CALL WAIT30MS
                      5517     
                      5518     	; Wait for receiver to initialize
132A    120818        5519     	CALL	WAIT1S
132D    120808        5520     	CALL	WAIT200MS
1330    120808        5521     	CALL	WAIT200MS
1333    120803        5522     	CALL	WAIT100MS
                      5523     
                      5524     	; Enable interrupts
1336    75A822        5525     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1339    75B802        5526     	MOV	IP, #02H			; High priority to timer0 interrupts
133C    75E690        5527     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5528     	; Initialize comparator
133F    759B80        5529     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1342    759D03        5530     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5531     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5535     	; Initialize ADC
                      5536     	INITIALIZE_ADC			; Initialize ADC operation
1345    75D10E        5536+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1348    75BC58        5536+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
134B    75BB09        5536+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
134E    75BA11        5536+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1351    75E880        5536+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1354    1207EF        5537     	CALL	WAIT1MS
1357    D2AF          5538     	SETB	EA				; Enable all interrupts
                      5539     	; Measure number of lipo cells
1359    120AD7        5540     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5541     	; Initialize rc pulse
                      5542     	RCP_INT_ENABLE		 			; Enable interrupt
135C    43DA01        5542+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5543     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
135F    C2D8          5543+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1361    C269          5544     CLR FLAGS2 . 1 
1363    120808        5545     	CALL WAIT200MS
                      5546     	; Set initial arm variable
1366    753001        5547     	MOV	INITIAL_ARM, #1
                      5548     
                      5549     	; Measure PWM frequency
                      5550     MEASURE_PWM_FREQ_INIT: 	
1369    D259          5551     SETB FLAGS0 . 1 
                      5552     MEASURE_PWM_FREQ_START: 	
136B    7A05          5553     MOV R2 , # 5 
                      5554     MEASURE_PWM_FREQ_LOOP: 	
                      5555     	; Check if period diff was accepted
136D    E558          5556     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
136F    7002          5557     	JNZ	($+4)
                      5558     
1371    7A05          5559     MOV R2 , # 5 
                      5560     
1373    1207F4        5561     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1376    E559          5562     	MOV	A, NEW_RCP					; Load value
1378    C3            5563     	CLR	C
1379    9402          5564     SUBB A , # 2 
137B    40EE          5565     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5566     
137D    E52E          5567     	MOV	A, FLAGS3						; Check pwm frequency flags
137F    541F          5568     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1381    855B5A        5569     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1384    F55B          5570     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1386    B55AE2        5571     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5572     
1389    DAE2          5573     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5574     
                      5575     	; Clear measure pwm frequency flag
138B    C259          5576     CLR FLAGS0 . 1 
                      5577     	; Set up RC pulse interrupts after pwm frequency measurement
                      5578     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
138D    53DACF        5578+1   ANL PCA0CPM0 , # 0CFH 
1390    207603        5578+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1393    43DA20        5578+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1396    307603        5578+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1399    43DA10        5578+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5579     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
139C    C2D8          5579+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
139E    C269          5580     CLR FLAGS2 . 1 
13A0    120803        5581     	CALL WAIT100MS						; Wait for new RC pulse
                      5582     
                      5583     	; Validate RC pulse
                      5584     VALIDATE_RCP_START: 	
13A3    1207F4        5585     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
13A6    7802          5586     MOV R0 , # 2 
13A8    741F          5587     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13AA    552E          5588     	ANL	A, FLAGS3						; Check pwm frequency flags
13AC    7002          5589     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5590     
13AE    7800          5591     MOV R0 , # 0 
                      5592     
13B0    C3            5593     	CLR	C
13B1    E559          5594     	MOV	A, NEW_RCP					; Load value
13B3    98            5595     SUBB A , R0 
13B4    40ED          5596     	JC	VALIDATE_RCP_START				; No - start over
                      5597     
                      5598     	; Beep arm sequence start signal
13B6    C2AF          5599     	CLR 	EA							; Disable all interrupts
13B8    12081F        5600     	CALL BEEP_F1
13BB    1207FE        5601     	CALL WAIT30MS
13BE    12081F        5602     	CALL BEEP_F1
13C1    1207FE        5603     	CALL WAIT30MS
13C4    120826        5604     	CALL BEEP_F2
13C7    1207FE        5605     	CALL WAIT30MS
13CA    120826        5606     	CALL BEEP_F2
13CD    1207FE        5607     	CALL WAIT30MS
13D0    D2AF          5608     	SETB	EA							; Enable all interrupts
13D2    120808        5609     	CALL WAIT200MS	
                      5610     
                      5611     	; Arming sequence start
13D5    754800        5612     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5613     ARMING_START: 
13D8    C3            5614     	CLR	C
13D9    E559          5615     	MOV	A, NEW_RCP			; Load new RC pulse value
13DB    9548          5616     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
13DD    4003          5617     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5618     
13DF    855948        5619     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5620     
                      5621     ARM_TARGET_UPDATED: 
13E2    120803        5622     	CALL WAIT100MS				; Wait for new throttle value
13E5    C3            5623     	CLR	C
13E6    E559          5624     	MOV	A, NEW_RCP			; Load new RC pulse value
13E8    9401          5625     SUBB A , # 1 
13EA    4002          5626     	JC	ARM_END_BEEP			; Yes - proceed
                      5627     
13EC    80EA          5628     	JMP	ARMING_START			; No - start over
                      5629     
                      5630     ARM_END_BEEP: 
                      5631     	; Beep arm sequence end signal
13EE    C2AF          5632     	CLR 	EA					; Disable all interrupts
13F0    120834        5633     	CALL BEEP_F4
13F3    1207FE        5634     	CALL WAIT30MS
13F6    120834        5635     	CALL BEEP_F4
13F9    1207FE        5636     	CALL WAIT30MS
13FC    12082D        5637     	CALL BEEP_F3
13FF    1207FE        5638     	CALL WAIT30MS
1402    12082D        5639     	CALL BEEP_F3
1405    1207FE        5640     	CALL WAIT30MS
1408    D2AF          5641     	SETB	EA					; Enable all interrupts
140A    120808        5642     	CALL WAIT200MS
                      5643     
                      5644     	; Clear initial arm variable
140D    753000        5645     	MOV	INITIAL_ARM, #0
                      5646     
                      5647     	; Armed and waiting for power on
                      5648     WAIT_FOR_POWER_ON: 
1410    E4            5649     	CLR	A
1411    F531          5650     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1413    F532          5651     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5652     WAIT_FOR_POWER_ON_LOOP: 
1415    0531          5653     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
1417    E531          5654     	MOV	A, POWER_ON_WAIT_CNT_L
1419    F4            5655     	CPL	A
141A    7039          5656     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5657     
141C    0532          5658     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
141E    789A          5659     MOV R0 , # PGM_BEACON_DELAY 
1420    E6            5660     MOV A , @ R0 
1421    7819          5661     MOV R0 , # 25 
1423    14            5662     	DEC	A
1424    6012          5663     	JZ	BEEP_DELAY_SET
                      5664     
1426    7832          5665     MOV R0 , # 50 
1428    14            5666     	DEC	A
1429    600D          5667     	JZ	BEEP_DELAY_SET
                      5668     
142B    787D          5669     MOV R0 , # 125 
142D    14            5670     	DEC	A
142E    6008          5671     	JZ	BEEP_DELAY_SET
                      5672     
1430    78FA          5673     MOV R0 , # 250 
1432    14            5674     	DEC	A
1433    6003          5675     	JZ	BEEP_DELAY_SET
                      5676     
1435    753200        5677     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5678     
                      5679     BEEP_DELAY_SET: 
1438    C3            5680     	CLR	C
1439    E532          5681     	MOV	A, POWER_ON_WAIT_CNT_H
143B    98            5682     SUBB A , R0 
143C    4017          5683     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5684     
143E    1532          5685     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1440    7531B4        5686     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
1443    7899          5687     MOV R0 , # PGM_BEACON_STRENGTH 
1445    866F          5688     MOV BEEP_STRENGTH , @ R0 
1447    C2AF          5689     	CLR 	EA					; Disable all interrupts
1449    120834        5690     	CALL BEEP_F4				; Signal that there is no signal
144C    D2AF          5691     	SETB	EA					; Enable all interrupts
144E    7898          5692     MOV R0 , # PGM_BEEP_STRENGTH 
1450    866F          5693     MOV BEEP_STRENGTH , @ R0 
1452    120803        5694     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5695     
                      5696     WAIT_FOR_POWER_ON_NO_BEEP: 
1455    1207F9        5697     	CALL WAIT10MS
1458    E528          5698     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
145A    7008          5699     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5700     
145C    741F          5701     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
145E    552E          5702     	ANL	A, FLAGS3						; Check pwm frequency flags
1460    7002          5703     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5704     
1462    6169          5705     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5706     
                      5707     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1464    C3            5708     	CLR	C
1465    E559          5709     	MOV	A, NEW_RCP			; Load new RC pulse value
1467    9406          5710     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
1469    40AA          5711     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5712     
                      5713     IF MODE >= 1	; Tail or multi
146B    7888          5714     MOV R0 , # PGM_DIRECTION 
146D    E6            5715     MOV A , @ R0 
146E    C3            5716     	CLR	C
146F    9403          5717     	SUBB	A, #3
1471    6003          5718     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5719     ENDIF
                      5720     
1473    120803        5721     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5722     
1476    E528          5723     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1478    7003          5724     	JNZ	($+5)				; If it is not zero - proceed
                      5725     
147A    021369        5726     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5727     
                      5728     
                      5729     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5730     ;
                      5731     ; Start entry point
                      5732     ;
                      5733     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5734     INIT_START: 
147D    C2AF          5735     	CLR	EA
147F    119B          5736     	CALL SWITCH_POWER_OFF
1481    E4            5737     	CLR	A
1482    F522          5738     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1484    F523          5739     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1486    F524          5740     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1488    F525          5741     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
148A    D2AF          5742     	SETB	EA
148C    7885          5743     MOV R0 , # PGM_MOTOR_IDLE 
148E    8661          5744     MOV PWM_MOTOR_IDLE , @ R0 
1490    F540          5745     	MOV	GOV_TARGET_L, A		; Set target to zero
1492    F541          5746     	MOV	GOV_TARGET_H, A
1494    F542          5747     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1496    F543          5748     	MOV	GOV_INTEGRAL_H, A
1498    F544          5749     	MOV	GOV_INTEGRAL_X, A
149A    F56C          5750     	MOV	ADC_CONVERSION_CNT, A
149C    F549          5751     	MOV	GOV_ACTIVE, A
149E    F52B          5752     	MOV	FLAGS0, A				; Clear flags0
14A0    F52C          5753     	MOV	FLAGS1, A				; Clear flags1
14A2    F539          5754     	MOV	DEMAG_CONSECUTIVE_CNT, A
14A4    120C55        5755     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5756     	;**** **** **** **** ****
                      5757     	; Motor start beginning
                      5758     	;**** **** **** **** **** 
14A7    756C08        5759     MOV ADC_CONVERSION_CNT , # 8 
                      5760     	SET_ADC_IP_TEMP
14AA    75BB10        5760+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
14AD    1207EF        5761     	CALL WAIT1MS
14B0    120B72        5762     	CALL START_ADC_CONVERSION
                      5763     READ_INITIAL_TEMP: 
                      5764     	GET_ADC_STATUS 
14B3    E5E8          5764+1   MOV A , ADC0CN 
14B5    20ECFB        5765     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5766     	READ_ADC_RESULT						; Read initial temperature
14B8    A8BD          5766+1   MOV R0 , ADC0L 
14BA    A9BE          5766+1   MOV R1 , ADC0H 
14BC    E9            5767     MOV A , R1 
14BD    7001          5768     	JNZ	($+3)							; Is reading below 256?
                      5769     
14BF    F8            5770     MOV R0 , A 
                      5771     
14C0    886D          5772     MOV CURRENT_AVERAGE_TEMP , R0 
14C2    120B76        5773     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14C5    756C08        5774     MOV ADC_CONVERSION_CNT , # 8 
                      5775     	SET_ADC_IP_TEMP
14C8    75BB10        5775+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5776     
                      5777     	; Go to the desired startup mode
14CB    7895          5778     MOV R0 , # PGM_STARTUP_METHOD 
14CD    E6            5779     MOV A , @ R0 
14CE    30E003        5780     	JNB	ACC.0, DIRECT_METHOD_START
                      5781     
14D1    021515        5782     	JMP	STEPPER_METHOD_START
                      5783     
                      5784     DIRECT_METHOD_START: 
                      5785     	; Set up start operating conditions
14D4    7887          5786     MOV R0 , # PGM_PWM_FREQ 
14D6    E6            5787     MOV A , @ R0 
14D7    FE            5788     MOV R6 , A 
14D8    7602          5789     MOV @ R0 , # 2 
14DA    317E          5790     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
14DC    7887          5791     MOV R0 , # PGM_PWM_FREQ 
14DE    EE            5792     MOV A , R6 
14DF    F6            5793     MOV @ R0 , A 
                      5794     	; Set max allowed power
14E0    D261          5795     SETB FLAGS1 . 1 
14E2    C2AF          5796     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
14E4    755EFF        5797     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
14E7    120C25        5798     	CALL SET_STARTUP_PWM
14EA    85225E        5799     	MOV	PWM_LIMIT, REQUESTED_PWM
14ED    85225F        5800     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
14F0    D2AF          5801     	SETB	EA
14F2    C261          5802     CLR FLAGS1 . 1 
14F4    752501        5803     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
14F7    855D64        5804     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
14FA    756501        5805     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5806     	; Begin startup sequence
14FD    D260          5807     SETB FLAGS1 . 0 
14FF    D263          5808     SETB FLAGS1 . 3 
1501    753800        5809     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1504    120FF5        5810     	CALL COMM5COMM6				; Initialize commutation
1507    1130          5811     	CALL COMM6COMM1				
1509    120CCF        5812     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
150C    120C55        5813     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
150F    120D52        5814     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
1512    02163D        5815     	JMP	RUN1
                      5816     
                      5817     
                      5818     STEPPER_METHOD_START: 
                      5819     	; Set up start operating conditions
1515    7887          5820     MOV R0 , # PGM_PWM_FREQ 
1517    E6            5821     MOV A , @ R0 
1518    FE            5822     MOV R6 , A 
1519    7603          5823     MOV @ R0 , # 3 
151B    7893          5824     MOV R0 , # PGM_DAMPING_FORCE 
151D    E6            5825     MOV A , @ R0 
151E    FD            5826     MOV R5 , A 
151F    7605          5827     MOV @ R0 , # 5 
1521    317E          5828     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1523    7887          5829     MOV R0 , # PGM_PWM_FREQ 
1525    EE            5830     MOV A , R6 
1526    F6            5831     MOV @ R0 , A 
1527    7893          5832     MOV R0 , # PGM_DAMPING_FORCE 
1529    ED            5833     MOV A , R5 
152A    F6            5834     MOV @ R0 , A 
                      5835     	; Begin startup sequence
152B    D260          5836     SETB FLAGS1 . 0 
152D    D261          5837     SETB FLAGS1 . 1 
152F    D265          5838     SETB FLAGS1 . 5 
1531    120FF5        5839     	CALL COMM5COMM6			; Initialize commutation
1534    1130          5840     	CALL COMM6COMM1			
1536    755EFF        5841     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1539    120C25        5842     	CALL SET_STARTUP_PWM
153C    1207EF        5843     	CALL WAIT1MS
153F    120EFD        5844     	CALL COMM1COMM2
1542    1207EF        5845     	CALL WAIT1MS
1545    1207EF        5846     	CALL WAIT1MS
1548    120F2F        5847     	CALL COMM2COMM3
154B    1207F4        5848     	CALL WAIT3MS			
154E    120F79        5849     	CALL COMM3COMM4
1551    1207F4        5850     	CALL WAIT3MS			
1554    1207F4        5851     	CALL WAIT3MS			
1557    120FB4        5852     	CALL COMM4COMM5
155A    1207F9        5853     	CALL WAIT10MS				; Settle rotor
155D    120FF5        5854     	CALL COMM5COMM6
1560    1207F4        5855     	CALL WAIT3MS				
1563    1207EF        5856     	CALL WAIT1MS			
1566    C261          5857     CLR FLAGS1 . 1 
1568    D262          5858     SETB FLAGS1 . 2 
                      5859     
                      5860     	;**** **** **** **** ****
                      5861     	; Stepper phase beginning
                      5862     	;**** **** **** **** **** 
                      5863     STEPPER_ROT_BEG: 
156A    120B72        5864     	CALL START_ADC_CONVERSION
156D    120B76        5865     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1570    120C25        5866     	CALL SET_STARTUP_PWM
1573    756C08        5867     MOV ADC_CONVERSION_CNT , # 8 
                      5868     	SET_ADC_IP_TEMP
1576    75BB10        5868+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5869     
1579    1130          5870     	CALL COMM6COMM1				; Commutate
157B    120CC8        5871     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
157E    120D52        5872     	CALL CALC_NEW_WAIT_TIMES
1581    11AD          5873     	CALL DECREMENT_STEPPER_STEP
1583    3112          5874     	CALL STEPPER_TIMER_WAIT
                      5875     
1585    120EFD        5876     	CALL COMM1COMM2			
1588    120CC8        5877     	CALL CALC_NEXT_COMM_TIMING_START	
158B    120D52        5878     	CALL CALC_NEW_WAIT_TIMES
158E    11AD          5879     	CALL DECREMENT_STEPPER_STEP
1590    3112          5880     	CALL STEPPER_TIMER_WAIT
                      5881     
1592    120F2F        5882     	CALL COMM2COMM3			
1595    120CC8        5883     	CALL CALC_NEXT_COMM_TIMING_START	
1598    120D52        5884     	CALL CALC_NEW_WAIT_TIMES
159B    11AD          5885     	CALL DECREMENT_STEPPER_STEP
159D    3112          5886     	CALL STEPPER_TIMER_WAIT
                      5887     
159F    120F79        5888     	CALL COMM3COMM4			
15A2    120CC8        5889     	CALL CALC_NEXT_COMM_TIMING_START	
15A5    120D52        5890     	CALL CALC_NEW_WAIT_TIMES
15A8    11AD          5891     	CALL DECREMENT_STEPPER_STEP
15AA    3112          5892     	CALL STEPPER_TIMER_WAIT
                      5893     
15AC    120FB4        5894     	CALL COMM4COMM5			
15AF    120CC8        5895     	CALL CALC_NEXT_COMM_TIMING_START	
15B2    120D52        5896     	CALL CALC_NEW_WAIT_TIMES
15B5    11AD          5897     	CALL DECREMENT_STEPPER_STEP
15B7    3112          5898     	CALL STEPPER_TIMER_WAIT
                      5899     
15B9    120FF5        5900     	CALL COMM5COMM6			
15BC    120CC8        5901     	CALL CALC_NEXT_COMM_TIMING_START	
15BF    120D52        5902     	CALL CALC_NEW_WAIT_TIMES
15C2    11AD          5903     	CALL DECREMENT_STEPPER_STEP	
                      5904     	; Check stepper step versus end criteria
15C4    C3            5905     	CLR	C
15C5    E550          5906     	MOV	A, WT_STEPPER_STEP_L
15C7    9535          5907     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
15C9    E551          5908     	MOV	A, WT_STEPPER_STEP_H
15CB    9536          5909     	SUBB	A, STEPPER_STEP_END_H
15CD    400C          5910     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5911     
                      5912     	; Wait for step
15CF    3112          5913     	CALL STEPPER_TIMER_WAIT
15D1    C3            5914     	CLR	C
15D2    E559          5915     	MOV	A, NEW_RCP				; Load new pulse value
15D4    9401          5916     SUBB A , # 1 
15D6    5092          5917     	JNC	STEPPER_ROT_BEG
                      5918     
15D8    02176E        5919     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5920     
                      5921     STEPPER_ROT_EXIT: 
                      5922     	; Wait for step
15DB    3112          5923     	CALL STEPPER_TIMER_WAIT
                      5924     	; Clear stepper phase
15DD    C262          5925     CLR FLAGS1 . 2 
                      5926     	; Set dondamped low pwm frequency
15DF    7887          5927     MOV R0 , # PGM_PWM_FREQ 
15E1    E6            5928     MOV A , @ R0 
15E2    FE            5929     MOV R6 , A 
15E3    7602          5930     MOV @ R0 , # 2 
15E5    317E          5931     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
15E7    7887          5932     MOV R0 , # PGM_PWM_FREQ 
15E9    EE            5933     MOV A , R6 
15EA    F6            5934     MOV @ R0 , A 
                      5935     	; Set spoolup power variables (power is now controlled from RCP)
15EB    85225E        5936     	MOV	PWM_LIMIT, REQUESTED_PWM
15EE    85605F        5937     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
15F1    856025        5938     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
15F4    855D64        5939     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15F7    756501        5940     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5941     	; Set direct startup phase to acquire sync quickly
15FA    D263          5942     SETB FLAGS1 . 3 
15FC    753800        5943     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15FF    C2AF          5944     	CLR	EA						; Disable interrupts
                      5945     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
1601    207502        5945+1   JB FLAGS3 . 5 , ( $+5 ) 
1604    C293          5945+1   CLR P1 . 3 
1606    307502        5945+1   JNB FLAGS3 . 5 , ( $+5 ) 
1609    C297          5945+1   CLR P1 . 7 
                      5946     	CPFET_OFF						; Cp off
160B    207502        5946+1   JB FLAGS3 . 5 , ( $+5 ) 
160E    C297          5946+1   CLR P1 . 7 
1610    307502        5946+1   JNB FLAGS3 . 5 , ( $+5 ) 
1613    C293          5946+1   CLR P1 . 3 
1615    742D          5947     	MOV	A, #45					; 8us delay for pfets to go off
1617    D5E0FD        5948     	DJNZ	ACC, $
161A    D2AF          5949     	SETB	EA						; Enable interrupts
161C    1130          5950     	CALL COMM6COMM1				
161E    120CCF        5951     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
1621    120D3E        5952     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
1624    120D52        5953     	CALL CALC_NEW_WAIT_TIMES
1627    120DE3        5954     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
162A    756C00        5955     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5956     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
162D    75BB09        5956+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1630    02163D        5957     	JMP	RUN1
                      5958     
                      5959     
                      5960     
                      5961     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5962     ;
                      5963     ; Run entry point
                      5964     ;
                      5965     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5966     DAMPED_TRANSITION: 
                      5967     	; Transition from nondamped to damped if applicable
1633    317E          5968     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1635    1130          5969     	CALL	COMM6COMM1
1637    756C00        5970     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5971     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
163A    75BB09        5971+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5972     
                      5973     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5974     ; Out_cA changes from low to high
                      5975     RUN1: 
163D    120E05        5976     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
1640    120E8A        5977     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1643    120EB5        5978     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1646    12091E        5979     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1649    120EC9        5980     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
164C    120EFD        5981     	CALL COMM1COMM2			; Commutate
164F    120CCF        5982     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1652    120D3E        5983     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1655    120D52        5984     	CALL CALC_NEW_WAIT_TIMES
1658    120DE3        5985     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5986     
                      5987     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5988     ; Out_cB changes from high to low
                      5989     RUN2: 
165B    120DFC        5990     	CALL WAIT_FOR_COMP_OUT_LOW
165E    120E8A        5991     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1661    120EB5        5992     	CALL SETUP_COMM_WAIT	
1664    12097B        5993     	CALL CALC_GOVERNOR_PROP_ERROR
1667    120EC9        5994     	CALL WAIT_FOR_COMM
166A    120F2F        5995     	CALL COMM2COMM3
166D    120CCF        5996     	CALL CALC_NEXT_COMM_TIMING
1670    120D3E        5997     	CALL WAIT_ADVANCE_TIMING
1673    120D52        5998     	CALL CALC_NEW_WAIT_TIMES
1676    120DE3        5999     	CALL WAIT_BEFORE_ZC_SCAN	
                      6000     
                      6001     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6002     ; Out_cC changes from low to high
                      6003     RUN3: 
1679    120E05        6004     	CALL WAIT_FOR_COMP_OUT_HIGH
167C    120E8A        6005     	CALL	EVALUATE_COMPARATOR_INTEGRITY
167F    120EB5        6006     	CALL SETUP_COMM_WAIT	
1682    1209B4        6007     	CALL CALC_GOVERNOR_INT_ERROR
1685    120EC9        6008     	CALL WAIT_FOR_COMM
1688    120F79        6009     	CALL COMM3COMM4
168B    120CCF        6010     	CALL CALC_NEXT_COMM_TIMING
168E    120D3E        6011     	CALL WAIT_ADVANCE_TIMING
1691    120D52        6012     	CALL CALC_NEW_WAIT_TIMES
1694    120DE3        6013     	CALL WAIT_BEFORE_ZC_SCAN	
                      6014     
                      6015     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6016     ; Out_cA changes from high to low
                      6017     RUN4: 
1697    120DFC        6018     	CALL WAIT_FOR_COMP_OUT_LOW
169A    120E8A        6019     	CALL	EVALUATE_COMPARATOR_INTEGRITY
169D    120EB5        6020     	CALL SETUP_COMM_WAIT	
16A0    120A11        6021     	CALL CALC_GOVERNOR_PROP_CORRECTION
16A3    120EC9        6022     	CALL WAIT_FOR_COMM
16A6    120FB4        6023     	CALL COMM4COMM5
16A9    120CCF        6024     	CALL CALC_NEXT_COMM_TIMING
16AC    120D3E        6025     	CALL WAIT_ADVANCE_TIMING
16AF    120D52        6026     	CALL CALC_NEW_WAIT_TIMES
16B2    120DE3        6027     	CALL WAIT_BEFORE_ZC_SCAN	
                      6028     
                      6029     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6030     ; Out_cB changes from low to high
                      6031     RUN5: 
16B5    120E05        6032     	CALL WAIT_FOR_COMP_OUT_HIGH
16B8    120E8A        6033     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16BB    120EB5        6034     	CALL SETUP_COMM_WAIT	
16BE    120A75        6035     	CALL CALC_GOVERNOR_INT_CORRECTION
16C1    120EC9        6036     	CALL WAIT_FOR_COMM
16C4    120FF5        6037     	CALL COMM5COMM6
16C7    120CCF        6038     	CALL CALC_NEXT_COMM_TIMING
16CA    120D3E        6039     	CALL WAIT_ADVANCE_TIMING
16CD    120D52        6040     	CALL CALC_NEW_WAIT_TIMES
16D0    120DE3        6041     	CALL WAIT_BEFORE_ZC_SCAN	
                      6042     
                      6043     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6044     ; Out_cC changes from high to low
                      6045     RUN6: 
16D3    120DFC        6046     	CALL WAIT_FOR_COMP_OUT_LOW
16D6    120B72        6047     	CALL START_ADC_CONVERSION
16D9    120E8A        6048     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16DC    120EB5        6049     	CALL SETUP_COMM_WAIT	
16DF    120B76        6050     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
16E2    120EC9        6051     	CALL WAIT_FOR_COMM
16E5    1130          6052     	CALL COMM6COMM1
16E7    120CCF        6053     	CALL CALC_NEXT_COMM_TIMING
16EA    120D3E        6054     	CALL WAIT_ADVANCE_TIMING
16ED    120D52        6055     	CALL CALC_NEW_WAIT_TIMES
16F0    120DE3        6056     	CALL WAIT_BEFORE_ZC_SCAN	
                      6057     
                      6058     	; Check if it is direct startup
16F3    306342        6059     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6060     
                      6061     	; Set spoolup power variables
16F6    85605E        6062     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
16F9    85605F        6063     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
16FC    855D64        6064     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
16FF    756501        6065     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6066     	; Check startup ok counter
1702    7964          6067     MOV R1 , # 100 
1704    7A14          6068     MOV R2 , # 20 
                      6069     IF MODE >= 1	; Tail or multi
1706    7888          6070     MOV R0 , # PGM_DIRECTION 
1708    E6            6071     MOV A , @ R0 
1709    B40304        6072     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6073     
170C    791E          6074     MOV R1 , # 30 
170E    7A05          6075     MOV R2 , # 5 
                      6076     
                      6077     DIRECT_START_PARAMS_SET: 
                      6078     ENDIF
1710    C3            6079     	CLR	C
1711    E538          6080     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
1713    99            6081     SUBB A , R1 
1714    4015          6082     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6083     
1716    C263          6084     CLR FLAGS1 . 3 
1718    D264          6085     SETB FLAGS1 . 4 
171A    8A37          6086     MOV STARTUP_ROT_CNT , R2 
                      6087     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6091     IF MODE == 2	; Multi
171C    7888          6092     MOV R0 , # PGM_DIRECTION 
171E    E6            6093     MOV A , @ R0 
171F    B40306        6094     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6095     
1722    755EFF        6096     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
1725    755FFF        6097     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6098     
                      6099     DIRECT_START_PWM_LIM_SET: 
                      6100     ENDIF
1728    021738        6101     	JMP	NORMAL_RUN_CHECKS
                      6102     
                      6103     DIRECT_START_CHECK_RCP: 
172B    C3            6104     	CLR	C
172C    E559          6105     	MOV	A, NEW_RCP				; Load new pulse value
172E    9401          6106     SUBB A , # 1 
1730    4003          6107     	JC	($+5)
                      6108     
1732    02163D        6109     	LJMP	RUN1						; Continue to run 
                      6110     
1735    02176E        6111     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6112     
                      6113     
                      6114     NORMAL_RUN_CHECKS: 
                      6115     	; Check if it is initial run phase
1738    306419        6116     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6117     
                      6118     	; Decrement startup rotaton count
173B    E537          6119     	MOV	A, STARTUP_ROT_CNT
173D    14            6120     	DEC	A
                      6121     	; Check number of nondamped rotations
173E    7005          6122     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6123     
1740    C264          6124     CLR FLAGS1 . 4 
1742    021633        6125     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6126     
                      6127     NORMAL_RUN_CHECK_STARTUP_ROT: 
1745    F537          6128     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6129     
1747    C3            6130     	CLR	C
1748    E559          6131     	MOV	A, NEW_RCP				; Load new pulse value
174A    9401          6132     SUBB A , # 1 
174C    4003          6133     	JC	($+5)
                      6134     
174E    02163D        6135     	LJMP	RUN1						; Continue to run 
                      6136     
1751    02176E        6137     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6138     
                      6139     
                      6140     INITIAL_RUN_PHASE_DONE: 
                      6141     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6154     	; Exit run loop after a given time
1754    C3            6155     	CLR	C
1755    E55C          6156     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1757    94FA          6157     SUBB A , # 250 
1759    5013          6158     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6159     
                      6160     RUN6_CHECK_RCP_TIMEOUT: 
175B    741F          6161     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
175D    552E          6162     	ANL	A, FLAGS3					; Check pwm frequency flags
175F    7004          6163     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6164     
1761    E528          6165     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1763    6009          6166     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6167     
                      6168     RUN6_CHECK_SPEED: 
1765    C3            6169     	CLR	C
1766    E53D          6170     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1768    94F0          6171     	SUBB	A, #0F0H
176A    5002          6172     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
176C    C13D          6173     	JMP	RUN1						; Go back to run 1
                      6174     
                      6175     
                      6176     RUN_TO_WAIT_FOR_POWER_ON: 	
176E    C2AF          6177     	CLR	EA
1770    119B          6178     	CALL SWITCH_POWER_OFF
1772    7887          6179     MOV R0 , # PGM_PWM_FREQ 
1774    E6            6180     MOV A , @ R0 
1775    FE            6181     MOV R6 , A 
1776    7602          6182     MOV @ R0 , # 2 
1778    317E          6183     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
177A    7887          6184     MOV R0 , # PGM_PWM_FREQ 
177C    EE            6185     MOV A , R6 
177D    F6            6186     MOV @ R0 , A 
177E    E4            6187     	CLR	A
177F    F522          6188     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1781    F523          6189     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1783    F524          6190     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1785    F525          6191     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1787    F561          6192     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1789    C260          6193     CLR FLAGS1 . 0 
178B    D2AF          6194     	SETB	EA
178D    1207EF        6195     	CALL	WAIT1MS					; Wait for pwm to be stopped
1790    119B          6196     	CALL SWITCH_POWER_OFF
                      6197     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6228     IF MODE >= 1	; Tail or multi
1792    741F          6229     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1794    552E          6230     	ANL	A, FLAGS3					; Check pwm frequency flags
1796    7006          6231     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6232     
1798    E528          6233     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
179A    7002          6234     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6235     
179C    6169          6236     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6237     
                      6238     JMP_WAIT_FOR_POWER_ON: 
179E    8110          6239     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6240     ENDIF
                      6241     
                      6242     
                      6243     END
MACRO ASSEMBLER BLHELI                                      05/25/15 23:44:33 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1745H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E50H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D23H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B76H   A 
MEASURE_LIPO_WAIT~  C ADDR   0AE8H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AA2H   A 
GOVERNOR_CORR_NEG~  C ADDR   0A64H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0075H   A 
HOLD_FULL_H. . . .  N NUMB   0002h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
INIT_START . . . .  C ADDR   147DH   A 
FIND_THROTTLE_GAI~  C ADDR   1265H   A 
COMM45_NFET. . . .  C ADDR   0FD9H   A 
COMM45_NONDAMP . .  C ADDR   0FD6H   A 
COMM4COMM5 . . . .  C ADDR   0FB4H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D48H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C09H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0073H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   1239H   A 
GOVERNOR_CHECK_PWM  C ADDR   09F1H   A 
GOVERNOR_ACTIVATE.  C ADDR   0943H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
WAIT_FOR_POWER_ON.  C ADDR   1410H   A 
SET_DEFAULT_PARAM~  C ADDR   1118H   A 
COMM56_NONDAMP . .  C ADDR   101CH   A 
COMM23_CP. . . . .  C ADDR   0F67H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CCFH   A 
COMM5COMM6 . . . .  C ADDR   0FF5H   A 
CALC_GOVERNOR_INT~  C ADDR   0A7CH   A 
CALC_GOVERNOR_TAR~  C ADDR   097AH   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   1282H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   156AH   A 
DECODE_THROTTLE_R~  C ADDR   122BH   A 
STEPPER_STEP_MED_~  C ADDR   0CA1H   A 
INITIALIZE_ALL_TI~  C ADDR   0C55H   A 
STARTUP_PWM_SET_P~  C ADDR   0C49H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0077H   A 
HOLD_FULL_L. . . .  N NUMB   00EEh            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   1369H   A 
COMM61_CP. . . . .  C ADDR   1078H   A 
COMM_EXIT. . . . .  C ADDR   1087H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D2AH   A 
CALC_GOVERNOR_INT~  C ADDR   0A75H   A 
LSSS . . . . . . .  C ADDR   07A1H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   163DH   A 
CLEAR_RAM. . . . .  C ADDR   12E5H   A 
SET_BEC_VOLTAGE. .  C ADDR   1255H   A 
DECODE_GOVERNOR_G~  C ADDR   1212H   A 
DEC_STEP_HIGH. . .  C ADDR   10DBH   A 
WAIT_FOR_COMM. . .  C ADDR   0EC9H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D71H   A 
MEASURE_LIPO_ADD_~  C ADDR   0B65H   A 
CALC_GOVERNOR_PRO~  C ADDR   09B3H   A 
DIV_U16_BY_U16_DI~  C ADDR   0897H   A 
WAIT100MS. . . . .  C ADDR   0803H   A 
WAIT1MS. . . . . .  C ADDR   07EFH   A 
ENDIF_STATE. . . .  C ADDR   07A8H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   1728H   A 
RUN2 . . . . . . .  C ADDR   165BH   A 
COMM45_CP. . . . .  C ADDR   0FECH   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DE3H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B6DH   A 
GOVERNOR_CORR_INT~  C ADDR   0AC1H   A 
GOVERNOR_STORE_PR~  C ADDR   09AFH   A 
DIV_U16_BY_U16_DI~  C ADDR   08A1H   A 
WAIT200MS. . . . .  C ADDR   0808H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   1679H   A 
DIRECT_METHOD_STA~  C ADDR   14D4H   A 
DECODE_DAMPING_DO~  C ADDR   11BAH   A 
PWM_WAIT . . . . .  C ADDR   0E75H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C19H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0AA9H   A 
GOVERNOR_CHECK_IN~  C ADDR   09D9H   A 
DIV_U16_BY_U16_DI~  C ADDR   08B8H   A 
WAIT3MS. . . . . .  C ADDR   07F4H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   179EH   A 
DIRECT_START_CHEC~  C ADDR   172BH   A 
RUN4 . . . . . . .  C ADDR   1697H   A 
STORE_TIMES_UP_OR~  C ADDR   0DC3H   A 
STORE_TIMES_DECRE~  C ADDR   0DD6H   A 
STEPPER_STEP_SET .  C ADDR   0CBBH   A 
TEMP_AVERAGE_INC .  C ADDR   0BA9H   A 
GOVERNOR_CORR_INT~  C ADDR   0AD2H   A 
MULT_S16_BY_U8_DI~  C ADDR   08C7H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   16B5H   A 
COMP_READ. . . . .  C ADDR   0E7BH   A 
COMP_WAIT_SET_RES~  C ADDR   0E3CH   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D77H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AC6H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A4H   A 
GOVERNOR_TARGET_C~  C ADDR   0926H   A 
CALC_GOVERNOR_TAR~  C ADDR   091EH   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   16D3H   A 
ARMING_START . . .  C ADDR   13D8H   A 
MEASURE_PWM_FREQ_~  C ADDR   136DH   A 
DECREMENT_STEP_EX~  C ADDR   1108H   A 
COMM_RETURN. . . .  C ADDR   109AH   A 
GOVERNOR_DEACTIVA~  C ADDR   0930H   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   13E2H   A 
EVALUATE_COMPARAT~  C ADDR   0E8AH   A 
TEMP_CHECK_EXIT. .  C ADDR   0BD3H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A4BH   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
NORMAL_RUN_CHECKS.  C ADDR   1738H   A 
DEC_STEP_MED_LOW .  C ADDR   10F6H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E0BH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D3EH   A 
CALC_GOVERNOR_PRO~  C ADDR   097BH   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0EE3H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1247H   A 
EVAL_COMP_EXIT . .  C ADDR   0EB4H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E9CH   A 
STEPPER_STEP_LOW .  C ADDR   0CAFH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B2AH   A 
PCA_INT_SET_TIMEO~  C ADDR   07BBH   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   15DBH   A 
STEPPER_METHOD_ST~  C ADDR   1515H   A 
DECODE_PARAMS_DIR~  C ADDR   11F4H   A 
COMM12_DAMP. . . .  C ADDR   0F07H   A 
SETUP_COMM_WAIT. .  C ADDR   0EB5H   A 
CALC_NEXT_COMM_TI~  C ADDR   0CC8H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BFFH   A 
CALC_GOVERNOR_INT~  C ADDR   0A10H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   13EEH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DFCH   A 
LOAD_MIN_TIME. . .  C ADDR   0D93H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D52H   A 
SET_STARTUP_PWM. .  C ADDR   0C25H   A 
GOVERNOR_STORE_IN~  C ADDR   0A0AH   A 
GOVERNOR_ACTIVATE~  C ADDR   096DH   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   175BH   A 
DECREMENT_STEP . .  C ADDR   10B9H   A 
COMM23_DAMP. . . .  C ADDR   0F37H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EE5H   A 
ADJUST_TIMING. . .  C ADDR   0D97H   A 
STEPPER_STEP_MED_~  C ADDR   0C85H   A 
MEASURE_LIPO_DIVI~  C ADDR   0B4AH   A 
MEASURE_LIPO_START  C ADDR   0AD7H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A74H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A05H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09ABH   A 
BEEP_F1. . . . . .  C ADDR   081FH   A 
WAIT1S_LOOP. . . .  C ADDR   081AH   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
INITIAL_RUN_PHASE~  C ADDR   1754H   A 
TEST_THROTTLE_GAIN  C ADDR   1273H   A 
STEPPER_STEP_MED .  C ADDR   0C93H   A 
GOVERNOR_STORE_PR~  C ADDR   0A72H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A36H   A 
MULT_S16_BY_U8_PO~  C ADDR   08E1H   A 
DIV_U16_BY_U16 . .  C ADDR   088FH   A 
BEEP_ONOFF . . . .  C ADDR   0842H   A 
BEEP_F2. . . . . .  C ADDR   0826H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   1256H   A 
DECREMENT_STEPPER~  C ADDR   10ADH   A 
COMM61_DAMP. . . .  C ADDR   1038H   A 
COMM34_DAMP. . . .  C ADDR   0F8BH   A 
TEMP_AVERAGE_INC_~  C ADDR   0B99H   A 
GOVERNOR_INT_MAX_~  C ADDR   09FEH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09E2H   A 
BEEP_F3. . . . . .  C ADDR   082DH   A 
SET_PWM_IN_HIGH. .  C ADDR   0791H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
DAMPED_TRANSITION.  C ADDR   1633H   A 
BEEP_DELAY_SET . .  C ADDR   1438H   A 
LOCK_BYTE_OK . . .  C ADDR   12A1H   A 
DECODE_PWM_FREQ_L~  C ADDR   120CH   A 
DECODE_DAMPING_3 .  C ADDR   1192H   A 
CALC_NEW_WAIT_RED~  C ADDR   0D62H   A 
BEEP_F4. . . . . .  C ADDR   0834H   A 
SET_PWM_IN . . . .  C ADDR   0793H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
DIRECT_START_PARA~  C ADDR   1710H   A 
DECODE_DAMPING_4 .  C ADDR   119CH   A 
COMM45_DAMP. . . .  C ADDR   0FBCH   A 
WAIT_FOR_COMM_SET~  C ADDR   0EF5H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BB1H   A 
GOVERNOR_APPLY_IN~  C ADDR   0AADH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A41H   A 
BEEP_OFF . . . . .  C ADDR   0883H   A 
WAIT10MS . . . . .  C ADDR   07F9H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
RESET_CAL_DONE . .  C ADDR   12BDH   A 
DECODE_DAMPING_5 .  C ADDR   11A6H   A 
DECODE_PARAMETERS.  C ADDR   117EH   A 
STEPPER_TIMER_WAIT  C ADDR   1112H   A 
STORE_TIMES_INCRE~  C ADDR   0DC9H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BF8H   A 
MEASURE_LIPO_CELLS  C ADDR   0AD7H   A 
CALC_GOVERNOR_INT~  C ADDR   09B4H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07D5H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
RUN6_CHECK_SPEED .  C ADDR   1765H   A 
WAIT_FOR_POWER_ON~  C ADDR   1464H   A 
DECODE_DAMPING_6 .  C ADDR   11B0H   A 
DEC_STEP_LOW . . .  C ADDR   10FFH   A 
COMM56_DAMP. . . .  C ADDR   1007H   A 
SWITCH_POWER_OFF .  C ADDR   109BH   A 
WAIT30MS . . . . .  C ADDR   07FEH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0075h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   176EH   A 
EVAL_COMP_CHECK_T~  C ADDR   0EAAH   A 
ADJUST_TIMING_TWO~  C ADDR   0DB9H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C24H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A18H   A 
GOVERNOR_ACTIVATE~  C ADDR   0974H   A 
WAIT1S . . . . . .  C ADDR   0818H   A 
WAITXMS_M. . . . .  C ADDR   080FH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0074H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   14B3H   A 
WAIT_FOR_POWER_ON~  C ADDR   1455H   A 
DECODE_PWM_FREQ_E~  C ADDR   1211H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0EF7H   A 
PWM_WAIT_STARTUP .  C ADDR   0E70H   A 
START_ADC_CONVERS~  C ADDR   0B72H   A 
MULT_S16_BY_U8_EX~  C ADDR   0915H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   13A3H   A 
LOCK_BYTE_TEST . .  C ADDR   129AH   A 
DEC_STEP_MED_HIGH.  C ADDR   10E4H   A 
COMM_RESTORE_POWER  C ADDR   1098H   A 
COMM12_NONDAMP . .  C ADDR   0F1CH   A 
COMM1COMM2 . . . .  C ADDR   0EFDH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0BAFH   A 
TEMP_AVERAGE_DEC .  C ADDR   0BA5H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A11H   A 
WAITXMS_O. . . . .  C ADDR   080DH   A 
PCA_INT_PPM_TIMEO~  C ADDR   07C7H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
WAIT_FOR_POWER_ON~  C ADDR   1415H   A 
DEC_STEP_MED . . .  C ADDR   10EDH   A 
READ_TIMER . . . .  C ADDR   0CD3H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BD7H   A 
CALC_GOVERNOR_INT~  C ADDR   0AD6H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09EBH   A 
MULT_S16_BY_U8_DI~  C ADDR   08FAH   A 
BEEP . . . . . . .  C ADDR   083BH   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0076H   A 
HOLD_CRUISE_L. . .  N NUMB   0030h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
COMM23_NFET. . . .  C ADDR   0F54H   A 
COMM23_NONDAMP . .  C ADDR   0F51H   A 
COMM2COMM3 . . . .  C ADDR   0F2FH   A 
STEPPER_STEP_HIGH.  C ADDR   0C77H   A 
MEASURE_LIPO_CELL~  C ADDR   0B0FH   A 
GOVERNOR_STORE_IN~  C ADDR   0AD4H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A96H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A5FH   A 
GOVERNOR_ACTIVATE~  C ADDR   0961H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B71H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A47H   A 
GOVERNOR_CHECK_PR~  C ADDR   0998H   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   136BH   A 
COMM61_NFET. . . .  C ADDR   105DH   A 
COMM61_NONDAMP . .  C ADDR   105AH   A 
COMM6COMM1 . . . .  C ADDR   1030H   A 
COMM34_NONDAMP . .  C ADDR   0F98H   A 
COMM3COMM4 . . . .  C ADDR   0F79H   A 
COMP_WAIT_SET_MAX~  C ADDR   0E29H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E05H   A 
STARTUP_PWM_EXIT .  C ADDR   0C54H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B61H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A70H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6018    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     87    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
