MACRO ASSEMBLER BLHELI                                      05/25/15 13:56:17 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=159) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
  009F                  49     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        50     
                        51     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                  52     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                        53     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                       663     ENDIF
                       664     
                       665     ;**** **** **** **** ****
                       666     ; TX programming defaults
                       667     ;
                       668     ; Parameter dependencies:
                       669     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       670     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       671     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       672     ; - Damping force is only used if DampedLight or Damped is selected
                       673     ;
                       674     ; Multi
  0009                 675     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 676     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 677     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 678     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 679     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 680     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 681     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 682     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 683     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 684     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       685     IF DAMPED_MODE_ENABLE == 1
  0001                 686     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       687     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 690     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 691     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 692     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                 693     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0028                 694     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 40	; Beacon strength
  0005                 695     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       696     ; Common
  0000                 697     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1=Enabled 	0=Disabled
  0003                 698     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 699     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 700     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (used in bidirectional mode)
  0000                 701     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       702     
                       703     ;**** **** **** **** ****
                       704     ; Constant definitions for multi
                       705     IF MODE == 2
                       706     
  0001                 707     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       708     
  000A                 709     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 710     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 711     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 712     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 713     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 714     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 715     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 716     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       717     
  0032                 718     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 719     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       720     
  000A                 721     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 722     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       723     
  0008                 724     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       725     
                       726     ENDIF
                       727     
                       728     ;**** **** **** **** ****
                       729     ; Temporary register definitions
  REG                  730     TEMP1		EQU	R0
  REG                  731     TEMP2		EQU	R1
  REG                  732     TEMP3		EQU	R2
  REG                  733     TEMP4		EQU	R3
  REG                  734     TEMP5		EQU	R4
  REG                  735     TEMP6		EQU	R5
  REG                  736     TEMP7		EQU	R6
  REG                  737     TEMP8		EQU	R7
                       738     
                       739     ;**** **** **** **** ****
                       740     ; Register definitions
------                 741     DSEG AT 20H					; Variables segment 
                       742     
0020                   743     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   744     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       745     
0022                   746     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   747     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   748     CURRENT_PWM: 				DS	1		; Current pwm
0025                   749     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   750     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   751     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   752     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   753     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   754     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       755     
002B                   756     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 757     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 758     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 759     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 760     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 761     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       762     ;						EQU 	5
                       763     ;						EQU 	6
                       764     ;						EQU 	7
                       765     
002C                   766     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 767     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 768     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 769     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 770     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 771     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 772     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 773     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       774     ;						EQU 	7
                       775     
002D                   776     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 777     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 778     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 779     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 780     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 781     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 782     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       783     ;						EQU 	6	
                       784     ;						EQU 	7	
                       785     
002E                   786     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 787     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 788     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 789     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 790     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 791     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 792     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 793     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 794     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       795     
                       796     ;**** **** **** **** ****
                       797     ; RAM definitions
------                 798     DSEG AT 30H						; Ram data segment, direct addressing
                       799     
0030                   800     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       801     
0031                   802     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   803     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       804     
0033                   805     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   806     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   807     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   808     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   809     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   810     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   811     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       812     
003A                   813     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   814     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   815     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   816     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   817     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   818     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       819     
0040                   820     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   821     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   822     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   823     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   824     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   825     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   826     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   827     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   828     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   829     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       830     
004A                   831     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   832     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   833     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   834     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   835     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   836     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   837     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   838     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       839     
0052                   840     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   841     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   842     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   843     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   844     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   845     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   846     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   847     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   848     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   849     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   850     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   851     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       852     
005E                   853     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   854     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   855     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   856     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   857     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   858     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       859     
0064                   860     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   861     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       862     
0066                   863     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   864     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       865     
0068                   866     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   867     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   868     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   869     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   870     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       871     
006D                   872     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       873     
006E                   874     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   875     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       876     
0070                   877     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   878     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   879     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       880     
                       881     ; Indirect addressing data segment. The variables below must be in this sequence
------                 882     ISEG AT 080H					
0080                   883     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                   884     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                   885     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                   886     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                   887     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                   888     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                   889     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                   890     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                   891     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                   892     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                   893     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                   894     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                   895     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                   896     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                   897     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                   898     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                   899     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                   900     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                   901     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                   902     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                   903     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                   904     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                   905     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                   906     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                   907     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                   908     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                   909     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                   910     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                   911     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                   912     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                   913     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                       914     
                       915     ; The sequence of the variables below is no longer of importance
009F                   916     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                   917     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                   918     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                   919     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                   920     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                       921     
                       922     
                       923     ; Indirect addressing data segment
------                 924     ISEG AT 0D0H					
00D0                   925     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                       926     
                       927     
                       928     ;**** **** **** **** ****
------                 929     CSEG AT 1A00H            ; "Eeprom" segment
  000B                 930     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                 931     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                 932     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                       933     
1A00    0B             934     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02             935     EEP_FW_SUB_REVISION:  DB 2 
1A02    11             936     EEP_LAYOUT_REVISION:  DB 17 
                       937     
                       938     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                       971     
                       972     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1005     
                      1006     IF MODE == 2
1A03    09            1007     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1008     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1009     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1010     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1011     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1012     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1013     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1014     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1015     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1016     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1017     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1018     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1019     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1020     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1021     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1022     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1023     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1024     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1025     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1026     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1027     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1028     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1029     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1030     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    28            1031     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    28            1032     EEP_PGM_BEACON_STRENGTH:  DB 40 
1A1D    05            1033     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1034     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1035     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1036     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1037     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1038     ENDIF
                      1039     
                      1040     
1A22    FF            1041     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1042     
------                1043     CSEG AT 1A60H
1A60    20202020      1044     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      1045     
                      1046     ;**** **** **** **** ****
                      1047             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1047+1   CSEG AT 0  ; CODE SEGMENT START
0000    02124B        1047+1   JMP RESET 
------                1047+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1047+1   JMP T0_INT 
------                1047+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1047+1   JMP T2_INT 
------                1047+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1047+1   JMP PCA_INT 
------                1047+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1047+1   JMP T3_INT 
------                1048     CSEG AT 80H			; Code segment after interrupt vectors 
                      1049     
                      1050     ;**** **** **** **** ****
                      1051     
                      1052     ; Table definitions
0080    02030406      1053     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1054     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1055     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1056     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1057     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1060     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1068     IF MODE == 2
                      1069       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1070     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1071       ENDIF
                      1072       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1075     ENDIF
                      1076     
                      1077     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1078     ;
                      1079     ; Timer0 interrupt routine
                      1080     ;
                      1081     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1082     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1083     ;
                      1084     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1085     T0_INT: 	; Used for pwm control
00BA    C2AF          1086     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1087     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1088     	PUSH	ACC		
                      1089     	; Check if pwm is on
00C0    205A10        1090     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1091     
                      1092     	; Do not execute pwm when stopped
00C3    30600A        1093     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1094     	; Do not execute pwm on during demag recovery
00C6    205C07        1095     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1096     	; Pwm on cycle. 
00C9    302F02        1097     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1098     
                      1099     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1100     	CLR	A					
00CD    73            1101     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1102     
                      1103     T0_INT_PWM_ON_LOW_PWM: 
                      1104     
                      1105     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1106     	JMP	T0_INT_PWM_ON_EXECUTE
                      1107     ENDIF
                      1108     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1125     
                      1126     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1127     	JMP	T0_INT_PWM_ON_EXIT
                      1128     
                      1129     
                      1130     T0_INT_PWM_OFF: 
00D3    306306        1131     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1132     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    C292          1132+1   CLR P1 . 2 
00D8    C296          1132+1   CLR P1 . 6 
00DA    C295          1132+1   CLR P1 . 5 
                      1133     T0_INT_PWM_OFF_START_CHECKED: 
                      1134     	; Pwm off cycle
00DC    85258A        1135     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1136     	; Clear pwm on flag
00DF    C25A          1137     CLR FLAGS0 . 2 
                      1138     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1139     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1140     	CPL	A						; Full pwm?
00E4    7002          1141     	JNZ	($+4)					; No - branch
00E6    21C6          1142     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1143     
00E8    0563          1144     	INC	PWM_OFF_CNT				; Increment event counter
                      1145     	; Do not execute pwm when stopped
00EA    306013        1146     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1147     
                      1148     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1149     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1150     
                      1151     	; Separate exit commands here for minimum delay
00F0    758B00        1152     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1153     	POP	ACC			; Restore preserved registers
00F5    D0D0          1154     	POP	PSW
                      1155     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    C292          1155+1   CLR P1 . 2 
00F9    C296          1155+1   CLR P1 . 6 
00FB    C295          1155+1   CLR P1 . 5 
00FD    D2AF          1156     	SETB	EA			; Enable all interrupts
00FF    32            1157     	RETI
                      1158     
                      1159     T0_INT_PWM_OFF_STOPPED: 
                      1160     	ALL_NFETS_OFF 					; Switch off all nfets
0100    C292          1160+1   CLR P1 . 2 
0102    C296          1160+1   CLR P1 . 6 
0104    C295          1160+1   CLR P1 . 5 
0106    0201B6        1161     	JMP	T0_INT_PWM_OFF_EXIT
                      1162     
                      1163     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1164     SETB FLAGS1 . 5 
010B    C266          1165     CLR FLAGS1 . 6 
010D    E567          1166     	MOV	A, DAMPING_ON
010F    601C          1167     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1168     
0111    C3            1169     	CLR	C
0112    E563          1170     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1171     	DEC	A
0115    9567          1172     	SUBB	A, DAMPING_ON
0117    4014          1173     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1174     
0119    C265          1175     CLR FLAGS1 . 5 
011B    D266          1176     SETB FLAGS1 . 6 
011D    C3            1177     	CLR	C
011E    E563          1178     	MOV	A, PWM_OFF_CNT					
0120    9566          1179     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1180     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1181     
0124    0201B6        1182     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1183     
                      1184     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1185     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1186     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1187     
                      1188     T0_INT_PWM_OFF_DO_DAMPED: 
                      1189     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1190     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1191     
                      1192     	ALL_NFETS_OFF 					; Switch off all nfets
0130    C292          1192+1   CLR P1 . 2 
0132    C296          1192+1   CLR P1 . 6 
0134    C295          1192+1   CLR P1 . 5 
0136    7406          1193     MOV A , # 6 
0138    D5E0FD        1194     	DJNZ	ACC, $	
                      1195     	ALL_PFETS_ON 					; Switch on all pfets
013B    D293          1195+1   SETB P1 . 3 
013D    D297          1195+1   SETB P1 . 7 
013F    D294          1195+1   SETB P1 . 4 
0141    0201B6        1196     	JMP	T0_INT_PWM_OFF_EXIT
                      1197     
                      1198     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1199     IF DAMPED_MODE_ENABLE == 1
0144    D266          1200     SETB FLAGS1 . 6 
                      1201     ENDIF
                      1202     	ALL_NFETS_OFF 					; Switch off all nfets
0146    C292          1202+1   CLR P1 . 2 
0148    C296          1202+1   CLR P1 . 6 
014A    C295          1202+1   CLR P1 . 5 
014C    E53E          1203     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1204     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1205     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1206     
                      1207     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1210     MOV A , # 6 
0156    D5E0FD        1211     	DJNZ	ACC, $	
                      1212     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1212+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D297          1212+1   SETB P1 . 7 
015E    307502        1212+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D293          1212+1   SETB P1 . 3 
                      1213     ENDIF
0163    0201B6        1214     	JMP	T0_INT_PWM_OFF_EXIT
                      1215     
                      1216     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1217     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1218     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1221     MOV A , # 6 
016B    D5E0FD        1222     	DJNZ	ACC, $	
                      1223     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1223+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D297          1223+1   SETB P1 . 7 
0173    307502        1223+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D293          1223+1   SETB P1 . 3 
                      1224     ENDIF
0178    0201B6        1225     	JMP	T0_INT_PWM_OFF_EXIT
                      1226     
                      1227     T0_INT_PWM_OFF_COMM_3: 
                      1228     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1231     MOV A , # 6 
017D    D5E0FD        1232     	DJNZ	ACC, $	
                      1233     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1233+1   SETB P1 . 4 
                      1234     ENDIF
0182    0201B6        1235     	JMP	T0_INT_PWM_OFF_EXIT
                      1236     
                      1237     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1238     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1239     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1240     
                      1241     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1244     MOV A , # 6 
018D    D5E0FD        1245     	DJNZ	ACC, $	
                      1246     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1246+1   SETB P1 . 4 
                      1247     ENDIF
0192    0201B6        1248     	JMP	T0_INT_PWM_OFF_EXIT
                      1249     
                      1250     T0_INT_PWM_OFF_COMM_5: 
                      1251     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1254     MOV A , # 6 
0197    D5E0FD        1255     	DJNZ	ACC, $	
                      1256     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1256+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D293          1256+1   SETB P1 . 3 
019F    307502        1256+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D297          1256+1   SETB P1 . 7 
                      1257     ENDIF
01A4    0201B6        1258     	JMP	T0_INT_PWM_OFF_EXIT
                      1259     
                      1260     T0_INT_PWM_OFF_COMM_6: 
                      1261     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1264     MOV A , # 6 
01A9    D5E0FD        1265     	DJNZ	ACC, $	
                      1266     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1266+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D293          1266+1   SETB P1 . 3 
01B1    307502        1266+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D297          1266+1   SETB P1 . 7 
                      1267     ENDIF
                      1268     
                      1269     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1270     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1271     	POP	ACC			; Restore preserved registers
01BB    D0D0          1272     	POP	PSW
                      1273     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    C292          1273+1   CLR P1 . 2 
01BF    C296          1273+1   CLR P1 . 6 
01C1    C295          1273+1   CLR P1 . 5 
01C3    D2AF          1274     	SETB	EA			; Enable all interrupts
01C5    32            1275     	RETI
                      1276     
                      1277     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1278     	POP	ACC			; Restore preserved registers
01C8    D0D0          1279     	POP	PSW
01CA    D2AF          1280     	SETB	EA			; Enable all interrupts
01CC    32            1281     	RETI
                      1282     
                      1283     
                      1284     
                      1285     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1286     	AJMP	T0_INT_PWM_ON_EXIT
                      1287     
                      1288     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1289     	ANFET_ON	
01CF    E525          1289+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1289+1   JZ ( $+12 ) 
01D3    207502        1289+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    D292          1289+1   SETB P1 . 2 
01D8    307502        1289+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    D296          1289+1   SETB P1 . 6 
                      1290     	BNFET_OFF
01DD    C295          1290+1   CLR P1 . 5 
01DF    61D3          1291     	AJMP	T0_INT_PWM_ON_EXIT
                      1292     
                      1293     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1294     	BNFET_ON
01E1    E525          1294+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1294+1   JZ ( $+4 ) 
01E5    D295          1294+1   SETB P1 . 5 
                      1295     	CNFET_OFF
01E7    207502        1295+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    C296          1295+1   CLR P1 . 6 
01EC    307502        1295+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    C292          1295+1   CLR P1 . 2 
01F1    61D3          1296     	AJMP	T0_INT_PWM_ON_EXIT
                      1297     
                      1298     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1299     	CNFET_ON
01F3    E525          1299+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1299+1   JZ ( $+12 ) 
01F7    207502        1299+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    D296          1299+1   SETB P1 . 6 
01FC    307502        1299+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    D292          1299+1   SETB P1 . 2 
                      1300     	ANFET_OFF
0201    207502        1300+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    C292          1300+1   CLR P1 . 2 
0206    307502        1300+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    C296          1300+1   CLR P1 . 6 
020B    61D3          1301     	AJMP	T0_INT_PWM_ON_EXIT
                      1302     
                      1303     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1304     	APFET_OFF
020D    207502        1304+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C293          1304+1   CLR P1 . 3 
0212    307502        1304+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C297          1304+1   CLR P1 . 7 
                      1305     	ANFET_ON								; Switch nFETs
0217    E525          1305+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1305+1   JZ ( $+12 ) 
021B    207502        1305+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    D292          1305+1   SETB P1 . 2 
0220    307502        1305+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    D296          1305+1   SETB P1 . 6 
                      1306     	CPFET_OFF
0225    207502        1306+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C297          1306+1   CLR P1 . 7 
022A    307502        1306+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C293          1306+1   CLR P1 . 3 
                      1307     	BNFET_OFF 							
022F    C295          1307+1   CLR P1 . 5 
0231    61D3          1308     	AJMP	T0_INT_PWM_ON_EXIT
                      1309     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1310     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1311     	APFET_OFF
0233    207502        1311+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C293          1311+1   CLR P1 . 3 
0238    307502        1311+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C297          1311+1   CLR P1 . 7 
                      1312     	CPFET_OFF
023D    207502        1312+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C297          1312+1   CLR P1 . 7 
0242    307502        1312+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C293          1312+1   CLR P1 . 3 
0247    7406          1313     MOV A , # 6 
0249    D5E0FD        1314     	DJNZ ACC,	$
                      1315     	ANFET_ON								; Switch nFETs
024C    E525          1315+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1315+1   JZ ( $+12 ) 
0250    207502        1315+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    D292          1315+1   SETB P1 . 2 
0255    307502        1315+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    D296          1315+1   SETB P1 . 6 
                      1316     	BNFET_OFF 							
025A    C295          1316+1   CLR P1 . 5 
025C    61D3          1317     	AJMP	T0_INT_PWM_ON_EXIT
                      1318     
                      1319     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1320     	APFET_OFF
025E    207502        1320+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C293          1320+1   CLR P1 . 3 
0263    307502        1320+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C297          1320+1   CLR P1 . 7 
                      1321     	ANFET_ON								; Switch nFETs
0268    E525          1321+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1321+1   JZ ( $+12 ) 
026C    207502        1321+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    D292          1321+1   SETB P1 . 2 
0271    307502        1321+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    D296          1321+1   SETB P1 . 6 
                      1322     	BPFET_OFF
0276    C294          1322+1   CLR P1 . 4 
                      1323     	BNFET_OFF								
0278    C295          1323+1   CLR P1 . 5 
027A    61D3          1324     	AJMP	T0_INT_PWM_ON_EXIT
                      1325     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1326     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1327     	APFET_OFF
027C    207502        1327+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C293          1327+1   CLR P1 . 3 
0281    307502        1327+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C297          1327+1   CLR P1 . 7 
                      1328     	BPFET_OFF
0286    C294          1328+1   CLR P1 . 4 
0288    7406          1329     MOV A , # 6 
028A    D5E0FD        1330     	DJNZ ACC,	$
                      1331     	ANFET_ON								; Switch nFETs
028D    E525          1331+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1331+1   JZ ( $+12 ) 
0291    207502        1331+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    D292          1331+1   SETB P1 . 2 
0296    307502        1331+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    D296          1331+1   SETB P1 . 6 
                      1332     	BNFET_OFF								
029B    C295          1332+1   CLR P1 . 5 
029D    61D3          1333     	AJMP	T0_INT_PWM_ON_EXIT
                      1334     
                      1335     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1336     	BPFET_OFF
029F    C294          1336+1   CLR P1 . 4 
                      1337     	BNFET_ON								; Switch nFETs
02A1    E525          1337+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1337+1   JZ ( $+4 ) 
02A5    D295          1337+1   SETB P1 . 5 
                      1338     	APFET_OFF
02A7    207502        1338+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C293          1338+1   CLR P1 . 3 
02AC    307502        1338+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C297          1338+1   CLR P1 . 7 
                      1339     	CNFET_OFF								
02B1    207502        1339+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    C296          1339+1   CLR P1 . 6 
02B6    307502        1339+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    C292          1339+1   CLR P1 . 2 
02BB    61D3          1340     	AJMP	T0_INT_PWM_ON_EXIT
                      1341     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1342     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1343     	BPFET_OFF
02BD    C294          1343+1   CLR P1 . 4 
                      1344     	APFET_OFF
02BF    207502        1344+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C293          1344+1   CLR P1 . 3 
02C4    307502        1344+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C297          1344+1   CLR P1 . 7 
02C9    7406          1345     MOV A , # 6 
02CB    D5E0FD        1346     	DJNZ ACC,	$
                      1347     	BNFET_ON								; Switch nFETs
02CE    E525          1347+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1347+1   JZ ( $+4 ) 
02D2    D295          1347+1   SETB P1 . 5 
                      1348     	CNFET_OFF								
02D4    207502        1348+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    C296          1348+1   CLR P1 . 6 
02D9    307502        1348+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    C292          1348+1   CLR P1 . 2 
02DE    61D3          1349     	AJMP	T0_INT_PWM_ON_EXIT
                      1350     
                      1351     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1352     	BPFET_OFF
02E0    C294          1352+1   CLR P1 . 4 
                      1353     	BNFET_ON								; Switch nFETs
02E2    E525          1353+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1353+1   JZ ( $+4 ) 
02E6    D295          1353+1   SETB P1 . 5 
                      1354     	CPFET_OFF
02E8    207502        1354+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C297          1354+1   CLR P1 . 7 
02ED    307502        1354+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C293          1354+1   CLR P1 . 3 
                      1355     	CNFET_OFF								
02F2    207502        1355+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    C296          1355+1   CLR P1 . 6 
02F7    307502        1355+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    C292          1355+1   CLR P1 . 2 
02FC    61D3          1356     	AJMP	T0_INT_PWM_ON_EXIT
                      1357     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1358     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1359     	BPFET_OFF
02FE    C294          1359+1   CLR P1 . 4 
                      1360     	CPFET_OFF
0300    207502        1360+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C297          1360+1   CLR P1 . 7 
0305    307502        1360+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C293          1360+1   CLR P1 . 3 
030A    7406          1361     MOV A , # 6 
030C    D5E0FD        1362     	DJNZ ACC,	$
                      1363     	BNFET_ON								; Switch nFETs
030F    E525          1363+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1363+1   JZ ( $+4 ) 
0313    D295          1363+1   SETB P1 . 5 
                      1364     	CNFET_OFF								
0315    207502        1364+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    C296          1364+1   CLR P1 . 6 
031A    307502        1364+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    C292          1364+1   CLR P1 . 2 
031F    61D3          1365     	AJMP	T0_INT_PWM_ON_EXIT
                      1366     
                      1367     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1368     	CPFET_OFF
0321    207502        1368+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C297          1368+1   CLR P1 . 7 
0326    307502        1368+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C293          1368+1   CLR P1 . 3 
                      1369     	CNFET_ON								; Switch nFETs
032B    E525          1369+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1369+1   JZ ( $+12 ) 
032F    207502        1369+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    D296          1369+1   SETB P1 . 6 
0334    307502        1369+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    D292          1369+1   SETB P1 . 2 
                      1370     	BPFET_OFF
0339    C294          1370+1   CLR P1 . 4 
                      1371     	ANFET_OFF								
033B    207502        1371+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    C292          1371+1   CLR P1 . 2 
0340    307502        1371+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    C296          1371+1   CLR P1 . 6 
0345    61D3          1372     	AJMP	T0_INT_PWM_ON_EXIT
                      1373     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1374     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1375     	CPFET_OFF
0347    207502        1375+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C297          1375+1   CLR P1 . 7 
034C    307502        1375+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C293          1375+1   CLR P1 . 3 
                      1376     	BPFET_OFF
0351    C294          1376+1   CLR P1 . 4 
0353    7406          1377     MOV A , # 6 
0355    D5E0FD        1378     	DJNZ ACC,	$
                      1379     	CNFET_ON								; Switch nFETs
0358    E525          1379+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1379+1   JZ ( $+12 ) 
035C    207502        1379+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    D296          1379+1   SETB P1 . 6 
0361    307502        1379+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    D292          1379+1   SETB P1 . 2 
                      1380     	ANFET_OFF								
0366    207502        1380+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    C292          1380+1   CLR P1 . 2 
036B    307502        1380+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    C296          1380+1   CLR P1 . 6 
0370    61D3          1381     	AJMP	T0_INT_PWM_ON_EXIT
                      1382     
                      1383     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1384     	CPFET_OFF
0372    207502        1384+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C297          1384+1   CLR P1 . 7 
0377    307502        1384+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C293          1384+1   CLR P1 . 3 
                      1385     	CNFET_ON								; Switch nFETs
037C    E525          1385+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1385+1   JZ ( $+12 ) 
0380    207502        1385+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    D296          1385+1   SETB P1 . 6 
0385    307502        1385+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    D292          1385+1   SETB P1 . 2 
                      1386     	APFET_OFF
038A    207502        1386+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C293          1386+1   CLR P1 . 3 
038F    307502        1386+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C297          1386+1   CLR P1 . 7 
                      1387     	ANFET_OFF								
0394    207502        1387+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    C292          1387+1   CLR P1 . 2 
0399    307502        1387+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    C296          1387+1   CLR P1 . 6 
039E    61D3          1388     	AJMP	T0_INT_PWM_ON_EXIT
                      1389     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1390     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1391     	CPFET_OFF
03A0    207502        1391+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C297          1391+1   CLR P1 . 7 
03A5    307502        1391+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C293          1391+1   CLR P1 . 3 
                      1392     	APFET_OFF
03AA    207502        1392+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C293          1392+1   CLR P1 . 3 
03AF    307502        1392+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C297          1392+1   CLR P1 . 7 
03B4    7406          1393     MOV A , # 6 
03B6    D5E0FD        1394     	DJNZ ACC,	$
                      1395     	CNFET_ON								; Switch nFETs
03B9    E525          1395+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1395+1   JZ ( $+12 ) 
03BD    207502        1395+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    D296          1395+1   SETB P1 . 6 
03C2    307502        1395+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    D292          1395+1   SETB P1 . 2 
                      1396     	ANFET_OFF								
03C7    207502        1396+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    C292          1396+1   CLR P1 . 2 
03CC    307502        1396+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    C296          1396+1   CLR P1 . 6 
03D1    61D3          1397     	AJMP	T0_INT_PWM_ON_EXIT
                      1398     
                      1399     T0_INT_PWM_ON_EXIT: 
                      1400     	; Set timer for coming on cycle length
03D3    E525          1401     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1402     	CPL	A						; cpl is 255-x
03D6    F58A          1403     	MOV	TL0, A					; Write start point for timer
                      1404     	; Set other variables
03D8    758B00        1405     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1406     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1407     SETB FLAGS0 . 2 
                      1408     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1409     	; Exit interrupt
03E0    D0E0          1410     	POP	ACC			; Restore preserved registers
03E2    D0D0          1411     	POP	PSW
03E4    D2AF          1412     	SETB	EA			; Enable all interrupts
03E6    32            1413     	RETI
                      1414     
                      1415     
                      1416     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1417     ;
                      1418     ; Timer2 interrupt routine
                      1419     ;
                      1420     ; No assumptions
                      1421     ;
                      1422     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1423     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1424     	CLR	EA
03E9    C2AD          1425     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1426     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1427     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1428     	PUSH	ACC
03F2    D2D3          1429     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1430     	SETB	EA
                      1431     	; Clear low byte interrupt flag
03F6    C2CE          1432     	CLR	TF2L						; Clear interrupt flag
                      1433     	; Check RC pulse timeout counter
03F8    E528          1434     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1435     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1436     
                      1437     	; Decrement timeout counter (if PWM)
03FC    741F          1438     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1439     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1440     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1441     
0402    1528          1442     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1443     	AJMP	T2_INT_SKIP_START
                      1444     
                      1445     T2_INT_PULSES_ABSENT: 
                      1446     	; Timeout counter has reached zero, pulses are absent
0406    7800          1447     MOV R0 , # 0 
0408    7900          1448     MOV R1 , # 0 
                      1449     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1449+1   MOV A , P0 
040C    307601        1449+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1449+1   CPL A  ; YES - INVERT
0410    30E502        1450     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1451     MOV R0 , # 255 
                      1452     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1452+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1452+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1452+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1452+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1452+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1453     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1453+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1454     CLR FLAGS2 . 1 
                      1455     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1455+1   MOV A , P0 
042A    307601        1455+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1455+1   CPL A  ; YES - INVERT
042E    30E502        1456     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1457     MOV R1 , # 255 
0433    C3            1458     	CLR	C
0434    E8            1459     MOV A , R0 
0435    99            1460     SUBB A , R1 
0436    70CE          1461     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1462     
0438    305903        1463     JNB FLAGS0 . 1 , ( $+6 ) 
                      1464     
043B    752818        1465     MOV RCP_TIMEOUT_CNT , # 24 
                      1466     
043E    741F          1467     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1468     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1469     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1470     
0444    752818        1471     MOV RCP_TIMEOUT_CNT , # 24 
                      1472     
                      1473     T2_INT_PPM_TIMEOUT_SET: 
0447    8859          1474     MOV NEW_RCP , R0 
0449    D268          1475     SETB FLAGS2 . 0 
                      1476     
                      1477     T2_INT_SKIP_START: 
                      1478     	; Check RC pulse skip counter
044B    E529          1479     	MOV	A, RCP_SKIP_CNT			
044D    6004          1480     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1481     	
                      1482     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1483     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1484     	AJMP	T2_INT_RCP_UPDATE_START
                      1485     
                      1486     T2_INT_SKIP_END: 
0453    741F          1487     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1488     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1489     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1490     
                      1491     	; Skip counter has reached zero, start looking for RC pulses again
                      1492     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1492+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1493     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1493+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1494     	
                      1495     T2_INT_RCP_UPDATE_START: 
                      1496     	; Process updated RC pulse
045E    206802        1497     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1498     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1499     
0463    E559          1500     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1501     MOV R0 , A 
0466    C268          1502     CLR FLAGS2 . 0 
                      1503     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1504     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1505     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1506     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1507     
                      1508     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1511     
                      1512     IF MODE == 2	; Multi
046E    7982          1513     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1514     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1515     ENDIF
                      1516     
                      1517     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1518     	CLR	C
0474    E8            1519     MOV A , R0 
0475    94F0          1520     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1521     	JC	T2_INT_RCP_UPDATE_MULT
                      1522     
0479    74F0          1523     	MOV	A, #240			; Set requested pwm to max
047B    F8            1524     MOV R0 , A 
                      1525     
                      1526     T2_INT_RCP_UPDATE_MULT: 	
                      1527     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1528     MOV A , R0 
047D    C4            1529     	SWAP	A			; After this "0.0625"
047E    540F          1530     	ANL	A, #0FH
0480    28            1531     ADD A , R0 
0481    F8            1532     MOV R0 , A 
                      1533     	; Adjust tail gain
0482    7984          1534     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1535     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1536     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1537     
0489    C3            1538     	CLR	C
048A    13            1539     	RRC	A			; After this "0.5"
048B    C3            1540     	CLR	C
048C    13            1541     	RRC	A			; After this "0.25"
048D    8721          1542     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1543     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1544     
0492    C3            1545     	CLR	C
0493    13            1546     	RRC	A			; After this "0.125"
                      1547     
                      1548     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1549     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1550     
0497    C3            1551     	CLR	C
0498    C8            1552     XCH A , R0 
0499    98            1553     SUBB A , R0 
049A    F8            1554     MOV R0 , A 
049B    81A4          1555     	AJMP	T2_INT_PWM_MIN_RUN
                      1556     
                      1557     T2_INT_RCP_GAIN_POS: 
049D    28            1558     ADD A , R0 
049E    F8            1559     MOV R0 , A 
049F    5003          1560     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1561     
04A1    74FF          1562     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1563     MOV R0 , A 
                      1564     
                      1565     T2_INT_PWM_MIN_RUN:  
                      1566     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1576     
                      1577     T2_INT_PWM_UPDATE:  
                      1578     	; Check if any startup phase flags are set
04A4    E52C          1579     	MOV	A, FLAGS1
04A6    5406          1580     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1581     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1582     
                      1583     	; Update requested_pwm
04AA    8822          1584     MOV REQUESTED_PWM , R0 
                      1585     	; Limit pwm during direct start
04AC    30630A        1586     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1587     
04AF    C3            1588     	CLR	C
04B0    E522          1589     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1590     	SUBB	A, PWM_LIMIT
04B4    4003          1591     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1592     
04B6    855E22        1593     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1594     
                      1595     T2_INT_CURRENT_PWM_UPDATE:  
                      1596     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1597     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1598     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1599     ENDIF
                      1600     
                      1601     	; Update current pwm, with limited throttle change rate
04BE    C3            1602     	CLR	C
04BF    E522          1603     	MOV	A, REQUESTED_PWM	 
04C1    9524          1604     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1605     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1606     
                      1607     	; 
                      1608     	; mov	Temp1, #Pgm_Throttle_Rate_Decoded		
04C5    7801          1609     MOV R0 , # 1 
                      1610     	; subb	A, @Temp1					; Is difference larger than throttle change rate?
04C7    98            1611     SUBB A , R0 
04C8    400D          1612     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1613     
04CA    E524          1614     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
                      1615     	; add	A, @Temp1
04CC    28            1616     ADD A , R0 
04CD    F524          1617     	MOV	CURRENT_PWM, A
04CF    5009          1618     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1619     
04D1    7524FF        1620     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1621     	JMP	T2_INT_CURRENT_PWM_DONE
                      1622     
                      1623     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1624     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1625     T2_INT_CURRENT_PWM_DONE: 
                      1626     IF MODE >= 1	; Tail or multi
                      1627     	; Set current_pwm_limited
04DA    A824          1628     MOV R0 , CURRENT_PWM 
04DC    C3            1629     	CLR	C
04DD    E524          1630     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1631     	SUBB	A, PWM_LIMIT
04E1    4002          1632     	JC	($+4)					; If current pwm below limit - branch
                      1633     
04E3    A85E          1634     MOV R0 , PWM_LIMIT 
                      1635     
04E5    8825          1636     MOV CURRENT_PWM_LIMITED , R0 
                      1637     ENDIF
                      1638     T2_INT_PWM_EXIT: 	
                      1639     	; Check if high byte flag is set
04E7    20CF0C        1640     	JB	TF2H, T2H_INT		
04EA    D0E0          1641     	POP	ACC			; Restore preserved registers
04EC    D0D0          1642     	POP	PSW
04EE    C2D3          1643     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1644     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1645     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1646     	RETI
                      1647     
                      1648     T2H_INT: 
                      1649     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1650     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1651     MOV R0 , # 1 
                      1652     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1653     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1654     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1655     
                      1656     	; Decrement timeout counter (if PPM)
04FE    741F          1657     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1658     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1659     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1660     
0504    1528          1661     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1662     
                      1663     T2H_INT_RCP_STOP_CHECK: 
                      1664     	; Check RC pulse against stop value
0506    C3            1665     	CLR	C
0507    E559          1666     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1667     SUBB A , # 1 
050B    4005          1668     	JC	T2H_INT_RCP_STOP
                      1669     
                      1670     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1671     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1672     	AJMP	T2H_INT_RCP_GOV_PWM
                      1673     
                      1674     T2H_INT_RCP_STOP: 	
                      1675     	; RC pulse less than stop value
0512    755D00        1676     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1677     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1678     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1679     	ADD	A, #1
051C    F55C          1680     	MOV	RCP_STOP_CNT, A
051E    5003          1681     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1682     
0520    755CFF        1683     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1684     
                      1685     T2H_INT_RCP_GOV_PWM: 
                      1686     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1815     IF MODE == 2	; Multi
0523    E55F          1816     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1817     	ADD	A, #10
0527    5005          1818     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1819     
0529    755FFF        1820     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1821     	AJMP	T2H_INT_RCP_EXIT
                      1822     
                      1823     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1824     	MOV	PWM_LIMIT_SPOOLUP, A
                      1825     ENDIF
                      1826     
                      1827     T2H_INT_RCP_EXIT: 
0530    D0E0          1828     	POP	ACC			; Restore preserved registers
0532    D0D0          1829     	POP	PSW
0534    C2D3          1830     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1831     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1832     	SETB	ET2			; Enable timer2 interrupts
053B    32            1833     	RETI
                      1834     
                      1835     
                      1836     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1837     ;
                      1838     ; Timer3 interrupt routine
                      1839     ;
                      1840     ; No assumptions
                      1841     ;
                      1842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1843     T3_INT: 	; Used for commutation timing
053C    C2AF          1844     	CLR 	EA			; Disable all interrupts
053E    53917F        1845     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1846     CLR FLAGS0 . 0 
0543    D2AF          1847     	SETB	EA			; Enable all interrupts
0545    32            1848     	RETI
                      1849     
                      1850     
                      1851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1852     ;
                      1853     ; PCA interrupt routine
                      1854     ;
                      1855     ; No assumptions
                      1856     ;
                      1857     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1858     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          1859     	CLR	EA
0548    53E6EF        1860     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          1861     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          1862     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          1863     	PUSH	ACC
0551    C0F0          1864     	PUSH	B
0553    D2D3          1865     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          1866     	SETB	EA
                      1867     	; Get the PCA counter values
                      1868     	GET_RCP_CAPTURE_VALUES
0557    A8FB          1868+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          1868+1   MOV R1 , PCA0CPH0 
                      1869     	; Clear interrupt flag
                      1870     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          1870+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1871     	; Check which edge it is
055D    306902        1872     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B1          1873     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      1874     
                      1875     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        1875+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        1875+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        1875+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        1875+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        1875+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          1876     SETB FLAGS2 . 1 
                      1877     	; Read RC signal level
                      1878     	READ_RCP_INT			
0573    E580          1878+1   MOV A , P0 
0575    307601        1878+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            1878+1   CPL A  ; YES - INVERT
                      1879     	; Test RC signal level
0579    20E502        1880     JB ACC . 5 , ( $+5 ) 
057C    A185          1881     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      1882     
                      1883     	; RC pulse was high, store RC pulse start timestamp
057E    8826          1884     MOV RCP_PREV_EDGE_L , R0 
0580    8927          1885     MOV RCP_PREV_EDGE_H , R1 
0582    0207B1        1886     	LJMP	PCA_INT_EXIT				; Exit
                      1887     
                      1888     PCA_INT_FAIL_MINIMUM: 
                      1889     	; Prepare for next interrupt
                      1890     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        1890+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        1890+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        1890+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        1890+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        1890+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1891     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          1891+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          1892     CLR FLAGS2 . 1 
0598    741F          1893     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          1894     	ANL	A, FLAGS3					; Check pwm frequency flags
059C    7002          1895     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      1896     
059E    E197          1897     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      1898     
05A0    7800          1899     MOV R0 , # 0 
                      1900     	READ_RCP_INT 					; Test RC signal level again
05A2    E580          1900+1   MOV A , P0 
05A4    307601        1900+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A7    F4            1900+1   CPL A  ; YES - INVERT
05A8    30E502        1901     JNB ACC . 5 , ( $+5 ) 
05AB    E197          1902     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      1903     
05AD    8859          1904     MOV NEW_RCP , R0 
05AF    E186          1905     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      1906     
                      1907     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      1908     	; Prepare for next interrupt
                      1909     	RCP_INT_FIRST 					; Set first edge trig
05B1    53DACF        1909+1   ANL PCA0CPM0 , # 0CFH 
05B4    207603        1909+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B7    43DA20        1909+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BA    307603        1909+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BD    43DA10        1909+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C0    C269          1910     CLR FLAGS2 . 1 
                      1911     	; Check if pwm frequency shall be measured
05C2    205902        1912     JB FLAGS0 . 1 , ( $+5 ) 
05C5    C16B          1913     	AJMP	PCA_INT_FALL				; No - skip measurements
                      1914     
                      1915     	; Set second edge trig only during pwm frequency measurement
                      1916     	RCP_INT_SECOND 				; Set second edge trig
05C7    53DACF        1916+1   ANL PCA0CPM0 , # 0CFH 
05CA    207603        1916+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CD    43DA10        1916+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D0    307603        1916+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D3    43DA20        1916+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      1917     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D6    C2D8          1917+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05D8    D269          1918     SETB FLAGS2 . 1 
                      1919     	; Store edge data to RAM
05DA    8854          1920     MOV RCP_EDGE_L , R0 
05DC    8955          1921     MOV RCP_EDGE_H , R1 
                      1922     	; Calculate pwm frequency
05DE    C3            1923     	CLR	C
05DF    E8            1924     MOV A , R0 
05E0    9552          1925     	SUBB	A, RCP_PREPREV_EDGE_L	
05E2    F8            1926     MOV R0 , A 
05E3    E9            1927     MOV A , R1 
05E4    9553          1928     	SUBB	A, RCP_PREPREV_EDGE_H
05E6    F9            1929     MOV R1 , A 
05E7    E4            1930     	CLR	A
05E8    FB            1931     MOV R3 , A 
05E9    7AFA          1932     MOV R2 , # 250 
                      1933     	; Check if pwm frequency is 12kHz
05EB    C3            1934     	CLR	C
05EC    E8            1935     MOV A , R0 
05ED    94C8          1936     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05EF    E9            1937     MOV A , R1 
05F0    9400          1938     	SUBB	A, #HIGH(200)
05F2    5008          1939     	JNC	PCA_INT_CHECK_8KHZ
                      1940     
05F4    E4            1941     	CLR	A
05F5    D2E4          1942     SETB ACC . 4 
05F7    FB            1943     MOV R3 , A 
05F8    7A0A          1944     MOV R2 , # 10 
05FA    C13E          1945     	AJMP	PCA_INT_RESTORE_EDGE
                      1946     
                      1947     PCA_INT_CHECK_8KHZ: 
                      1948     	; Check if pwm frequency is 8kHz
05FC    C3            1949     	CLR	C
05FD    E8            1950     MOV A , R0 
05FE    9468          1951     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0600    E9            1952     MOV A , R1 
0601    9401          1953     	SUBB	A, #HIGH(360)
0603    5008          1954     	JNC	PCA_INT_CHECK_4KHZ
                      1955     
0605    E4            1956     	CLR	A
0606    D2E3          1957     SETB ACC . 3 
0608    FB            1958     MOV R3 , A 
0609    7A0F          1959     MOV R2 , # 15 
060B    C13E          1960     	AJMP	PCA_INT_RESTORE_EDGE
                      1961     
                      1962     PCA_INT_CHECK_4KHZ: 
                      1963     	; Check if pwm frequency is 4kHz
060D    C3            1964     	CLR	C
060E    E8            1965     MOV A , R0 
060F    94D0          1966     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0611    E9            1967     MOV A , R1 
0612    9402          1968     	SUBB	A, #HIGH(720)
0614    5008          1969     	JNC	PCA_INT_CHECK_2KHZ
                      1970     
0616    E4            1971     	CLR	A
0617    D2E2          1972     SETB ACC . 2 
0619    FB            1973     MOV R3 , A 
061A    7A1E          1974     MOV R2 , # 30 
061C    C13E          1975     	AJMP	PCA_INT_RESTORE_EDGE
                      1976     
                      1977     PCA_INT_CHECK_2KHZ: 
                      1978     	; Check if pwm frequency is 2kHz
061E    C3            1979     	CLR	C
061F    E8            1980     MOV A , R0 
0620    94A0          1981     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0622    E9            1982     MOV A , R1 
0623    9405          1983     	SUBB	A, #HIGH(1440)
0625    5008          1984     	JNC	PCA_INT_CHECK_1KHZ
                      1985     
0627    E4            1986     	CLR	A
0628    D2E1          1987     SETB ACC . 1 
062A    FB            1988     MOV R3 , A 
062B    7A3C          1989     MOV R2 , # 60 
062D    C13E          1990     	AJMP	PCA_INT_RESTORE_EDGE
                      1991     
                      1992     PCA_INT_CHECK_1KHZ: 
                      1993     	; Check if pwm frequency is 1kHz
062F    C3            1994     	CLR	C
0630    E8            1995     MOV A , R0 
0631    9498          1996     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0633    E9            1997     MOV A , R1 
0634    9408          1998     	SUBB	A, #HIGH(2200)
0636    5006          1999     	JNC	PCA_INT_RESTORE_EDGE
                      2000     
0638    E4            2001     	CLR	A
0639    D2E0          2002     SETB ACC . 0 
063B    FB            2003     MOV R3 , A 
063C    7A78          2004     MOV R2 , # 120 
                      2005     
                      2006     PCA_INT_RESTORE_EDGE: 
                      2007     	; Calculate difference between this period and previous period
063E    C3            2008     	CLR	C
063F    E8            2009     MOV A , R0 
0640    9556          2010     	SUBB	A, RCP_PREV_PERIOD_L
0642    FC            2011     MOV R4 , A 
0643    E9            2012     MOV A , R1 
0644    9557          2013     	SUBB	A, RCP_PREV_PERIOD_H
0646    FD            2014     MOV R5 , A 
                      2015     	; Make positive
0647    30E708        2016     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064A    EC            2017     MOV A , R4 
064B    F4            2018     	CPL	A
064C    2401          2019     	ADD	A, #1
064E    FC            2020     MOV R4 , A 
064F    ED            2021     MOV A , R5 
0650    F4            2022     	CPL	A
0651    FD            2023     MOV R5 , A 
                      2024     
                      2025     PCA_INT_CHECK_DIFF: 
                      2026     	; Check difference
0652    755800        2027     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0655    7008          2028     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2029     
0657    C3            2030     	CLR	C
0658    EC            2031     MOV A , R4 
0659    9A            2032     SUBB A , R2 
065A    5003          2033     	JNC	PCA_INT_STORE_DATA
                      2034     
065C    755801        2035     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2036     
                      2037     PCA_INT_STORE_DATA: 
                      2038     	; Store previous period
065F    8856          2039     MOV RCP_PREV_PERIOD_L , R0 
0661    8957          2040     MOV RCP_PREV_PERIOD_H , R1 
                      2041     	; Restore edge data from RAM
0663    A854          2042     MOV R0 , RCP_EDGE_L 
0665    A955          2043     MOV R1 , RCP_EDGE_H 
                      2044     	; Store pre previous edge
0667    8852          2045     MOV RCP_PREPREV_EDGE_L , R0 
0669    8953          2046     MOV RCP_PREPREV_EDGE_H , R1 
                      2047     
                      2048     PCA_INT_FALL: 
                      2049     	; RC pulse edge was second, calculate new pulse length
066B    C3            2050     	CLR	C
066C    E8            2051     MOV A , R0 
066D    9526          2052     	SUBB	A, RCP_PREV_EDGE_L	
066F    F8            2053     MOV R0 , A 
0670    E9            2054     MOV A , R1 
0671    9527          2055     	SUBB	A, RCP_PREV_EDGE_H
0673    F9            2056     MOV R1 , A 
0674    307402        2057     JNB FLAGS3 . 4 , ( $+5 ) 
0677    E16A          2058     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0679    307302        2059     JNB FLAGS3 . 3 , ( $+5 ) 
067C    E16A          2060     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2061     
067E    307202        2062     JNB FLAGS3 . 2 , ( $+5 ) 
0681    E163          2063     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2064     
0683    E9            2065     MOV A , R1 
0684    C3            2066     	CLR	C
0685    13            2067     	RRC	A
0686    F9            2068     MOV R1 , A 
0687    E8            2069     MOV A , R0 
0688    13            2070     	RRC	A
0689    F8            2071     MOV R0 , A 
                      2072     
068A    307102        2073     JNB FLAGS3 . 1 , ( $+5 ) 
068D    E163          2074     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2075     
068F    E9            2076     MOV A , R1 
0690    C3            2077     	CLR	C
0691    13            2078     	RRC	A
0692    F9            2079     MOV R1 , A 
0693    E8            2080     MOV A , R0 
0694    13            2081     	RRC	A
0695    F8            2082     MOV R0 , A 
                      2083     
0696    307002        2084     JNB FLAGS3 . 0 , ( $+5 ) 
0699    E163          2085     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2086     
069B    E9            2087     MOV A , R1 
069C    C3            2088     	CLR	C
069D    13            2089     	RRC	A
069E    FD            2090     MOV R5 , A 
069F    E8            2091     MOV A , R0 
06A0    13            2092     	RRC	A
06A1    FC            2093     MOV R4 , A 
                      2094     	; Skip range limitation if pwm frequency measurement
06A2    205918        2095     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2096     
                      2097     	; Check if 2160us or above (in order to ignore false pulses)
06A5    C3            2098     	CLR	C
06A6    EC            2099     MOV A , R4 
06A7    941C          2100     	SUBB	A, #28
06A9    ED            2101     MOV A , R5 
06AA    9402          2102     	SUBB A, #2
06AC    4003          2103     	JC	($+5)						; No - proceed
                      2104     
06AE    020797        2105     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2106     
                      2107     	; Check if below 800us (in order to ignore false pulses)
06B1    ED            2108     MOV A , R5 
06B2    7009          2109     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2110     
06B4    C3            2111     	CLR	C
06B5    EC            2112     MOV A , R4 
06B6    94C8          2113     	SUBB	A, #200
06B8    5003          2114     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2115     
06BA    020797        2116     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2117     
                      2118     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2119     	; Calculate "1000us" plus throttle minimum
06BD    7400          2120     	MOV	A, #0						; Set 1000us as default minimum
06BF    20770B        2121     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2122     
                      2123     IF MODE >= 1	; Tail or multi
06C2    7888          2124     MOV R0 , # PGM_DIRECTION 
06C4    E6            2125     MOV A , @ R0 
                      2126     ENDIF
06C5    7896          2127     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2128     IF MODE >= 1	; Tail or multi
06C7    B40302        2129     	CJNE	A, #3, ($+5)
                      2130     
06CA    789E          2131     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2132     ENDIF
06CC    E6            2133     MOV A , @ R0 
                      2134     
                      2135     PCA_INT_PPM_CALCULATE: 
06CD    24FA          2136     	ADD	A, #250						; Add 1000us to minimum
06CF    FE            2137     MOV R6 , A 
06D0    E4            2138     	CLR	A
06D1    3400          2139     	ADDC	A, #0
06D3    FF            2140     MOV R7 , A 
                      2141     
06D4    C3            2142     	CLR	C
06D5    EC            2143     MOV A , R4 
06D6    9E            2144     SUBB A , R6 
06D7    FC            2145     MOV R4 , A 
06D8    ED            2146     MOV A , R5 
06D9    9F            2147     SUBB A , R7 
06DA    FD            2148     MOV R5 , A 
                      2149     IF MODE >= 1	; Tail or multi
06DB    9208          2150     	MOV	BIT_ACCESS_INT.0, C
06DD    7888          2151     MOV R0 , # PGM_DIRECTION 
06DF    E6            2152     MOV A , @ R0 
06E0    B40322        2153     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2154     
06E3    A208          2155     	MOV	C, BIT_ACCESS_INT.0
06E5    5009          2156     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2157     
                      2158     PCA_INT_PPM_BIDIR_REV: 
06E7    20751B        2159     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2160     
06EA    C2AF          2161     	CLR	EA							; Direction change, turn off all fets
06EC    D275          2162     SETB FLAGS3 . 5 
06EE    C1F7          2163     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2164     
                      2165     PCA_INT_PPM_BIDIR_FWD: 
06F0    307512        2166     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2167     
06F3    C2AF          2168     	CLR	EA							; Direction change, turn off all fets
06F5    C275          2169     CLR FLAGS3 . 5 
                      2170     
                      2171     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2172     	ALL_NFETS_OFF
06F7    C292          2172+1   CLR P1 . 2 
06F9    C296          2172+1   CLR P1 . 6 
06FB    C295          2172+1   CLR P1 . 5 
                      2173     	ALL_PFETS_OFF
06FD    C293          2173+1   CLR P1 . 3 
06FF    C297          2173+1   CLR P1 . 7 
0701    C294          2173+1   CLR P1 . 4 
0703    D2AF          2174     	SETB	EA
                      2175     
                      2176     PCA_INT_PPM_BIDIR_DIR_SET: 
0705    A208          2177     	MOV	C, BIT_ACCESS_INT.0
                      2178     ENDIF
0707    5017          2179     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2180     
                      2181     IF MODE >= 1	; Tail or multi
0709    E6            2182     MOV A , @ R0 
070A    B4030D        2183     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2184     
070D    EC            2185     MOV A , R4 
070E    F4            2186     	CPL	A
070F    2401          2187     	ADD	A, #1
0711    FC            2188     MOV R4 , A 
0712    ED            2189     MOV A , R5 
0713    F4            2190     	CPL	A
0714    3400          2191     	ADDC	A, #0
0716    FD            2192     MOV R5 , A 
0717    020720        2193     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2194     
                      2195     PCA_INT_PPM_UNIDIR_NEG: 
                      2196     ENDIF
071A    7800          2197     MOV R0 , # 0 
071C    7900          2198     MOV R1 , # 0 
071E    E16A          2199     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2200     
                      2201     PCA_INT_PPM_NEG_CHECKED: 
                      2202     IF MODE >= 1	; Tail or multi
0720    7888          2203     MOV R0 , # PGM_DIRECTION 
0722    E6            2204     MOV A , @ R0 
0723    B40315        2205     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2206     
0726    EC            2207     MOV A , R4 
0727    33            2208     	RLC	A
0728    FC            2209     MOV R4 A 
0729    ED            2210     MOV A , R5 
072A    33            2211     	RLC	A
072B    FD            2212     MOV R5 A 
072C    C3            2213     	CLR	C							; Subtract deadband
072D    EC            2214     MOV A , R4 
072E    9405          2215     	SUBB	A, #5		
0730    FC            2216     MOV R4 , A 
0731    ED            2217     MOV A , R5 
0732    9400          2218     	SUBB	A, #0
0734    FD            2219     MOV R5 , A 
0735    5004          2220     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2221     
0737    7C00          2222     MOV R4 , # 0 
0739    7D00          2223     MOV R5 , # 0 
                      2224     
                      2225     PCA_INT_PPM_BIDIR_DONE: 
                      2226     ENDIF
073B    C3            2227     	CLR	C							; Check that RC pulse is within legal range (max 255)
073C    EC            2228     MOV A , R4 
073D    94FF          2229     SUBB A , # 255 
073F    ED            2230     MOV A , R5 
0740    9400          2231     	SUBB	A, #0
0742    4006          2232     	JC	PCA_INT_PPM_MAX_CHECKED
                      2233     
0744    78FF          2234     MOV R0 , # 255 
0746    7900          2235     MOV R1 , # 0 
0748    E16A          2236     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2237     
                      2238     PCA_INT_PPM_MAX_CHECKED: 
074A    EC            2239     MOV A , R4 
074B    856EF0        2240     	MOV	B, PPM_THROTTLE_GAIN
074E    A4            2241     	MUL	AB
074F    C5F0          2242     	XCH	A, B
0751    A2F7          2243     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0753    33            2244     	RLC	A
0754    F8            2245     MOV R0 , A 
0755    7900          2246     MOV R1 , # 0 
0757    4003          2247     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2248     	
0759    020786        2249     	JMP	PCA_INT_LIMITED			
                      2250     
                      2251     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075C    78FF          2252     MOV R0 , # 255 
075E    7900          2253     MOV R1 , # 0 
0760    020786        2254     	JMP	PCA_INT_LIMITED			
                      2255     
                      2256     PCA_INT_PWM_DIVIDE: 
0763    E9            2257     MOV A , R1 
0764    C3            2258     	CLR	C
0765    13            2259     	RRC	A
0766    F9            2260     MOV R1 , A 
0767    E8            2261     MOV A , R0 
0768    13            2262     	RRC	A
0769    F8            2263     MOV R0 , A 
                      2264     
                      2265     PCA_INT_PWM_DIVIDE_DONE: 
076A    30740E        2266     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076D    E9            2267     MOV A , R1 
076E    6002          2268     	JZ	($+4)
                      2269     
0770    78FF          2270     MOV R0 , # 255 
                      2271     
0772    C3            2272     	CLR	C
0773    E8            2273     MOV A , R0 
0774    13            2274     	RRC	A
0775    38            2275     ADDC A , R0 
0776    F8            2276     MOV R0 , A 
0777    E4            2277     	CLR	A
0778    3400          2278     	ADDC	A, #0
077A    F9            2279     MOV R1 , A 
                      2280     
                      2281     PCA_INT_CHECK_LEGAL_RANGE: 
                      2282     	; Check that RC pulse is within legal range
077B    C3            2283     	CLR	C
077C    E8            2284     MOV A , R0 
077D    94FF          2285     SUBB A , # 255 
077F    E9            2286     MOV A , R1 
0780    9400          2287     	SUBB	A, #0
0782    4002          2288     	JC	PCA_INT_LIMITED
                      2289     
0784    78FF          2290     MOV R0 , # 255 
                      2291     
                      2292     PCA_INT_LIMITED: 
                      2293     	; RC pulse value accepted
0786    8859          2294     MOV NEW_RCP , R0 
0788    D268          2295     SETB FLAGS2 . 0 
078A    205902        2296     JB FLAGS0 . 1 , ( $+5 ) 
078D    E197          2297     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2298     
078F    741F          2299     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0791    F4            2300     	CPL	A
0792    552E          2301     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0794    4B            2302     ORL A , R3 
0795    F52E          2303     	MOV	FLAGS3, A
                      2304     
                      2305     PCA_INT_SET_TIMEOUT: 
0797    752818        2306     MOV RCP_TIMEOUT_CNT , # 24 
079A    741F          2307     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
079C    552E          2308     	ANL	A, FLAGS3					; Check pwm frequency flags
079E    7003          2309     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2310     
07A0    75280A        2311     MOV RCP_TIMEOUT_CNT , # 10 
                      2312     
                      2313     PCA_INT_PPM_TIMEOUT_SET: 
07A3    305902        2314     JNB FLAGS0 . 1 , ( $+5 ) 
07A6    E1B1          2315     	AJMP PCA_INT_EXIT				; Yes - exit
                      2316     
07A8    741F          2317     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07AA    552E          2318     	ANL	A, FLAGS3					; Check pwm frequency flags
07AC    6003          2319     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2320     
                      2321     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
07AE    53DAFE        2321+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2322     
                      2323     PCA_INT_EXIT: 	; Exit interrupt routine	
07B1    752906        2324     MOV RCP_SKIP_CNT , # 6 
07B4    741F          2325     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
07B6    552E          2326     	ANL	A, FLAGS3					; Check pwm frequency flags
07B8    7003          2327     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2328     
07BA    75290A        2329     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2330     
07BD    D0F0          2331     	POP	B			; Restore preserved registers
07BF    D0E0          2332     	POP	ACC			
07C1    D0D0          2333     	POP	PSW
07C3    C2D3          2334     	CLR	PSW.3		; Select register bank 0 for main program routines	
07C5    D2AD          2335     	SETB	ET2			; Enable timer2 interrupts
07C7    43E610        2336     	ORL	EIE1, #10H	; Enable PCA0 interrupts
07CA    32            2337     	RETI
                      2338     
                      2339     
                      2340     
                      2341     
                      2342     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2343     ;
                      2344     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2345     ;
                      2346     ; No assumptions
                      2347     ;
                      2348     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2349     WAIT1MS: 	
07CB    7901          2350     MOV R1 , # 1 
07CD    0207E9        2351     	JMP	WAITXMS_O
                      2352     
                      2353     WAIT3MS: 	
07D0    7903          2354     MOV R1 , # 3 
07D2    0207E9        2355     	JMP	WAITXMS_O
                      2356     
                      2357     WAIT10MS: 	
07D5    790A          2358     MOV R1 , # 10 
07D7    0207E9        2359     	JMP	WAITXMS_O
                      2360     
                      2361     WAIT30MS: 	
07DA    791E          2362     MOV R1 , # 30 
07DC    0207E9        2363     	JMP	WAITXMS_O
                      2364     
                      2365     WAIT100MS: 	
07DF    7964          2366     MOV R1 , # 100 
07E1    0207E9        2367     	JMP	WAITXMS_O
                      2368     
                      2369     WAIT200MS: 	
07E4    79C8          2370     MOV R1 , # 200 
07E6    0207E9        2371     	JMP	WAITXMS_O
                      2372     
                      2373     WAITXMS_O: 	; Outer loop
07E9    7817          2374     MOV R0 , # 23 
                      2375     WAITXMS_M: 	; Middle loop
07EB    E4            2376     	CLR	A
07EC    D5E0FD        2377      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
07EF    D8FA          2378     DJNZ R0 , WAITXMS_M 
07F1    D9F6          2379     DJNZ R1 , WAITXMS_O 
07F3    22            2380     	RET
                      2381     
                      2382     
                      2383     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2384     ;
                      2385     ; Beeper routines (4 different entry points) 
                      2386     ;
                      2387     ; No assumptions
                      2388     ;
                      2389     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2390     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
07F4    7A14          2391     MOV R2 , # 20 
07F6    7B78          2392     MOV R3 , # 120 
07F8    020810        2393     	JMP	BEEP
                      2394     
                      2395     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
07FB    7A10          2396     MOV R2 , # 16 
07FD    7B8C          2397     MOV R3 , # 140 
07FF    020810        2398     	JMP	BEEP
                      2399     
                      2400     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0802    7A0D          2401     MOV R2 , # 13 
0804    7BB4          2402     MOV R3 , # 180 
0806    020810        2403     	JMP	BEEP
                      2404     
                      2405     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
0809    7A0B          2406     MOV R2 , # 11 
080B    7BC8          2407     MOV R3 , # 200 
080D    020810        2408     	JMP	BEEP
                      2409     
                      2410     BEEP: 	; Beep loop start
0810    AC25          2411     MOV R4 , CURRENT_PWM_LIMITED 
0812    752501        2412     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0815    7902          2413     MOV R1 , # 2 
                      2414     BEEP_ONOFF: 
0817    B275          2415     CPL FLAGS3 . 5 
0819    E4            2416     	CLR	A
                      2417     	BPFET_OFF			; BpFET off
081A    C294          2417+1   CLR P1 . 4 
081C    D5E0FD        2418     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2419     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
081F    E525          2419+1   MOV A , CURRENT_PWM_LIMITED 
0821    6002          2419+1   JZ ( $+4 ) 
0823    D295          2419+1   SETB P1 . 5 
0825    D5E0FD        2420     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2421     	BNFET_OFF			; BnFET off again
0828    C295          2421+1   CLR P1 . 5 
082A    D5E0FD        2422     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2423     	BPFET_ON			; BpFET on
082D    D294          2423+1   SETB P1 . 4 
082F    D5E0FD        2424     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2425     	; Turn on nfet
                      2426     	ANFET_ON			; AnFET on
0832    E525          2426+1   MOV A , CURRENT_PWM_LIMITED 
0834    600A          2426+1   JZ ( $+12 ) 
0836    207502        2426+1   JB FLAGS3 . 5 , ( $+5 ) 
0839    D292          2426+1   SETB P1 . 2 
083B    307502        2426+1   JNB FLAGS3 . 5 , ( $+5 ) 
083E    D296          2426+1   SETB P1 . 6 
0840    E56F          2427     	MOV	A, BEEP_STRENGTH
0842    D5E0FD        2428     	DJNZ	ACC, $		
                      2429     	; Turn off nfet
                      2430     	ANFET_OFF			; AnFET off
0845    207502        2430+1   JB FLAGS3 . 5 , ( $+5 ) 
0848    C292          2430+1   CLR P1 . 2 
084A    307502        2430+1   JNB FLAGS3 . 5 , ( $+5 ) 
084D    C296          2430+1   CLR P1 . 6 
084F    7496          2431     	MOV	A, #150		; 25s off
0851    D5E0FD        2432     	DJNZ	ACC, $		
0854    D9C1          2433     DJNZ R1 , BEEP_ONOFF 
                      2434     	; Copy variable
0856    EA            2435     MOV A , R2 
0857    F8            2436     MOV R0 , A 
                      2437     BEEP_OFF: 		; Fets off loop
0858    D5E0FD        2438     	DJNZ	ACC, $
085B    D8FB          2439     DJNZ R0 , BEEP_OFF 
085D    DBB1          2440     DJNZ R3 , BEEP 
                      2441     	BPFET_OFF			; BpFET off
085F    C294          2441+1   CLR P1 . 4 
0861    8C25          2442     MOV CURRENT_PWM_LIMITED , R4 
0863    22            2443     	RET
                      2444     
                      2445     
                      2446     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2447     ;
                      2448     ; Division 16bit unsigned by 16bit unsigned
                      2449     ;
                      2450     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2451     ; Result will be in Temp2/Temp1
                      2452     ;
                      2453     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2454     DIV_U16_BY_U16: 	
0864    C3            2455     	CLR	C       
0865    7C00          2456     MOV R4 , # 0 
0867    7D00          2457     MOV R5 , # 0 
0869    75F000        2458     	MOV	B, #0
                      2459     DIV_U16_BY_U16_DIV1: 
086C    05F0          2460     	INC	B      			; Increment counter for each left shift
086E    EA            2461     MOV A , R2 
086F    33            2462     	RLC	A      		
0870    FA            2463     MOV R2 , A 
0871    EB            2464     MOV A , R3 
0872    33            2465     	RLC	A      	  	
0873    FB            2466     MOV R3 , A 
0874    50F6          2467     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2468     DIV_U16_BY_U16_DIV2:         
0876    EB            2469     MOV A , R3 
0877    13            2470     	RRC	A      
0878    FB            2471     MOV R3 , A 
0879    EA            2472     MOV A , R2 
087A    13            2473     	RRC	A      
087B    FA            2474     MOV R2 , A 
087C    C3            2475     	CLR	C      
087D    E9            2476     MOV A , R1 
087E    FF            2477     MOV R7 , A 
087F    E8            2478     MOV A , R0 
0880    FE            2479     MOV R6 , A 
0881    E8            2480     MOV A , R0 
0882    9A            2481     SUBB A , R2 
0883    F8            2482     MOV R0 , A 
0884    E9            2483     MOV A , R1 
0885    9B            2484     SUBB A , R3 
0886    F9            2485     MOV R1 , A 
0887    5004          2486     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0889    EF            2487     MOV A , R7 
088A    F9            2488     MOV R1 , A 
088B    EE            2489     MOV A , R6 
088C    F8            2490     MOV R0 , A 
                      2491     DIV_U16_BY_U16_DIV3: 
088D    B3            2492     	CPL	C      			; Invert carry, so it can be directly copied into result
088E    EC            2493     MOV A , R4 
088F    33            2494     	RLC	A      			; Shift carry flag into temporary result
0890    FC            2495     MOV R4 , A 
0891    ED            2496     MOV A , R5 
0892    33            2497     	RLC	A
0893    FD            2498     MOV R5 , A 
0894    D5F0DF        2499     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0897    ED            2500     MOV A , R5 
0898    F9            2501     MOV R1 , A 
0899    EC            2502     MOV A , R4 
089A    F8            2503     MOV R0 , A 
089B    22            2504     	RET
                      2505     
                      2506     
                      2507     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2508     ;
                      2509     ; Multiplication 16bit signed by 8bit unsigned
                      2510     ;
                      2511     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2512     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2513     ;
                      2514     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2515     MULT_S16_BY_U8_DIV_16: 
089C    E8            2516     MOV A , R0 
089D    89F0          2517     MOV B , R1 
089F    8A20          2518     MOV BIT_ACCESS , R2 
08A1    D2D4          2519     	SETB	PSW.4		; Select register bank 2 for math routines
08A3    F8            2520     MOV R0 , A 
08A4    A9F0          2521     MOV R1 , B 
08A6    7B00          2522     MOV R3 , # 0 
08A8    30F70B        2523     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2524     
08AB    7BFF          2525     MOV R3 , # 0FFH 
08AD    F4            2526     	CPL	A
08AE    2401          2527     	ADD	A, #1
08B0    F8            2528     MOV R0 , A 
08B1    E9            2529     MOV A , R1 
08B2    F4            2530     	CPL	A
08B3    3400          2531     	ADDC	A, #0
08B5    F9            2532     MOV R1 , A 
                      2533     MULT_S16_BY_U8_POSITIVE: 
08B6    E8            2534     MOV A , R0 
08B7    8520F0        2535     	MOV	B, BIT_ACCESS
08BA    A4            2536     	MUL	AB
08BB    ADF0          2537     MOV R5 , B 
08BD    F8            2538     MOV R0 , A 
08BE    E9            2539     MOV A , R1 
08BF    8520F0        2540     	MOV	B, BIT_ACCESS
08C2    A4            2541     	MUL	AB
08C3    AFF0          2542     MOV R7 , B 
08C5    FE            2543     MOV R6 , A 
08C6    ED            2544     MOV A , R5 
08C7    2E            2545     ADD A , R6 
08C8    F9            2546     MOV R1 , A 
08C9    7400          2547     	MOV	A, #0
08CB    3F            2548     ADDC A , R7 
08CC    FA            2549     MOV R2 , A 
08CD    7C04          2550     MOV R4 , # 4 
                      2551     MULT_S16_BY_U8_DIV_LOOP: 
08CF    C3            2552     	CLR	C			; Rotate right 
08D0    EA            2553     MOV A , R2 
08D1    13            2554     	RRC	A
08D2    FA            2555     MOV R2 , A 
08D3    E9            2556     MOV A , R1 
08D4    13            2557     	RRC	A
08D5    F9            2558     MOV R1 , A 
08D6    E8            2559     MOV A , R0 
08D7    13            2560     	RRC	A
08D8    F8            2561     MOV R0 , A 
08D9    DCF4          2562     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2563     
08DB    8BF0          2564     MOV B , R3 
08DD    30F70A        2565     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2566     
08E0    E8            2567     MOV A , R0 
08E1    F4            2568     	CPL	A
08E2    2401          2569     	ADD	A, #1
08E4    F8            2570     MOV R0 , A 
08E5    E9            2571     MOV A , R1 
08E6    F4            2572     	CPL	A
08E7    3400          2573     	ADDC	A, #0
08E9    F9            2574     MOV R1 , A 
                      2575     
                      2576     MULT_S16_BY_U8_EXIT: 
08EA    E8            2577     MOV A , R0 
08EB    89F0          2578     MOV B , R1 
08ED    C2D4          2579     	CLR	PSW.4		; Select normal register bank
08EF    F8            2580     MOV R0 , A 
08F0    A9F0          2581     MOV R1 , B 
08F2    22            2582     	RET
                      2583     
                      2584     
                      2585     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2586     ;
                      2587     ; Calculate governor routines
                      2588     ;
                      2589     ; No assumptions
                      2590     ;
                      2591     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2592     ; The governor task is split into several routines in order to distribute processing time
                      2593     ;
                      2594     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2595     ; First governor routine - calculate governor target
                      2596     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      2736     IF MODE == 2	; Multi
                      2737     CALC_GOVERNOR_TARGET: 
08F3    7882          2738     MOV R0 , # PGM_GOV_MODE 
08F5    B60403        2739     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
08F8    02094F        2740     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      2741     
                      2742     GOVERNOR_TARGET_CALC: 
                      2743     	; Stop governor for stop RC pulse	
08FB    C3            2744     	CLR	C
08FC    E559          2745     	MOV	A, NEW_RCP				; Check RC pulse against stop value
08FE    9401          2746     SUBB A , # 1 
0900    4003          2747     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      2748     
0902    020918        2749     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      2750     
                      2751     GOVERNOR_DEACTIVATE: 
0905    852224        2752     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
0908    E4            2753     	CLR	A
0909    F540          2754     	MOV	GOV_TARGET_L, A			; Set target to zero
090B    F541          2755     	MOV	GOV_TARGET_H, A
090D    F542          2756     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
090F    F543          2757     	MOV	GOV_INTEGRAL_H, A
0911    F544          2758     	MOV	GOV_INTEGRAL_X, A
0913    F549          2759     	MOV	GOV_ACTIVE, A
0915    02094F        2760     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      2761     
                      2762     GOVERNOR_ACTIVATE: 
0918    7882          2763     MOV R0 , # PGM_GOV_MODE 
091A    E6            2764     MOV A , @ R0 
091B    FC            2765     MOV R4 , A 
091C    754901        2766     	MOV	GOV_ACTIVE, #1
091F    E522          2767     	MOV	A, REQUESTED_PWM			; Load requested pwm
0921    F523          2768     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      2769     	; Calculate comm period target 2*(51000/Requested_Pwm)
0923    7838          2770     MOV R0 , # 38H 
0925    79C7          2771     MOV R1 , # 0C7H 
0927    AA3C          2772     MOV R2 , COMM_PERIOD4X_L 
0929    AB3D          2773     MOV R3 , COMM_PERIOD4X_H 
                      2774     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
092B    C3            2775     	CLR	C
092C    EB            2776     MOV A , R3 
092D    13            2777     	RRC	A
092E    FB            2778     MOV R3 , A 
092F    EA            2779     MOV A , R2 
0930    13            2780     	RRC	A
0931    FA            2781     MOV R2 , A 
                      2782     	; Check range
0932    EC            2783     MOV A , R4 
0933    14            2784     	DEC	A
0934    6013          2785     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      2786     GOVERNOR_ACTIVATE_100K: 
0936    C3            2787     	CLR	C
0937    EB            2788     MOV A , R3 
0938    13            2789     	RRC	A
0939    FB            2790     MOV R3 , A 
093A    EA            2791     MOV A , R2 
093B    13            2792     	RRC	A
093C    FA            2793     MOV R2 , A 
093D    EC            2794     MOV A , R4 
093E    14            2795     	DEC	A
093F    14            2796     	DEC	A
0940    6007          2797     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      2798     GOVERNOR_ACTIVATE_50K: 
0942    C3            2799     	CLR	C
0943    EB            2800     MOV A , R3 
0944    13            2801     	RRC	A
0945    FB            2802     MOV R3 , A 
0946    EA            2803     MOV A , R2 
0947    13            2804     	RRC	A
0948    FA            2805     MOV R2 , A 
                      2806     GOVERNOR_ACTIVATE_RANGE_SET: 
0949    1164          2807     	CALL	DIV_U16_BY_U16
                      2808     	; Store governor target
094B    8840          2809     MOV GOV_TARGET_L , R0 
094D    8941          2810     MOV GOV_TARGET_H , R1 
                      2811     CALC_GOVERNOR_TARGET_EXIT: 
094F    22            2812     	RET						
                      2813     ENDIF
                      2814     
                      2815     
                      2816     ; Second governor routine - calculate governor proportional error
                      2817     CALC_GOVERNOR_PROP_ERROR: 
                      2818     	; Exit if governor is inactive
0950    E549          2819     	MOV	A, GOV_ACTIVE
0952    6034          2820     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      2821     
                      2822     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      2840     IF MODE == 2	; Multi
                      2841     	; Calculate error
0954    C3            2842     	CLR	C
0955    E540          2843     	MOV	A, GOV_TARGET_L
0957    9523          2844     	SUBB	A, GOVERNOR_REQ_PWM
0959    F8            2845     MOV R0 , A 
095A    E541          2846     	MOV	A, GOV_TARGET_H
095C    9400          2847     	SUBB	A, #0
095E    F9            2848     MOV R1 , A 
                      2849     ENDIF
                      2850     	; Check error and limit
095F    500C          2851     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      2852     
0961    C3            2853     	CLR	C
0962    E8            2854     MOV A , R0 
0963    9480          2855     	SUBB	A, #80H					; Is error too negative?
0965    E9            2856     MOV A , R1 
0966    94FF          2857     	SUBB	A, #0FFH
0968    4016          2858     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
096A    020984        2859     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2860     
                      2861     GOVERNOR_CHECK_PROP_LIMIT_POS: 
096D    C3            2862     	CLR	C
096E    E8            2863     MOV A , R0 
096F    947F          2864     	SUBB	A, #7FH					; Is error too positive?
0971    E9            2865     MOV A , R1 
0972    9400          2866     	SUBB	A, #00H
0974    5003          2867     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0976    020984        2868     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2869     
                      2870     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0979    787F          2871     MOV R0 , # 7FH 
097B    7900          2872     MOV R1 , # 00H 
097D    020984        2873     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2874     
                      2875     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0980    7880          2876     MOV R0 , # 80H 
0982    79FF          2877     MOV R1 , # 0FFH 
                      2878     
                      2879     GOVERNOR_STORE_PROP_ERROR: 
                      2880     	; Store proportional
0984    8845          2881     MOV GOV_PROPORTIONAL_L , R0 
0986    8946          2882     MOV GOV_PROPORTIONAL_H , R1 
                      2883     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0988    22            2884     	RET						
                      2885     
                      2886     
                      2887     ; Third governor routine - calculate governor integral error
                      2888     CALC_GOVERNOR_INT_ERROR: 
                      2889     	; Exit if governor is inactive
0989    E549          2890     	MOV	A, GOV_ACTIVE
098B    6058          2891     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      2892     
                      2893     	; Add proportional to integral
098D    E545          2894     	MOV	A, GOV_PROPORTIONAL_L
098F    2542          2895     	ADD	A, GOV_INTEGRAL_L
0991    F8            2896     MOV R0 , A 
0992    E546          2897     	MOV	A, GOV_PROPORTIONAL_H
0994    3543          2898     	ADDC	A, GOV_INTEGRAL_H
0996    F9            2899     MOV R1 , A 
0997    854620        2900     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
099A    E4            2901     	CLR	A
099B    300701        2902     	JNB	BIT_ACCESS.7, ($+4)			
099E    F4            2903     	CPL	A
099F    3544          2904     	ADDC	A, GOV_INTEGRAL_X
09A1    FA            2905     MOV R2 , A 
                      2906     	; Check integral and limit
09A2    30E709        2907     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      2908     
09A5    C3            2909     	CLR	C
09A6    EA            2910     MOV A , R2 
09A7    94F0          2911     	SUBB	A, #0F0H					; Is error too negative?
09A9    4015          2912     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
09AB    0209C6        2913     	JMP	GOVERNOR_CHECK_PWM
                      2914     
                      2915     GOVERNOR_CHECK_INT_LIMIT_POS: 
09AE    C3            2916     	CLR	C
09AF    EA            2917     MOV A , R2 
09B0    940F          2918     	SUBB	A, #0FH					; Is error too positive?
09B2    5003          2919     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
09B4    0209C6        2920     	JMP	GOVERNOR_CHECK_PWM
                      2921     
                      2922     GOVERNOR_LIMIT_INT_ERROR_POS: 
09B7    78FF          2923     MOV R0 , # 0FFH 
09B9    79FF          2924     MOV R1 , # 0FFH 
09BB    7A0F          2925     MOV R2 , # 0FH 
09BD    0209C6        2926     	JMP	GOVERNOR_CHECK_PWM
                      2927     
                      2928     GOVERNOR_LIMIT_INT_ERROR_NEG: 
09C0    7800          2929     MOV R0 , # 00H 
09C2    7900          2930     MOV R1 , # 00H 
09C4    7AF0          2931     MOV R2 , # 0F0H 
                      2932     
                      2933     GOVERNOR_CHECK_PWM: 
                      2934     	; Check current pwm
09C6    C3            2935     	CLR	C
09C7    E524          2936     	MOV	A, CURRENT_PWM
09C9    955E          2937     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
09CB    5006          2938     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      2939     
09CD    E524          2940     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
09CF    6009          2941     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      2942     
09D1    21DF          2943     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      2944     
                      2945     GOVERNOR_INT_MAX_PWM: 
09D3    E546          2946     	MOV	A, GOV_PROPORTIONAL_H
09D5    20E70D        2947     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      2948     
09D8    21DF          2949     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      2950     
                      2951     GOVERNOR_INT_MIN_PWM: 
09DA    E546          2952     	MOV	A, GOV_PROPORTIONAL_H
09DC    30E706        2953     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      2954     
                      2955     GOVERNOR_STORE_INT_ERROR: 
                      2956     	; Store integral
09DF    8842          2957     MOV GOV_INTEGRAL_L , R0 
09E1    8943          2958     MOV GOV_INTEGRAL_H , R1 
09E3    8A44          2959     MOV GOV_INTEGRAL_X , R2 
                      2960     CALC_GOVERNOR_INT_ERROR_EXIT: 
09E5    22            2961     	RET						
                      2962     
                      2963     
                      2964     ; Fourth governor routine - calculate governor proportional correction
                      2965     CALC_GOVERNOR_PROP_CORRECTION: 
                      2966     	; Exit if governor is inactive
09E6    E549          2967     	MOV	A, GOV_ACTIVE
09E8    7003          2968     	JNZ	CALC_GOVERNOR_PROP_CORR
09EA    020A49        2969     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      2970     
                      2971     CALC_GOVERNOR_PROP_CORR: 
                      2972     	; Load proportional gain
09ED    789F          2973     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
09EF    E6            2974     MOV A , @ R0 
09F0    FA            2975     MOV R2 , A 
                      2976     	; Load proportional
09F1    C3            2977     	CLR	C
09F2    E545          2978     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
09F4    33            2979     	RLC	A
09F5    F8            2980     MOV R0 , A 
09F6    E546          2981     	MOV	A, GOV_PROPORTIONAL_H
09F8    33            2982     	RLC	A
09F9    F9            2983     MOV R1 , A 
                      2984     	; Apply gain
09FA    119C          2985     	CALL	MULT_S16_BY_U8_DIV_16
                      2986     	; Check error and limit (to low byte)
09FC    E9            2987     MOV A , R1 
09FD    30E70B        2988     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      2989     
0A00    C3            2990     	CLR	C
0A01    E8            2991     MOV A , R0 
0A02    9480          2992     	SUBB	A, #80H					; Is error too negative?
0A04    E9            2993     MOV A , R1 
0A05    94FF          2994     	SUBB	A, #0FFH
0A07    4013          2995     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0A09    4120          2996     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      2997     
                      2998     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0A0B    C3            2999     	CLR	C
0A0C    E8            3000     MOV A , R0 
0A0D    947F          3001     	SUBB	A, #7FH					; Is error too positive?
0A0F    E9            3002     MOV A , R1 
0A10    9400          3003     	SUBB	A, #00H
0A12    5002          3004     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0A14    4120          3005     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3006     
                      3007     GOVERNOR_LIMIT_PROP_CORR_POS: 
0A16    787F          3008     MOV R0 , # 7FH 
0A18    7900          3009     MOV R1 , # 00H 
0A1A    4120          3010     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3011     
                      3012     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0A1C    7880          3013     MOV R0 , # 80H 
0A1E    79FF          3014     MOV R1 , # 0FFH 
                      3015     
                      3016     GOVERNOR_APPLY_PROP_CORR: 
                      3017     	; Test proportional sign
0A20    E8            3018     MOV A , R0 
0A21    20E715        3019     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3020     
                      3021     	; Subtract positive proportional
0A24    C3            3022     	CLR	C
0A25    E523          3023     	MOV	A, GOVERNOR_REQ_PWM
0A27    98            3024     SUBB A , R0 
0A28    F8            3025     MOV R0 , A 
                      3026     	; Check result
0A29    4009          3027     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3028     
0A2B    C3            3029     	CLR	C
0A2C    E8            3030     MOV A , R0 
0A2D    9401          3031     	SUBB	A, #1
0A2F    4003          3032     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0A31    020A47        3033     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3034     
                      3035     GOVERNOR_CORR_PROP_MIN_PWM: 
0A34    7801          3036     MOV R0 , # 1 
0A36    020A47        3037     	JMP	GOVERNOR_STORE_PROP_CORR
                      3038     
                      3039     GOVERNOR_CORR_NEG_PROP: 
                      3040     	; Add negative proportional
0A39    E8            3041     MOV A , R0 
0A3A    F4            3042     	CPL	A
0A3B    2401          3043     	ADD	A, #1
0A3D    2523          3044     	ADD	A, GOVERNOR_REQ_PWM
0A3F    F8            3045     MOV R0 , A 
                      3046     	; Check result
0A40    4003          3047     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0A42    020A47        3048     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3049     
                      3050     GOVERNOR_CORR_PROP_MAX_PWM: 
0A45    78FF          3051     MOV R0 , # 255 
                      3052     GOVERNOR_STORE_PROP_CORR: 
                      3053     	; Store proportional pwm
0A47    8847          3054     MOV GOV_PROP_PWM , R0 
                      3055     CALC_GOVERNOR_PROP_CORR_EXIT: 
0A49    22            3056     	RET
                      3057     
                      3058     
                      3059     ; Fifth governor routine - calculate governor integral correction
                      3060     CALC_GOVERNOR_INT_CORRECTION: 
                      3061     	; Exit if governor is inactive
0A4A    E549          3062     	MOV	A, GOV_ACTIVE
0A4C    7003          3063     	JNZ	CALC_GOVERNOR_INT_CORR
0A4E    020AAB        3064     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3065     
                      3066     CALC_GOVERNOR_INT_CORR: 
                      3067     	; Load integral gain
0A51    78A0          3068     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0A53    E6            3069     MOV A , @ R0 
0A54    FA            3070     MOV R2 , A 
                      3071     	; Load integral
0A55    A843          3072     MOV R0 , GOV_INTEGRAL_H 
0A57    A944          3073     MOV R1 , GOV_INTEGRAL_X 
                      3074     	; Apply gain
0A59    119C          3075     	CALL	MULT_S16_BY_U8_DIV_16
                      3076     	; Check integral and limit
0A5B    E9            3077     MOV A , R1 
0A5C    30E70C        3078     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3079     
0A5F    C3            3080     	CLR	C
0A60    E8            3081     MOV A , R0 
0A61    9401          3082     	SUBB	A, #01H					; Is integral too negative?
0A63    E9            3083     MOV A , R1 
0A64    94FF          3084     	SUBB	A, #0FFH
0A66    4016          3085     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0A68    020A82        3086     	JMP	GOVERNOR_APPLY_INT_CORR
                      3087     
                      3088     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0A6B    C3            3089     	CLR	C
0A6C    E8            3090     MOV A , R0 
0A6D    94FF          3091     	SUBB	A, #0FFH					; Is integral too positive?
0A6F    E9            3092     MOV A , R1 
0A70    9400          3093     	SUBB	A, #00H
0A72    5003          3094     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0A74    020A82        3095     	JMP	GOVERNOR_APPLY_INT_CORR
                      3096     
                      3097     GOVERNOR_LIMIT_INT_CORR_POS: 
0A77    78FF          3098     MOV R0 , # 0FFH 
0A79    7900          3099     MOV R1 , # 00H 
0A7B    020A82        3100     	JMP	GOVERNOR_APPLY_INT_CORR
                      3101     
                      3102     GOVERNOR_LIMIT_INT_CORR_NEG: 
0A7E    7801          3103     MOV R0 , # 01H 
0A80    79FF          3104     MOV R1 , # 0FFH 
                      3105     
                      3106     GOVERNOR_APPLY_INT_CORR: 
                      3107     	; Test integral sign
0A82    E9            3108     MOV A , R1 
0A83    20E715        3109     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3110     
                      3111     	; Subtract positive integral
0A86    C3            3112     	CLR	C
0A87    E547          3113     	MOV	A, GOV_PROP_PWM
0A89    98            3114     SUBB A , R0 
0A8A    F8            3115     MOV R0 , A 
                      3116     	; Check result
0A8B    4009          3117     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3118     
0A8D    C3            3119     	CLR	C
0A8E    E8            3120     MOV A , R0 
0A8F    9401          3121     	SUBB	A, #1
0A91    4003          3122     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0A93    020AA9        3123     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3124     
                      3125     GOVERNOR_CORR_INT_MIN_PWM: 
0A96    7800          3126     MOV R0 , # 0 
0A98    020AA9        3127     	JMP	GOVERNOR_STORE_INT_CORR
                      3128     
                      3129     GOVERNOR_CORR_NEG_INT: 
                      3130     	; Add negative integral
0A9B    E8            3131     MOV A , R0 
0A9C    F4            3132     	CPL	A
0A9D    2401          3133     	ADD	A, #1
0A9F    2547          3134     	ADD	A, GOV_PROP_PWM
0AA1    F8            3135     MOV R0 , A 
                      3136     	; Check result
0AA2    4003          3137     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0AA4    020AA9        3138     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3139     
                      3140     GOVERNOR_CORR_INT_MAX_PWM: 
0AA7    78FF          3141     MOV R0 , # 255 
                      3142     GOVERNOR_STORE_INT_CORR: 
                      3143     	; Store current pwm
0AA9    8824          3144     MOV CURRENT_PWM , R0 
                      3145     CALC_GOVERNOR_INT_CORR_EXIT: 
0AAB    22            3146     	RET
                      3147     
                      3148     
                      3149     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3150     ;
                      3151     ; Measure lipo cells
                      3152     ;
                      3153     ; No assumptions
                      3154     ;
                      3155     ; Measure voltage and calculate lipo cells
                      3156     ;
                      3157     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3158     MEASURE_LIPO_CELLS: 
                      3159     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3163     MEASURE_LIPO_START: 
                      3164     	; Load programmed low voltage limit
0AAC    7883          3165     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0AAE    E6            3166     MOV A , @ R0 
0AAF    F520          3167     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3168     	; Set commutation to BpFET on
0AB1    120FCA        3169     	CALL	COMM5COMM6			
                      3170     	; Start adc
                      3171     	START_ADC 
0AB4    75E890        3171+1   MOV ADC0CN , # 90H  ; ADC START
                      3172     	; Wait for ADC reference to settle, and then start again
0AB7    1207CB        3173     	CALL	WAIT1MS
                      3174     	START_ADC
0ABA    75E890        3174+1   MOV ADC0CN , # 90H  ; ADC START
                      3175     	; Wait for ADC conversion to complete
                      3176     MEASURE_LIPO_WAIT_ADC: 
                      3177     	GET_ADC_STATUS 
0ABD    E5E8          3177+1   MOV A , ADC0CN 
0ABF    20ECFB        3178     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3179     	; Read ADC result
                      3180     	READ_ADC_RESULT
0AC2    A8BD          3180+1   MOV R0 , ADC0L 
0AC4    A9BE          3180+1   MOV R1 , ADC0H 
                      3181     	; Stop ADC
                      3182     	STOP_ADC
                      3183     	; Switch power off
0AC6    121070        3184     	CALL	SWITCH_POWER_OFF		
                      3185     	; Set limit step
0AC9    756A55        3186     MOV LIPO_ADC_LIMIT_L , # 85 
0ACC    756B00        3187     MOV LIPO_ADC_LIMIT_H , # 0 
0ACF    C3            3188     	CLR	C
0AD0    7400          3189     MOV A , # 0 
0AD2    13            3190     	RRC	A
0AD3    FD            3191     MOV R5 , A 
0AD4    7455          3192     MOV A , # 85 
0AD6    13            3193     	RRC	A
0AD7    FC            3194     MOV R4 , A 
0AD8    7455          3195     MOV A , # 85 
0ADA    2C            3196     ADD A , R4 
0ADB    FC            3197     MOV R4 , A 
0ADC    7400          3198     MOV A , # 0 
0ADE    3D            3199     ADDC A , R5 
0ADF    FD            3200     MOV R5 , A 
0AE0    EC            3201     MOV A , R4 
0AE1    FA            3202     MOV R2 , A 
0AE2    ED            3203     MOV A , R5 
0AE3    FB            3204     MOV R3 , A 
                      3205     MEASURE_LIPO_CELL_LOOP: 
                      3206     	; Check voltage against xS lower limit
0AE4    C3            3207     	CLR	C
0AE5    E8            3208     MOV A , R0 
0AE6    9A            3209     SUBB A , R2 
0AE7    E9            3210     MOV A , R1 
0AE8    9B            3211     SUBB A , R3 
0AE9    4014          3212     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3213     
                      3214     	; Set xS voltage limit
0AEB    E56A          3215     	MOV	A, LIPO_ADC_LIMIT_L		
0AED    2455          3216     ADD A , # 85 
0AEF    F56A          3217     	MOV	LIPO_ADC_LIMIT_L, A
0AF1    E56B          3218     	MOV	A, LIPO_ADC_LIMIT_H		
0AF3    3400          3219     ADDC A , # 0 
0AF5    F56B          3220     	MOV	LIPO_ADC_LIMIT_H, A
                      3221     	; Set (x+1)S lower limit
0AF7    EA            3222     MOV A , R2 
0AF8    2C            3223     ADD A , R4 
0AF9    FA            3224     MOV R2 , A 
0AFA    EB            3225     MOV A , R3 
0AFB    3D            3226     ADDC A , R5 
0AFC    FB            3227     MOV R3 , A 
0AFD    80E5          3228     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3229     
                      3230     MEASURE_LIPO_ADJUST: 
0AFF    AE6A          3231     MOV R6 , LIPO_ADC_LIMIT_L 
0B01    AF6B          3232     MOV R7 , LIPO_ADC_LIMIT_H 
                      3233     	; Calculate 3.125%
0B03    C3            3234     	CLR	C
0B04    E56B          3235     	MOV	A, LIPO_ADC_LIMIT_H
0B06    13            3236     	RRC	A
0B07    F9            3237     MOV R1 , A 
0B08    E56A          3238     	MOV	A, LIPO_ADC_LIMIT_L	
0B0A    13            3239     	RRC	A
0B0B    F8            3240     MOV R0 , A 
0B0C    C3            3241     	CLR	C
0B0D    E9            3242     MOV A , R1 
0B0E    13            3243     	RRC	A
0B0F    F9            3244     MOV R1 , A 
0B10    E8            3245     MOV A , R0 
0B11    13            3246     	RRC	A
0B12    F8            3247     MOV R0 , A 
0B13    E56A          3248     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0B15    28            3249     ADD A , R0 
0B16    F568          3250     	MOV	LIPO_ADC_REFERENCE_L, A
0B18    E56B          3251     	MOV	A, LIPO_ADC_LIMIT_H
0B1A    39            3252     ADDC A , R1 
0B1B    F569          3253     	MOV	LIPO_ADC_REFERENCE_H, A
                      3254     	; Divide three times to get to 3.125%
0B1D    7A03          3255     MOV R2 , # 3 
                      3256     MEASURE_LIPO_DIVIDE_LOOP: 
0B1F    C3            3257     	CLR	C
0B20    E9            3258     MOV A , R1 
0B21    13            3259     	RRC	A
0B22    F9            3260     MOV R1 , A 
0B23    E8            3261     MOV A , R0 
0B24    13            3262     	RRC	A
0B25    F8            3263     MOV R0 , A 
0B26    DAF7          3264     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3265     
                      3266     	; Add the programmed number of 0.1V (or 3.125% increments)
0B28    AA20          3267     MOV R2 , BIT_ACCESS 
0B2A    1A            3268     DEC R2 
0B2B    7009          3269     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3270     
0B2D    756A00        3271     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0B30    756B00        3272     	MOV	LIPO_ADC_LIMIT_H, #0
0B33    020B46        3273     	JMP	MEASURE_LIPO_EXIT	
                      3274     
                      3275     MEASURE_LIPO_LIMIT_ON: 
0B36    1A            3276     DEC R2 
0B37    EA            3277     MOV A , R2 
0B38    6008          3278     	JZ	MEASURE_LIPO_UPDATE
                      3279     
                      3280     MEASURE_LIPO_ADD_LOOP: 
0B3A    EE            3281     MOV A , R6 
0B3B    28            3282     ADD A , R0 
0B3C    FE            3283     MOV R6 , A 
0B3D    EF            3284     MOV A , R7 
0B3E    39            3285     ADDC A , R1 
0B3F    FF            3286     MOV R7 , A 
0B40    DAF8          3287     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3288     
                      3289     MEASURE_LIPO_UPDATE: 
                      3290     	; Set ADC limit
0B42    8E6A          3291     MOV LIPO_ADC_LIMIT_L , R6 
0B44    8F6B          3292     MOV LIPO_ADC_LIMIT_H , R7 
                      3293     MEASURE_LIPO_EXIT: 
0B46    22            3294     	RET
                      3295     
                      3296     
                      3297     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3298     ;
                      3299     ; Start ADC conversion
                      3300     ;
                      3301     ; No assumptions
                      3302     ;
                      3303     ; Start conversion used for measuring power supply voltage
                      3304     ;
                      3305     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3306     START_ADC_CONVERSION: 
                      3307     	; Start adc
                      3308     	START_ADC 
0B47    75E890        3308+1   MOV ADC0CN , # 90H  ; ADC START
0B4A    22            3309     	RET
                      3310     
                      3311     
                      3312     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3313     ;
                      3314     ; Check temperature, power supply voltage and limit power
                      3315     ;
                      3316     ; No assumptions
                      3317     ;
                      3318     ; Used to limit main motor power in order to maintain the required voltage
                      3319     ;
                      3320     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3321     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3322     	; Load programmed low voltage limit
0B4B    7883          3323     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B4D    E6            3324     MOV A , @ R0 
0B4E    FF            3325     MOV R7 , A 
                      3326     	; Wait for ADC conversion to complete
                      3327     	GET_ADC_STATUS 
0B4F    E5E8          3327+1   MOV A , ADC0CN 
0B51    20ECF7        3328     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3329     	; Read ADC result
                      3330     	READ_ADC_RESULT
0B54    A8BD          3330+1   MOV R0 , ADC0L 
0B56    A9BE          3330+1   MOV R1 , ADC0H 
                      3331     	; Stop ADC
                      3332     	STOP_ADC
                      3333     
0B58    056C          3334     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0B5A    C3            3335     	CLR	C
0B5B    E56C          3336     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0B5D    9408          3337     SUBB A , # 8 
0B5F    404B          3338     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3339     
0B61    756C00        3340     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0B64    E9            3341     MOV A , R1 
0B65    7007          3342     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3343     
0B67    E56D          3344     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0B69    601B          3345     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0B6B    020B7A        3346     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3347     
                      3348     TEMP_AVERAGE_INC_DEC: 
0B6E    C3            3349     	CLR	C
0B6F    E8            3350     MOV A , R0 
0B70    956D          3351     	SUBB	A, CURRENT_AVERAGE_TEMP
0B72    6010          3352     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3353     
0B74    E56D          3354     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0B76    5006          3355     	JNC	TEMP_AVERAGE_INC				
                      3356     
0B78    600C          3357     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3358     TEMP_AVERAGE_DEC: 
0B7A    14            3359     	DEC	A						; Decrement average
0B7B    020B86        3360     	JMP	TEMP_AVERAGE_UPDATED
                      3361     
                      3362     TEMP_AVERAGE_INC: 
0B7E    04            3363     	INC	A						; Increment average
0B7F    60F9          3364     	JZ	TEMP_AVERAGE_DEC
0B81    020B86        3365     	JMP	TEMP_AVERAGE_UPDATED
                      3366     
                      3367     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0B84    E56D          3368     	MOV	A, CURRENT_AVERAGE_TEMP
                      3369     TEMP_AVERAGE_UPDATED: 
0B86    F56D          3370     	MOV	CURRENT_AVERAGE_TEMP, A
0B88    C3            3371     	CLR	C
0B89    9472          3372     SUBB A , # 114 
0B8B    401B          3373     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3374     
0B8D    755EC0        3375     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3376     
0B90    C3            3377     	CLR	C
0B91    9404          3378     SUBB A , # 4 
0B93    4013          3379     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3380     
0B95    755E80        3381     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3382     
0B98    C3            3383     	CLR	C
0B99    9404          3384     SUBB A , # 4 
0B9B    400B          3385     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3386     
0B9D    755E40        3387     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3388     
0BA0    C3            3389     	CLR	C
0BA1    9404          3390     SUBB A , # 4 
0BA3    4003          3391     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3392     
0BA5    755E00        3393     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3394     
                      3395     TEMP_CHECK_EXIT: 
                      3396     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0BA8    75BB09        3396+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0BAB    22            3397     	RET
                      3398     
                      3399     CHECK_VOLTAGE_START: 
                      3400     IF MODE == 0 OR MODE == 2	; Main or multi
                      3401     	; Check if low voltage limiting is enabled
0BAC    EF            3402     MOV A , R7 
0BAD    C3            3403     	CLR	C
0BAE    9401          3404     	SUBB	A, #1					; Is low voltage limit disabled?
0BB0    601B          3405     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3406     
                      3407     	; Check if ADC is saturated
0BB2    C3            3408     	CLR	C
0BB3    E8            3409     MOV A , R0 
0BB4    94FF          3410     	SUBB	A, #0FFH
0BB6    E9            3411     MOV A , R1 
0BB7    9403          3412     	SUBB	A, #03H
0BB9    5012          3413     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3414     
                      3415     	; Check voltage against limit
0BBB    C3            3416     	CLR	C
0BBC    E8            3417     MOV A , R0 
0BBD    956A          3418     	SUBB	A, LIPO_ADC_LIMIT_L
0BBF    E9            3419     MOV A , R1 
0BC0    956B          3420     	SUBB	A, LIPO_ADC_LIMIT_H
0BC2    5009          3421     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3422     
                      3423     	; Decrease pwm limit
0BC4    E55E          3424     	MOV  A, PWM_LIMIT
0BC6    600C          3425     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3426     
0BC8    155E          3427     	DEC	PWM_LIMIT					; Decrement limit
0BCA    020BD4        3428     	JMP	CHECK_VOLTAGE_LIM
                      3429     
                      3430     CHECK_VOLTAGE_GOOD: 
                      3431     	; Increase pwm limit
0BCD    E55E          3432     	MOV  A, PWM_LIMIT
0BCF    F4            3433     	CPL	A			
0BD0    6002          3434     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3435     
0BD2    055E          3436     	INC	PWM_LIMIT					; Increment limit
                      3437     
                      3438     CHECK_VOLTAGE_LIM: 
0BD4    A85E          3439     MOV R0 , PWM_LIMIT 
0BD6    C3            3440     	CLR	C
0BD7    E524          3441     	MOV	A, CURRENT_PWM
0BD9    98            3442     SUBB A , R0 
0BDA    5002          3443     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3444     
0BDC    A824          3445     MOV R0 , CURRENT_PWM 
                      3446     
                      3447     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3448     	; Slow spoolup
0BDE    C3            3449     	CLR	C
0BDF    E8            3450     MOV A , R0 
0BE0    955F          3451     	SUBB	A, PWM_LIMIT_SPOOLUP
0BE2    400A          3452     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3453     
0BE4    A85F          3454     MOV R0 , PWM_LIMIT_SPOOLUP 
0BE6    E55F          3455     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0BE8    F4            3456     	CPL	A
0BE9    6003          3457     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3458      
0BEB    855F5E        3459     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3460     
                      3461     CHECK_VOLTAGE_EXIT: 
0BEE    8825          3462     MOV CURRENT_PWM_LIMITED , R0 
                      3463     ENDIF
                      3464     	; Set adc mux for next conversion
0BF0    C3            3465     	CLR	C
0BF1    E56C          3466     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0BF3    B40703        3467     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3468     
                      3469     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0BF6    75BB10        3469+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3470     
                      3471     CHECK_VOLTAGE_RET: 
0BF9    22            3472     	RET
                      3473     
                      3474     
                      3475     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3476     ;
                      3477     ; Set startup PWM routine
                      3478     ;
                      3479     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3480     ;
                      3481     ; Used for pwm control during startup
                      3482     ;
                      3483     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3484     SET_STARTUP_PWM: 	
                      3485     	; Set pwm values according to startup phase flags
0BFA    306102        3486     JNB FLAGS1 . 1 , ( $+5 ) 
0BFD    7832          3487     MOV R0 , # 50 
0BFF    306202        3488     JNB FLAGS1 . 2 , ( $+5 ) 
0C02    7878          3489     MOV R0 , # 120 
                      3490     
                      3491     	; Update pwm variables if any startup phase flag is set
0C04    E52C          3492     	MOV	A, FLAGS1
0C06    5406          3493     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0C08    601F          3494     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3495     
                      3496     	; Adjust startup power
0C0A    E8            3497     MOV A , R0 
0C0B    79A2          3498     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0C0D    87F0          3499     MOV B , @ R1 
0C0F    A4            3500     	MUL	AB
0C10    C5F0          3501     	XCH	A, B
0C12    A2F7          3502     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0C14    33            3503     	RLC	A
0C15    F8            3504     MOV R0 , A 
0C16    C3            3505     	CLR	C
0C17    E8            3506     MOV A , R0 
0C18    955E          3507     	SUBB	A, PWM_LIMIT	
0C1A    4002          3508     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3509     
0C1C    A85E          3510     MOV R0 , PWM_LIMIT 
                      3511     
                      3512     STARTUP_PWM_SET_PWM: 
                      3513     	; Set pwm variables
0C1E    8822          3514     MOV REQUESTED_PWM , R0 
0C20    8824          3515     MOV CURRENT_PWM , R0 
0C22    8825          3516     MOV CURRENT_PWM_LIMITED , R0 
0C24    306102        3517     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3518     
0C27    8860          3519     MOV PWM_SPOOLUP_BEG , R0 
                      3520     
                      3521     STARTUP_PWM_EXIT: 
0C29    22            3522     	RET
                      3523     
                      3524     
                      3525     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3526     ;
                      3527     ; Initialize all timings routine
                      3528     ;
                      3529     ; No assumptions
                      3530     ;
                      3531     ; Part of initialization before motor start
                      3532     ;
                      3533     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3534     INITIALIZE_ALL_TIMINGS:  
                      3535     	; Load programmed startup rpm
0C2A    788F          3536     MOV R0 , # PGM_STARTUP_RPM 
0C2C    E6            3537     MOV A , @ R0 
0C2D    FF            3538     MOV R7 , A 
                      3539     	; Check startup rpm setting and set step accordingly
0C2E    C3            3540     	CLR	C
0C2F    EF            3541     MOV A , R7 
0C30    9405          3542     	SUBB	A, #5
0C32    5018          3543     	JNC	STEPPER_STEP_HIGH
0C34    C3            3544     	CLR	C
0C35    EF            3545     MOV A , R7 
0C36    9404          3546     	SUBB	A, #4
0C38    5020          3547     	JNC	STEPPER_STEP_MED_HIGH
0C3A    C3            3548     	CLR	C
0C3B    EF            3549     MOV A , R7 
0C3C    9403          3550     	SUBB	A, #3
0C3E    5028          3551     	JNC	STEPPER_STEP_MED
0C40    C3            3552     	CLR	C
0C41    EF            3553     MOV A , R7 
0C42    9402          3554     	SUBB	A, #2
0C44    5030          3555     	JNC	STEPPER_STEP_MED_LOW
0C46    C3            3556     	CLR	C
0C47    EF            3557     MOV A , R7 
0C48    9401          3558     	SUBB	A, #1
0C4A    5038          3559     	JNC	STEPPER_STEP_LOW
                      3560     
                      3561     STEPPER_STEP_HIGH: 
0C4C    7533A0        3562     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0C4F    75340F        3563     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0C52    75353C        3564     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C55    753605        3565     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C58    8190          3566     	AJMP	STEPPER_STEP_SET
                      3567     STEPPER_STEP_MED_HIGH: 
0C5A    7533C0        3568     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C5D    753412        3569     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C60    753540        3570     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C63    753606        3571     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C66    8190          3572     	AJMP	STEPPER_STEP_SET
                      3573     STEPPER_STEP_MED: 
0C68    753370        3574     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C6B    753417        3575     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C6E    7535D0        3576     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C71    753607        3577     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C74    8190          3578     	AJMP	STEPPER_STEP_SET
                      3579     STEPPER_STEP_MED_LOW: 
0C76    75334C        3580     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C79    75341D        3581     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C7C    7535C4        3582     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C7F    753609        3583     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0C82    8190          3584     	AJMP	STEPPER_STEP_SET
                      3585     STEPPER_STEP_LOW: 
0C84    753328        3586     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0C87    753423        3587     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0C8A    7535B8        3588     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0C8D    75360B        3589     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3590     
                      3591     STEPPER_STEP_SET: 
0C90    853350        3592     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0C93    853451        3593     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0C96    753C00        3594     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0C99    753D08        3595     	MOV	COMM_PERIOD4X_H, #08H
0C9C    22            3596     	RET
                      3597     
                      3598     
                      3599     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3600     ;
                      3601     ; Calculate next commutation timing routine
                      3602     ;
                      3603     ; No assumptions
                      3604     ;
                      3605     ; Called immediately after each commutation
                      3606     ; Also sets up timer 3 to wait advance timing
                      3607     ; Two entry points are used
                      3608     ;
                      3609     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3610     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0C9D    A850          3611     MOV R0 , WT_STEPPER_STEP_L 
0C9F    A951          3612     MOV R1 , WT_STEPPER_STEP_H 
0CA1    020CA8        3613     	JMP	READ_TIMER
                      3614     
                      3615     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0CA4    A84A          3616     MOV R0 , WT_ADVANCE_L 
0CA6    A94B          3617     MOV R1 , WT_ADVANCE_H 
                      3618     READ_TIMER: 
                      3619     	; Set up next wait
0CA8    759100        3620     	MOV	TMR3CN, #00H		; Timer3 disabled
0CAB    C3            3621     	CLR	C
0CAC    E4            3622     	CLR	A
0CAD    98            3623     SUBB A , R0 
0CAE    F594          3624     	MOV	TMR3L, A
0CB0    E4            3625     	CLR	A
0CB1    99            3626     SUBB A , R1 
0CB2    F595          3627     	MOV	TMR3H, A
0CB4    759104        3628     	MOV	TMR3CN, #04H		; Timer3 enabled
0CB7    D258          3629     SETB FLAGS0 . 0 
                      3630     	; Read commutation time
0CB9    75C820        3631     	MOV	TMR2CN, #20H		; Timer2 disabled
0CBC    A8CC          3632     MOV R0 , TMR2L 
0CBE    A9CD          3633     MOV R1 , TMR2H 
0CC0    75C824        3634     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3635     	; Calculate this commutation time
0CC3    AA3A          3636     MOV R2 , PREV_COMM_L 
0CC5    AB3B          3637     MOV R3 , PREV_COMM_H 
0CC7    883A          3638     MOV PREV_COMM_L , R0 
0CC9    893B          3639     MOV PREV_COMM_H , R1 
0CCB    C3            3640     	CLR	C
0CCC    E8            3641     MOV A , R0 
0CCD    9A            3642     SUBB A , R2 
0CCE    F8            3643     MOV R0 , A 
0CCF    E9            3644     MOV A , R1 
0CD0    9B            3645     SUBB A , R3 
0CD1    F9            3646     MOV R1 , A 
                      3647     	; Calculate next zero cross scan timeout 
0CD2    AA3C          3648     MOV R2 , COMM_PERIOD4X_L 
0CD4    AB3D          3649     MOV R3 , COMM_PERIOD4X_H 
0CD6    C3            3650     	CLR	C
0CD7    EB            3651     MOV A , R3 
0CD8    13            3652     	RRC	A					; Divide by 2
0CD9    FD            3653     MOV R5 , A 
0CDA    EA            3654     MOV A , R2 
0CDB    13            3655     	RRC	A
0CDC    FC            3656     MOV R4 , A 
0CDD    C3            3657     	CLR	C
0CDE    ED            3658     MOV A , R5 
0CDF    13            3659     	RRC	A					; Divide by 2 again
0CE0    FD            3660     MOV R5 , A 
0CE1    EC            3661     MOV A , R4 
0CE2    13            3662     	RRC	A
0CE3    FC            3663     MOV R4 , A 
0CE4    C3            3664     	CLR	C
0CE5    EA            3665     MOV A , R2 
0CE6    9C            3666     SUBB A , R4 
0CE7    FA            3667     MOV R2 , A 
0CE8    EB            3668     MOV A , R3 
0CE9    9D            3669     SUBB A , R5 
0CEA    FB            3670     MOV R3 , A 
                      3671     
0CEB    EA            3672     MOV A , R2 
0CEC    28            3673     ADD A , R0 
0CED    FA            3674     MOV R2 , A 
0CEE    EB            3675     MOV A , R3 
0CEF    39            3676     ADDC A , R1 
0CF0    FB            3677     MOV R3 , A 
0CF1    8A3C          3678     MOV COMM_PERIOD4X_L , R2 
0CF3    8B3D          3679     MOV COMM_PERIOD4X_H , R3 
0CF5    4001          3680     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      3681     
0CF7    22            3682     	RET
                      3683     
                      3684     CALC_NEXT_COMM_SLOW: 
0CF8    753CFF        3685     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0CFB    753DFF        3686     	MOV	COMM_PERIOD4X_H, #0FFH
0CFE    22            3687     	RET
                      3688     
                      3689     
                      3690     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3691     ;
                      3692     ; Setup zero cross scan wait
                      3693     ;
                      3694     ; No assumptions
                      3695     ;
                      3696     ; Sets up timer 3 to wait the zero cross scan wait time
                      3697     ;
                      3698     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3699     SETUP_ZC_SCAN_WAIT: 
0CFF    759100        3700     	MOV	TMR3CN, #00H		; Timer3 disabled
0D02    C3            3701     	CLR	C
0D03    E4            3702     	CLR	A
0D04    954C          3703     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0D06    F594          3704     	MOV	TMR3L, A
0D08    E4            3705     	CLR	A
0D09    954D          3706     	SUBB	A, WT_ZC_SCAN_H		
0D0B    F595          3707     	MOV	TMR3H, A
0D0D    759104        3708     	MOV	TMR3CN, #04H		; Timer3 enabled
0D10    D258          3709     SETB FLAGS0 . 0 
0D12    22            3710     	RET
                      3711     
                      3712     
                      3713     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3714     ;
                      3715     ; Wait advance timing routine
                      3716     ;
                      3717     ; No assumptions
                      3718     ;
                      3719     ; Waits for the advance timing to elapse, waits one zero cross
                      3720     ; wait and sets up the next zero cross wait
                      3721     ;
                      3722     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3723     WAIT_ADVANCE_TIMING: 	
0D13    7F01          3724     MOV R7 , # 1 
0D15    789C          3725     MOV R0 , # PGM_DEMAG_COMP 
0D17    E6            3726     MOV A , @ R0 
0D18    14            3727     	DEC	A
0D19    6002          3728     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      3729     
0D1B    7F02          3730     MOV R7 , # 2 
                      3731     
                      3732     WAIT_ADVANCE_TIMING_WAIT: 
0D1D    305802        3733     JNB FLAGS0 . 0 , ( $+5 ) 
0D20    A11D          3734     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      3735     
0D22    91FF          3736     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0D24    DFF7          3737     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      3738     
0D26    22            3739     	RET
                      3740     
                      3741     
                      3742     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3743     ;
                      3744     ; Calculate new wait times routine
                      3745     ;
                      3746     ; No assumptions
                      3747     ;
                      3748     ; Calculates new wait times
                      3749     ;
                      3750     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3751     CALC_NEW_WAIT_TIMES: 	
                      3752     	; Load programmed commutation timing
0D27    7892          3753     MOV R0 , # PGM_COMM_TIMING 
0D29    E6            3754     MOV A , @ R0 
0D2A    FF            3755     MOV R7 , A 
0D2B    7E14          3756     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      3757     IF MODE == 2
0D2D    A83D          3758     MOV R0 , COMM_PERIOD4X_H 
0D2F    C3            3759     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0D30    E8            3760     MOV A , R0 
0D31    9404          3761     	SUBB	A, #4
0D33    4002          3762     	JC	CALC_NEW_WAIT_RED_SET
                      3763     
0D35    7804          3764     MOV R0 , # 4 
                      3765     
                      3766     CALC_NEW_WAIT_RED_SET: 
0D37    C3            3767     	CLR	C
0D38    E8            3768     MOV A , R0 
0D39    33            3769     	RLC	A
0D3A    F8            3770     MOV R0 , A 
0D3B    C3            3771     	CLR	C
0D3C    EE            3772     MOV A , R6 
0D3D    98            3773     SUBB A , R0 
0D3E    FE            3774     MOV R6 , A 
                      3775     ENDIF
0D3F    306304        3776     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      3777     
0D42    7F03          3778     MOV R7 , # 3 
0D44    7E00          3779     MOV R6 , # 0 
                      3780     
                      3781     CALC_NEW_WAIT_DIR_START_SET: 
                      3782     	; Load current commutation timing
0D46    A93D          3783     MOV R1 , COMM_PERIOD4X_H 
0D48    A83C          3784     MOV R0 , COMM_PERIOD4X_L 
0D4A    7A04          3785     MOV R2 , # 4 
                      3786     DIVIDE_WAIT_TIMES: 
0D4C    C3            3787     	CLR	C
0D4D    E9            3788     MOV A , R1 
0D4E    13            3789     	RRC	A					; Divide by 2
0D4F    F9            3790     MOV R1 , A 
0D50    E8            3791     MOV A , R0 
0D51    13            3792     	RRC	A
0D52    F8            3793     MOV R0 , A 
0D53    DAF7          3794     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      3795     
0D55    C3            3796     	CLR	C
0D56    E8            3797     MOV A , R0 
0D57    9E            3798     SUBB A , R6 
0D58    F8            3799     MOV R0 , A 
0D59    E9            3800     MOV A , R1 
0D5A    9400          3801     	SUBB	A, #0
0D5C    F9            3802     MOV R1 , A 
0D5D    4009          3803     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      3804     
0D5F    C3            3805     	CLR	C
0D60    E8            3806     MOV A , R0 
0D61    9402          3807     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D63    E9            3808     MOV A , R1 
0D64    9400          3809     	SUBB	A, #0
0D66    5004          3810     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      3811     
                      3812     LOAD_MIN_TIME: 
0D68    7802          3813     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D6A    E4            3814     	CLR	A
0D6B    F9            3815     MOV R1 , A 
                      3816     
                      3817     ADJUST_TIMING: 
0D6C    E9            3818     MOV A , R1 
0D6D    FB            3819     MOV R3 , A 
0D6E    E8            3820     MOV A , R0 
0D6F    FA            3821     MOV R2 , A 
0D70    C3            3822     	CLR	C
0D71    E9            3823     MOV A , R1 
0D72    13            3824     	RRC	A					; Divide by 2
0D73    FD            3825     MOV R5 , A 
0D74    E8            3826     MOV A , R0 
0D75    13            3827     	RRC	A
0D76    FC            3828     MOV R4 , A 
0D77    C3            3829     	CLR	C
0D78    EF            3830     MOV A , R7 
0D79    9403          3831     	SUBB	A, #3				; Is timing normal?
0D7B    602E          3832     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      3833     
0D7D    EF            3834     MOV A , R7 
0D7E    20E00D        3835     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      3836     
0D81    E8            3837     MOV A , R0 
0D82    2C            3838     ADD A , R4 
0D83    F8            3839     MOV R0 , A 
0D84    E9            3840     MOV A , R1 
0D85    3D            3841     ADDC A , R5 
0D86    F9            3842     MOV R1 , A 
0D87    EC            3843     MOV A , R4 
0D88    FA            3844     MOV R2 , A 
0D89    ED            3845     MOV A , R5 
0D8A    FB            3846     MOV R3 , A 
0D8B    020D98        3847     	JMP	STORE_TIMES_UP_OR_DOWN
                      3848     
                      3849     ADJUST_TIMING_TWO_STEPS: 
0D8E    E8            3850     MOV A , R0 
0D8F    28            3851     ADD A , R0 
0D90    F8            3852     MOV R0 , A 
0D91    E9            3853     MOV A , R1 
0D92    39            3854     ADDC A , R1 
0D93    F9            3855     MOV R1 , A 
0D94    7A02          3856     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0D96    E4            3857     	CLR	A
0D97    FB            3858     MOV R3 , A 
                      3859     
                      3860     STORE_TIMES_UP_OR_DOWN: 
0D98    C3            3861     	CLR	C
0D99    EF            3862     MOV A , R7 
0D9A    9403          3863     	SUBB	A, #3				; Is timing higher than normal?
0D9C    400D          3864     	JC	STORE_TIMES_DECREASE	; No - branch
                      3865     
                      3866     STORE_TIMES_INCREASE: 
0D9E    8A4E          3867     MOV WT_COMM_L , R2 
0DA0    8B4F          3868     MOV WT_COMM_H , R3 
0DA2    884A          3869     MOV WT_ADVANCE_L , R0 
0DA4    894B          3870     MOV WT_ADVANCE_H , R1 
0DA6    8C4C          3871     MOV WT_ZC_SCAN_L , R4 
0DA8    8D4D          3872     MOV WT_ZC_SCAN_H , R5 
0DAA    22            3873     	RET
                      3874     
                      3875     STORE_TIMES_DECREASE: 
0DAB    884E          3876     MOV WT_COMM_L , R0 
0DAD    894F          3877     MOV WT_COMM_H , R1 
0DAF    8A4A          3878     MOV WT_ADVANCE_L , R2 
0DB1    8B4B          3879     MOV WT_ADVANCE_H , R3 
0DB3    8C4C          3880     MOV WT_ZC_SCAN_L , R4 
0DB5    8D4D          3881     MOV WT_ZC_SCAN_H , R5 
0DB7    22            3882     	RET
                      3883     
                      3884     
                      3885     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3886     ;
                      3887     ; Wait before zero cross scan routine
                      3888     ;
                      3889     ; No assumptions
                      3890     ;
                      3891     ; Waits for the zero cross scan wait time to elapse
                      3892     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      3893     ;
                      3894     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3895     WAIT_BEFORE_ZC_SCAN: 	
0DB8    305802        3896     JNB FLAGS0 . 0 , ( $+5 ) 
0DBB    A1B8          3897     	AJMP	WAIT_BEFORE_ZC_SCAN
                      3898     
0DBD    759100        3899     	MOV	TMR3CN, #00H		; Timer3 disabled
0DC0    C3            3900     	CLR	C
0DC1    E4            3901     	CLR	A
0DC2    953C          3902     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0DC4    F594          3903     	MOV	TMR3L, A
0DC6    E4            3904     	CLR	A
0DC7    953D          3905     	SUBB	A, COMM_PERIOD4X_H		
0DC9    F595          3906     	MOV	TMR3H, A
0DCB    759104        3907     	MOV	TMR3CN, #04H		; Timer3 enabled
0DCE    D258          3908     SETB FLAGS0 . 0 
0DD0    22            3909     	RET
                      3910     
                      3911     
                      3912     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3913     ;
                      3914     ; Wait for comparator to go low/high routines
                      3915     ;
                      3916     ; No assumptions
                      3917     ;
                      3918     ; Waits for the zero cross scan wait time to elapse
                      3919     ; Then scans for comparator going low/high
                      3920     ;
                      3921     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3922     WAIT_FOR_COMP_OUT_LOW: 
0DD1    753F00        3923     	MOV	COMP_WAIT_READS, #0
0DD4    752000        3924     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0DD7    020DE0        3925     	JMP	WAIT_FOR_COMP_OUT_START
                      3926     
                      3927     WAIT_FOR_COMP_OUT_HIGH: 
0DDA    753F00        3928     	MOV	COMP_WAIT_READS, #0
0DDD    752040        3929     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      3930     
                      3931     WAIT_FOR_COMP_OUT_START: 
0DE0    D2AF          3932     	SETB	EA						; Enable interrupts
0DE2    053F          3933     	INC	COMP_WAIT_READS
0DE4    205801        3934     JB FLAGS0 . 0 , ( $+4 ) 
0DE7    22            3935     	RET							; Yes - return
                      3936     
                      3937     	; Set default comparator response times
0DE8    759D00        3938     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      3939     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      3942     	; Select number of comparator readings based upon current rotation speed
0DEB    E53D          3943     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0DED    C3            3944     	CLR	C
0DEE    13            3945     	RRC	A						; Divide by 4
0DEF    C3            3946     	CLR	C
0DF0    13            3947     	RRC	A
0DF1    F8            3948     MOV R0 , A 
0DF2    08            3949     INC R0 
0DF3    6030          3950     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      3951     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0DF5    306A06        3952     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      3953     
0DF8    C3            3954     	CLR	C
0DF9    13            3955     	RRC	A						; Divide by 4 again
0DFA    C3            3956     	CLR	C
0DFB    13            3957     	RRC	A
0DFC    F8            3958     MOV R0 , A 
0DFD    08            3959     INC R0 
                      3960     
                      3961     COMP_WAIT_SET_MAX_READINGS: 
0DFE    C3            3962     	CLR	C
0DFF    E8            3963     MOV A , R0 
0E00    940A          3964     	SUBB	A, #10
0E02    4002          3965     	JC	($+4)
                      3966     
0E04    780A          3967     MOV R0 , # 10 
                      3968     
0E06    306D08        3969     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      3970     
0E09    C3            3971     	CLR	C
0E0A    E8            3972     MOV A , R0 
0E0B    9404          3973     	SUBB	A, #4
0E0D    4002          3974     	JC	($+4)
                      3975     
0E0F    7804          3976     MOV R0 , # 4 
                      3977     
                      3978     COMP_WAIT_SET_RESPONSE_TIME: 
0E11    C3            3979     	CLR	C
0E12    E53D          3980     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0E14    9408          3981     	SUBB	A, #8
0E16    400D          3982     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      3983     
0E18    759D02        3984     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      3985     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0E1B    C3            3988     	CLR	C
0E1C    E53D          3989     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0E1E    9410          3990     	SUBB	A, #16
0E20    4003          3991     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      3992     
0E22    759D03        3993     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      3994     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      3997     
                      3998     COMP_WAIT_ON_COMP_ABLE: 
0E25    205803        3999     JB FLAGS0 . 0 , ( $+6 ) 
0E28    D2AF          4000     	SETB	EA							; Enable interrupts
0E2A    22            4001     	RET								; Yes - return
                      4002     
0E2B    791E          4003     MOV R1 , # 30 
0E2D    206D02        4004     JB FLAGS2 . 5 , ( $+5 ) 
0E30    790A          4005     MOV R1 , # 10 
0E32    D2AF          4006     	SETB	EA							; Enable interrupts
0E34    00            4007     	NOP								; Allocate only just enough time to capture interrupt
0E35    00            4008     	NOP
0E36    C2AF          4009     	CLR	EA							; Disable interrupts
0E38    205A0A        4010     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4011     
0E3B    793C          4012     MOV R1 , # 60 
0E3D    206D02        4013     JB FLAGS2 . 5 , ( $+5 ) 
0E40    7914          4014     MOV R1 , # 20 
0E42    3066E0        4015     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4016     
                      4017     PWM_WAIT_STARTUP: 						
0E45    306302        4018     JNB FLAGS1 . 3 , PWM_WAIT 
                      4019     
0E48    7978          4020     MOV R1 , # 120 
                      4021     PWM_WAIT: 						
0E4A    C3            4022     	CLR	C
0E4B    E58B          4023     	MOV	A, TL1
0E4D    99            4024     SUBB A , R1 
                      4025     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0E4E    40D5          4030     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4031     ENDIF
                      4032     
                      4033     COMP_READ: 
                      4034     	READ_COMP_OUT 					; Read comparator output
0E50    E59B          4034+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0E52    F4            4035     	CPL	A
0E53    5440          4036     	ANL	A, #40H
0E55    B52002        4037     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4038     
0E58    A1E0          4039     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4040     
0E5A    D8C9          4041     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4042     
0E5C    D2AF          4043     	SETB	EA						; Enable interrupts
0E5E    22            4044     	RET							
                      4045     
                      4046     
                      4047     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4048     ;
                      4049     ; Evaluate comparator integrity
                      4050     ;
                      4051     ; No assumptions
                      4052     ;
                      4053     ; Checks comparator signal behaviour versus expected behaviour
                      4054     ;
                      4055     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4056     EVALUATE_COMPARATOR_INTEGRITY: 
0E5F    C25B          4057     CLR FLAGS0 . 3 
                      4058     	; Check if demag compensation is enabled
0E61    789C          4059     MOV R0 , # PGM_DEMAG_COMP 
0E63    E6            4060     MOV A , @ R0 
0E64    14            4061     	DEC	A
0E65    600A          4062     	JZ	EVAL_COMP_NO_DEMAG
                      4063     
                      4064     	; Check if a demag situation has occurred
0E67    E53F          4065     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0E69    14            4066     	DEC	A
0E6A    7005          4067     	JNZ	EVAL_COMP_NO_DEMAG
                      4068     
0E6C    206302        4069     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4070     
0E6F    D25B          4071     SETB FLAGS0 . 3 
                      4072     
                      4073     EVAL_COMP_NO_DEMAG: 
0E71    30630B        4074     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4075     
0E74    0538          4076     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0E76    205810        4077     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4078     
0E79    753800        4079     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0E7C    020E89        4080     	JMP	EVAL_COMP_EXIT
                      4081     
                      4082     EVAL_COMP_CHECK_TIMEOUT: 
0E7F    205807        4083     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0E82    1581          4084     	DEC	SP							; Routine exit without "ret" command
0E84    1581          4085     	DEC	SP
0E86    0217F1        4086     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4087     
                      4088     EVAL_COMP_EXIT: 
0E89    22            4089     	RET
                      4090     
                      4091     
                      4092     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4093     ;
                      4094     ; Setup commutation timing routine
                      4095     ;
                      4096     ; No assumptions
                      4097     ;
                      4098     ; Sets up and starts wait from commutation to zero cross
                      4099     ;
                      4100     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4101     SETUP_COMM_WAIT:  
0E8A    759100        4102     	MOV	TMR3CN, #00H		; Timer3 disabled
0E8D    C3            4103     	CLR	C
0E8E    E4            4104     	CLR	A
0E8F    954E          4105     	SUBB	A, WT_COMM_L		; Set wait commutation value
0E91    F594          4106     	MOV	TMR3L, A
0E93    E4            4107     	CLR	A
0E94    954F          4108     	SUBB	A, WT_COMM_H		
0E96    F595          4109     	MOV	TMR3H, A
0E98    759104        4110     	MOV	TMR3CN, #04H		; Timer3 enabled
0E9B    D258          4111     SETB FLAGS0 . 0 
0E9D    22            4112     	RET
                      4113     
                      4114     
                      4115     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4116     ;
                      4117     ; Wait for commutation routine
                      4118     ;
                      4119     ; No assumptions
                      4120     ;
                      4121     ; Waits from zero cross to commutation 
                      4122     ;
                      4123     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4124     WAIT_FOR_COMM:  
                      4125     	; Increment or reset consecutive count
0E9E    0539          4126     	INC	DEMAG_CONSECUTIVE_CNT
0EA0    205B03        4127     JB FLAGS0 . 3 , ( $+6 ) 
                      4128     
0EA3    753900        4129     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4130     
                      4131     	; Check if a demag situation has occurred
0EA6    305B23        4132     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4133     
                      4134     	; Load programmed demag compensation
0EA9    78A3          4135     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0EAB    E6            4136     MOV A , @ R0 
0EAC    FF            4137     MOV R7 , A 
                      4138     
                      4139     	; Check for power off
0EAD    BF0108        4140     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4141     
0EB0    D25C          4142     SETB FLAGS0 . 4 
                      4143     	ALL_NFETS_OFF
0EB2    C292          4143+1   CLR P1 . 2 
0EB4    C296          4143+1   CLR P1 . 6 
0EB6    C295          4143+1   CLR P1 . 5 
                      4144     
                      4145     	; Wait a blind wait
                      4146     WAIT_FOR_COMM_BLIND: 
0EB8    91FF          4147     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4148     WAIT_DEMAG_DEFAULT_ZC: 	
0EBA    305802        4149     JNB FLAGS0 . 0 , ( $+5 ) 
0EBD    C1BA          4150     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4151     
                      4152     	; Check for power off
0EBF    BF0208        4153     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4154     
0EC2    D25C          4155     SETB FLAGS0 . 4 
                      4156     	ALL_NFETS_OFF
0EC4    C292          4156+1   CLR P1 . 2 
0EC6    C296          4156+1   CLR P1 . 6 
0EC8    C295          4156+1   CLR P1 . 5 
                      4157     
                      4158     WAIT_FOR_COMM_SETUP: 
0ECA    D18A          4159     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4160     WAIT_FOR_COMM_WAIT: 
0ECC    305802        4161     JNB FLAGS0 . 0 , ( $+5 ) 
0ECF    C1CC          4162     	AJMP	WAIT_FOR_COMM_WAIT					
                      4163     
0ED1    22            4164     	RET
                      4165     
                      4166     
                      4167     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4168     ;
                      4169     ; Commutation routines
                      4170     ;
                      4171     ; No assumptions
                      4172     ;
                      4173     ; Performs commutation switching 
                      4174     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4175     ;
                      4176     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4177     COMM1COMM2: 	
0ED2    C2AF          4178     	CLR 	EA					; Disable all interrupts
                      4179     	BPFET_OFF					; Bp off
0ED4    C294          4179+1   CLR P1 . 4 
0ED6    206A03        4180     JB FLAGS2 . 2 , COMM12_DAMP 
0ED9    020EF1        4181     	JMP	COMM12_NONDAMP
                      4182     COMM12_DAMP: 
                      4183     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4187     IF DAMPED_MODE_ENABLE == 1
0EDC    900347        4188     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4189     ENDIF
0EDF    30650F        4190     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4191     	CPFET_OFF				
0EE2    207502        4191+1   JB FLAGS3 . 5 , ( $+5 ) 
0EE5    C297          4191+1   CLR P1 . 7 
0EE7    307502        4191+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EEA    C293          4191+1   CLR P1 . 3 
0EEC    7406          4192     MOV A , # 6 
0EEE    D5E0FD        4193     	DJNZ ACC,	$
                      4194     COMM12_NONDAMP: 
                      4195     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	ANFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	ANFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4203     	APFET_ON					; Ap on
0EF1    207502        4203+1   JB FLAGS3 . 5 , ( $+5 ) 
0EF4    D293          4203+1   SETB P1 . 3 
0EF6    307502        4203+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EF9    D297          4203+1   SETB P1 . 7 
                      4204     	SET_COMP_PHASE_B 			; Set comparator to phase B
0EFB    759F80        4204+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EFE    753E02        4205     	MOV	COMM_PHASE, #2
0F01    02105C        4206     	JMP	COMM_EXIT
                      4207     
                      4208     COMM2COMM3: 	
0F04    C2AF          4209     	CLR 	EA					; Disable all interrupts
0F06    206A03        4210     JB FLAGS2 . 2 , COMM23_DAMP 
0F09    020F26        4211     	JMP	COMM23_NONDAMP
                      4212     COMM23_DAMP: 
                      4213     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4216     IF DAMPED_MODE_ENABLE == 1
0F0C    9002FE        4217     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4218     ENDIF
0F0F    306517        4219     JNB FLAGS1 . 5 , COMM23_NFET 
                      4220     	BPFET_OFF				
0F12    C294          4220+1   CLR P1 . 4 
                      4221     	CPFET_OFF				
0F14    207502        4221+1   JB FLAGS3 . 5 , ( $+5 ) 
0F17    C297          4221+1   CLR P1 . 7 
0F19    307502        4221+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F1C    C293          4221+1   CLR P1 . 3 
0F1E    7406          4222     MOV A , # 6 
0F20    D5E0FD        4223     	DJNZ ACC,	$
0F23    020F29        4224     	JMP	COMM23_NFET
                      4225     COMM23_NONDAMP: 
0F26    9001E1        4226     	MOV	DPTR, #PWM_BFET_ON	
                      4227     COMM23_NFET: 
                      4228     	CNFET_OFF					; Cn off
0F29    207502        4228+1   JB FLAGS3 . 5 , ( $+5 ) 
0F2C    C296          4228+1   CLR P1 . 6 
0F2E    307502        4228+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F31    C292          4228+1   CLR P1 . 2 
0F33    305A06        4229     JNB FLAGS0 . 2 , COMM23_CP 
                      4230     	BNFET_ON					; Yes - Bn on
0F36    E525          4230+1   MOV A , CURRENT_PWM_LIMITED 
0F38    6002          4230+1   JZ ( $+4 ) 
0F3A    D295          4230+1   SETB P1 . 5 
                      4231     COMM23_CP: 
                      4232     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F3C    207503        4232+1   JB FLAGS3 . 5 , ( $+6 ) 
0F3F    759F89        4232+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F42    307503        4232+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F45    759F81        4232+1   MOV CPT0MX , # 81H 
0F48    753E03        4233     	MOV	COMM_PHASE, #3
0F4B    02105C        4234     	JMP	COMM_EXIT
                      4235     
                      4236     COMM3COMM4: 	
0F4E    C2AF          4237     	CLR 	EA					; Disable all interrupts
                      4238     	APFET_OFF					; Ap off
0F50    207502        4238+1   JB FLAGS3 . 5 , ( $+5 ) 
0F53    C293          4238+1   CLR P1 . 3 
0F55    307502        4238+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F58    C297          4238+1   CLR P1 . 7 
0F5A    206A03        4239     JB FLAGS2 . 2 , COMM34_DAMP 
0F5D    020F6D        4240     	JMP	COMM34_NONDAMP
                      4241     COMM34_DAMP: 
                      4242     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4246     IF DAMPED_MODE_ENABLE == 1
0F60    9002BD        4247     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4248     ENDIF
0F63    306507        4249     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4250     	BPFET_OFF				
0F66    C294          4250+1   CLR P1 . 4 
0F68    7406          4251     MOV A , # 6 
0F6A    D5E0FD        4252     	DJNZ ACC,	$
                      4253     COMM34_NONDAMP: 
                      4254     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	CNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	CNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4262     	CPFET_ON					; Cp on
0F6D    207502        4262+1   JB FLAGS3 . 5 , ( $+5 ) 
0F70    D297          4262+1   SETB P1 . 7 
0F72    307502        4262+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F75    D293          4262+1   SETB P1 . 3 
                      4263     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F77    207503        4263+1   JB FLAGS3 . 5 , ( $+6 ) 
0F7A    759F81        4263+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F7D    307503        4263+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F80    759F89        4263+1   MOV CPT0MX , # 89H 
0F83    753E04        4264     	MOV	COMM_PHASE, #4
0F86    02105C        4265     	JMP	COMM_EXIT
                      4266     
                      4267     COMM4COMM5: 	
0F89    C2AF          4268     	CLR 	EA					; Disable all interrupts
0F8B    206A03        4269     JB FLAGS2 . 2 , COMM45_DAMP 
0F8E    020FAB        4270     	JMP	COMM45_NONDAMP
                      4271     COMM45_DAMP: 
                      4272     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4275     IF DAMPED_MODE_ENABLE == 1
0F91    90027C        4276     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4277     ENDIF
0F94    306517        4278     JNB FLAGS1 . 5 , COMM45_NFET 
                      4279     	APFET_OFF				
0F97    207502        4279+1   JB FLAGS3 . 5 , ( $+5 ) 
0F9A    C293          4279+1   CLR P1 . 3 
0F9C    307502        4279+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F9F    C297          4279+1   CLR P1 . 7 
                      4280     	BPFET_OFF				
0FA1    C294          4280+1   CLR P1 . 4 
0FA3    7406          4281     MOV A , # 6 
0FA5    D5E0FD        4282     	DJNZ ACC,	$
0FA8    020FAE        4283     	JMP	COMM45_NFET
                      4284     COMM45_NONDAMP: 
0FAB    9001CF        4285     	MOV	DPTR, #PWM_AFET_ON
                      4286     COMM45_NFET: 
                      4287     	BNFET_OFF					; Bn off
0FAE    C295          4287+1   CLR P1 . 5 
0FB0    305A0E        4288     JNB FLAGS0 . 2 , COMM45_CP 
                      4289     	ANFET_ON					; Yes - An on
0FB3    E525          4289+1   MOV A , CURRENT_PWM_LIMITED 
0FB5    600A          4289+1   JZ ( $+12 ) 
0FB7    207502        4289+1   JB FLAGS3 . 5 , ( $+5 ) 
0FBA    D292          4289+1   SETB P1 . 2 
0FBC    307502        4289+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FBF    D296          4289+1   SETB P1 . 6 
                      4290     COMM45_CP: 
                      4291     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FC1    759F80        4291+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FC4    753E05        4292     	MOV	COMM_PHASE, #5
0FC7    02105C        4293     	JMP	COMM_EXIT
                      4294     
                      4295     COMM5COMM6: 	
0FCA    C2AF          4296     	CLR 	EA					; Disable all interrupts
                      4297     	CPFET_OFF					; Cp off
0FCC    207502        4297+1   JB FLAGS3 . 5 , ( $+5 ) 
0FCF    C297          4297+1   CLR P1 . 7 
0FD1    307502        4297+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FD4    C293          4297+1   CLR P1 . 3 
0FD6    206A03        4298     JB FLAGS2 . 2 , COMM56_DAMP 
0FD9    020FF1        4299     	JMP	COMM56_NONDAMP
                      4300     COMM56_DAMP: 
                      4301     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4305     IF DAMPED_MODE_ENABLE == 1
0FDC    900233        4306     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4307     ENDIF
0FDF    30650F        4308     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4309     	APFET_OFF				
0FE2    207502        4309+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE5    C293          4309+1   CLR P1 . 3 
0FE7    307502        4309+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FEA    C297          4309+1   CLR P1 . 7 
0FEC    7406          4310     MOV A , # 6 
0FEE    D5E0FD        4311     	DJNZ ACC,	$
                      4312     COMM56_NONDAMP: 
                      4313     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                               	BNFET_ON				
                               	MOV	A, #HIGH_DRIVER_PRECHG_TIME
                               	DJNZ ACC,	$
                               	BNFET_OFF				
                               	MOV	A, #PFETON_DELAY
                               	DJNZ ACC,	$
                               ENDIF
                      4321     	BPFET_ON					; Bp on
0FF1    D294          4321+1   SETB P1 . 4 
                      4322     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FF3    207503        4322+1   JB FLAGS3 . 5 , ( $+6 ) 
0FF6    759F89        4322+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FF9    307503        4322+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FFC    759F81        4322+1   MOV CPT0MX , # 81H 
0FFF    753E06        4323     	MOV	COMM_PHASE, #6
1002    02105C        4324     	JMP	COMM_EXIT
                      4325     
                      4326     COMM6COMM1: 	
1005    C2AF          4327     	CLR 	EA					; Disable all interrupts
1007    206A03        4328     JB FLAGS2 . 2 , COMM61_DAMP 
100A    02102F        4329     	JMP	COMM61_NONDAMP
                      4330     COMM61_DAMP: 
                      4331     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4334     IF DAMPED_MODE_ENABLE == 1
100D    9003A0        4335     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4336     ENDIF
1010    30651F        4337     JNB FLAGS1 . 5 , COMM61_NFET 
                      4338     	APFET_OFF				
1013    207502        4338+1   JB FLAGS3 . 5 , ( $+5 ) 
1016    C293          4338+1   CLR P1 . 3 
1018    307502        4338+1   JNB FLAGS3 . 5 , ( $+5 ) 
101B    C297          4338+1   CLR P1 . 7 
                      4339     	CPFET_OFF				
101D    207502        4339+1   JB FLAGS3 . 5 , ( $+5 ) 
1020    C297          4339+1   CLR P1 . 7 
1022    307502        4339+1   JNB FLAGS3 . 5 , ( $+5 ) 
1025    C293          4339+1   CLR P1 . 3 
1027    7406          4340     MOV A , # 6 
1029    D5E0FD        4341     	DJNZ ACC,	$
102C    021032        4342     	JMP	COMM61_NFET
                      4343     COMM61_NONDAMP: 
102F    9001F3        4344     	MOV	DPTR, #PWM_CFET_ON
                      4345     COMM61_NFET: 
                      4346     	ANFET_OFF					; An off
1032    207502        4346+1   JB FLAGS3 . 5 , ( $+5 ) 
1035    C292          4346+1   CLR P1 . 2 
1037    307502        4346+1   JNB FLAGS3 . 5 , ( $+5 ) 
103A    C296          4346+1   CLR P1 . 6 
103C    305A0E        4347     JNB FLAGS0 . 2 , COMM61_CP 
                      4348     	CNFET_ON					; Yes - Cn on
103F    E525          4348+1   MOV A , CURRENT_PWM_LIMITED 
1041    600A          4348+1   JZ ( $+12 ) 
1043    207502        4348+1   JB FLAGS3 . 5 , ( $+5 ) 
1046    D296          4348+1   SETB P1 . 6 
1048    307502        4348+1   JNB FLAGS3 . 5 , ( $+5 ) 
104B    D292          4348+1   SETB P1 . 2 
                      4349     COMM61_CP: 
                      4350     	SET_COMP_PHASE_A 			; Set comparator to phase A
104D    207503        4350+1   JB FLAGS3 . 5 , ( $+6 ) 
1050    759F81        4350+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1053    307503        4350+1   JNB FLAGS3 . 5 , ( $+6 ) 
1056    759F89        4350+1   MOV CPT0MX , # 89H 
1059    753E01        4351     	MOV	COMM_PHASE, #1
                      4352     
                      4353     COMM_EXIT: 
105C    D2AF          4354     	SETB	EA					; Enable all interrupts
105E    789C          4355     MOV R0 , # PGM_DEMAG_COMP 
1060    E6            4356     MOV A , @ R0 
1061    C3            4357     	CLR	C
1062    9402          4358     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
1064    4007          4359     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4360     
1066    C3            4361     	CLR	C
1067    E539          4362     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
1069    9403          4363     	SUBB	A, #3
106B    5002          4364     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4365     
                      4366     COMM_RESTORE_POWER: 
106D    C25C          4367     CLR FLAGS0 . 4 
                      4368     
                      4369     COMM_RETURN: 
106F    22            4370     	RET
                      4371     
                      4372     
                      4373     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4374     ;
                      4375     ; Switch power off routine
                      4376     ;
                      4377     ; No assumptions
                      4378     ;
                      4379     ; Switches all fets off 
                      4380     ;
                      4381     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4382     SWITCH_POWER_OFF: 
1070    9001CD        4383     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4384     	ALL_NFETS_OFF			; Turn off all nfets
1073    C292          4384+1   CLR P1 . 2 
1075    C296          4384+1   CLR P1 . 6 
1077    C295          4384+1   CLR P1 . 5 
                      4385     	ALL_PFETS_OFF			; Turn off all pfets
1079    C293          4385+1   CLR P1 . 3 
107B    C297          4385+1   CLR P1 . 7 
107D    C294          4385+1   CLR P1 . 4 
107F    C25A          4386     CLR FLAGS0 . 2 
1081    22            4387     	RET			
                      4388     
                      4389     
                      4390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4391     ;
                      4392     ; Decrement stepper step routine
                      4393     ;
                      4394     ; No assumptions
                      4395     ;
                      4396     ; Decrements the stepper step 
                      4397     ;
                      4398     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4399     DECREMENT_STEPPER_STEP: 
1082    C3            4400     	CLR	C
1083    E550          4401     	MOV	A, WT_STEPPER_STEP_L
1085    9535          4402     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1087    E551          4403     	MOV	A, WT_STEPPER_STEP_H
1089    9536          4404     	SUBB	A, STEPPER_STEP_END_H	
108B    5001          4405     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
108D    22            4406     	RET
                      4407     
                      4408     DECREMENT_STEP: 
                      4409     	; Load programmed startup acceleration
108E    7890          4410     MOV R0 , # PGM_STARTUP_ACCEL 
1090    E6            4411     MOV A , @ R0 
1091    FF            4412     MOV R7 , A 
                      4413     	; Check acceleration setting and set step size accordingly
1092    C3            4414     	CLR	C
1093    EF            4415     MOV A , R7 
1094    9405          4416     	SUBB	A, #5
1096    5018          4417     	JNC	DEC_STEP_HIGH
1098    C3            4418     	CLR	C
1099    EF            4419     MOV A , R7 
109A    9404          4420     	SUBB	A, #4
109C    501B          4421     	JNC	DEC_STEP_MED_HIGH
109E    C3            4422     	CLR	C
109F    EF            4423     MOV A , R7 
10A0    9403          4424     	SUBB	A, #3
10A2    501E          4425     	JNC	DEC_STEP_MED
10A4    C3            4426     	CLR	C
10A5    EF            4427     MOV A , R7 
10A6    9402          4428     	SUBB	A, #2
10A8    5021          4429     	JNC	DEC_STEP_MED_LOW
10AA    C3            4430     	CLR	C
10AB    EF            4431     MOV A , R7 
10AC    9401          4432     	SUBB	A, #1
10AE    5024          4433     	JNC	DEC_STEP_LOW
                      4434     
                      4435     DEC_STEP_HIGH: 
10B0    C3            4436     	CLR	C
10B1    E550          4437     	MOV	A, WT_STEPPER_STEP_L
10B3    943C          4438     	SUBB	A, #LOW(30 SHL 1)		
10B5    F8            4439     MOV R0 , A 
10B6    0210DD        4440     	JMP	DECREMENT_STEP_EXIT
                      4441     DEC_STEP_MED_HIGH: 
10B9    C3            4442     	CLR	C
10BA    E550          4443     	MOV	A, WT_STEPPER_STEP_L
10BC    9428          4444     	SUBB	A, #LOW(20 SHL 1)		
10BE    F8            4445     MOV R0 , A 
10BF    0210DD        4446     	JMP	DECREMENT_STEP_EXIT
                      4447     DEC_STEP_MED: 
10C2    C3            4448     	CLR	C
10C3    E550          4449     	MOV	A, WT_STEPPER_STEP_L
10C5    941A          4450     	SUBB	A, #LOW(13 SHL 1)		
10C7    F8            4451     MOV R0 , A 
10C8    0210DD        4452     	JMP	DECREMENT_STEP_EXIT
                      4453     DEC_STEP_MED_LOW: 
10CB    C3            4454     	CLR	C
10CC    E550          4455     	MOV	A, WT_STEPPER_STEP_L
10CE    9412          4456     	SUBB	A, #LOW(9 SHL 1)		
10D0    F8            4457     MOV R0 , A 
10D1    0210DD        4458     	JMP	DECREMENT_STEP_EXIT
                      4459     DEC_STEP_LOW: 
10D4    C3            4460     	CLR	C
10D5    E550          4461     	MOV	A, WT_STEPPER_STEP_L
10D7    940A          4462     	SUBB	A, #LOW(5 SHL 1)		
10D9    F8            4463     MOV R0 , A 
10DA    0210DD        4464     	JMP	DECREMENT_STEP_EXIT
                      4465     
                      4466     DECREMENT_STEP_EXIT: 
10DD    E551          4467     	MOV	A, WT_STEPPER_STEP_H
10DF    9400          4468     	SUBB	A, #0		
10E1    F9            4469     MOV R1 , A 
10E2    8850          4470     MOV WT_STEPPER_STEP_L , R0 
10E4    8951          4471     MOV WT_STEPPER_STEP_H , R1 
10E6    22            4472     	RET
                      4473     
                      4474     
                      4475     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4476     ;
                      4477     ; Stepper timer wait
                      4478     ;
                      4479     ; No assumptions
                      4480     ;
                      4481     ; Waits for the stepper step timer to elapse
                      4482     ;
                      4483     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4484     STEPPER_TIMER_WAIT: 
10E7    305802        4485     JNB FLAGS0 . 0 , ( $+5 ) 
10EA    01E7          4486     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
10EC    22            4487     	RET
                      4488     
                      4489     
                      4490     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4491     ;
                      4492     ; Set default parameters
                      4493     ;
                      4494     ; No assumptions
                      4495     ;
                      4496     ; Sets default programming parameters
                      4497     ;
                      4498     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4499     SET_DEFAULT_PARAMETERS: 
                      4500     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4561     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4622     IF MODE == 2	; Multi
10ED    7880          4623     MOV R0 , # PGM_GOV_P_GAIN 
10EF    7609          4624     MOV @ R0 , # 9 
10F1    08            4625     INC R0 
10F2    7609          4626     MOV @ R0 , # 9 
10F4    08            4627     INC R0 
10F5    7604          4628     MOV @ R0 , # 4 
10F7    08            4629     INC R0 
10F8    7601          4630     MOV @ R0 , # 1 
10FA    08            4631     INC R0 
10FB    7603          4632     MOV @ R0 , # 3 
10FD    08            4633     INC R0 
10FE    76FF          4634     MOV @ R0 , # 0XFF 
1100    08            4635     INC R0 
1101    7609          4636     MOV @ R0 , # 9 
1103    08            4637     INC R0 
1104    7601          4638     MOV @ R0 , # 1 
1106    08            4639     INC R0 
1107    7601          4640     MOV @ R0 , # 1 
1109    08            4641     INC R0 
110A    7601          4642     MOV @ R0 , # 1 
                      4643     
110C    788C          4644     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
110E    7600          4645     MOV @ R0 , # 0 
1110    08            4646     INC R0 
1111    76FF          4647     MOV @ R0 , # 0XFF 
1113    08            4648     INC R0 
1114    76FF          4649     MOV @ R0 , # 0XFF 
1116    08            4650     INC R0 
1117    7601          4651     MOV @ R0 , # 1 
1119    08            4652     INC R0 
111A    7605          4653     MOV @ R0 , # 5 
111C    08            4654     INC R0 
111D    76FF          4655     MOV @ R0 , # 0XFF 
111F    08            4656     INC R0 
1120    7603          4657     MOV @ R0 , # 3 
1122    08            4658     INC R0 
1123    7606          4659     MOV @ R0 , # 6 
1125    08            4660     INC R0 
1126    76FF          4661     MOV @ R0 , # 0XFF 
1128    08            4662     INC R0 
1129    7602          4663     MOV @ R0 , # 2 
112B    08            4664     INC R0 
112C    7603          4665     MOV @ R0 , # 3 
112E    08            4666     INC R0 
112F    76FA          4667     MOV @ R0 , # 250 
1131    08            4668     INC R0 
1132    7628          4669     MOV @ R0 , # 40 
1134    08            4670     INC R0 
1135    7628          4671     MOV @ R0 , # 40 
1137    08            4672     INC R0 
1138    7605          4673     MOV @ R0 , # 5 
113A    08            4674     INC R0 
113B    7601          4675     MOV @ R0 , # 1 
113D    08            4676     INC R0 
113E    7602          4677     MOV @ R0 , # 2 
1140    08            4678     INC R0 
1141    7600          4679     MOV @ R0 , # 0 
1143    08            4680     INC R0 
1144    767D          4681     MOV @ R0 , # 125 
                      4682     ENDIF
1146    22            4683     	RET
                      4684     
                      4685     
                      4686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4687     ;
                      4688     ; Decode parameters
                      4689     ;
                      4690     ; No assumptions
                      4691     ;
                      4692     ; Decodes programming parameters
                      4693     ;
                      4694     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4695     DECODE_PARAMETERS: 
                      4696     	; Load programmed damping force
1147    7893          4697     MOV R0 , # PGM_DAMPING_FORCE 
1149    E6            4698     MOV A , @ R0 
114A    FF            4699     MOV R7 , A 
                      4700     	; Decode damping
114B    756609        4701     	MOV	DAMPING_PERIOD, #9		; Set default
114E    756701        4702     	MOV	DAMPING_ON, #1
1151    C3            4703     	CLR	C
1152    BF0206        4704     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      4705     
1155    756605        4706     	MOV	DAMPING_PERIOD, #5
1158    756701        4707     	MOV	DAMPING_ON, #1
                      4708     
                      4709     DECODE_DAMPING_3: 
115B    C3            4710     	CLR	C
115C    BF0306        4711     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      4712     
115F    756605        4713     	MOV	DAMPING_PERIOD, #5
1162    756702        4714     	MOV	DAMPING_ON, #2
                      4715     
                      4716     DECODE_DAMPING_4: 
1165    C3            4717     	CLR	C
1166    BF0406        4718     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      4719     
1169    756605        4720     	MOV	DAMPING_PERIOD, #5
116C    756703        4721     	MOV	DAMPING_ON, #3
                      4722     
                      4723     DECODE_DAMPING_5: 
116F    C3            4724     	CLR	C
1170    BF0506        4725     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      4726     
1173    756609        4727     	MOV	DAMPING_PERIOD, #9
1176    756707        4728     	MOV	DAMPING_ON, #7
                      4729     
                      4730     DECODE_DAMPING_6: 
1179    C3            4731     	CLR	C
117A    BF0606        4732     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      4733     
117D    756600        4734     	MOV	DAMPING_PERIOD, #0
1180    756700        4735     	MOV	DAMPING_ON, #0
                      4736     
                      4737     DECODE_DAMPING_DONE: 
                      4738     	; Load programmed pwm frequency
1183    7887          4739     MOV R0 , # PGM_PWM_FREQ 
1185    E6            4740     MOV A , @ R0 
1186    FF            4741     MOV R7 , A 
                      4742     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      4749     IF MODE >= 1	; Tail or multi
1187    C26C          4750     CLR FLAGS2 . 4 
1189    C3            4751     	CLR	C
118A    BF0302        4752     CJNE R7 , # 3 , ( $+5 ) 
118D    D26C          4753     SETB FLAGS2 . 4 
118F    C26B          4754     CLR FLAGS2 . 3 
1191    C3            4755     	CLR	C
1192    BF0402        4756     CJNE R7 , # 4 , ( $+5 ) 
1195    D26B          4757     SETB FLAGS2 . 3 
                      4758     ENDIF
1197    C26A          4759     CLR FLAGS2 . 2 
1199    7418          4760     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
119B    552D          4761     	ANL	A, FLAGS2					; Check if any damped mode is set
119D    6002          4762     	JZ	($+4)
119F    D26A          4763     SETB FLAGS2 . 2 
11A1    C265          4764     CLR FLAGS1 . 5 
11A3    6002          4765     	JZ	($+4)
11A5    D265          4766     SETB FLAGS1 . 5 
11A7    D266          4767     SETB FLAGS1 . 6 
11A9    6002          4768     	JZ	($+4)
11AB    C266          4769     CLR FLAGS1 . 6 
                      4770     	; Load programmed direction
11AD    7888          4771     MOV R0 , # PGM_DIRECTION 
                      4772     IF MODE >= 1	; Tail or multi
11AF    E6            4773     MOV A , @ R0 
11B0    C3            4774     	CLR	C
11B1    9403          4775     	SUBB	A, #3
11B3    6008          4776     	JZ	DECODE_PARAMS_DIR_SET
                      4777     ENDIF
                      4778     
11B5    C275          4779     CLR FLAGS3 . 5 
11B7    E6            4780     MOV A , @ R0 
11B8    30E102        4781     	JNB	ACC.1, ($+5)
11BB    D275          4782     SETB FLAGS3 . 5 
                      4783     DECODE_PARAMS_DIR_SET: 
11BD    C276          4784     CLR FLAGS3 . 6 
11BF    7889          4785     MOV R0 , # PGM_INPUT_POL 
11C1    E6            4786     MOV A , @ R0 
11C2    30E102        4787     	JNB	ACC.1, ($+5)
11C5    D276          4788     SETB FLAGS3 . 6 
11C7    C3            4789     	CLR	C
11C8    EF            4790     MOV A , R7 
11C9    9402          4791     	SUBB	A, #2
11CB    6008          4792     	JZ	DECODE_PWM_FREQ_LOW
                      4793     
11CD    758E01        4794     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
11D0    D26D          4795     SETB FLAGS2 . 5 
11D2    0211DA        4796     	JMP	DECODE_PWM_FREQ_END
                      4797     
                      4798     DECODE_PWM_FREQ_LOW: 
11D5    758E00        4799     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
11D8    C26D          4800     CLR FLAGS2 . 5 
                      4801     
                      4802     DECODE_PWM_FREQ_END: 
11DA    22            4803     	RET
                      4804     
                      4805     
                      4806     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4807     ;
                      4808     ; Decode governor gain
                      4809     ;
                      4810     ; No assumptions
                      4811     ;
                      4812     ; Decodes governor gains
                      4813     ;
                      4814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4815     DECODE_GOVERNOR_GAINS: 
                      4816     	; Decode governor gains
11DB    7880          4817     MOV R0 , # PGM_GOV_P_GAIN 
11DD    E6            4818     MOV A , @ R0 
11DE    14            4819     	DEC	A	
11DF    900080        4820     	MOV	DPTR, #GOV_GAIN_TABLE
11E2    93            4821     	MOVC A, @A+DPTR	
11E3    789F          4822     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
11E5    F6            4823     MOV @ R0 , A 
11E6    7881          4824     MOV R0 , # PGM_GOV_I_GAIN 
11E8    E6            4825     MOV A , @ R0 
11E9    14            4826     	DEC	A	
11EA    900080        4827     	MOV	DPTR, #GOV_GAIN_TABLE
11ED    93            4828     	MOVC A, @A+DPTR	
11EE    78A0          4829     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
11F0    F6            4830     MOV @ R0 , A 
11F1    1170          4831     	CALL	SWITCH_POWER_OFF		; Reset DPTR
11F3    22            4832     	RET
                      4833     
                      4834     
                      4835     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4836     ;
                      4837     ; Decode throttle rate
                      4838     ;
                      4839     ; No assumptions
                      4840     ;
                      4841     ; Decodes throttle rate
                      4842     ;
                      4843     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4844     DECODE_THROTTLE_RATE: 
                      4845     	; Decode throttle rate
11F4    789B          4846     MOV R0 , # PGM_THROTTLE_RATE 
11F6    E6            4847     MOV A , @ R0 
11F7    14            4848     	DEC	A	
11F8    90008D        4849     	MOV	DPTR, #THROTTLE_RATE_TABLE
11FB    93            4850     	MOVC A, @A+DPTR	
11FC    78A1          4851     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
11FE    F6            4852     MOV @ R0 , A 
11FF    1170          4853     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1201    22            4854     	RET
                      4855     
                      4856     
                      4857     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4858     ;
                      4859     ; Decode startup power
                      4860     ;
                      4861     ; No assumptions
                      4862     ;
                      4863     ; Decodes startup power
                      4864     ;
                      4865     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4866     DECODE_STARTUP_POWER: 
                      4867     	; Decode startup power
1202    7886          4868     MOV R0 , # PGM_STARTUP_PWR 
1204    E6            4869     MOV A , @ R0 
1205    14            4870     	DEC	A	
1206    90009A        4871     	MOV	DPTR, #STARTUP_POWER_TABLE
1209    93            4872     	MOVC A, @A+DPTR	
120A    78A2          4873     MOV R0 , # PGM_STARTUP_PWR_DECODED 
120C    F6            4874     MOV @ R0 , A 
120D    1170          4875     	CALL	SWITCH_POWER_OFF			; Reset DPTR
120F    22            4876     	RET
                      4877     
                      4878     
                      4879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4880     ;
                      4881     ; Decode demag compensation
                      4882     ;
                      4883     ; No assumptions
                      4884     ;
                      4885     ; Decodes throttle rate
                      4886     ;
                      4887     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4888     DECODE_DEMAG_COMP: 
                      4889     	; Decode demag compensation
1210    789C          4890     MOV R0 , # PGM_DEMAG_COMP 
1212    E6            4891     MOV A , @ R0 
1213    14            4892     	DEC	A	
1214    9000A7        4893     	MOV	DPTR, #DEMAG_POWER_TABLE
1217    93            4894     	MOVC A, @A+DPTR	
1218    78A3          4895     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
121A    F6            4896     MOV @ R0 , A 
121B    1170          4897     	CALL	SWITCH_POWER_OFF			; Reset DPTR
121D    22            4898     	RET
                      4899     
                      4900     
                      4901     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4902     ;
                      4903     ; Set BEC voltage
                      4904     ;
                      4905     ; No assumptions
                      4906     ;
                      4907     ; Sets the BEC output voltage low or high
                      4908     ;
                      4909     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4910     SET_BEC_VOLTAGE: 
                      4911     	; Set bec voltage
                      4912     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
121E    22            4922     	RET
                      4923     
                      4924     
                      4925     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4926     ;
                      4927     ; Find throttle gain
                      4928     ;
                      4929     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      4930     ;
                      4931     ; Finds throttle gain from throttle calibration values
                      4932     ;
                      4933     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4934     FIND_THROTTLE_GAIN: 
                      4935     	; Load programmed minimum and maximum throttle
121F    7896          4936     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1221    E6            4937     MOV A , @ R0 
1222    FA            4938     MOV R2 , A 
1223    7897          4939     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1225    E6            4940     MOV A , @ R0 
1226    FB            4941     MOV R3 , A 
                      4942     	; Check if full range is chosen
1227    307704        4943     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      4944     
122A    7A00          4945     MOV R2 , # 0 
122C    7BFF          4946     MOV R3 , # 255 
                      4947     
                      4948     FIND_THROTTLE_GAIN_CALCULATE: 
                      4949     	; Calculate difference
122E    C3            4950     	CLR	C
122F    EB            4951     MOV A , R3 
1230    9A            4952     SUBB A , R2 
1231    FC            4953     MOV R4 , A 
                      4954     	; Check that difference is minimum 130
1232    C3            4955     	CLR	C
1233    9482          4956     	SUBB	A, #130
1235    5002          4957     	JNC	($+4)
                      4958     
1237    7C82          4959     MOV R4 , # 130 
                      4960     
                      4961     	; Find gain
1239    756E00        4962     	MOV	PPM_THROTTLE_GAIN, #0
                      4963     TEST_THROTTLE_GAIN: 
123C    056E          4964     	INC	PPM_THROTTLE_GAIN
123E    EC            4965     MOV A , R4 
123F    856EF0        4966     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
1242    A4            4967     	MUL	AB
1243    C3            4968     	CLR	C
1244    E5F0          4969     	MOV	A, B
1246    9480          4970     	SUBB	A, #128
1248    40F2          4971     	JC	TEST_THROTTLE_GAIN
124A    22            4972     	RET
                      4973     
                      4974     
                      4975     
                      4976     
                      4977     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4978     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4979     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4980     ;
                      4981     ; Main program start
                      4982     ;
                      4983     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4984     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4985     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4986     
                      4987     RESET: 
                      4988     	; Check flash lock byte
124B    E5EF          4989     	MOV	A, RSTSRC			
124D    20E603        4990     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      4991     
1250    752000        4992     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      4993     
1253    0520          4994     	INC	BIT_ACCESS
1255    903FFF        4995     MOV DPTR , # 16383 
1258    E520          4996     	MOV	A, BIT_ACCESS
125A    14            4997     	DEC	A
125B    6006          4998     	JZ	LOCK_BYTE_TEST
                      4999     
125D    901FFF        5000     MOV DPTR , # 8191 
1260    14            5001     	DEC	A
1261    6000          5002     	JZ	LOCK_BYTE_TEST
                      5003     
                      5004     LOCK_BYTE_TEST: 
1263    93            5005     	MOVC A, @A+DPTR		; Read lock byte
1264    04            5006     	INC	A				
1265    6003          5007     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5008     
                      5009     IF ONE_S_CAPABLE == 0		
1267    75EF12        5010     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5011     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5014     
                      5015     LOCK_BYTE_OK: 
                      5016     	; Select register bank 0 for main program routines
126A    C2D3          5017     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5018     	; Disable the WDT.
126C    53D9BF        5019     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5020     	; Initialize stack
126F    7581C0        5021     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5022     	; Initialize VDD monitor
1272    43FF80        5023     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1275    1207CB        5024     	CALL	WAIT1MS			; Wait at least 100us
                      5025     IF ONE_S_CAPABLE == 0		
1278    75EF02        5026     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5027     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5030     	; Set clock frequency
127B    43B203        5031     	ORL	OSCICN, #03H		; Set clock divider to 1
127E    E5B3          5032     	MOV	A, OSCICL				
1280    2404          5033     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1282    4002          5034     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5035     
1284    F5B3          5036     	MOV	OSCICL, A
                      5037     
                      5038     RESET_CAL_DONE: 
                      5039     	; Switch power off
1286    1170          5040     	CALL	SWITCH_POWER_OFF
                      5041     	; Ports initialization
1288    7580FF        5042     MOV P0 , # 255 
128B    75A400        5043     MOV P0MDOUT , # 0 
128E    75F1F0        5044     MOV P0MDIN , # -16 
1291    75D4DF        5045     MOV P0SKIP , # -33 
1294    759002        5046     MOV P1 , # 2 
1297    75A5FC        5047     MOV P1MDOUT , # 252 
129A    75F2FD        5048     MOV P1MDIN , # -3 
129D    75D502        5049     MOV P1SKIP , # 2 
                      5050     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
12A0    75A610        5053     MOV P2MDOUT , # 16 
                      5054     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5061     	; Initialize the XBAR and related functionality
                      5062     	INITIALIZE_XBAR		
12A3    75A0FF        5062+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
12A6    75F3F1        5062+1   MOV P2MDIN , # -15 
12A9    75E241        5062+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5063     	; Clear RAM
12AC    E4            5064     	CLR	A				; Clear accumulator
12AD    F8            5065     MOV R0 , A 
                      5066     CLEAR_RAM: 	
12AE    F6            5067     MOV @ R0 , A 
12AF    D8FD          5068     DJNZ R0 , CLEAR_RAM 
                      5069     	; Set default programmed parameters
12B1    11ED          5070     	CALL	SET_DEFAULT_PARAMETERS
                      5071     	; EEPROM 
12B3    121868        5072     	CALL ERASE_AND_STORE_ALL_IN_EEPROM
                      5073     	; Decode parameters
12B6    3147          5074     	CALL	DECODE_PARAMETERS
                      5075     	; Decode governor gains
12B8    31DB          5076     	CALL	DECODE_GOVERNOR_GAINS
                      5077     	; Decode throttle rate
12BA    31F4          5078     	CALL	DECODE_THROTTLE_RATE
                      5079     	; Decode startup power
12BC    5102          5080     	CALL	DECODE_STARTUP_POWER
                      5081     	; Decode demag compensation
12BE    5110          5082     	CALL	DECODE_DEMAG_COMP
                      5083     	; Set BEC voltage
12C0    511E          5084     	CALL	SET_BEC_VOLTAGE
                      5085     	; Find throttle gain from stored min and max settings
12C2    511F          5086     	CALL	FIND_THROTTLE_GAIN
                      5087     	; Set beep strength
12C4    7898          5088     MOV R0 , # PGM_BEEP_STRENGTH 
12C6    866F          5089     MOV BEEP_STRENGTH , @ R0 
                      5090     	; Switch power off
12C8    1170          5091     	CALL	SWITCH_POWER_OFF
                      5092     	; Timer control
12CA    758850        5093     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5094     	; Timer mode
12CD    758902        5095     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5096     	; Timer2: clk/12 for 128us and 32ms interrupts
12D0    75C824        5097     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5098     	; Timer3: clk/12 for commutation timing
12D3    759104        5099     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5100     	; PCA
12D6    75D840        5101     	MOV	PCA0CN, #40H		; PCA enabled
                      5102     	; Initializing beep
12D9    C2AF          5103     	CLR	EA				; Disable interrupts explicitly
12DB    1207E4        5104     	CALL WAIT200MS	
12DE    1207F4        5105     	CALL BEEP_F1
12E1    1207DA        5106     	CALL WAIT30MS
12E4    1207FB        5107     	CALL BEEP_F2
12E7    1207DA        5108     	CALL WAIT30MS
12EA    120802        5109     	CALL BEEP_F3
12ED    1207DA        5110     	CALL WAIT30MS
                      5111     
                      5112     	; Wait for receiver to initialize
12F0    121CB8        5113     	CALL	WAIT1S
12F3    1207E4        5114     	CALL	WAIT200MS
12F6    1207E4        5115     	CALL	WAIT200MS
12F9    1207DF        5116     	CALL	WAIT100MS
                      5117     
                      5118     	; Enable interrupts
12FC    75A822        5119     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
12FF    75B802        5120     	MOV	IP, #02H			; High priority to timer0 interrupts
1302    75E690        5121     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5122     	; Initialize comparator
1305    759B80        5123     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1308    759D03        5124     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5125     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5129     	; Initialize ADC
                      5130     	INITIALIZE_ADC			; Initialize ADC operation
130B    75D10E        5130+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
130E    75BC58        5130+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
1311    75BB09        5130+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1314    75BA11        5130+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1317    75E880        5130+1   MOV ADC0CN , # 80H  ; ADC ENABLED
131A    1207CB        5131     	CALL	WAIT1MS
131D    D2AF          5132     	SETB	EA				; Enable all interrupts
                      5133     	; Measure number of lipo cells
131F    120AAC        5134     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5135     	; Initialize rc pulse
                      5136     	RCP_INT_ENABLE		 			; Enable interrupt
1322    43DA01        5136+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5137     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1325    C2D8          5137+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1327    C269          5138     CLR FLAGS2 . 1 
1329    1207E4        5139     	CALL WAIT200MS
                      5140     	; Set initial arm variable
132C    753001        5141     	MOV	INITIAL_ARM, #1
                      5142     
                      5143     	; Measure PWM frequency
                      5144     MEASURE_PWM_FREQ_INIT: 	
132F    D259          5145     SETB FLAGS0 . 1 
                      5146     MEASURE_PWM_FREQ_START: 	
1331    7A05          5147     MOV R2 , # 5 
                      5148     MEASURE_PWM_FREQ_LOOP: 	
                      5149     	; Check if period diff was accepted
1333    E558          5150     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1335    7002          5151     	JNZ	($+4)
                      5152     
1337    7A05          5153     MOV R2 , # 5 
                      5154     
1339    1207D0        5155     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
133C    E559          5156     	MOV	A, NEW_RCP					; Load value
133E    C3            5157     	CLR	C
133F    9402          5158     SUBB A , # 2 
1341    40EE          5159     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5160     
1343    E52E          5161     	MOV	A, FLAGS3						; Check pwm frequency flags
1345    541F          5162     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1347    855B5A        5163     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
134A    F55B          5164     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
134C    B55AE2        5165     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5166     
134F    DAE2          5167     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5168     
                      5169     	; Clear measure pwm frequency flag
1351    C259          5170     CLR FLAGS0 . 1 
                      5171     	; Set up RC pulse interrupts after pwm frequency measurement
                      5172     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1353    53DACF        5172+1   ANL PCA0CPM0 , # 0CFH 
1356    207603        5172+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1359    43DA20        5172+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
135C    307603        5172+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
135F    43DA10        5172+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5173     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1362    C2D8          5173+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1364    C269          5174     CLR FLAGS2 . 1 
1366    1207DF        5175     	CALL WAIT100MS						; Wait for new RC pulse
                      5176     
                      5177     	; Validate RC pulse
                      5178     VALIDATE_RCP_START: 	
1369    1207D0        5179     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
136C    7802          5180     MOV R0 , # 2 
136E    741F          5181     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1370    552E          5182     	ANL	A, FLAGS3						; Check pwm frequency flags
1372    7002          5183     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5184     
1374    7800          5185     MOV R0 , # 0 
                      5186     
1376    C3            5187     	CLR	C
1377    E559          5188     	MOV	A, NEW_RCP					; Load value
1379    98            5189     SUBB A , R0 
137A    40ED          5190     	JC	VALIDATE_RCP_START				; No - start over
                      5191     
                      5192     	; Beep arm sequence start signal
137C    C2AF          5193     	CLR 	EA							; Disable all interrupts
137E    1207F4        5194     	CALL BEEP_F1						; Signal that RC pulse is ready
1381    1207F4        5195     	CALL BEEP_F1
1384    1207F4        5196     	CALL BEEP_F1
1387    D2AF          5197     	SETB	EA							; Enable all interrupts
1389    1207E4        5198     	CALL WAIT200MS	
                      5199     
                      5200     	; Arming sequence start
138C    754800        5201     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5202     ARMING_START: 
                      5203     IF MODE >= 1	; Tail or multi
138F    7888          5204     MOV R0 , # PGM_DIRECTION 
1391    E6            5205     MOV A , @ R0 
1392    B40302        5206     	CJNE	A, #3, ($+5)
                      5207     
1395    816A          5208     	AJMP	PROGRAM_BY_TX_CHECKED	; Disable tx programming if bidirectional operation
                      5209     ENDIF
                      5210     
1397    1207D0        5211     	CALL WAIT3MS
139A    788C          5212     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
139C    E6            5213     MOV A , @ R0 
139D    C3            5214     	CLR	C
139E    9401          5215     	SUBB	A, #1				; Is TX programming enabled?
13A0    5003          5216     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5217     
13A2    02146A        5218     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5219     
                      5220     ARMING_INITIAL_ARM_CHECK: 
13A5    E530          5221     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
13A7    C3            5222     	CLR	C
13A8    9401          5223     	SUBB	A, #1				; Is it the initial arm sequence?
13AA    5003          5224     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5225     
13AC    02146A        5226     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5227     
                      5228     ARMING_PPM_CHECK: 
13AF    741F          5229     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
13B1    552E          5230     	ANL	A, FLAGS3				; Check pwm frequency flags
13B3    6035          5231     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5232     
                      5233     	; PWM tx program entry
13B5    C3            5234     	CLR	C
13B6    E559          5235     	MOV	A, NEW_RCP			; Load new RC pulse value
13B8    94FF          5236     SUBB A , # 255 
13BA    5003          5237     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5238     
13BC    02146A        5239     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5240     
                      5241     PROGRAM_BY_TX_ENTRY_PWM: 	
13BF    C2AF          5242     	CLR	EA					; Disable all interrupts
13C1    120809        5243     	CALL BEEP_F4
13C4    D2AF          5244     	SETB	EA					; Enable all interrupts
13C6    1207DF        5245     	CALL WAIT100MS
13C9    C3            5246     	CLR	C
13CA    E559          5247     	MOV	A, NEW_RCP			; Load new RC pulse value
13CC    9401          5248     SUBB A , # 1 
13CE    50EF          5249     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5250     
                      5251     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
13D0    C2AF          5252     	CLR	EA					; Disable all interrupts
13D2    1207F4        5253     	CALL BEEP_F1
13D5    1207D5        5254     	CALL WAIT10MS
13D8    1207F4        5255     	CALL BEEP_F1
13DB    D2AF          5256     	SETB	EA					; Enable all interrupts
13DD    1207DF        5257     	CALL WAIT100MS
13E0    C3            5258     	CLR	C
13E1    E559          5259     	MOV	A, NEW_RCP			; Load new RC pulse value
13E3    94FF          5260     SUBB A , # 255 
13E5    40E9          5261     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5262     
13E7    021D3D        5263     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5264     
                      5265     	; PPM throttle calibration and tx program entry
                      5266     THROTTLE_HIGH_CAL_START: 
13EA    7F05          5267     MOV R7 , # 5 
                      5268     THROTTLE_HIGH_CAL: 			
13EC    D277          5269     SETB FLAGS3 . 7 
13EE    511F          5270     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13F0    1207DF        5271     	CALL WAIT100MS				; Wait for new throttle value
13F3    C2AF          5272     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13F5    C277          5273     CLR FLAGS3 . 7 
13F7    511F          5274     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13F9    AE59          5275     MOV R6 , NEW_RCP 
13FB    C3            5276     	CLR	C
13FC    E559          5277     	MOV	A, NEW_RCP			; Load new RC pulse value
13FE    947F          5278     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1400    D2AF          5279     	SETB	EA					; Enable interrupts
1402    4070          5280     	JC	ARM_TARGET_UPDATED		; No - branch
                      5281     
1404    1207CB        5282     	CALL WAIT1MS		
1407    C2AF          5283     	CLR	EA					; Disable all interrupts
1409    120809        5284     	CALL BEEP_F4
140C    D2AF          5285     	SETB	EA					; Enable all interrupts
140E    DFDC          5286     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5287     
1410    C3            5288     	CLR	C
1411    EE            5289     MOV A , R6 
1412    9405          5290     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
1414    7897          5291     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1416    F6            5292     MOV @ R0 , A 
1417    1207E4        5293     	CALL WAIT200MS				
141A    121868        5294     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
141D    121CC0        5295     	CALL	SUCCESS_BEEP
                      5296     
                      5297     THROTTLE_LOW_CAL_START: 
1420    7F0A          5298     MOV R7 , # 10 
                      5299     THROTTLE_LOW_CAL: 			
1422    D277          5300     SETB FLAGS3 . 7 
1424    511F          5301     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1426    1207DF        5302     	CALL WAIT100MS
1429    C2AF          5303     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
142B    C277          5304     CLR FLAGS3 . 7 
142D    511F          5305     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
142F    AE59          5306     MOV R6 , NEW_RCP 
1431    C3            5307     	CLR	C
1432    E559          5308     	MOV	A, NEW_RCP			; Load new RC pulse value
1434    947F          5309     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
1436    D2AF          5310     	SETB	EA					; Enable interrupts
1438    50E6          5311     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5312     
143A    1207CB        5313     	CALL WAIT1MS		
143D    C2AF          5314     	CLR	EA					; Disable all interrupts
143F    1207F4        5315     	CALL BEEP_F1
1442    1207D5        5316     	CALL WAIT10MS
1445    1207F4        5317     	CALL BEEP_F1
1448    D2AF          5318     	SETB	EA					; Enable all interrupts
144A    DFD6          5319     DJNZ R7 , THROTTLE_LOW_CAL 
                      5320     
144C    EE            5321     MOV A , R6 
144D    2405          5322     	ADD	A, #5				; Add about 2%
144F    7896          5323     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1451    F6            5324     MOV @ R0 , A 
1452    1207E4        5325     	CALL WAIT200MS				
1455    121868        5326     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1458    121CEF        5327     	CALL	SUCCESS_BEEP_INVERTED
                      5328     
                      5329     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
145B    1207DF        5330     	CALL WAIT100MS
145E    511F          5331     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1460    C3            5332     	CLR	C
1461    E559          5333     	MOV	A, NEW_RCP			; Load new RC pulse value
1463    94FF          5334     SUBB A , # 255 
1465    40F4          5335     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5336     
1467    021D3D        5337     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5338     
                      5339     PROGRAM_BY_TX_CHECKED: 
146A    C3            5340     	CLR	C
146B    E559          5341     	MOV	A, NEW_RCP			; Load new RC pulse value
146D    9548          5342     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
146F    4003          5343     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5344     
1471    855948        5345     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5346     
                      5347     ARM_TARGET_UPDATED: 
1474    1207DF        5348     	CALL WAIT100MS				; Wait for new throttle value
1477    C3            5349     	CLR	C
1478    E559          5350     	MOV	A, NEW_RCP			; Load new RC pulse value
147A    9401          5351     SUBB A , # 1 
147C    4002          5352     	JC	ARM_END_BEEP			; Yes - proceed
                      5353     
147E    618F          5354     	JMP	ARMING_START			; No - start over
                      5355     
                      5356     ARM_END_BEEP: 
                      5357     	; Beep arm sequence end signal
1480    C2AF          5358     	CLR 	EA					; Disable all interrupts
1482    120809        5359     	CALL BEEP_F4				; Signal that rcpulse is ready
1485    120809        5360     	CALL BEEP_F4
1488    120809        5361     	CALL BEEP_F4
148B    D2AF          5362     	SETB	EA					; Enable all interrupts
148D    1207E4        5363     	CALL WAIT200MS
                      5364     
                      5365     	; Clear initial arm variable
1490    753000        5366     	MOV	INITIAL_ARM, #0
                      5367     
                      5368     	; Armed and waiting for power on
                      5369     WAIT_FOR_POWER_ON: 
1493    E4            5370     	CLR	A
1494    F531          5371     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1496    F532          5372     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5373     WAIT_FOR_POWER_ON_LOOP: 
1498    0531          5374     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
149A    E531          5375     	MOV	A, POWER_ON_WAIT_CNT_L
149C    F4            5376     	CPL	A
149D    7039          5377     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5378     
149F    0532          5379     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
14A1    789A          5380     MOV R0 , # PGM_BEACON_DELAY 
14A3    E6            5381     MOV A , @ R0 
14A4    7819          5382     MOV R0 , # 25 
14A6    14            5383     	DEC	A
14A7    6012          5384     	JZ	BEEP_DELAY_SET
                      5385     
14A9    7832          5386     MOV R0 , # 50 
14AB    14            5387     	DEC	A
14AC    600D          5388     	JZ	BEEP_DELAY_SET
                      5389     
14AE    787D          5390     MOV R0 , # 125 
14B0    14            5391     	DEC	A
14B1    6008          5392     	JZ	BEEP_DELAY_SET
                      5393     
14B3    78FA          5394     MOV R0 , # 250 
14B5    14            5395     	DEC	A
14B6    6003          5396     	JZ	BEEP_DELAY_SET
                      5397     
14B8    753200        5398     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5399     
                      5400     BEEP_DELAY_SET: 
14BB    C3            5401     	CLR	C
14BC    E532          5402     	MOV	A, POWER_ON_WAIT_CNT_H
14BE    98            5403     SUBB A , R0 
14BF    4017          5404     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5405     
14C1    1532          5406     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
14C3    7531B4        5407     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
14C6    7899          5408     MOV R0 , # PGM_BEACON_STRENGTH 
14C8    866F          5409     MOV BEEP_STRENGTH , @ R0 
14CA    C2AF          5410     	CLR 	EA					; Disable all interrupts
14CC    120809        5411     	CALL BEEP_F4				; Signal that there is no signal
14CF    D2AF          5412     	SETB	EA					; Enable all interrupts
14D1    7898          5413     MOV R0 , # PGM_BEEP_STRENGTH 
14D3    866F          5414     MOV BEEP_STRENGTH , @ R0 
14D5    1207DF        5415     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5416     
                      5417     WAIT_FOR_POWER_ON_NO_BEEP: 
14D8    1207D5        5418     	CALL WAIT10MS
14DB    E528          5419     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
14DD    7008          5420     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5421     
14DF    741F          5422     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
14E1    552E          5423     	ANL	A, FLAGS3						; Check pwm frequency flags
14E3    7002          5424     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5425     
14E5    612F          5426     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5427     
                      5428     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
14E7    C3            5429     	CLR	C
14E8    E559          5430     	MOV	A, NEW_RCP			; Load new RC pulse value
14EA    9406          5431     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
14EC    40AA          5432     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5433     
                      5434     IF MODE >= 1	; Tail or multi
14EE    7888          5435     MOV R0 , # PGM_DIRECTION 
14F0    E6            5436     MOV A , @ R0 
14F1    C3            5437     	CLR	C
14F2    9403          5438     	SUBB	A, #3
14F4    6003          5439     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5440     ENDIF
                      5441     
14F6    1207DF        5442     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5443     
14F9    E528          5444     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
14FB    7003          5445     	JNZ	($+5)				; If it is not zero - proceed
                      5446     
14FD    02132F        5447     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5448     
                      5449     
                      5450     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5451     ;
                      5452     ; Start entry point
                      5453     ;
                      5454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5455     INIT_START: 
1500    C2AF          5456     	CLR	EA
1502    1170          5457     	CALL SWITCH_POWER_OFF
1504    E4            5458     	CLR	A
1505    F522          5459     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1507    F523          5460     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1509    F524          5461     	MOV	CURRENT_PWM, A			; Set current pwm to zero
150B    F525          5462     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
150D    D2AF          5463     	SETB	EA
150F    7885          5464     MOV R0 , # PGM_MOTOR_IDLE 
1511    8661          5465     MOV PWM_MOTOR_IDLE , @ R0 
1513    F540          5466     	MOV	GOV_TARGET_L, A		; Set target to zero
1515    F541          5467     	MOV	GOV_TARGET_H, A
1517    F542          5468     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
1519    F543          5469     	MOV	GOV_INTEGRAL_H, A
151B    F544          5470     	MOV	GOV_INTEGRAL_X, A
151D    F56C          5471     	MOV	ADC_CONVERSION_CNT, A
151F    F549          5472     	MOV	GOV_ACTIVE, A
1521    F52B          5473     	MOV	FLAGS0, A				; Clear flags0
1523    F52C          5474     	MOV	FLAGS1, A				; Clear flags1
1525    F539          5475     	MOV	DEMAG_CONSECUTIVE_CNT, A
1527    120C2A        5476     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5477     	;**** **** **** **** ****
                      5478     	; Motor start beginning
                      5479     	;**** **** **** **** **** 
152A    756C08        5480     MOV ADC_CONVERSION_CNT , # 8 
                      5481     	SET_ADC_IP_TEMP
152D    75BB10        5481+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1530    1207CB        5482     	CALL WAIT1MS
1533    120B47        5483     	CALL START_ADC_CONVERSION
                      5484     READ_INITIAL_TEMP: 
                      5485     	GET_ADC_STATUS 
1536    E5E8          5485+1   MOV A , ADC0CN 
1538    20ECFB        5486     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5487     	READ_ADC_RESULT						; Read initial temperature
153B    A8BD          5487+1   MOV R0 , ADC0L 
153D    A9BE          5487+1   MOV R1 , ADC0H 
153F    E9            5488     MOV A , R1 
1540    7001          5489     	JNZ	($+3)							; Is reading below 256?
                      5490     
1542    F8            5491     MOV R0 , A 
                      5492     
1543    886D          5493     MOV CURRENT_AVERAGE_TEMP , R0 
1545    120B4B        5494     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1548    756C08        5495     MOV ADC_CONVERSION_CNT , # 8 
                      5496     	SET_ADC_IP_TEMP
154B    75BB10        5496+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5497     
                      5498     	; Go to the desired startup mode
154E    7895          5499     MOV R0 , # PGM_STARTUP_METHOD 
1550    E6            5500     MOV A , @ R0 
1551    30E003        5501     	JNB	ACC.0, DIRECT_METHOD_START
                      5502     
1554    021598        5503     	JMP	STEPPER_METHOD_START
                      5504     
                      5505     DIRECT_METHOD_START: 
                      5506     	; Set up start operating conditions
1557    7887          5507     MOV R0 , # PGM_PWM_FREQ 
1559    E6            5508     MOV A , @ R0 
155A    FE            5509     MOV R6 , A 
155B    7602          5510     MOV @ R0 , # 2 
155D    3147          5511     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
155F    7887          5512     MOV R0 , # PGM_PWM_FREQ 
1561    EE            5513     MOV A , R6 
1562    F6            5514     MOV @ R0 , A 
                      5515     	; Set max allowed power
1563    D261          5516     SETB FLAGS1 . 1 
1565    C2AF          5517     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
1567    755EFF        5518     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
156A    120BFA        5519     	CALL SET_STARTUP_PWM
156D    85225E        5520     	MOV	PWM_LIMIT, REQUESTED_PWM
1570    85225F        5521     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
1573    D2AF          5522     	SETB	EA
1575    C261          5523     CLR FLAGS1 . 1 
1577    752501        5524     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
157A    855D64        5525     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
157D    756501        5526     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5527     	; Begin startup sequence
1580    D260          5528     SETB FLAGS1 . 0 
1582    D263          5529     SETB FLAGS1 . 3 
1584    753800        5530     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1587    120FCA        5531     	CALL COMM5COMM6				; Initialize commutation
158A    1105          5532     	CALL COMM6COMM1				
158C    120CA4        5533     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
158F    120C2A        5534     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
1592    120D27        5535     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
1595    0216C0        5536     	JMP	RUN1
                      5537     
                      5538     
                      5539     STEPPER_METHOD_START: 
                      5540     	; Set up start operating conditions
1598    7887          5541     MOV R0 , # PGM_PWM_FREQ 
159A    E6            5542     MOV A , @ R0 
159B    FE            5543     MOV R6 , A 
159C    7603          5544     MOV @ R0 , # 3 
159E    7893          5545     MOV R0 , # PGM_DAMPING_FORCE 
15A0    E6            5546     MOV A , @ R0 
15A1    FD            5547     MOV R5 , A 
15A2    7605          5548     MOV @ R0 , # 5 
15A4    3147          5549     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15A6    7887          5550     MOV R0 , # PGM_PWM_FREQ 
15A8    EE            5551     MOV A , R6 
15A9    F6            5552     MOV @ R0 , A 
15AA    7893          5553     MOV R0 , # PGM_DAMPING_FORCE 
15AC    ED            5554     MOV A , R5 
15AD    F6            5555     MOV @ R0 , A 
                      5556     	; Begin startup sequence
15AE    D260          5557     SETB FLAGS1 . 0 
15B0    D261          5558     SETB FLAGS1 . 1 
15B2    D265          5559     SETB FLAGS1 . 5 
15B4    120FCA        5560     	CALL COMM5COMM6			; Initialize commutation
15B7    1105          5561     	CALL COMM6COMM1			
15B9    755EFF        5562     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15BC    120BFA        5563     	CALL SET_STARTUP_PWM
15BF    1207CB        5564     	CALL WAIT1MS
15C2    120ED2        5565     	CALL COMM1COMM2
15C5    1207CB        5566     	CALL WAIT1MS
15C8    1207CB        5567     	CALL WAIT1MS
15CB    120F04        5568     	CALL COMM2COMM3
15CE    1207D0        5569     	CALL WAIT3MS			
15D1    120F4E        5570     	CALL COMM3COMM4
15D4    1207D0        5571     	CALL WAIT3MS			
15D7    1207D0        5572     	CALL WAIT3MS			
15DA    120F89        5573     	CALL COMM4COMM5
15DD    1207D5        5574     	CALL WAIT10MS				; Settle rotor
15E0    120FCA        5575     	CALL COMM5COMM6
15E3    1207D0        5576     	CALL WAIT3MS				
15E6    1207CB        5577     	CALL WAIT1MS			
15E9    C261          5578     CLR FLAGS1 . 1 
15EB    D262          5579     SETB FLAGS1 . 2 
                      5580     
                      5581     	;**** **** **** **** ****
                      5582     	; Stepper phase beginning
                      5583     	;**** **** **** **** **** 
                      5584     STEPPER_ROT_BEG: 
15ED    120B47        5585     	CALL START_ADC_CONVERSION
15F0    120B4B        5586     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
15F3    120BFA        5587     	CALL SET_STARTUP_PWM
15F6    756C08        5588     MOV ADC_CONVERSION_CNT , # 8 
                      5589     	SET_ADC_IP_TEMP
15F9    75BB10        5589+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5590     
15FC    1105          5591     	CALL COMM6COMM1				; Commutate
15FE    120C9D        5592     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
1601    120D27        5593     	CALL CALC_NEW_WAIT_TIMES
1604    1182          5594     	CALL DECREMENT_STEPPER_STEP
1606    11E7          5595     	CALL STEPPER_TIMER_WAIT
                      5596     
1608    120ED2        5597     	CALL COMM1COMM2			
160B    120C9D        5598     	CALL CALC_NEXT_COMM_TIMING_START	
160E    120D27        5599     	CALL CALC_NEW_WAIT_TIMES
1611    1182          5600     	CALL DECREMENT_STEPPER_STEP
1613    11E7          5601     	CALL STEPPER_TIMER_WAIT
                      5602     
1615    120F04        5603     	CALL COMM2COMM3			
1618    120C9D        5604     	CALL CALC_NEXT_COMM_TIMING_START	
161B    120D27        5605     	CALL CALC_NEW_WAIT_TIMES
161E    1182          5606     	CALL DECREMENT_STEPPER_STEP
1620    11E7          5607     	CALL STEPPER_TIMER_WAIT
                      5608     
1622    120F4E        5609     	CALL COMM3COMM4			
1625    120C9D        5610     	CALL CALC_NEXT_COMM_TIMING_START	
1628    120D27        5611     	CALL CALC_NEW_WAIT_TIMES
162B    1182          5612     	CALL DECREMENT_STEPPER_STEP
162D    11E7          5613     	CALL STEPPER_TIMER_WAIT
                      5614     
162F    120F89        5615     	CALL COMM4COMM5			
1632    120C9D        5616     	CALL CALC_NEXT_COMM_TIMING_START	
1635    120D27        5617     	CALL CALC_NEW_WAIT_TIMES
1638    1182          5618     	CALL DECREMENT_STEPPER_STEP
163A    11E7          5619     	CALL STEPPER_TIMER_WAIT
                      5620     
163C    120FCA        5621     	CALL COMM5COMM6			
163F    120C9D        5622     	CALL CALC_NEXT_COMM_TIMING_START	
1642    120D27        5623     	CALL CALC_NEW_WAIT_TIMES
1645    1182          5624     	CALL DECREMENT_STEPPER_STEP	
                      5625     	; Check stepper step versus end criteria
1647    C3            5626     	CLR	C
1648    E550          5627     	MOV	A, WT_STEPPER_STEP_L
164A    9535          5628     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
164C    E551          5629     	MOV	A, WT_STEPPER_STEP_H
164E    9536          5630     	SUBB	A, STEPPER_STEP_END_H
1650    400C          5631     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5632     
                      5633     	; Wait for step
1652    11E7          5634     	CALL STEPPER_TIMER_WAIT
1654    C3            5635     	CLR	C
1655    E559          5636     	MOV	A, NEW_RCP				; Load new pulse value
1657    9401          5637     SUBB A , # 1 
1659    5092          5638     	JNC	STEPPER_ROT_BEG
                      5639     
165B    0217F1        5640     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5641     
                      5642     STEPPER_ROT_EXIT: 
                      5643     	; Wait for step
165E    11E7          5644     	CALL STEPPER_TIMER_WAIT
                      5645     	; Clear stepper phase
1660    C262          5646     CLR FLAGS1 . 2 
                      5647     	; Set dondamped low pwm frequency
1662    7887          5648     MOV R0 , # PGM_PWM_FREQ 
1664    E6            5649     MOV A , @ R0 
1665    FE            5650     MOV R6 , A 
1666    7602          5651     MOV @ R0 , # 2 
1668    3147          5652     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
166A    7887          5653     MOV R0 , # PGM_PWM_FREQ 
166C    EE            5654     MOV A , R6 
166D    F6            5655     MOV @ R0 , A 
                      5656     	; Set spoolup power variables (power is now controlled from RCP)
166E    85225E        5657     	MOV	PWM_LIMIT, REQUESTED_PWM
1671    85605F        5658     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
1674    856025        5659     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
1677    855D64        5660     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
167A    756501        5661     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5662     	; Set direct startup phase to acquire sync quickly
167D    D263          5663     SETB FLAGS1 . 3 
167F    753800        5664     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1682    C2AF          5665     	CLR	EA						; Disable interrupts
                      5666     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
1684    207502        5666+1   JB FLAGS3 . 5 , ( $+5 ) 
1687    C293          5666+1   CLR P1 . 3 
1689    307502        5666+1   JNB FLAGS3 . 5 , ( $+5 ) 
168C    C297          5666+1   CLR P1 . 7 
                      5667     	CPFET_OFF						; Cp off
168E    207502        5667+1   JB FLAGS3 . 5 , ( $+5 ) 
1691    C297          5667+1   CLR P1 . 7 
1693    307502        5667+1   JNB FLAGS3 . 5 , ( $+5 ) 
1696    C293          5667+1   CLR P1 . 3 
1698    742D          5668     	MOV	A, #45					; 8us delay for pfets to go off
169A    D5E0FD        5669     	DJNZ	ACC, $
169D    D2AF          5670     	SETB	EA						; Enable interrupts
169F    1105          5671     	CALL COMM6COMM1				
16A1    120CA4        5672     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16A4    120D13        5673     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16A7    120D27        5674     	CALL CALC_NEW_WAIT_TIMES
16AA    120DB8        5675     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16AD    756C00        5676     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5677     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16B0    75BB09        5677+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16B3    0216C0        5678     	JMP	RUN1
                      5679     
                      5680     
                      5681     
                      5682     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5683     ;
                      5684     ; Run entry point
                      5685     ;
                      5686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5687     DAMPED_TRANSITION: 
                      5688     	; Transition from nondamped to damped if applicable
16B6    3147          5689     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16B8    1105          5690     	CALL	COMM6COMM1
16BA    756C00        5691     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5692     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16BD    75BB09        5692+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5693     
                      5694     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5695     ; Out_cA changes from low to high
                      5696     RUN1: 
16C0    120DDA        5697     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16C3    120E5F        5698     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
16C6    120E8A        5699     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
16C9    1208F3        5700     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
16CC    120E9E        5701     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
16CF    120ED2        5702     	CALL COMM1COMM2			; Commutate
16D2    120CA4        5703     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
16D5    120D13        5704     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
16D8    120D27        5705     	CALL CALC_NEW_WAIT_TIMES
16DB    120DB8        5706     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5707     
                      5708     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5709     ; Out_cB changes from high to low
                      5710     RUN2: 
16DE    120DD1        5711     	CALL WAIT_FOR_COMP_OUT_LOW
16E1    120E5F        5712     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16E4    120E8A        5713     	CALL SETUP_COMM_WAIT	
16E7    120950        5714     	CALL CALC_GOVERNOR_PROP_ERROR
16EA    120E9E        5715     	CALL WAIT_FOR_COMM
16ED    120F04        5716     	CALL COMM2COMM3
16F0    120CA4        5717     	CALL CALC_NEXT_COMM_TIMING
16F3    120D13        5718     	CALL WAIT_ADVANCE_TIMING
16F6    120D27        5719     	CALL CALC_NEW_WAIT_TIMES
16F9    120DB8        5720     	CALL WAIT_BEFORE_ZC_SCAN	
                      5721     
                      5722     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5723     ; Out_cC changes from low to high
                      5724     RUN3: 
16FC    120DDA        5725     	CALL WAIT_FOR_COMP_OUT_HIGH
16FF    120E5F        5726     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1702    120E8A        5727     	CALL SETUP_COMM_WAIT	
1705    120989        5728     	CALL CALC_GOVERNOR_INT_ERROR
1708    120E9E        5729     	CALL WAIT_FOR_COMM
170B    120F4E        5730     	CALL COMM3COMM4
170E    120CA4        5731     	CALL CALC_NEXT_COMM_TIMING
1711    120D13        5732     	CALL WAIT_ADVANCE_TIMING
1714    120D27        5733     	CALL CALC_NEW_WAIT_TIMES
1717    120DB8        5734     	CALL WAIT_BEFORE_ZC_SCAN	
                      5735     
                      5736     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5737     ; Out_cA changes from high to low
                      5738     RUN4: 
171A    120DD1        5739     	CALL WAIT_FOR_COMP_OUT_LOW
171D    120E5F        5740     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1720    120E8A        5741     	CALL SETUP_COMM_WAIT	
1723    1209E6        5742     	CALL CALC_GOVERNOR_PROP_CORRECTION
1726    120E9E        5743     	CALL WAIT_FOR_COMM
1729    120F89        5744     	CALL COMM4COMM5
172C    120CA4        5745     	CALL CALC_NEXT_COMM_TIMING
172F    120D13        5746     	CALL WAIT_ADVANCE_TIMING
1732    120D27        5747     	CALL CALC_NEW_WAIT_TIMES
1735    120DB8        5748     	CALL WAIT_BEFORE_ZC_SCAN	
                      5749     
                      5750     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5751     ; Out_cB changes from low to high
                      5752     RUN5: 
1738    120DDA        5753     	CALL WAIT_FOR_COMP_OUT_HIGH
173B    120E5F        5754     	CALL	EVALUATE_COMPARATOR_INTEGRITY
173E    120E8A        5755     	CALL SETUP_COMM_WAIT	
1741    120A4A        5756     	CALL CALC_GOVERNOR_INT_CORRECTION
1744    120E9E        5757     	CALL WAIT_FOR_COMM
1747    120FCA        5758     	CALL COMM5COMM6
174A    120CA4        5759     	CALL CALC_NEXT_COMM_TIMING
174D    120D13        5760     	CALL WAIT_ADVANCE_TIMING
1750    120D27        5761     	CALL CALC_NEW_WAIT_TIMES
1753    120DB8        5762     	CALL WAIT_BEFORE_ZC_SCAN	
                      5763     
                      5764     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5765     ; Out_cC changes from high to low
                      5766     RUN6: 
1756    120DD1        5767     	CALL WAIT_FOR_COMP_OUT_LOW
1759    120B47        5768     	CALL START_ADC_CONVERSION
175C    120E5F        5769     	CALL	EVALUATE_COMPARATOR_INTEGRITY
175F    120E8A        5770     	CALL SETUP_COMM_WAIT	
1762    120B4B        5771     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1765    120E9E        5772     	CALL WAIT_FOR_COMM
1768    1105          5773     	CALL COMM6COMM1
176A    120CA4        5774     	CALL CALC_NEXT_COMM_TIMING
176D    120D13        5775     	CALL WAIT_ADVANCE_TIMING
1770    120D27        5776     	CALL CALC_NEW_WAIT_TIMES
1773    120DB8        5777     	CALL WAIT_BEFORE_ZC_SCAN	
                      5778     
                      5779     	; Check if it is direct startup
1776    306342        5780     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      5781     
                      5782     	; Set spoolup power variables
1779    85605E        5783     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
177C    85605F        5784     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
177F    855D64        5785     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
1782    756501        5786     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5787     	; Check startup ok counter
1785    7964          5788     MOV R1 , # 100 
1787    7A14          5789     MOV R2 , # 20 
                      5790     IF MODE >= 1	; Tail or multi
1789    7888          5791     MOV R0 , # PGM_DIRECTION 
178B    E6            5792     MOV A , @ R0 
178C    B40304        5793     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      5794     
178F    791E          5795     MOV R1 , # 30 
1791    7A05          5796     MOV R2 , # 5 
                      5797     
                      5798     DIRECT_START_PARAMS_SET: 
                      5799     ENDIF
1793    C3            5800     	CLR	C
1794    E538          5801     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
1796    99            5802     SUBB A , R1 
1797    4015          5803     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5804     
1799    C263          5805     CLR FLAGS1 . 3 
179B    D264          5806     SETB FLAGS1 . 4 
179D    8A37          5807     MOV STARTUP_ROT_CNT , R2 
                      5808     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      5812     IF MODE == 2	; Multi
179F    7888          5813     MOV R0 , # PGM_DIRECTION 
17A1    E6            5814     MOV A , @ R0 
17A2    B40306        5815     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      5816     
17A5    755EFF        5817     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17A8    755FFF        5818     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      5819     
                      5820     DIRECT_START_PWM_LIM_SET: 
                      5821     ENDIF
17AB    0217BB        5822     	JMP	NORMAL_RUN_CHECKS
                      5823     
                      5824     DIRECT_START_CHECK_RCP: 
17AE    C3            5825     	CLR	C
17AF    E559          5826     	MOV	A, NEW_RCP				; Load new pulse value
17B1    9401          5827     SUBB A , # 1 
17B3    4003          5828     	JC	($+5)
                      5829     
17B5    0216C0        5830     	LJMP	RUN1						; Continue to run 
                      5831     
17B8    0217F1        5832     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5833     
                      5834     
                      5835     NORMAL_RUN_CHECKS: 
                      5836     	; Check if it is initial run phase
17BB    306419        5837     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      5838     
                      5839     	; Decrement startup rotaton count
17BE    E537          5840     	MOV	A, STARTUP_ROT_CNT
17C0    14            5841     	DEC	A
                      5842     	; Check number of nondamped rotations
17C1    7005          5843     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      5844     
17C3    C264          5845     CLR FLAGS1 . 4 
17C5    0216B6        5846     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      5847     
                      5848     NORMAL_RUN_CHECK_STARTUP_ROT: 
17C8    F537          5849     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      5850     
17CA    C3            5851     	CLR	C
17CB    E559          5852     	MOV	A, NEW_RCP				; Load new pulse value
17CD    9401          5853     SUBB A , # 1 
17CF    4003          5854     	JC	($+5)
                      5855     
17D1    0216C0        5856     	LJMP	RUN1						; Continue to run 
                      5857     
17D4    0217F1        5858     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5859     
                      5860     
                      5861     INITIAL_RUN_PHASE_DONE: 
                      5862     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      5875     	; Exit run loop after a given time
17D7    C3            5876     	CLR	C
17D8    E55C          5877     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
17DA    94FA          5878     SUBB A , # 250 
17DC    5013          5879     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      5880     
                      5881     RUN6_CHECK_RCP_TIMEOUT: 
17DE    741F          5882     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
17E0    552E          5883     	ANL	A, FLAGS3					; Check pwm frequency flags
17E2    7004          5884     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      5885     
17E4    E528          5886     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
17E6    6009          5887     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      5888     
                      5889     RUN6_CHECK_SPEED: 
17E8    C3            5890     	CLR	C
17E9    E53D          5891     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
17EB    94F0          5892     	SUBB	A, #0F0H
17ED    5002          5893     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
17EF    C1C0          5894     	JMP	RUN1						; Go back to run 1
                      5895     
                      5896     
                      5897     RUN_TO_WAIT_FOR_POWER_ON: 	
17F1    C2AF          5898     	CLR	EA
17F3    1170          5899     	CALL SWITCH_POWER_OFF
17F5    7887          5900     MOV R0 , # PGM_PWM_FREQ 
17F7    E6            5901     MOV A , @ R0 
17F8    FE            5902     MOV R6 , A 
17F9    7602          5903     MOV @ R0 , # 2 
17FB    3147          5904     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
17FD    7887          5905     MOV R0 , # PGM_PWM_FREQ 
17FF    EE            5906     MOV A , R6 
1800    F6            5907     MOV @ R0 , A 
1801    E4            5908     	CLR	A
1802    F522          5909     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
1804    F523          5910     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1806    F524          5911     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1808    F525          5912     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
180A    F561          5913     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
180C    C260          5914     CLR FLAGS1 . 0 
180E    D2AF          5915     	SETB	EA
1810    1207CB        5916     	CALL	WAIT1MS					; Wait for pwm to be stopped
1813    121070        5917     	CALL SWITCH_POWER_OFF
                      5918     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      5949     IF MODE >= 1	; Tail or multi
1816    741F          5950     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1818    552E          5951     	ANL	A, FLAGS3					; Check pwm frequency flags
181A    7007          5952     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      5953     
181C    E528          5954     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
181E    7003          5955     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      5956     
1820    02132F        5957     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      5958     
                      5959     JMP_WAIT_FOR_POWER_ON: 
1823    021493        5960     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      5961     ENDIF
                      5962     
                      5963     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5964     
                      5965     $INCLUDE (BLHELITXPGM.INC)			; Include source code for programming the ESC with the TX
                      6685     
                      6686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6687     
                      6688     
                      6689     
                      6690     
                      6691     END
MACRO ASSEMBLER BLHELI                                      05/25/15 13:56:17 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   17C8H   A 
COMP_WAIT_ON_COMP~  C ADDR   0E25H   A 
CALC_NEXT_COMM_SL~  C ADDR   0CF8H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0B4BH   A 
MEASURE_LIPO_WAIT~  C ADDR   0ABDH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A77H   A 
GOVERNOR_CORR_NEG~  C ADDR   0A39H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
FUNCTION_BEEP. . .  C ADDR   1D24H   A 
INIT_START . . . .  C ADDR   1500H   A 
PROGRAM_BY_TX_ENT~  C ADDR   13BFH   A 
FIND_THROTTLE_GAI~  C ADDR   122EH   A 
COMM45_NFET. . . .  C ADDR   0FAEH   A 
COMM45_NONDAMP . .  C ADDR   0FABH   A 
COMM4COMM5 . . . .  C ADDR   0F89H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D1DH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0BDEH   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PARAVAL_BEEP . . .  C ADDR   1D32H   A 
STORE_MULTI_FUNC_~  C ADDR   1C92H   A 
DECODE_STARTUP_PO~  C ADDR   1202H   A 
GOVERNOR_CHECK_PWM  C ADDR   09C6H   A 
GOVERNOR_ACTIVATE.  C ADDR   0918H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
STORE_MULTI_FUNC_~  C ADDR   1C97H   A 
WRITE_EEPROM_SIGN~  C ADDR   1C30H   A 
WAIT_FOR_POWER_ON.  C ADDR   1493H   A 
THROTTLE_LOW_CAL_~  C ADDR   1420H   A 
ARMING_INITIAL_AR~  C ADDR   13A5H   A 
PROGRAM_BY_TX_CHE~  C ADDR   146AH   A 
ERASE_AND_STORE_A~  C ADDR   1868H   A 
SET_DEFAULT_PARAM~  C ADDR   10EDH   A 
COMM56_NONDAMP . .  C ADDR   0FF1H   A 
COMM23_CP. . . . .  C ADDR   0F3CH   A 
CALC_NEXT_COMM_TI~  C ADDR   0CA4H   A 
COMM5COMM6 . . . .  C ADDR   0FCAH   A 
CALC_GOVERNOR_INT~  C ADDR   0A51H   A 
CALC_GOVERNOR_TAR~  C ADDR   094FH   A 
PCA_INT_STORE_DATA  C ADDR   065FH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   124BH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1FFFh            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
FUNCTION_NEXT. . .  C ADDR   1D9BH   A 
STORE_MULTI_FUNC_~  C ADDR   1C9CH   A 
STEPPER_ROT_BEG. .  C ADDR   15EDH   A 
THROTTLE_HIGH_CAL.  C ADDR   13ECH   A 
DECODE_THROTTLE_R~  C ADDR   11F4H   A 
STEPPER_STEP_MED_~  C ADDR   0C76H   A 
INITIALIZE_ALL_TI~  C ADDR   0C2AH   A 
STARTUP_PWM_SET_P~  C ADDR   0C1EH   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
PARAVAL_NEXT . . .  C ADDR   1D86H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA1H   A 
WRITE_EEPROM_BYTE.  C ADDR   1C04H   A 
MEASURE_PWM_FREQ_~  C ADDR   132FH   A 
COMM61_CP. . . . .  C ADDR   104DH   A 
COMM_EXIT. . . . .  C ADDR   105CH   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0CFFH   A 
CALC_GOVERNOR_INT~  C ADDR   0A4AH   A 
PCA_INT_PPM_CHECK~  C ADDR   06BDH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0763H   A 
PCA_INT_LIMITED. .  C ADDR   0786H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
FUNC_PARAVAL_WAIT.  C ADDR   1D50H   A 
STORE_MULTI_FUNC_~  C ADDR   1CA6H   A 
WRITE_TAG. . . . .  C ADDR   1C59H   A 
READ_EEPROM_STORE~  C ADDR   183FH   A 
RUN1 . . . . . . .  C ADDR   16C0H   A 
CLEAR_RAM. . . . .  C ADDR   12AEH   A 
SET_BEC_VOLTAGE. .  C ADDR   121EH   A 
DECODE_GOVERNOR_G~  C ADDR   11DBH   A 
DEC_STEP_HIGH. . .  C ADDR   10B0H   A 
WAIT_FOR_COMM. . .  C ADDR   0E9EH   A 
CALC_NEW_WAIT_DIR~  C ADDR   0D46H   A 
MEASURE_LIPO_ADD_~  C ADDR   0B3AH   A 
CALC_GOVERNOR_PRO~  C ADDR   0988H   A 
DIV_U16_BY_U16_DI~  C ADDR   086CH   A 
WAIT100MS. . . . .  C ADDR   07DFH   A 
WAIT1MS. . . . . .  C ADDR   07CBH   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
FUNCTION_PARAVAL_~  C ADDR   1D1EH   A 
STORE_MULTI_FUNC_~  C ADDR   1CABH   A 
STORE_NEW_VALUE_I~  C ADDR   1C61H   A 
DIRECT_START_PWM_~  C ADDR   17ABH   A 
RUN2 . . . . . . .  C ADDR   16DEH   A 
ARMING_PPM_CHECK .  C ADDR   13AFH   A 
COMM45_CP. . . . .  C ADDR   0FC1H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0DB8H   A 
MEASURE_LIPO_UPDA~  C ADDR   0B42H   A 
GOVERNOR_CORR_INT~  C ADDR   0A96H   A 
GOVERNOR_STORE_PR~  C ADDR   0984H   A 
DIV_U16_BY_U16_DI~  C ADDR   0876H   A 
WAIT200MS. . . . .  C ADDR   07E4H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
STORE_MULTI_FUNC_~  C ADDR   1CB0H   A 
RUN3 . . . . . . .  C ADDR   16FCH   A 
DIRECT_METHOD_STA~  C ADDR   1557H   A 
DECODE_DAMPING_DO~  C ADDR   1183H   A 
PWM_WAIT . . . . .  C ADDR   0E4AH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0BEEH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A7EH   A 
GOVERNOR_CHECK_IN~  C ADDR   09AEH   A 
DIV_U16_BY_U16_DI~  C ADDR   088DH   A 
WAIT3MS. . . . . .  C ADDR   07D0H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
BEEP_NO_ENTRY. . .  C ADDR   1D49H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1823H   A 
DIRECT_START_CHEC~  C ADDR   17AEH   A 
RUN4 . . . . . . .  C ADDR   171AH   A 
STORE_TIMES_UP_OR~  C ADDR   0D98H   A 
STORE_TIMES_DECRE~  C ADDR   0DABH   A 
STEPPER_STEP_SET .  C ADDR   0C90H   A 
TEMP_AVERAGE_INC .  C ADDR   0B7EH   A 
GOVERNOR_CORR_INT~  C ADDR   0AA7H   A 
MULT_S16_BY_U8_DI~  C ADDR   089CH   A 
PCA_INT_PPM_NEG_C~  C ADDR   0720H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
READ_TAGS. . . . .  C ADDR   1C3FH   A 
RUN5 . . . . . . .  C ADDR   1738H   A 
COMP_READ. . . . .  C ADDR   0E50H   A 
COMP_WAIT_SET_RES~  C ADDR   0E11H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0D4CH   A 
GOVERNOR_CORR_NEG~  C ADDR   0A9BH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0979H   A 
GOVERNOR_TARGET_C~  C ADDR   08FBH   A 
CALC_GOVERNOR_TAR~  C ADDR   08F3H   A 
PCA_INT_PWM_DIVID~  C ADDR   076AH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
RUN6 . . . . . . .  C ADDR   1756H   A 
ARMING_START . . .  C ADDR   138FH   A 
MEASURE_PWM_FREQ_~  C ADDR   1333H   A 
DECREMENT_STEP_EX~  C ADDR   10DDH   A 
COMM_RETURN. . . .  C ADDR   106FH   A 
GOVERNOR_DEACTIVA~  C ADDR   0905H   A 
PCA_INT_CHECK_LEG~  C ADDR   077BH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
ARM_TARGET_UPDATED  C ADDR   1474H   A 
EVALUATE_COMPARAT~  C ADDR   0E5FH   A 
TEMP_CHECK_EXIT. .  C ADDR   0BA8H   A 
GOVERNOR_APPLY_PR~  C ADDR   0A20H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
WRITE_EEPROM_BLOC~  C ADDR   188BH   A 
NORMAL_RUN_CHECKS.  C ADDR   17BBH   A 
DEC_STEP_MED_LOW .  C ADDR   10CBH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DE0H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0D13H   A 
CALC_GOVERNOR_PRO~  C ADDR   0950H   A 
PCA_INT_PPM_UNIDI~  C ADDR   071AH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
WRITE_EEPROM_BLOC~  C ADDR   1899H   A 
READ_ALL_EEPROM_P~  C ADDR   1826H   A 
PROGRAM_BY_TX_ENT~  C ADDR   145BH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0EB8H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   1210H   A 
EVAL_COMP_EXIT . .  C ADDR   0E89H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0E71H   A 
STEPPER_STEP_LOW .  C ADDR   0C84H   A 
MEASURE_LIPO_ADJU~  C ADDR   0AFFH   A 
PCA_INT_SET_TIMEO~  C ADDR   0797H   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
STEPPER_ROT_EXIT .  C ADDR   165EH   A 
STEPPER_METHOD_ST~  C ADDR   1598H   A 
DECODE_PARAMS_DIR~  C ADDR   11BDH   A 
COMM12_DAMP. . . .  C ADDR   0EDCH   A 
SETUP_COMM_WAIT. .  C ADDR   0E8AH   A 
CALC_NEXT_COMM_TI~  C ADDR   0C9DH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0BD4H   A 
CALC_GOVERNOR_INT~  C ADDR   09E5H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
ARM_END_BEEP . . .  C ADDR   1480H   A 
THROTTLE_HIGH_CAL~  C ADDR   13EAH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DD1H   A 
LOAD_MIN_TIME. . .  C ADDR   0D68H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0D27H   A 
SET_STARTUP_PWM. .  C ADDR   0BFAH   A 
GOVERNOR_STORE_IN~  C ADDR   09DFH   A 
GOVERNOR_ACTIVATE~  C ADDR   0942H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   0000h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
FUNC_PARAVAL . . .  C ADDR   1D4CH   A 
WAIT1S_LOOP. . . .  C ADDR   1CBAH   A 
STORE_MULTI_FUNC_1  C ADDR   1C65H   A 
RUN6_CHECK_RCP_TI~  C ADDR   17DEH   A 
DECREMENT_STEP . .  C ADDR   108EH   A 
COMM23_DAMP. . . .  C ADDR   0F0CH   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0EBAH   A 
ADJUST_TIMING. . .  C ADDR   0D6CH   A 
STEPPER_STEP_MED_~  C ADDR   0C5AH   A 
MEASURE_LIPO_DIVI~  C ADDR   0B1FH   A 
MEASURE_LIPO_START  C ADDR   0AACH   A 
CALC_GOVERNOR_PRO~  C ADDR   0A49H   A 
GOVERNOR_INT_MIN_~  C ADDR   09DAH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0980H   A 
BEEP_F1. . . . . .  C ADDR   07F4H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
CPFET. . . . . . .  N NUMB   0007h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
STORE_MULTI_FUNC_2  C ADDR   1C6AH   A 
INITIAL_RUN_PHASE~  C ADDR   17D7H   A 
TEST_THROTTLE_GAIN  C ADDR   123CH   A 
STEPPER_STEP_MED .  C ADDR   0C68H   A 
GOVERNOR_STORE_PR~  C ADDR   0A47H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A0BH   A 
MULT_S16_BY_U8_PO~  C ADDR   08B6H   A 
DIV_U16_BY_U16 . .  C ADDR   0864H   A 
BEEP_ONOFF . . . .  C ADDR   0817H   A 
BEEP_F2. . . . . .  C ADDR   07FBH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F0H   A 
PCA_INT_CHECK_DIFF  C ADDR   0652H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
PARAVAL_NO_ENTRY .  C ADDR   1D46H   A 
STORE_MULTI_FUNC_3  C ADDR   1C6FH   A 
SUCCESS_BEEP_INVE~  C ADDR   1CEFH   A 
SUCCESS_BEEP . . .  C ADDR   1CC0H   A 
FIND_THROTTLE_GAIN  C ADDR   121FH   A 
DECREMENT_STEPPER~  C ADDR   1082H   A 
COMM61_DAMP. . . .  C ADDR   100DH   A 
COMM34_DAMP. . . .  C ADDR   0F60H   A 
TEMP_AVERAGE_INC_~  C ADDR   0B6EH   A 
GOVERNOR_INT_MAX_~  C ADDR   09D3H   A 
GOVERNOR_LIMIT_IN~  C ADDR   09B7H   A 
BEEP_F3. . . . . .  C ADDR   0802H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
STORE_MULTI_FUNC_4  C ADDR   1C74H   A 
DAMPED_TRANSITION.  C ADDR   16B6H   A 
BEEP_DELAY_SET . .  C ADDR   14BBH   A 
PROGRAM_BY_TX_ENT~  C ADDR   13D0H   A 
LOCK_BYTE_OK . . .  C ADDR   126AH   A 
DECODE_PWM_FREQ_L~  C ADDR   11D5H   A 
DECODE_DAMPING_3 .  C ADDR   115BH   A 
CALC_NEW_WAIT_RED~  C ADDR   0D37H   A 
BEEP_F4. . . . . .  C ADDR   0809H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074AH   A 
PCA_INT_RESTORE_E~  C ADDR   063EH   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
PROGRAM_BY_TX_EXIT  C ADDR   1DAAH   A 
STORE_MULTI_FUNC_5  C ADDR   1C79H   A 
READ_EEPROM_BYTE .  C ADDR   1C00H   A 
DIRECT_START_PARA~  C ADDR   1793H   A 
THROTTLE_LOW_CAL .  C ADDR   1422H   A 
DECODE_DAMPING_4 .  C ADDR   1165H   A 
COMM45_DAMP. . . .  C ADDR   0F91H   A 
WAIT_FOR_COMM_SET~  C ADDR   0ECAH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B86H   A 
GOVERNOR_APPLY_IN~  C ADDR   0A82H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A16H   A 
BEEP_OFF . . . . .  C ADDR   0858H   A 
WAIT10MS . . . . .  C ADDR   07D5H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F7H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
STORE_MULTI_FUNC_6  C ADDR   1C7EH   A 
READ_TAG . . . . .  C ADDR   1C48H   A 
RESET_CAL_DONE . .  C ADDR   1286H   A 
DECODE_DAMPING_5 .  C ADDR   116FH   A 
DECODE_PARAMETERS.  C ADDR   1147H   A 
STEPPER_TIMER_WAIT  C ADDR   10E7H   A 
STORE_TIMES_INCRE~  C ADDR   0D9EH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0BCDH   A 
MEASURE_LIPO_CELLS  C ADDR   0AACH   A 
CALC_GOVERNOR_INT~  C ADDR   0989H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CDH   A 
PCA_INT_EXIT . . .  C ADDR   07B1H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
STORE_MULTI_FUNC_7  C ADDR   1C83H   A 
RUN6_CHECK_SPEED .  C ADDR   17E8H   A 
WAIT_FOR_POWER_ON~  C ADDR   14E7H   A 
DECODE_DAMPING_6 .  C ADDR   1179H   A 
DEC_STEP_LOW . . .  C ADDR   10D4H   A 
COMM56_DAMP. . . .  C ADDR   0FDCH   A 
SWITCH_POWER_OFF .  C ADDR   1070H   A 
WAIT30MS . . . . .  C ADDR   07DAH   A 
PCA_INT_PPM_BIDIR~  C ADDR   073BH   A 
PCA_INT_CHECK_1KHZ  C ADDR   062FH   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
FUNC_PARAVAL_CONT~  C ADDR   1D79H   A 
STORE_MULTI_FUNC_8  C ADDR   1C88H   A 
WRITE_TAGS . . . .  C ADDR   1C52H   A 
WAIT1S . . . . . .  C ADDR   1CB8H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   17F1H   A 
EVAL_COMP_CHECK_T~  C ADDR   0E7FH   A 
ADJUST_TIMING_TWO~  C ADDR   0D8EH   A 
CHECK_VOLTAGE_RET.  C ADDR   0BF9H   A 
CALC_GOVERNOR_PRO~  C ADDR   09EDH   A 
GOVERNOR_ACTIVATE~  C ADDR   0949H   A 
WAITXMS_M. . . . .  C ADDR   07EBH   A 
PCA_INT_CHECK_2KHZ  C ADDR   061EH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
STORE_MULTI_FUNC_9  C ADDR   1C8DH   A 
READ_INITIAL_TEMP.  C ADDR   1536H   A 
WAIT_FOR_POWER_ON~  C ADDR   14D8H   A 
DECODE_PWM_FREQ_E~  C ADDR   11DAH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0ECCH   A 
PWM_WAIT_STARTUP .  C ADDR   0E45H   A 
START_ADC_CONVERS~  C ADDR   0B47H   A 
MULT_S16_BY_U8_EX~  C ADDR   08EAH   A 
PCA_INT_PPM_LIMIT~  C ADDR   075CH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
STORE_IN_RAM_EXIT.  C ADDR   1CB5H   A 
VALIDATE_RCP_START  C ADDR   1369H   A 
LOCK_BYTE_TEST . .  C ADDR   1263H   A 
DEC_STEP_MED_HIGH.  C ADDR   10B9H   A 
COMM_RESTORE_POWER  C ADDR   106DH   A 
COMM12_NONDAMP . .  C ADDR   0EF1H   A 
COMM1COMM2 . . . .  C ADDR   0ED2H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B84H   A 
TEMP_AVERAGE_DEC .  C ADDR   0B7AH   A 
CALC_GOVERNOR_PRO~  C ADDR   09E6H   A 
WAITXMS_O. . . . .  C ADDR   07E9H   A 
PCA_INT_PPM_TIMEO~  C ADDR   07A3H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060DH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
READ_EEPROM_EXIT .  C ADDR   1867H   A 
WAIT_FOR_POWER_ON~  C ADDR   1498H   A 
DEC_STEP_MED . . .  C ADDR   10C2H   A 
READ_TIMER . . . .  C ADDR   0CA8H   A 
CHECK_VOLTAGE_STA~  C ADDR   0BACH   A 
CALC_GOVERNOR_INT~  C ADDR   0AABH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09C0H   A 
MULT_S16_BY_U8_DI~  C ADDR   08CFH   A 
BEEP . . . . . . .  C ADDR   0810H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0705H   A 
PCA_INT_FALL . . .  C ADDR   066BH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
ERASE_FLASH. . . .  C ADDR   1C19H   A 
PROGRAM_BY_TX. . .  C ADDR   1D3DH   A 
COMM23_NFET. . . .  C ADDR   0F29H   A 
COMM23_NONDAMP . .  C ADDR   0F26H   A 
COMM2COMM3 . . . .  C ADDR   0F04H   A 
STEPPER_STEP_HIGH.  C ADDR   0C4CH   A 
MEASURE_LIPO_CELL~  C ADDR   0AE4H   A 
GOVERNOR_STORE_IN~  C ADDR   0AA9H   A 
GOVERNOR_CHECK_IN~  C ADDR   0A6BH   A 
GOVERNOR_CORR_PRO~  C ADDR   0A34H   A 
GOVERNOR_ACTIVATE~  C ADDR   0936H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
FUNC_PARAVAL_STORE  C ADDR   1D6BH   A 
WRITE_EEPROM_BYTE~  C ADDR   1C05H   A 
READ_EEPROM_BLOCK1  C ADDR   184FH   A 
READ_EEPROM_READ .  C ADDR   1848H   A 
MEASURE_LIPO_EXIT.  C ADDR   0B46H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A1CH   A 
GOVERNOR_CHECK_PR~  C ADDR   096DH   A 
PCA_INT_SECOND_ME~  C ADDR   05B1H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
READ_EEPROM_BLOCK2  C ADDR   185DH   A 
MEASURE_PWM_FREQ_~  C ADDR   1331H   A 
COMM61_NFET. . . .  C ADDR   1032H   A 
COMM61_NONDAMP . .  C ADDR   102FH   A 
COMM6COMM1 . . . .  C ADDR   1005H   A 
COMM34_NONDAMP . .  C ADDR   0F6DH   A 
COMM3COMM4 . . . .  C ADDR   0F4EH   A 
COMP_WAIT_SET_MAX~  C ADDR   0DFEH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0DDAH   A 
STARTUP_PWM_EXIT .  C ADDR   0C29H   A 
MEASURE_LIPO_LIMI~  C ADDR   0B36H   A 
GOVERNOR_CORR_PRO~  C ADDR   0A45H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E7H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FCH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6723    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     82    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
