MACRO ASSEMBLER BLHELI                                      05/26/15 15:16:12 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.16.13.326
OBJECT MODULE PLACED IN OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ
ASSEMBLER INVOKED BY: SET(BESC=96) OBJECT(OUTPUT\SKYWALKER_40A_MULTI_REV11_2.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ; Up to 8K Bytes of In-System Self-Programmable Flash
                         4     ; 768 Bytes Internal SRAM
                         5     ;
                         6     ;**** **** **** **** ****
                         7     ; Master clock is internal 24MHz oscillator
                         8     ; Timer 0 (167/500ns counts) always counts up and is used for
                         9     ; - PWM generation
                        10     ; Timer 1 (167/500ns counts) always counts up and is used for
                        11     ; - Time from pwm on/off event
                        12     ; Timer 2 (500ns counts) always counts up and is used for
                        13     ; - RC pulse timeout/skip counts and commutation times
                        14     ; Timer 3 (500ns counts) always counts up and is used for
                        15     ; - Commutation timeouts
                        16     ; PCA0 (500ns counts) always counts up and is used for
                        17     ; - RC pulse measurement
                        18     ;
                        19     ;**** **** **** **** ****
                        20     ; Interrupt handling
                        21     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                        22     ; Also some interrupt flags need to be cleared by software
                        23     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrupts
                        24     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                        25     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                        26     ;
                        27     ;**** **** **** **** ****
                        28     ; Motor control:
                        29     ; - Brushless motor control with 6 states for each electrical 360 degrees
                        30     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                        31     ; - Timing advance in this implementation is set to 15deg nominally
                        32     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                        33     ; Motor sequence starting from zero crossing:
                        34     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                        35     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                        36     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                        37     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                        38     ;
                        39     ; Motor startup in stepper mode:
                        40     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                        41     ; In this stepper motor mode comparator information is not used.
                        42     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                        43     ; Stepper phase comes next, where there is a step length decrease sequence.
                        44     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                        45     ; Motor startup in direct mode:
                        46     ; Direct startup is the only phase, before normal bemf commutation run begins.
                        47     ;
                        48     ;**** **** **** **** ****
                        49     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0016                  50     DP_3A_MAIN 					EQU 22
  0017                  51     DP_3A_TAIL  					EQU 23
  0018                  52     DP_3A_MULTI  					EQU 24
  0022                  53     TURNIGY_PLUSH_12A_MAIN 			EQU 34
  0023                  54     TURNIGY_PLUSH_12A_TAIL 			EQU 35   
  0024                  55     TURNIGY_PLUSH_12A_MULTI 			EQU 36   
  004C                  56     TURNIGY_KFORCE_40A_MAIN 			EQU 76   
  004D                  57     TURNIGY_KFORCE_40A_TAIL 			EQU 77   
  004E                  58     TURNIGY_KFORCE_40A_MULTI 		EQU 78    
  005B                  59     SKYWALKER_20A_MAIN 				EQU 91
  005C                  60     SKYWALKER_20A_TAIL 				EQU 92   
  005D                  61     SKYWALKER_20A_MULTI 			EQU 93   
  005E                  62     SKYWALKER_40A_MAIN 				EQU 94
  005F                  63     SKYWALKER_40A_TAIL 				EQU 95   
  0060                  64     SKYWALKER_40A_MULTI 			EQU 96   
  009D                  65     PLATINUM_PRO_30A_MAIN			EQU 157   
  009E                  66     PLATINUM_PRO_30A_TAIL 			EQU 158  
  009F                  67     PLATINUM_PRO_30A_MULTI 			EQU 159  
                        68     
                        69     ;**** **** **** **** ****
                        70     ; ESC selection statements
                        71     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        75     
                        76     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        80     
                        81     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                        85     
                        86     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        90     
                        91     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                        95     
                        96     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       100     
                       101     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       105     
                       106     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       110     
                       111     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       115     
                       116     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       120     
                       121     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       125     
                       126     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       130     
                       131     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       135     
                       136     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       140     
                       141     IF BESC == SKYWALKER_40A_MULTI
  0002                 142     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       143     $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                       650     ENDIF
                       651     
                       652     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       656     
                       657     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       661     
                       662     IF BESC == PLATINUM_PRO_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                       666     
                       667     
                       668     ;**** **** **** **** ****
                       669     ; TX programming defaults
                       670     ;
                       671     ; Parameter dependencies:
                       672     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                       673     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                       674     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                       675     ; - Damping force is only used if DampedLight or Damped is selected
                       676     ;
                       677     ; Main
  0007                 678     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                 679     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                 680     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                 681     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Middle		3=Low
  0004                 682     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                 683     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                 684     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 685     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 686     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                 687     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                 688     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                 689     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 690     DEFAULT_PGM_MAIN_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed
  0001                 691     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                 692     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                 693     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                 694     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                 695     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                 696     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       697     ; Tail
  0003                 698     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                 699     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                 700     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 701     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 702     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                 703     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                 704     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       705     IF DAMPED_MODE_ENABLE == 1
  0004                 706     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       707     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                 710     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=Low		3=High
  0001                 711     DEFAULT_PGM_TAIL_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 712     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                 713     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                 714     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                 715     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       716     ; Multi
  0009                 717     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                 718     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                 719     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                 720     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                 721     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                 722     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                 723     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                 724     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0001                 725     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 1	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                 726     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                       727     IF DAMPED_MODE_ENABLE == 1
  0001                 728     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                       729     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                 732     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=Low		3=High
  0001                 733     DEFAULT_PGM_MULTI_DIRECTION		EQU 1 	; 1=Normal 	2=Reversed	3=Bidirectional
  0001                 734     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0014                 735     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 20	; Beep strength
  0014                 736     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 20	; Beacon strength
  0005                 737     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 5 	; 1=1m		2=2m			3=5m			4=10m		5=Infinite
                       738     ; Common
  0000                 739     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 0 	; 1 = Enabled 	0 = Disabled
  0003                 740     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 3	; 4 * 3 + 1000 = 1012
  00FA                 741     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 250	; 4 * 250 + 1000 = 2000
  007D                 742     DEFAULT_PGM_PPM_CENTER_THROTTLE	EQU 125	; 4 * 125 + 1000 = 1500 (用于双向模式)
  0000                 743     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0 = Low		1 = High
                       744     
                       745     ;**** **** **** **** ****
                       746     ; Constant definitions for main
                       747     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	2	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       769     ; Constant definitions for tail
                       770     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                       791     ; Constant definitions for multi
                       792     IF MODE == 2
                       793     
  0001                 794     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                       795     
  000A                 796     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                 797     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                 798     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                 799     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                 800     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                 801     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                 802     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                 803     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                       804     
  0032                 805     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                 806     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                       807     
  000A                 808     COMM_TIME_RED		EQU 	10	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                 809     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                       810     
  0008                 811     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                       812     
                       813     ENDIF
                       814     
                       815     ;**** **** **** **** ****
                       816     ; Temporary register definitions
  REG                  817     TEMP1		EQU	R0
  REG                  818     TEMP2		EQU	R1
  REG                  819     TEMP3		EQU	R2
  REG                  820     TEMP4		EQU	R3
  REG                  821     TEMP5		EQU	R4
  REG                  822     TEMP6		EQU	R5
  REG                  823     TEMP7		EQU	R6
  REG                  824     TEMP8		EQU	R7
                       825     
                       826     ;**** **** **** **** ****
                       827     ; Register definitions
------                 828     DSEG AT 20H					; Variables segment 
                       829     
0020                   830     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                   831     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                       832     
0022                   833     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                   834     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                   835     CURRENT_PWM: 				DS	1		; Current pwm
0025                   836     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                   837     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                   838     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                   839     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                   840     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                   841     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                       842     
002B                   843     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                 844     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                 845     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                 846     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                 847     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                 848     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                       849     ;						EQU 	5
                       850     ;						EQU 	6
                       851     ;						EQU 	7
                       852     
002C                   853     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                 854     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                 855     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                 856     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                 857     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                 858     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                 859     CURR_PWMOFF_DAMPED			EQU	5		; Currently running pwm off cycle is damped
  0006                 860     CURR_PWMOFF_COMP_ABLE		EQU	6		; Currently running pwm off cycle is usable for comparator
                       861     ;						EQU 	7
                       862     
002D                   863     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                 864     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                 865     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                 866     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                 867     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                 868     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                 869     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
                       870     ;						EQU 	6	
                       871     ;						EQU 	7	
                       872     
002E                   873     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                 874     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                 875     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                 876     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                 877     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                 878     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                 879     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                 880     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                 881     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                       882     
                       883     ;**** **** **** **** ****
                       884     ; RAM definitions
------                 885     DSEG AT 30H						; Ram data segment, direct addressing
                       886     
0030                   887     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                       888     
0031                   889     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                   890     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                       891     
0033                   892     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                   893     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                   894     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                   895     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                   896     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                   897     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                   898     DEMAG_CONSECUTIVE_CNT: 		DS	1		; Counter used to count consecutive demag events
                       899     
003A                   900     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                   901     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                   902     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                   903     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                   904     COMM_PHASE: 				DS	1		; Current commutation phase
003F                   905     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                       906     
0040                   907     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0041                   908     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0042                   909     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0043                   910     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0044                   911     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0045                   912     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0046                   913     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0047                   914     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0048                   915     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0049                   916     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                       917     
004A                   918     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                   919     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                   920     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                   921     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                   922     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                   923     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                   924     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0051                   925     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                       926     
0052                   927     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                   928     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                   929     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0055                   930     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0056                   931     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0057                   932     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0058                   933     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0059                   934     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
005A                   935     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                   936     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                   937     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value
005D                   938     AUTO_BAILOUT_ARMED: 			DS	1		; Set when auto rotation bailout is armed 
                       939     
005E                   940     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005F                   941     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
0060                   942     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
0061                   943     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0062                   944     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0063                   945     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                       946     
0064                   947     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0065                   948     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                       949     
0066                   950     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0067                   951     DAMPING_ON: 				DS	1		; Damping on part of damping period
                       952     
0068                   953     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0069                   954     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
006A                   955     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
006B                   956     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006C                   957     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                       958     
006D                   959     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                       960     
006E                   961     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006F                   962     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                       963     
0070                   964     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
0071                   965     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0072                   966     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                       967     
                       968     
                       969     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       970     ;
                       971     ; Skypup 2015.05.25
                       972     ; 宏定义
                       973     ;
                       974     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       975     ;
  0002                 976     THR_DELTA			EQU	2	; 油门缓启动增量
  00A0                 977     THR_SWITCH		EQU	0A0H	; 超过多大油门启动
                       978     ;
  00FF                 979     PWM_FULL			EQU	0FFH	; 大约 2000us 全油门
  007F                 980     PWM_CRUISE		EQU	07FH	; 大约 1500us 巡航油门
                       981     ;
  0002                 982     HOLD_FULL_H		EQU	02H	; 650 0x028A 高位
  008A                 983     HOLD_FULL_L		EQU	8AH	; 650 0x028A 低位
  0029                 984     HOLD_CRUISE_H		EQU	29H	; 10500 0x2904 高位
  0004                 985     HOLD_CRUISE_L		EQU	04H	; 10500 0x2904 低位
                       986     
                       987     
                       988     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       989     ;
                       990     ; Skypup 2015.05.25
                       991     ; 变量定义
                       992     ;
                       993     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                       994     ;
0073                   995     FLAG_BEFORE_ARM: 			DS	1		; 标记在解锁前需要 New_Rcp 为一个较大的值
0074                   996     PREV_RCP: 					DS	1		; 上一次输出的 New_Rcp 值
                       997     ;
0075                   998     NPWMIN: 					DS	1		; 读取的 PWM 信号，高或低。
  0001                 999     PWM_IN_HIGH				EQU	1		; PWM 高, 大于 THR_SWITCH
  0000                1000     PWM_IN_LOW				EQU	0		; PWM 低, 小于 THR_SWITCH
                      1001     ;
0076                  1002     NHOLD_L: 					DS	1		; nHold 低位
0077                  1003     NHOLD_H: 					DS	1		; nHold 高位
                      1004     ;
0078                  1005     CSTATE: 					DS	1		; 状态
                      1006     ;
                      1007     ;	State 状态矩阵
                      1008     ; 
                      1009     ;	00   ->   10   ->   20   ->   00
                      1010     ; 
                      1011     ;	00:Wait          -> 10
                      1012     ;	10:Full          -> 20
                      1013     ;	20:Cruise        -> 00
  0000                1014     STATE_WAIT		EQU	00H
  0010                1015     STATE_FULL		EQU	10H
  0020                1016     STATE_CRUISE		EQU	20H
                      1017     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1018     
                      1019     ; Indirect addressing data segment. The variables below must be in this sequence
------                1020     ISEG AT 080H					
0080                  1021     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  1022     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  1023     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
0083                  1024     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  1025     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  1026     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  1027     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  1028     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  1029     PGM_DIRECTION: 				DS	1		; Programmed rotation direction
0089                  1030     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  1031     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  1032     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  1033     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  1034     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  1035     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  1036     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  1037     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  1038     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  1039     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  1040     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  1041     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  1042     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  1043     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  1044     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  1045     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  1046     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  1047     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  1048     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  1049     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  1050     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
009E                  1051     PGM_PPM_CENTER_THROTTLE: 		DS	1		; Programmed throttle center (in bidirectional mode)
                      1052     
                      1053     ; The sequence of the variables below is no longer of importance
009F                  1054     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
00A0                  1055     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A1                  1056     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A2                  1057     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A3                  1058     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      1059     
                      1060     
                      1061     ; Indirect addressing data segment
------                1062     ISEG AT 0D0H					
00D0                  1063     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      1064     
                      1065     
                      1066     ;**** **** **** **** ****
------                1067     CSEG AT 1A00H            ; "Eeprom" segment
  000B                1068     EEPROM_FW_MAIN_REVISION		EQU	11		; Main revision of the firmware
  0002                1069     EEPROM_FW_SUB_REVISION		EQU	2		; Sub revision of the firmware
  0011                1070     EEPROM_LAYOUT_REVISION		EQU	17		; Revision of the EEPROM layout
                      1071     
1A00    0B            1072     EEP_FW_MAIN_REVISION:  DB 11 
1A01    02            1073     EEP_FW_SUB_REVISION:  DB 2 
1A02    11            1074     EEP_LAYOUT_REVISION:  DB 17 
                      1075     
                      1076     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_MAIN_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               _EEP_PGM_PPM_CENTER_THROTTLE:	DB	0FFH							; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1109     
                      1110     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION:			DB	DEFAULT_PGM_TAIL_DIRECTION		; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               EEP_PGM_PPM_CENTER_THROTTLE:	DB	DEFAULT_PGM_PPM_CENTER_THROTTLE	; EEPROM copy of programmed center throttle (final value is 4x+1000=1488)
                               ENDIF
                      1143     
                      1144     IF MODE == 2
1A03    09            1145     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            1146     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            1147     EEP_PGM_GOV_MODE:  DB 4 
1A06    01            1148     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            1149     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1150     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            1151     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            1152     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1153     EEP_PGM_DIRECTION:  DB 1 
1A0C    01            1154     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1155     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1156     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    00            1157     EEP_ENABLE_TX_PROGRAM:  DB 0 
1A10    FF            1158     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            1159     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            1160     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1161     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            1162     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            1163     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            1164     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            1165     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            1166     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    03            1167     EEP_PGM_PPM_MIN_THROTTLE:  DB 3 
1A1A    FA            1168     EEP_PGM_PPM_MAX_THROTTLE:  DB 250 
1A1B    14            1169     EEP_PGM_BEEP_STRENGTH:  DB 20 
1A1C    14            1170     EEP_PGM_BEACON_STRENGTH:  DB 20 
1A1D    05            1171     EEP_PGM_BEACON_DELAY:  DB 5 
1A1E    01            1172     EEP_PGM_THROTTLE_RATE:  DB 1 
1A1F    02            1173     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            1174     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
1A21    7D            1175     EEP_PGM_PPM_CENTER_THROTTLE:  DB 125 
                      1176     ENDIF
                      1177     
                      1178     
1A22    FF            1179     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      1180     
------                1181     CSEG AT 1A60H
1A60    6F72672E      1182     EEP_NAME: 					DB	"org.skypup.esc.b"				; Name tag (16 Bytes)
1A64    736B7970
1A68    75702E65
1A6C    73632E62
                      1183     
                      1184     ;**** **** **** **** ****
                      1185             		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1185+1   CSEG AT 0  ; CODE SEGMENT START
0000    021348        1185+1   JMP RESET 
------                1185+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200BA        1185+1   JMP T0_INT 
------                1185+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203E7        1185+1   JMP T2_INT 
------                1185+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    020546        1185+1   JMP PCA_INT 
------                1185+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    02053C        1185+1   JMP T3_INT 
------                1186     CSEG AT 80H			; Code segment after interrupt vectors 
                      1187     
                      1188     ;**** **** **** **** ****
                      1189     
                      1190     ; Table definitions
0080    02030406      1191     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1192     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      1193     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    000201        1194     DEMAG_POWER_TABLE:   	DB 	0, 2, 1
                      1195     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 3, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      1198     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                               ENDIF
                      1206     IF MODE == 2
                      1207       IF DAMPED_MODE_ENABLE == 1
00AA    0D0D0405      1208     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 3, 2
00AE    06020D05
00B2    05050D06
00B6    04050302
                      1209       ENDIF
                      1210       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 3, 2
                                 ENDIF
                      1213     ENDIF
                      1214     
                      1215     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1216     ;
                      1217     ; Timer0 interrupt routine
                      1218     ;
                      1219     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1220     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                      1221     ;
                      1222     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1223     T0_INT: 	; Used for pwm control
00BA    C2AF          1224     	CLR 	EA			; Disable all interrupts
00BC    C0D0          1225     	PUSH	PSW			; Preserve registers through interrupt
00BE    C0E0          1226     	PUSH	ACC		
                      1227     	; Check if pwm is on
00C0    205A10        1228     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1229     
                      1230     	; Do not execute pwm when stopped
00C3    30600A        1231     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1232     	; Do not execute pwm on during demag recovery
00C6    205C07        1233     JB FLAGS0 . 4 , T0_INT_PWM_ON_STOPPED 
                      1234     	; Pwm on cycle. 
00C9    302F02        1235     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1236     
                      1237     T0_INT_PWM_ON_EXECUTE: 
00CC    E4            1238     	CLR	A					
00CD    73            1239     	JMP	@A+DPTR					; Jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1240     
                      1241     T0_INT_PWM_ON_LOW_PWM: 
                      1242     
                      1243     IF MODE == 0 OR MODE == 2	; Main or multi
00CE    80FC          1244     	JMP	T0_INT_PWM_ON_EXECUTE
                      1245     ENDIF
                      1246     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1263     
                      1264     T0_INT_PWM_ON_STOPPED: 
00D0    0203D3        1265     	JMP	T0_INT_PWM_ON_EXIT
                      1266     
                      1267     
                      1268     T0_INT_PWM_OFF: 
00D3    306306        1269     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      1270     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00D6    D297          1270+1   SETB P1 . 7 
00D8    D295          1270+1   SETB P1 . 5 
00DA    D293          1270+1   SETB P1 . 3 
                      1271     T0_INT_PWM_OFF_START_CHECKED: 
                      1272     	; Pwm off cycle
00DC    85258A        1273     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1274     	; Clear pwm on flag
00DF    C25A          1275     CLR FLAGS0 . 2 
                      1276     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E1    E525          1277     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E3    F4            1278     	CPL	A						; Full pwm?
00E4    7002          1279     	JNZ	($+4)					; No - branch
00E6    21C6          1280     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1281     
00E8    0563          1282     	INC	PWM_OFF_CNT				; Increment event counter
                      1283     	; Do not execute pwm when stopped
00EA    306013        1284     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1285     
                      1286     	; If damped operation, set pFETs on in pwm_off
00ED    206A19        1287     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1288     
                      1289     	; Separate exit commands here for minimum delay
00F0    758B00        1290     	MOV	TL1, #0		; Reset timer1	
00F3    D0E0          1291     	POP	ACC			; Restore preserved registers
00F5    D0D0          1292     	POP	PSW
                      1293     	ALL_NFETS_OFF 		; Switch off all nfets
00F7    D297          1293+1   SETB P1 . 7 
00F9    D295          1293+1   SETB P1 . 5 
00FB    D293          1293+1   SETB P1 . 3 
00FD    D2AF          1294     	SETB	EA			; Enable all interrupts
00FF    32            1295     	RETI
                      1296     
                      1297     T0_INT_PWM_OFF_STOPPED: 
                      1298     	ALL_NFETS_OFF 					; Switch off all nfets
0100    D297          1298+1   SETB P1 . 7 
0102    D295          1298+1   SETB P1 . 5 
0104    D293          1298+1   SETB P1 . 3 
0106    0201B6        1299     	JMP	T0_INT_PWM_OFF_EXIT
                      1300     
                      1301     T0_INT_PWM_OFF_DAMPED: 
0109    D265          1302     SETB FLAGS1 . 5 
010B    C266          1303     CLR FLAGS1 . 6 
010D    E567          1304     	MOV	A, DAMPING_ON
010F    601C          1305     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      1306     
0111    C3            1307     	CLR	C
0112    E563          1308     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0114    14            1309     	DEC	A
0115    9567          1310     	SUBB	A, DAMPING_ON
0117    4014          1311     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1312     
0119    C265          1313     CLR FLAGS1 . 5 
011B    D266          1314     SETB FLAGS1 . 6 
011D    C3            1315     	CLR	C
011E    E563          1316     	MOV	A, PWM_OFF_CNT					
0120    9566          1317     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0122    5003          1318     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      1319     
0124    0201B6        1320     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1321     
                      1322     T0_INT_PWM_OFF_CLR_CNT: 
0127    756300        1323     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012A    0201B6        1324     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1325     
                      1326     T0_INT_PWM_OFF_DO_DAMPED: 
                      1327     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
012D    206C14        1328     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1329     
                      1330     	ALL_NFETS_OFF 					; Switch off all nfets
0130    D297          1330+1   SETB P1 . 7 
0132    D295          1330+1   SETB P1 . 5 
0134    D293          1330+1   SETB P1 . 3 
0136    7406          1331     MOV A , # 6 
0138    D5E0FD        1332     	DJNZ	ACC, $	
                      1333     	ALL_PFETS_ON 					; Switch on all pfets
013B    D296          1333+1   SETB P1 . 6 
013D    D294          1333+1   SETB P1 . 4 
013F    D292          1333+1   SETB P1 . 2 
0141    0201B6        1334     	JMP	T0_INT_PWM_OFF_EXIT
                      1335     
                      1336     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1337     IF DAMPED_MODE_ENABLE == 1
0144    D266          1338     SETB FLAGS1 . 6 
                      1339     ENDIF
                      1340     	ALL_NFETS_OFF 					; Switch off all nfets
0146    D297          1340+1   SETB P1 . 7 
0148    D295          1340+1   SETB P1 . 5 
014A    D293          1340+1   SETB P1 . 3 
014C    E53E          1341     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
014E    20E234        1342     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0151    20E112        1343     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1344     
                      1345     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0154    7406          1348     MOV A , # 6 
0156    D5E0FD        1349     	DJNZ	ACC, $	
                      1350     	CPFET_ON			; Comm phase 1 - turn on C
0159    207502        1350+1   JB FLAGS3 . 5 , ( $+5 ) 
015C    D292          1350+1   SETB P1 . 2 
015E    307502        1350+1   JNB FLAGS3 . 5 , ( $+5 ) 
0161    D296          1350+1   SETB P1 . 6 
                      1351     ENDIF
0163    0201B6        1352     	JMP	T0_INT_PWM_OFF_EXIT
                      1353     
                      1354     T0_INT_PWM_OFF_COMM_2_3: 
0166    20E012        1355     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1356     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
0169    7406          1359     MOV A , # 6 
016B    D5E0FD        1360     	DJNZ	ACC, $	
                      1361     	CPFET_ON			; Comm phase 2 - turn on C
016E    207502        1361+1   JB FLAGS3 . 5 , ( $+5 ) 
0171    D292          1361+1   SETB P1 . 2 
0173    307502        1361+1   JNB FLAGS3 . 5 , ( $+5 ) 
0176    D296          1361+1   SETB P1 . 6 
                      1362     ENDIF
0178    0201B6        1363     	JMP	T0_INT_PWM_OFF_EXIT
                      1364     
                      1365     T0_INT_PWM_OFF_COMM_3: 
                      1366     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017B    7406          1369     MOV A , # 6 
017D    D5E0FD        1370     	DJNZ	ACC, $	
                      1371     	BPFET_ON			; Comm phase 3 - turn on B
0180    D294          1371+1   SETB P1 . 4 
                      1372     ENDIF
0182    0201B6        1373     	JMP	T0_INT_PWM_OFF_EXIT
                      1374     
                      1375     T0_INT_PWM_OFF_COMM_4_5_6: 
0185    20E11F        1376     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0188    20E00A        1377     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1378     
                      1379     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018B    7406          1382     MOV A , # 6 
018D    D5E0FD        1383     	DJNZ	ACC, $	
                      1384     	BPFET_ON			; Comm phase 4 - turn on B
0190    D294          1384+1   SETB P1 . 4 
                      1385     ENDIF
0192    0201B6        1386     	JMP	T0_INT_PWM_OFF_EXIT
                      1387     
                      1388     T0_INT_PWM_OFF_COMM_5: 
                      1389     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0195    7406          1392     MOV A , # 6 
0197    D5E0FD        1393     	DJNZ	ACC, $	
                      1394     	APFET_ON			; Comm phase 5 - turn on A
019A    207502        1394+1   JB FLAGS3 . 5 , ( $+5 ) 
019D    D296          1394+1   SETB P1 . 6 
019F    307502        1394+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A2    D292          1394+1   SETB P1 . 2 
                      1395     ENDIF
01A4    0201B6        1396     	JMP	T0_INT_PWM_OFF_EXIT
                      1397     
                      1398     T0_INT_PWM_OFF_COMM_6: 
                      1399     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01A7    7406          1402     MOV A , # 6 
01A9    D5E0FD        1403     	DJNZ	ACC, $	
                      1404     	APFET_ON			; Comm phase 6 - turn on A
01AC    207502        1404+1   JB FLAGS3 . 5 , ( $+5 ) 
01AF    D296          1404+1   SETB P1 . 6 
01B1    307502        1404+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B4    D292          1404+1   SETB P1 . 2 
                      1405     ENDIF
                      1406     
                      1407     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01B6    758B00        1408     	MOV	TL1, #0		; Reset timer1	
01B9    D0E0          1409     	POP	ACC			; Restore preserved registers
01BB    D0D0          1410     	POP	PSW
                      1411     	ALL_NFETS_OFF 		; Switch off all nfets
01BD    D297          1411+1   SETB P1 . 7 
01BF    D295          1411+1   SETB P1 . 5 
01C1    D293          1411+1   SETB P1 . 3 
01C3    D2AF          1412     	SETB	EA			; Enable all interrupts
01C5    32            1413     	RETI
                      1414     
                      1415     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01C6    D0E0          1416     	POP	ACC			; Restore preserved registers
01C8    D0D0          1417     	POP	PSW
01CA    D2AF          1418     	SETB	EA			; Enable all interrupts
01CC    32            1419     	RETI
                      1420     
                      1421     
                      1422     
                      1423     PWM_NOFET_ON: 	; Dummy pwm on cycle
01CD    61D3          1424     	AJMP	T0_INT_PWM_ON_EXIT
                      1425     
                      1426     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1427     	ANFET_ON	
01CF    E525          1427+1   MOV A , CURRENT_PWM_LIMITED 
01D1    600A          1427+1   JZ ( $+12 ) 
01D3    207502        1427+1   JB FLAGS3 . 5 , ( $+5 ) 
01D6    C297          1427+1   CLR P1 . 7 
01D8    307502        1427+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DB    C293          1427+1   CLR P1 . 3 
                      1428     	BNFET_OFF
01DD    D295          1428+1   SETB P1 . 5 
01DF    61D3          1429     	AJMP	T0_INT_PWM_ON_EXIT
                      1430     
                      1431     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1432     	BNFET_ON
01E1    E525          1432+1   MOV A , CURRENT_PWM_LIMITED 
01E3    6002          1432+1   JZ ( $+4 ) 
01E5    C295          1432+1   CLR P1 . 5 
                      1433     	CNFET_OFF
01E7    207502        1433+1   JB FLAGS3 . 5 , ( $+5 ) 
01EA    D293          1433+1   SETB P1 . 3 
01EC    307502        1433+1   JNB FLAGS3 . 5 , ( $+5 ) 
01EF    D297          1433+1   SETB P1 . 7 
01F1    61D3          1434     	AJMP	T0_INT_PWM_ON_EXIT
                      1435     
                      1436     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1437     	CNFET_ON
01F3    E525          1437+1   MOV A , CURRENT_PWM_LIMITED 
01F5    600A          1437+1   JZ ( $+12 ) 
01F7    207502        1437+1   JB FLAGS3 . 5 , ( $+5 ) 
01FA    C293          1437+1   CLR P1 . 3 
01FC    307502        1437+1   JNB FLAGS3 . 5 , ( $+5 ) 
01FF    C297          1437+1   CLR P1 . 7 
                      1438     	ANFET_OFF
0201    207502        1438+1   JB FLAGS3 . 5 , ( $+5 ) 
0204    D297          1438+1   SETB P1 . 7 
0206    307502        1438+1   JNB FLAGS3 . 5 , ( $+5 ) 
0209    D293          1438+1   SETB P1 . 3 
020B    61D3          1439     	AJMP	T0_INT_PWM_ON_EXIT
                      1440     
                      1441     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1442     	APFET_OFF
020D    207502        1442+1   JB FLAGS3 . 5 , ( $+5 ) 
0210    C296          1442+1   CLR P1 . 6 
0212    307502        1442+1   JNB FLAGS3 . 5 , ( $+5 ) 
0215    C292          1442+1   CLR P1 . 2 
                      1443     	ANFET_ON								; Switch nFETs
0217    E525          1443+1   MOV A , CURRENT_PWM_LIMITED 
0219    600A          1443+1   JZ ( $+12 ) 
021B    207502        1443+1   JB FLAGS3 . 5 , ( $+5 ) 
021E    C297          1443+1   CLR P1 . 7 
0220    307502        1443+1   JNB FLAGS3 . 5 , ( $+5 ) 
0223    C293          1443+1   CLR P1 . 3 
                      1444     	CPFET_OFF
0225    207502        1444+1   JB FLAGS3 . 5 , ( $+5 ) 
0228    C292          1444+1   CLR P1 . 2 
022A    307502        1444+1   JNB FLAGS3 . 5 , ( $+5 ) 
022D    C296          1444+1   CLR P1 . 6 
                      1445     	BNFET_OFF 							
022F    D295          1445+1   SETB P1 . 5 
0231    61D3          1446     	AJMP	T0_INT_PWM_ON_EXIT
                      1447     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1448     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1449     	APFET_OFF
0233    207502        1449+1   JB FLAGS3 . 5 , ( $+5 ) 
0236    C296          1449+1   CLR P1 . 6 
0238    307502        1449+1   JNB FLAGS3 . 5 , ( $+5 ) 
023B    C292          1449+1   CLR P1 . 2 
                      1450     	CPFET_OFF
023D    207502        1450+1   JB FLAGS3 . 5 , ( $+5 ) 
0240    C292          1450+1   CLR P1 . 2 
0242    307502        1450+1   JNB FLAGS3 . 5 , ( $+5 ) 
0245    C296          1450+1   CLR P1 . 6 
0247    7406          1451     MOV A , # 6 
0249    D5E0FD        1452     	DJNZ ACC,	$
                      1453     	ANFET_ON								; Switch nFETs
024C    E525          1453+1   MOV A , CURRENT_PWM_LIMITED 
024E    600A          1453+1   JZ ( $+12 ) 
0250    207502        1453+1   JB FLAGS3 . 5 , ( $+5 ) 
0253    C297          1453+1   CLR P1 . 7 
0255    307502        1453+1   JNB FLAGS3 . 5 , ( $+5 ) 
0258    C293          1453+1   CLR P1 . 3 
                      1454     	BNFET_OFF 							
025A    D295          1454+1   SETB P1 . 5 
025C    61D3          1455     	AJMP	T0_INT_PWM_ON_EXIT
                      1456     
                      1457     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1458     	APFET_OFF
025E    207502        1458+1   JB FLAGS3 . 5 , ( $+5 ) 
0261    C296          1458+1   CLR P1 . 6 
0263    307502        1458+1   JNB FLAGS3 . 5 , ( $+5 ) 
0266    C292          1458+1   CLR P1 . 2 
                      1459     	ANFET_ON								; Switch nFETs
0268    E525          1459+1   MOV A , CURRENT_PWM_LIMITED 
026A    600A          1459+1   JZ ( $+12 ) 
026C    207502        1459+1   JB FLAGS3 . 5 , ( $+5 ) 
026F    C297          1459+1   CLR P1 . 7 
0271    307502        1459+1   JNB FLAGS3 . 5 , ( $+5 ) 
0274    C293          1459+1   CLR P1 . 3 
                      1460     	BPFET_OFF
0276    C294          1460+1   CLR P1 . 4 
                      1461     	BNFET_OFF								
0278    D295          1461+1   SETB P1 . 5 
027A    61D3          1462     	AJMP	T0_INT_PWM_ON_EXIT
                      1463     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1464     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1465     	APFET_OFF
027C    207502        1465+1   JB FLAGS3 . 5 , ( $+5 ) 
027F    C296          1465+1   CLR P1 . 6 
0281    307502        1465+1   JNB FLAGS3 . 5 , ( $+5 ) 
0284    C292          1465+1   CLR P1 . 2 
                      1466     	BPFET_OFF
0286    C294          1466+1   CLR P1 . 4 
0288    7406          1467     MOV A , # 6 
028A    D5E0FD        1468     	DJNZ ACC,	$
                      1469     	ANFET_ON								; Switch nFETs
028D    E525          1469+1   MOV A , CURRENT_PWM_LIMITED 
028F    600A          1469+1   JZ ( $+12 ) 
0291    207502        1469+1   JB FLAGS3 . 5 , ( $+5 ) 
0294    C297          1469+1   CLR P1 . 7 
0296    307502        1469+1   JNB FLAGS3 . 5 , ( $+5 ) 
0299    C293          1469+1   CLR P1 . 3 
                      1470     	BNFET_OFF								
029B    D295          1470+1   SETB P1 . 5 
029D    61D3          1471     	AJMP	T0_INT_PWM_ON_EXIT
                      1472     
                      1473     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1474     	BPFET_OFF
029F    C294          1474+1   CLR P1 . 4 
                      1475     	BNFET_ON								; Switch nFETs
02A1    E525          1475+1   MOV A , CURRENT_PWM_LIMITED 
02A3    6002          1475+1   JZ ( $+4 ) 
02A5    C295          1475+1   CLR P1 . 5 
                      1476     	APFET_OFF
02A7    207502        1476+1   JB FLAGS3 . 5 , ( $+5 ) 
02AA    C296          1476+1   CLR P1 . 6 
02AC    307502        1476+1   JNB FLAGS3 . 5 , ( $+5 ) 
02AF    C292          1476+1   CLR P1 . 2 
                      1477     	CNFET_OFF								
02B1    207502        1477+1   JB FLAGS3 . 5 , ( $+5 ) 
02B4    D293          1477+1   SETB P1 . 3 
02B6    307502        1477+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B9    D297          1477+1   SETB P1 . 7 
02BB    61D3          1478     	AJMP	T0_INT_PWM_ON_EXIT
                      1479     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1480     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1481     	BPFET_OFF
02BD    C294          1481+1   CLR P1 . 4 
                      1482     	APFET_OFF
02BF    207502        1482+1   JB FLAGS3 . 5 , ( $+5 ) 
02C2    C296          1482+1   CLR P1 . 6 
02C4    307502        1482+1   JNB FLAGS3 . 5 , ( $+5 ) 
02C7    C292          1482+1   CLR P1 . 2 
02C9    7406          1483     MOV A , # 6 
02CB    D5E0FD        1484     	DJNZ ACC,	$
                      1485     	BNFET_ON								; Switch nFETs
02CE    E525          1485+1   MOV A , CURRENT_PWM_LIMITED 
02D0    6002          1485+1   JZ ( $+4 ) 
02D2    C295          1485+1   CLR P1 . 5 
                      1486     	CNFET_OFF								
02D4    207502        1486+1   JB FLAGS3 . 5 , ( $+5 ) 
02D7    D293          1486+1   SETB P1 . 3 
02D9    307502        1486+1   JNB FLAGS3 . 5 , ( $+5 ) 
02DC    D297          1486+1   SETB P1 . 7 
02DE    61D3          1487     	AJMP	T0_INT_PWM_ON_EXIT
                      1488     
                      1489     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1490     	BPFET_OFF
02E0    C294          1490+1   CLR P1 . 4 
                      1491     	BNFET_ON								; Switch nFETs
02E2    E525          1491+1   MOV A , CURRENT_PWM_LIMITED 
02E4    6002          1491+1   JZ ( $+4 ) 
02E6    C295          1491+1   CLR P1 . 5 
                      1492     	CPFET_OFF
02E8    207502        1492+1   JB FLAGS3 . 5 , ( $+5 ) 
02EB    C292          1492+1   CLR P1 . 2 
02ED    307502        1492+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F0    C296          1492+1   CLR P1 . 6 
                      1493     	CNFET_OFF								
02F2    207502        1493+1   JB FLAGS3 . 5 , ( $+5 ) 
02F5    D293          1493+1   SETB P1 . 3 
02F7    307502        1493+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FA    D297          1493+1   SETB P1 . 7 
02FC    61D3          1494     	AJMP	T0_INT_PWM_ON_EXIT
                      1495     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1496     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1497     	BPFET_OFF
02FE    C294          1497+1   CLR P1 . 4 
                      1498     	CPFET_OFF
0300    207502        1498+1   JB FLAGS3 . 5 , ( $+5 ) 
0303    C292          1498+1   CLR P1 . 2 
0305    307502        1498+1   JNB FLAGS3 . 5 , ( $+5 ) 
0308    C296          1498+1   CLR P1 . 6 
030A    7406          1499     MOV A , # 6 
030C    D5E0FD        1500     	DJNZ ACC,	$
                      1501     	BNFET_ON								; Switch nFETs
030F    E525          1501+1   MOV A , CURRENT_PWM_LIMITED 
0311    6002          1501+1   JZ ( $+4 ) 
0313    C295          1501+1   CLR P1 . 5 
                      1502     	CNFET_OFF								
0315    207502        1502+1   JB FLAGS3 . 5 , ( $+5 ) 
0318    D293          1502+1   SETB P1 . 3 
031A    307502        1502+1   JNB FLAGS3 . 5 , ( $+5 ) 
031D    D297          1502+1   SETB P1 . 7 
031F    61D3          1503     	AJMP	T0_INT_PWM_ON_EXIT
                      1504     
                      1505     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1506     	CPFET_OFF
0321    207502        1506+1   JB FLAGS3 . 5 , ( $+5 ) 
0324    C292          1506+1   CLR P1 . 2 
0326    307502        1506+1   JNB FLAGS3 . 5 , ( $+5 ) 
0329    C296          1506+1   CLR P1 . 6 
                      1507     	CNFET_ON								; Switch nFETs
032B    E525          1507+1   MOV A , CURRENT_PWM_LIMITED 
032D    600A          1507+1   JZ ( $+12 ) 
032F    207502        1507+1   JB FLAGS3 . 5 , ( $+5 ) 
0332    C293          1507+1   CLR P1 . 3 
0334    307502        1507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0337    C297          1507+1   CLR P1 . 7 
                      1508     	BPFET_OFF
0339    C294          1508+1   CLR P1 . 4 
                      1509     	ANFET_OFF								
033B    207502        1509+1   JB FLAGS3 . 5 , ( $+5 ) 
033E    D297          1509+1   SETB P1 . 7 
0340    307502        1509+1   JNB FLAGS3 . 5 , ( $+5 ) 
0343    D293          1509+1   SETB P1 . 3 
0345    61D3          1510     	AJMP	T0_INT_PWM_ON_EXIT
                      1511     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1512     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1513     	CPFET_OFF
0347    207502        1513+1   JB FLAGS3 . 5 , ( $+5 ) 
034A    C292          1513+1   CLR P1 . 2 
034C    307502        1513+1   JNB FLAGS3 . 5 , ( $+5 ) 
034F    C296          1513+1   CLR P1 . 6 
                      1514     	BPFET_OFF
0351    C294          1514+1   CLR P1 . 4 
0353    7406          1515     MOV A , # 6 
0355    D5E0FD        1516     	DJNZ ACC,	$
                      1517     	CNFET_ON								; Switch nFETs
0358    E525          1517+1   MOV A , CURRENT_PWM_LIMITED 
035A    600A          1517+1   JZ ( $+12 ) 
035C    207502        1517+1   JB FLAGS3 . 5 , ( $+5 ) 
035F    C293          1517+1   CLR P1 . 3 
0361    307502        1517+1   JNB FLAGS3 . 5 , ( $+5 ) 
0364    C297          1517+1   CLR P1 . 7 
                      1518     	ANFET_OFF								
0366    207502        1518+1   JB FLAGS3 . 5 , ( $+5 ) 
0369    D297          1518+1   SETB P1 . 7 
036B    307502        1518+1   JNB FLAGS3 . 5 , ( $+5 ) 
036E    D293          1518+1   SETB P1 . 3 
0370    61D3          1519     	AJMP	T0_INT_PWM_ON_EXIT
                      1520     
                      1521     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1522     	CPFET_OFF
0372    207502        1522+1   JB FLAGS3 . 5 , ( $+5 ) 
0375    C292          1522+1   CLR P1 . 2 
0377    307502        1522+1   JNB FLAGS3 . 5 , ( $+5 ) 
037A    C296          1522+1   CLR P1 . 6 
                      1523     	CNFET_ON								; Switch nFETs
037C    E525          1523+1   MOV A , CURRENT_PWM_LIMITED 
037E    600A          1523+1   JZ ( $+12 ) 
0380    207502        1523+1   JB FLAGS3 . 5 , ( $+5 ) 
0383    C293          1523+1   CLR P1 . 3 
0385    307502        1523+1   JNB FLAGS3 . 5 , ( $+5 ) 
0388    C297          1523+1   CLR P1 . 7 
                      1524     	APFET_OFF
038A    207502        1524+1   JB FLAGS3 . 5 , ( $+5 ) 
038D    C296          1524+1   CLR P1 . 6 
038F    307502        1524+1   JNB FLAGS3 . 5 , ( $+5 ) 
0392    C292          1524+1   CLR P1 . 2 
                      1525     	ANFET_OFF								
0394    207502        1525+1   JB FLAGS3 . 5 , ( $+5 ) 
0397    D297          1525+1   SETB P1 . 7 
0399    307502        1525+1   JNB FLAGS3 . 5 , ( $+5 ) 
039C    D293          1525+1   SETB P1 . 3 
039E    61D3          1526     	AJMP	T0_INT_PWM_ON_EXIT
                      1527     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1528     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1529     	CPFET_OFF
03A0    207502        1529+1   JB FLAGS3 . 5 , ( $+5 ) 
03A3    C292          1529+1   CLR P1 . 2 
03A5    307502        1529+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A8    C296          1529+1   CLR P1 . 6 
                      1530     	APFET_OFF
03AA    207502        1530+1   JB FLAGS3 . 5 , ( $+5 ) 
03AD    C296          1530+1   CLR P1 . 6 
03AF    307502        1530+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B2    C292          1530+1   CLR P1 . 2 
03B4    7406          1531     MOV A , # 6 
03B6    D5E0FD        1532     	DJNZ ACC,	$
                      1533     	CNFET_ON								; Switch nFETs
03B9    E525          1533+1   MOV A , CURRENT_PWM_LIMITED 
03BB    600A          1533+1   JZ ( $+12 ) 
03BD    207502        1533+1   JB FLAGS3 . 5 , ( $+5 ) 
03C0    C293          1533+1   CLR P1 . 3 
03C2    307502        1533+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C5    C297          1533+1   CLR P1 . 7 
                      1534     	ANFET_OFF								
03C7    207502        1534+1   JB FLAGS3 . 5 , ( $+5 ) 
03CA    D297          1534+1   SETB P1 . 7 
03CC    307502        1534+1   JNB FLAGS3 . 5 , ( $+5 ) 
03CF    D293          1534+1   SETB P1 . 3 
03D1    61D3          1535     	AJMP	T0_INT_PWM_ON_EXIT
                      1536     
                      1537     T0_INT_PWM_ON_EXIT: 
                      1538     	; Set timer for coming on cycle length
03D3    E525          1539     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D5    F4            1540     	CPL	A						; cpl is 255-x
03D6    F58A          1541     	MOV	TL0, A					; Write start point for timer
                      1542     	; Set other variables
03D8    758B00        1543     	MOV	TL1, #0					; Reset timer1	
03DB    756200        1544     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03DE    D25A          1545     SETB FLAGS0 . 2 
                      1546     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1547     	; Exit interrupt
03E0    D0E0          1548     	POP	ACC			; Restore preserved registers
03E2    D0D0          1549     	POP	PSW
03E4    D2AF          1550     	SETB	EA			; Enable all interrupts
03E6    32            1551     	RETI
                      1552     
                      1553     
                      1554     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1555     ;
                      1556     ; Timer2 interrupt routine
                      1557     ;
                      1558     ; No assumptions
                      1559     ;
                      1560     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1561     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03E7    C2AF          1562     	CLR	EA
03E9    C2AD          1563     	CLR	ET2			; Disable timer2 interrupts
03EB    53E6EF        1564     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
03EE    C0D0          1565     	PUSH	PSW			; Preserve registers through interrupt
03F0    C0E0          1566     	PUSH	ACC
03F2    D2D3          1567     	SETB	PSW.3		; Select register bank 1 for interrupt routines
03F4    D2AF          1568     	SETB	EA
                      1569     	; Clear low byte interrupt flag
03F6    C2CE          1570     	CLR	TF2L						; Clear interrupt flag
                      1571     	; Check RC pulse timeout counter
03F8    E528          1572     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03FA    600A          1573     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1574     
                      1575     	; Decrement timeout counter (if PWM)
03FC    741F          1576     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FE    552E          1577     	ANL	A, FLAGS3					; Check pwm frequency flags
0400    6049          1578     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1579     
0402    1528          1580     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0404    814B          1581     	AJMP	T2_INT_SKIP_START
                      1582     
                      1583     T2_INT_PULSES_ABSENT: 
                      1584     	; Timeout counter has reached zero, pulses are absent
0406    7800          1585     MOV R0 , # 0 
0408    7900          1586     MOV R1 , # 0 
                      1587     	READ_RCP_INT 					; Look at value of Rcp_In
040A    E580          1587+1   MOV A , P0 
040C    307601        1587+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040F    F4            1587+1   CPL A  ; YES - INVERT
0410    30E502        1588     JNB ACC . 5 , ( $+5 ) 
0413    78FF          1589     MOV R0 , # 255 
                      1590     	RCP_INT_FIRST 					; Set interrupt trig to first again
0415    53DACF        1590+1   ANL PCA0CPM0 , # 0CFH 
0418    207603        1590+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
041B    43DA20        1590+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041E    307603        1590+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0421    43DA10        1590+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1591     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0424    C2D8          1591+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0426    C269          1592     CLR FLAGS2 . 1 
                      1593     	READ_RCP_INT 					; Look once more at value of Rcp_In
0428    E580          1593+1   MOV A , P0 
042A    307601        1593+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042D    F4            1593+1   CPL A  ; YES - INVERT
042E    30E502        1594     JNB ACC . 5 , ( $+5 ) 
0431    79FF          1595     MOV R1 , # 255 
0433    C3            1596     	CLR	C
0434    E8            1597     MOV A , R0 
0435    99            1598     SUBB A , R1 
0436    70CE          1599     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1600     
0438    305903        1601     JNB FLAGS0 . 1 , ( $+6 ) 
                      1602     
043B    752818        1603     MOV RCP_TIMEOUT_CNT , # 24 
                      1604     
043E    741F          1605     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0440    552E          1606     	ANL	A, FLAGS3					; Check pwm frequency flags
0442    6003          1607     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1608     
0444    752818        1609     MOV RCP_TIMEOUT_CNT , # 24 
                      1610     
                      1611     
                      1612     T2_INT_PPM_TIMEOUT_SET: 
                      1613     
                      1614     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      1615     ; 
                      1616     ; 对 RCP 信号处理
                      1617     ; 1 小于 1500us 最低油门
                      1618     ; 2 大于 1500us 正常处理
                      1619     ; 
                      1620     ;	clr C
                      1621     ;	mov A, Temp1
                      1622     ;	subb A, #80h
                      1623     ;	jnc skypup_01
                      1624     ;	mov	Temp1, #RCP_MIN
                      1625     ; skypup_01:
                      1626     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0447    8859          1627     MOV NEW_RCP , R0 
0449    D268          1628     SETB FLAGS2 . 0 
                      1629     
                      1630     T2_INT_SKIP_START: 
                      1631     	; Check RC pulse skip counter
044B    E529          1632     	MOV	A, RCP_SKIP_CNT			
044D    6004          1633     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1634     	
                      1635     	; Decrement skip counter (only if edge counter is zero)
044F    1529          1636     	DEC	RCP_SKIP_CNT				; Decrement
0451    815E          1637     	AJMP	T2_INT_RCP_UPDATE_START
                      1638     
                      1639     T2_INT_SKIP_END: 
0453    741F          1640     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0455    552E          1641     	ANL	A, FLAGS3					; Check pwm frequency flags
0457    6005          1642     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1643     
                      1644     	; Skip counter has reached zero, start looking for RC pulses again
                      1645     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0459    43DA01        1645+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1646     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
045C    C2D8          1646+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1647     	
                      1648     T2_INT_RCP_UPDATE_START: 
                      1649     	; Process updated RC pulse
045E    206802        1650     JB FLAGS2 . 0 , ( $+5 ) 
0461    81E7          1651     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1652     
0463    E559          1653     	MOV	A, NEW_RCP				; Load new pulse value
0465    F8            1654     MOV R0 , A 
0466    C268          1655     CLR FLAGS2 . 0 
                      1656     	; Use a gain of 1.0625x for pwm input if not governor mode
0468    741F          1657     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
046A    552E          1658     	ANL	A, FLAGS3					; Check pwm frequency flags
046C    6036          1659     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1660     
                      1661     IF MODE == 0	; Main - do not adjust gain
                               	AJMP	T2_INT_PWM_MIN_RUN
                               ENDIF
                      1664     
                      1665     IF MODE == 2	; Multi
046E    7982          1666     MOV R1 , # PGM_GOV_MODE 
0470    B70431        1667     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1668     ENDIF
                      1669     
                      1670     	; Limit the maximum value to avoid wrap when scaled to pwm range
0473    C3            1671     	CLR	C
0474    E8            1672     MOV A , R0 
0475    94F0          1673     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0477    4003          1674     	JC	T2_INT_RCP_UPDATE_MULT
                      1675     
0479    74F0          1676     	MOV	A, #240			; Set requested pwm to max
047B    F8            1677     MOV R0 , A 
                      1678     
                      1679     T2_INT_RCP_UPDATE_MULT: 	
                      1680     	; Multiply by 1.0625 (optional adjustment gyro gain)
047C    E8            1681     MOV A , R0 
047D    C4            1682     	SWAP	A			; After this "0.0625"
047E    540F          1683     	ANL	A, #0FH
0480    28            1684     ADD A , R0 
0481    F8            1685     MOV R0 , A 
                      1686     	; Adjust tail gain
0482    7984          1687     MOV R1 , # PGM_MOTOR_GAIN 
0484    B70302        1688     CJNE @ R1 , # 3 , ( $+5 ) 
0487    81A4          1689     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1690     
0489    C3            1691     	CLR	C
048A    13            1692     	RRC	A			; After this "0.5"
048B    C3            1693     	CLR	C
048C    13            1694     	RRC	A			; After this "0.25"
048D    8721          1695     MOV BIT_ACCESS_INT , @ R1 
048F    200802        1696     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1697     
0492    C3            1698     	CLR	C
0493    13            1699     	RRC	A			; After this "0.125"
                      1700     
                      1701     T2_INT_RCP_GAIN_CORR: 
0494    200A06        1702     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1703     
0497    C3            1704     	CLR	C
0498    C8            1705     XCH A , R0 
0499    98            1706     SUBB A , R0 
049A    F8            1707     MOV R0 , A 
049B    81A4          1708     	AJMP	T2_INT_PWM_MIN_RUN
                      1709     
                      1710     T2_INT_RCP_GAIN_POS: 
049D    28            1711     ADD A , R0 
049E    F8            1712     MOV R0 , A 
049F    5003          1713     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1714     
04A1    74FF          1715     	MOV	A, #0FFH					; Yes - limit
04A3    F8            1716     MOV R0 , A 
                      1717     
                      1718     T2_INT_PWM_MIN_RUN:  
                      1719     IF MODE == 1	; Tail - limit minimum pwm
                               	; Limit minimum pwm
                               	CLR	C
                               	MOV	A, TEMP1
                               	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
                               	JNC	T2_INT_PWM_UPDATE			; No - branch
                               
                               	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
                               	MOV	TEMP1, A
                               ENDIF
                      1729     
                      1730     T2_INT_PWM_UPDATE:  
                      1731     	; Check if any startup phase flags are set
04A4    E52C          1732     	MOV	A, FLAGS1
04A6    5406          1733     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04A8    703D          1734     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      1735     
                      1736     	; Update requested_pwm
04AA    8822          1737     MOV REQUESTED_PWM , R0 
                      1738     	; Limit pwm during direct start
04AC    30630A        1739     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      1740     
04AF    C3            1741     	CLR	C
04B0    E522          1742     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B2    955E          1743     	SUBB	A, PWM_LIMIT
04B4    4003          1744     	JC	T2_INT_CURRENT_PWM_UPDATE
                      1745     
04B6    855E22        1746     	MOV	REQUESTED_PWM, PWM_LIMIT
                      1747     
                      1748     T2_INT_CURRENT_PWM_UPDATE:  
                      1749     IF MODE == 0 OR MODE == 2	; Main or multi
04B9    7882          1750     MOV R0 , # PGM_GOV_MODE 
04BB    B60429        1751     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      1752     ENDIF
                      1753     
                      1754     	; Update current pwm, with limited throttle change rate
04BE    C3            1755     	CLR	C
04BF    E522          1756     	MOV	A, REQUESTED_PWM	 
04C1    9524          1757     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C3    4012          1758     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1759     
                      1760     	; 缓启动
04C5    78A1          1761     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
                      1762     	;mov	Temp1, #1
04C7    96            1763     SUBB A , @ R0 
                      1764     	;subb	A, Temp1				; Is difference larger than throttle change rate?
04C8    400D          1765     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      1766     
04CA    E524          1767     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04CC    26            1768     ADD A , @ R0 
                      1769     	; add	A, Temp1
04CD    F524          1770     	MOV	CURRENT_PWM, A
04CF    5009          1771     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      1772     
04D1    7524FF        1773     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04D4    0204DA        1774     	JMP	T2_INT_CURRENT_PWM_DONE
                      1775     
                      1776     T2_INT_SET_CURRENT_PWM: 
04D7    852224        1777     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      1778     T2_INT_CURRENT_PWM_DONE: 
                      1779     IF MODE >= 1	; Tail or multi
                      1780     	; Set current_pwm_limited
04DA    A824          1781     MOV R0 , CURRENT_PWM 
04DC    C3            1782     	CLR	C
04DD    E524          1783     	MOV	A, CURRENT_PWM				; Check against limit
04DF    955E          1784     	SUBB	A, PWM_LIMIT
04E1    4002          1785     	JC	($+4)					; If current pwm below limit - branch
                      1786     
04E3    A85E          1787     MOV R0 , PWM_LIMIT 
                      1788     
04E5    8825          1789     MOV CURRENT_PWM_LIMITED , R0 
                      1790     ENDIF
                      1791     T2_INT_PWM_EXIT: 	
                      1792     	; Check if high byte flag is set
04E7    20CF0C        1793     	JB	TF2H, T2H_INT		
04EA    D0E0          1794     	POP	ACC			; Restore preserved registers
04EC    D0D0          1795     	POP	PSW
04EE    C2D3          1796     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F0    43E610        1797     	ORL	EIE1, #10H	; Enable PCA0 interrupts
04F3    D2AD          1798     	SETB	ET2			; Enable timer2 interrupts
04F5    32            1799     	RETI
                      1800     
                      1801     T2H_INT: 
                      1802     	; High byte interrupt (happens every 32ms)
04F6    C2CF          1803     	CLR	TF2H					; Clear interrupt flag
04F8    7801          1804     MOV R0 , # 1 
                      1805     	; Check RC pulse timeout counter (used here for PPM only)
04FA    E528          1806     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FC    6008          1807     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      1808     
                      1809     	; Decrement timeout counter (if PPM)
04FE    741F          1810     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0500    552E          1811     	ANL	A, FLAGS3					; Check pwm frequency flags
0502    7002          1812     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      1813     
0504    1528          1814     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      1815     
                      1816     T2H_INT_RCP_STOP_CHECK: 
                      1817     	; Check RC pulse against stop value
0506    C3            1818     	CLR	C
0507    E559          1819     	MOV	A, NEW_RCP				; Load new pulse value
0509    9401          1820     SUBB A , # 1 
050B    4005          1821     	JC	T2H_INT_RCP_STOP
                      1822     
                      1823     	; RC pulse higher than stop value, reset stop counter
050D    755C00        1824     	MOV	RCP_STOP_CNT, #0			; Reset rcp stop counter
0510    A123          1825     	AJMP	T2H_INT_RCP_GOV_PWM
                      1826     
                      1827     T2H_INT_RCP_STOP: 	
                      1828     	; RC pulse less than stop value
0512    755D00        1829     	MOV	AUTO_BAILOUT_ARMED, #0		; Disarm bailout		
0515    756400        1830     	MOV	SPOOLUP_LIMIT_CNT, #0
0518    E55C          1831     	MOV	A, RCP_STOP_CNT			; Increment stop counter
051A    2401          1832     	ADD	A, #1
051C    F55C          1833     	MOV	RCP_STOP_CNT, A
051E    5003          1834     	JNC	T2H_INT_RCP_GOV_PWM			; Branch if counter has not wrapped
                      1835     
0520    755CFF        1836     	MOV	RCP_STOP_CNT, #0FFH			; Set stop counter to max
                      1837     
                      1838     T2H_INT_RCP_GOV_PWM: 
                      1839     IF MODE == 0	; Main
                               	; Update governor variables
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #5						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP2, #4, ($+5)
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM			; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, then this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_BAILOUT_ARM
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               T2H_INT_RCP_BAILOUT_ARM:
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	INC	A
                               	JNZ	T2H_INT_RCP_EXIT
                               
                               	MOV	AUTO_BAILOUT_ARMED, #255			; Arm bailout
                               	MOV	SPOOLUP_LIMIT_CNT, #255			
                               
                               ENDIF
                      1968     IF MODE == 2	; Multi
0523    E55F          1969     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
0525    240A          1970     	ADD	A, #10
0527    5005          1971     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      1972     
0529    755FFF        1973     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
052C    A130          1974     	AJMP	T2H_INT_RCP_EXIT
                      1975     
                      1976     T2H_INT_RCP_NO_LIMIT: 
052E    F55F          1977     	MOV	PWM_LIMIT_SPOOLUP, A
                      1978     ENDIF
                      1979     
                      1980     T2H_INT_RCP_EXIT: 
0530    D0E0          1981     	POP	ACC			; Restore preserved registers
0532    D0D0          1982     	POP	PSW
0534    C2D3          1983     	CLR	PSW.3		; Select register bank 0 for main program routines	
0536    43E610        1984     	ORL	EIE1, #10H	; Enable PCA0 interrupts
0539    D2AD          1985     	SETB	ET2			; Enable timer2 interrupts
053B    32            1986     	RETI
                      1987     
                      1988     
                      1989     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1990     ;
                      1991     ; Timer3 interrupt routine
                      1992     ;
                      1993     ; No assumptions
                      1994     ;
                      1995     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1996     T3_INT: 	; Used for commutation timing
053C    C2AF          1997     	CLR 	EA			; Disable all interrupts
053E    53917F        1998     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0541    C258          1999     CLR FLAGS0 . 0 
0543    D2AF          2000     	SETB	EA			; Enable all interrupts
0545    32            2001     	RETI
                      2002     
                      2003     
                      2004     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2005     ;
                      2006     ; PCA interrupt routine
                      2007     ;
                      2008     ; No assumptions
                      2009     ;
                      2010     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2011     PCA_INT: 	; Used for RC pulse timing
0546    C2AF          2012     	CLR	EA
0548    53E6EF        2013     	ANL	EIE1, #0EFH	; Disable PCA0 interrupts
054B    C2AD          2014     	CLR	ET2			; Disable timer2 interrupts
054D    C0D0          2015     	PUSH	PSW			; Preserve registers through interrupt
054F    C0E0          2016     	PUSH	ACC
0551    C0F0          2017     	PUSH	B
0553    D2D3          2018     	SETB	PSW.3		; Select register bank 1 for interrupt routines
0555    D2AF          2019     	SETB	EA
                      2020     	; Get the PCA counter values
                      2021     	GET_RCP_CAPTURE_VALUES
0557    A8FB          2021+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0559    A9FC          2021+1   MOV R1 , PCA0CPH0 
                      2022     	; Clear interrupt flag
                      2023     	RCP_CLEAR_INT_FLAG 				
055B    C2D8          2023+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2024     	; Check which edge it is
055D    306902        2025     JNB FLAGS2 . 1 , ( $+5 ) 
0560    A1B3          2026     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2027     
                      2028     	RCP_INT_SECOND					; Yes - set second edge trig
0562    53DACF        2028+1   ANL PCA0CPM0 , # 0CFH 
0565    207603        2028+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0568    43DA10        2028+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
056B    307603        2028+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
056E    43DA20        2028+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0571    D269          2029     SETB FLAGS2 . 1 
                      2030     	; Read RC signal level
                      2031     	READ_RCP_INT			
0573    E580          2031+1   MOV A , P0 
0575    307601        2031+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0578    F4            2031+1   CPL A  ; YES - INVERT
                      2032     	; Test RC signal level
0579    20E502        2033     JB ACC . 5 , ( $+5 ) 
057C    A185          2034     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2035     
                      2036     	; RC pulse was high, store RC pulse start timestamp
057E    8826          2037     MOV RCP_PREV_EDGE_L , R0 
0580    8927          2038     MOV RCP_PREV_EDGE_H , R1 
0582    020846        2039     	LJMP	PCA_INT_EXIT				; Exit
                      2040     
                      2041     PCA_INT_FAIL_MINIMUM: 
                      2042     	; Prepare for next interrupt
                      2043     	RCP_INT_FIRST					; Set interrupt trig to first again
0585    53DACF        2043+1   ANL PCA0CPM0 , # 0CFH 
0588    207603        2043+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
058B    43DA20        2043+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
058E    307603        2043+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0591    43DA10        2043+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2044     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0594    C2D8          2044+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0596    C269          2045     CLR FLAGS2 . 1 
0598    741F          2046     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
059A    552E          2047     	ANL	A, FLAGS3					; Check pwm frequency flags
                      2048     	; jnz	($+4)					; If a flag is set (PWM) - proceed
059C    7003          2049     	JNZ	LINE_TEMP01					; If a flag is set (PWM) - proceed, Skypup 2015.05.26
                      2050     
                      2051     	; ajmp	pca_int_set_timeout			; If PPM - ignore trig as noise
059E    02082C        2052     	LJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise, Skypup 2015.05.26
                      2053     LINE_TEMP01: 
                      2054     
05A1    7800          2055     MOV R0 , # 0 
                      2056     	READ_RCP_INT 					; Test RC signal level again
05A3    E580          2056+1   MOV A , P0 
05A5    307601        2056+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
05A8    F4            2056+1   CPL A  ; YES - INVERT
                      2057     	; jnb	ACC.Rcp_In, ($+5)			; Is it high?
05A9    30E503        2058     JNB ACC . 5 , LINE_TEMP02 
                      2059     	; ajmp	pca_int_set_timeout			; Yes - set new timeout and exit
05AC    02082C        2060     	LJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit, Skypup 2015.05.26
                      2061     LINE_TEMP02: 
                      2062     
                      2063     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2064     ; 
                      2065     ; 对 RCP 信号处理
                      2066     ; 1 小于 1500us 最低油门
                      2067     ; 2 大于 1500us 正常处理
                      2068     ; 
                      2069     ;	clr C
                      2070     ;	mov A, Temp1
                      2071     ;	subb A, #80h
                      2072     ;	jnc skypup_02
                      2073     ;	mov	Temp1, #RCP_MIN
                      2074     ; skypup_02:
                      2075     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2076     
05AF    8859          2077     MOV NEW_RCP , R0 
05B1    E188          2078     	AJMP	PCA_INT_LIMITED			; Set new RC pulse, new timeout and exit
                      2079     
                      2080     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2081     	; Prepare for next interrupt
                      2082     	RCP_INT_FIRST 					; Set first edge trig
05B3    53DACF        2082+1   ANL PCA0CPM0 , # 0CFH 
05B6    207603        2082+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05B9    43DA20        2082+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05BC    307603        2082+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05BF    43DA10        2082+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05C2    C269          2083     CLR FLAGS2 . 1 
                      2084     	; Check if pwm frequency shall be measured
05C4    205902        2085     JB FLAGS0 . 1 , ( $+5 ) 
05C7    C16D          2086     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2087     
                      2088     	; Set second edge trig only during pwm frequency measurement
                      2089     	RCP_INT_SECOND 				; Set second edge trig
05C9    53DACF        2089+1   ANL PCA0CPM0 , # 0CFH 
05CC    207603        2089+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05CF    43DA10        2089+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05D2    307603        2089+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05D5    43DA20        2089+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2090     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05D8    C2D8          2090+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05DA    D269          2091     SETB FLAGS2 . 1 
                      2092     	; Store edge data to RAM
05DC    8854          2093     MOV RCP_EDGE_L , R0 
05DE    8955          2094     MOV RCP_EDGE_H , R1 
                      2095     	; Calculate pwm frequency
05E0    C3            2096     	CLR	C
05E1    E8            2097     MOV A , R0 
05E2    9552          2098     	SUBB	A, RCP_PREPREV_EDGE_L	
05E4    F8            2099     MOV R0 , A 
05E5    E9            2100     MOV A , R1 
05E6    9553          2101     	SUBB	A, RCP_PREPREV_EDGE_H
05E8    F9            2102     MOV R1 , A 
05E9    E4            2103     	CLR	A
05EA    FB            2104     MOV R3 , A 
05EB    7AFA          2105     MOV R2 , # 250 
                      2106     	; Check if pwm frequency is 12kHz
05ED    C3            2107     	CLR	C
05EE    E8            2108     MOV A , R0 
05EF    94C8          2109     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05F1    E9            2110     MOV A , R1 
05F2    9400          2111     	SUBB	A, #HIGH(200)
05F4    5008          2112     	JNC	PCA_INT_CHECK_8KHZ
                      2113     
05F6    E4            2114     	CLR	A
05F7    D2E4          2115     SETB ACC . 4 
05F9    FB            2116     MOV R3 , A 
05FA    7A0A          2117     MOV R2 , # 10 
05FC    C140          2118     	AJMP	PCA_INT_RESTORE_EDGE
                      2119     
                      2120     PCA_INT_CHECK_8KHZ: 
                      2121     	; Check if pwm frequency is 8kHz
05FE    C3            2122     	CLR	C
05FF    E8            2123     MOV A , R0 
0600    9468          2124     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
0602    E9            2125     MOV A , R1 
0603    9401          2126     	SUBB	A, #HIGH(360)
0605    5008          2127     	JNC	PCA_INT_CHECK_4KHZ
                      2128     
0607    E4            2129     	CLR	A
0608    D2E3          2130     SETB ACC . 3 
060A    FB            2131     MOV R3 , A 
060B    7A0F          2132     MOV R2 , # 15 
060D    C140          2133     	AJMP	PCA_INT_RESTORE_EDGE
                      2134     
                      2135     PCA_INT_CHECK_4KHZ: 
                      2136     	; Check if pwm frequency is 4kHz
060F    C3            2137     	CLR	C
0610    E8            2138     MOV A , R0 
0611    94D0          2139     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0613    E9            2140     MOV A , R1 
0614    9402          2141     	SUBB	A, #HIGH(720)
0616    5008          2142     	JNC	PCA_INT_CHECK_2KHZ
                      2143     
0618    E4            2144     	CLR	A
0619    D2E2          2145     SETB ACC . 2 
061B    FB            2146     MOV R3 , A 
061C    7A1E          2147     MOV R2 , # 30 
061E    C140          2148     	AJMP	PCA_INT_RESTORE_EDGE
                      2149     
                      2150     PCA_INT_CHECK_2KHZ: 
                      2151     	; Check if pwm frequency is 2kHz
0620    C3            2152     	CLR	C
0621    E8            2153     MOV A , R0 
0622    94A0          2154     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0624    E9            2155     MOV A , R1 
0625    9405          2156     	SUBB	A, #HIGH(1440)
0627    5008          2157     	JNC	PCA_INT_CHECK_1KHZ
                      2158     
0629    E4            2159     	CLR	A
062A    D2E1          2160     SETB ACC . 1 
062C    FB            2161     MOV R3 , A 
062D    7A3C          2162     MOV R2 , # 60 
062F    C140          2163     	AJMP	PCA_INT_RESTORE_EDGE
                      2164     
                      2165     PCA_INT_CHECK_1KHZ: 
                      2166     	; Check if pwm frequency is 1kHz
0631    C3            2167     	CLR	C
0632    E8            2168     MOV A , R0 
0633    9498          2169     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0635    E9            2170     MOV A , R1 
0636    9408          2171     	SUBB	A, #HIGH(2200)
0638    5006          2172     	JNC	PCA_INT_RESTORE_EDGE
                      2173     
063A    E4            2174     	CLR	A
063B    D2E0          2175     SETB ACC . 0 
063D    FB            2176     MOV R3 , A 
063E    7A78          2177     MOV R2 , # 120 
                      2178     
                      2179     PCA_INT_RESTORE_EDGE: 
                      2180     	; Calculate difference between this period and previous period
0640    C3            2181     	CLR	C
0641    E8            2182     MOV A , R0 
0642    9556          2183     	SUBB	A, RCP_PREV_PERIOD_L
0644    FC            2184     MOV R4 , A 
0645    E9            2185     MOV A , R1 
0646    9557          2186     	SUBB	A, RCP_PREV_PERIOD_H
0648    FD            2187     MOV R5 , A 
                      2188     	; Make positive
0649    30E708        2189     	JNB	ACC.7, PCA_INT_CHECK_DIFF
064C    EC            2190     MOV A , R4 
064D    F4            2191     	CPL	A
064E    2401          2192     	ADD	A, #1
0650    FC            2193     MOV R4 , A 
0651    ED            2194     MOV A , R5 
0652    F4            2195     	CPL	A
0653    FD            2196     MOV R5 , A 
                      2197     
                      2198     PCA_INT_CHECK_DIFF: 
                      2199     	; Check difference
0654    755800        2200     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0657    7008          2201     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2202     
0659    C3            2203     	CLR	C
065A    EC            2204     MOV A , R4 
065B    9A            2205     SUBB A , R2 
065C    5003          2206     	JNC	PCA_INT_STORE_DATA
                      2207     
065E    755801        2208     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2209     
                      2210     PCA_INT_STORE_DATA: 
                      2211     	; Store previous period
0661    8856          2212     MOV RCP_PREV_PERIOD_L , R0 
0663    8957          2213     MOV RCP_PREV_PERIOD_H , R1 
                      2214     	; Restore edge data from RAM
0665    A854          2215     MOV R0 , RCP_EDGE_L 
0667    A955          2216     MOV R1 , RCP_EDGE_H 
                      2217     	; Store pre previous edge
0669    8852          2218     MOV RCP_PREPREV_EDGE_L , R0 
066B    8953          2219     MOV RCP_PREPREV_EDGE_H , R1 
                      2220     
                      2221     PCA_INT_FALL: 
                      2222     	; RC pulse edge was second, calculate new pulse length
066D    C3            2223     	CLR	C
066E    E8            2224     MOV A , R0 
066F    9526          2225     	SUBB	A, RCP_PREV_EDGE_L	
0671    F8            2226     MOV R0 , A 
0672    E9            2227     MOV A , R1 
0673    9527          2228     	SUBB	A, RCP_PREV_EDGE_H
0675    F9            2229     MOV R1 , A 
0676    307402        2230     JNB FLAGS3 . 4 , ( $+5 ) 
0679    E16C          2231     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
067B    307302        2232     JNB FLAGS3 . 3 , ( $+5 ) 
067E    E16C          2233     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2234     
0680    307202        2235     JNB FLAGS3 . 2 , ( $+5 ) 
0683    E165          2236     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2237     
0685    E9            2238     MOV A , R1 
0686    C3            2239     	CLR	C
0687    13            2240     	RRC	A
0688    F9            2241     MOV R1 , A 
0689    E8            2242     MOV A , R0 
068A    13            2243     	RRC	A
068B    F8            2244     MOV R0 , A 
                      2245     
068C    307102        2246     JNB FLAGS3 . 1 , ( $+5 ) 
068F    E165          2247     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2248     
0691    E9            2249     MOV A , R1 
0692    C3            2250     	CLR	C
0693    13            2251     	RRC	A
0694    F9            2252     MOV R1 , A 
0695    E8            2253     MOV A , R0 
0696    13            2254     	RRC	A
0697    F8            2255     MOV R0 , A 
                      2256     
0698    307002        2257     JNB FLAGS3 . 0 , ( $+5 ) 
069B    E165          2258     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2259     
069D    E9            2260     MOV A , R1 
069E    C3            2261     	CLR	C
069F    13            2262     	RRC	A
06A0    FD            2263     MOV R5 , A 
06A1    E8            2264     MOV A , R0 
06A2    13            2265     	RRC	A
06A3    FC            2266     MOV R4 , A 
                      2267     	; Skip range limitation if pwm frequency measurement
06A4    205918        2268     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      2269     
                      2270     	; Check if 2160us or above (in order to ignore false pulses)
06A7    C3            2271     	CLR	C
06A8    EC            2272     MOV A , R4 
06A9    941C          2273     	SUBB	A, #28
06AB    ED            2274     MOV A , R5 
06AC    9402          2275     	SUBB A, #2
06AE    4003          2276     	JC	($+5)						; No - proceed
                      2277     
06B0    02082C        2278     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2279     
                      2280     	; Check if below 800us (in order to ignore false pulses)
06B3    ED            2281     MOV A , R5 
06B4    7009          2282     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      2283     
06B6    C3            2284     	CLR	C
06B7    EC            2285     MOV A , R4 
06B8    94C8          2286     	SUBB	A, #200
06BA    5003          2287     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      2288     
06BC    02082C        2289     	JMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      2290     
                      2291     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      2292     	; Calculate "1000us" plus throttle minimum
06BF    7400          2293     	MOV	A, #0						; Set 1000us as default minimum
06C1    20770B        2294     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      2295     
                      2296     IF MODE >= 1	; Tail or multi
06C4    7888          2297     MOV R0 , # PGM_DIRECTION 
06C6    E6            2298     MOV A , @ R0 
                      2299     ENDIF
06C7    7896          2300     MOV R0 , # PGM_PPM_MIN_THROTTLE 
                      2301     IF MODE >= 1	; Tail or multi
06C9    B40302        2302     	CJNE	A, #3, ($+5)
                      2303     
06CC    789E          2304     MOV R0 , # PGM_PPM_CENTER_THROTTLE 
                      2305     ENDIF
06CE    E6            2306     MOV A , @ R0 
                      2307     
                      2308     PCA_INT_PPM_CALCULATE: 
06CF    24FA          2309     	ADD	A, #250						; Add 1000us to minimum
06D1    FE            2310     MOV R6 , A 
06D2    E4            2311     	CLR	A
06D3    3400          2312     	ADDC	A, #0
06D5    FF            2313     MOV R7 , A 
                      2314     
06D6    C3            2315     	CLR	C
06D7    EC            2316     MOV A , R4 
06D8    9E            2317     SUBB A , R6 
06D9    FC            2318     MOV R4 , A 
06DA    ED            2319     MOV A , R5 
06DB    9F            2320     SUBB A , R7 
06DC    FD            2321     MOV R5 , A 
                      2322     IF MODE >= 1	; Tail or multi
06DD    9208          2323     	MOV	BIT_ACCESS_INT.0, C
06DF    7888          2324     MOV R0 , # PGM_DIRECTION 
06E1    E6            2325     MOV A , @ R0 
06E2    B40322        2326     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DIR_SET	; No - branch
                      2327     
06E5    A208          2328     	MOV	C, BIT_ACCESS_INT.0
06E7    5009          2329     	JNC	PCA_INT_PPM_BIDIR_FWD			; If result is positive - branch				
                      2330     
                      2331     PCA_INT_PPM_BIDIR_REV: 
06E9    20751B        2332     JB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2333     
06EC    C2AF          2334     	CLR	EA							; Direction change, turn off all fets
06EE    D275          2335     SETB FLAGS3 . 5 
06F0    C1F9          2336     	AJMP	PCA_INT_PPM_BIDIR_DIR_CHANGE
                      2337     
                      2338     PCA_INT_PPM_BIDIR_FWD: 
06F2    307512        2339     JNB FLAGS3 . 5 , PCA_INT_PPM_BIDIR_DIR_SET 
                      2340     
06F5    C2AF          2341     	CLR	EA							; Direction change, turn off all fets
06F7    C275          2342     CLR FLAGS3 . 5 
                      2343     
                      2344     PCA_INT_PPM_BIDIR_DIR_CHANGE: 
                      2345     	ALL_NFETS_OFF
06F9    D297          2345+1   SETB P1 . 7 
06FB    D295          2345+1   SETB P1 . 5 
06FD    D293          2345+1   SETB P1 . 3 
                      2346     	ALL_PFETS_OFF
06FF    C296          2346+1   CLR P1 . 6 
0701    C294          2346+1   CLR P1 . 4 
0703    C292          2346+1   CLR P1 . 2 
0705    D2AF          2347     	SETB	EA
                      2348     
                      2349     PCA_INT_PPM_BIDIR_DIR_SET: 
0707    A208          2350     	MOV	C, BIT_ACCESS_INT.0
                      2351     ENDIF
0709    5017          2352     	JNC	PCA_INT_PPM_NEG_CHECKED			; If result is positive - branch
                      2353     
                      2354     IF MODE >= 1	; Tail or multi
070B    E6            2355     MOV A , @ R0 
070C    B4030D        2356     	CJNE	A, #3, PCA_INT_PPM_UNIDIR_NEG 	; No - branch
                      2357     
070F    EC            2358     MOV A , R4 
0710    F4            2359     	CPL	A
0711    2401          2360     	ADD	A, #1
0713    FC            2361     MOV R4 , A 
0714    ED            2362     MOV A , R5 
0715    F4            2363     	CPL	A
0716    3400          2364     	ADDC	A, #0
0718    FD            2365     MOV R5 , A 
0719    020722        2366     	JMP	PCA_INT_PPM_NEG_CHECKED
                      2367     
                      2368     PCA_INT_PPM_UNIDIR_NEG: 
                      2369     ENDIF
071C    7800          2370     MOV R0 , # 0 
071E    7900          2371     MOV R1 , # 0 
0720    E16C          2372     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2373     
                      2374     PCA_INT_PPM_NEG_CHECKED: 
                      2375     IF MODE >= 1	; Tail or multi
0722    7888          2376     MOV R0 , # PGM_DIRECTION 
0724    E6            2377     MOV A , @ R0 
0725    B40315        2378     	CJNE	A, #3, PCA_INT_PPM_BIDIR_DONE		; No - branch
                      2379     
0728    EC            2380     MOV A , R4 
0729    33            2381     	RLC	A
072A    FC            2382     MOV R4 A 
072B    ED            2383     MOV A , R5 
072C    33            2384     	RLC	A
072D    FD            2385     MOV R5 A 
072E    C3            2386     	CLR	C							; Subtract deadband
072F    EC            2387     MOV A , R4 
0730    9405          2388     	SUBB	A, #5		
0732    FC            2389     MOV R4 , A 
0733    ED            2390     MOV A , R5 
0734    9400          2391     	SUBB	A, #0
0736    FD            2392     MOV R5 , A 
0737    5004          2393     	JNC	PCA_INT_PPM_BIDIR_DONE
                      2394     
0739    7C00          2395     MOV R4 , # 0 
073B    7D00          2396     MOV R5 , # 0 
                      2397     
                      2398     PCA_INT_PPM_BIDIR_DONE: 
                      2399     ENDIF
073D    C3            2400     	CLR	C							; Check that RC pulse is within legal range (max 255)
073E    EC            2401     MOV A , R4 
073F    94FF          2402     SUBB A , # 255 
0741    ED            2403     MOV A , R5 
0742    9400          2404     	SUBB	A, #0
0744    4006          2405     	JC	PCA_INT_PPM_MAX_CHECKED
                      2406     
0746    78FF          2407     MOV R0 , # 255 
0748    7900          2408     MOV R1 , # 0 
074A    E16C          2409     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2410     
                      2411     PCA_INT_PPM_MAX_CHECKED: 
074C    EC            2412     MOV A , R4 
074D    856EF0        2413     	MOV	B, PPM_THROTTLE_GAIN
0750    A4            2414     	MUL	AB
0751    C5F0          2415     	XCH	A, B
0753    A2F7          2416     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0755    33            2417     	RLC	A
0756    F8            2418     MOV R0 , A 
0757    7900          2419     MOV R1 , # 0 
0759    4003          2420     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      2421     	
075B    020788        2422     	JMP	PCA_INT_LIMITED			
                      2423     
                      2424     PCA_INT_PPM_LIMIT_AFTER_MULT: 
075E    78FF          2425     MOV R0 , # 255 
0760    7900          2426     MOV R1 , # 0 
0762    020788        2427     	JMP	PCA_INT_LIMITED			
                      2428     
                      2429     PCA_INT_PWM_DIVIDE: 
0765    E9            2430     MOV A , R1 
0766    C3            2431     	CLR	C
0767    13            2432     	RRC	A
0768    F9            2433     MOV R1 , A 
0769    E8            2434     MOV A , R0 
076A    13            2435     	RRC	A
076B    F8            2436     MOV R0 , A 
                      2437     
                      2438     PCA_INT_PWM_DIVIDE_DONE: 
076C    30740E        2439     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
076F    E9            2440     MOV A , R1 
0770    6002          2441     	JZ	($+4)
                      2442     
0772    78FF          2443     MOV R0 , # 255 
                      2444     
0774    C3            2445     	CLR	C
0775    E8            2446     MOV A , R0 
0776    13            2447     	RRC	A
0777    38            2448     ADDC A , R0 
0778    F8            2449     MOV R0 , A 
0779    E4            2450     	CLR	A
077A    3400          2451     	ADDC	A, #0
077C    F9            2452     MOV R1 , A 
                      2453     
                      2454     PCA_INT_CHECK_LEGAL_RANGE: 
                      2455     	; Check that RC pulse is within legal range
077D    C3            2456     	CLR	C
077E    E8            2457     MOV A , R0 
077F    94FF          2458     SUBB A , # 255 
0781    E9            2459     MOV A , R1 
0782    9400          2460     	SUBB	A, #0
0784    4002          2461     	JC	PCA_INT_LIMITED
                      2462     
0786    78FF          2463     MOV R0 , # 255 
                      2464     
                      2465     PCA_INT_LIMITED: 
                      2466     
                      2467     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2468     ; 
                      2469     ; GetPWM
                      2470     ; Skypup 2015.05.25
                      2471     ; 对 RCP 信号处理, 给 nPWMIn 赋值
                      2472     ; 	小于 THR_SWITCH nPWMIn = PWM_IN_LOW
                      2473     ; 	大于 THR_SWITCH nPWMIn = PWM_IN_HIGH
                      2474     ; 
                      2475     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2476     PROCEDURE_GETPWM: 
0788    C3            2477     	CLR	C
0789    E8            2478     MOV A , R0 
078A    94A0          2479     SUBB A , # 160 
078C    5005          2480     	JNC 	SET_PWM_IN_HIGH			; No nPWMIn = PWM_IN_HIGH
078E    7800          2481     MOV R0 , # 0 
0790    020795        2482     	JMP	SET_PWM_IN
                      2483     SET_PWM_IN_HIGH: 
0793    7801          2484     MOV R0 , # 1 
                      2485     SET_PWM_IN: 
0795    8875          2486     MOV NPWMIN , R0 
                      2487     END_PROCEDURE_GETPWM: 
                      2488     
                      2489     
                      2490     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2491     ;
                      2492     ; 是否解锁
                      2493     ; Skypup 2015.05.26
                      2494     ;
                      2495     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
0797    A873          2496     MOV R0 , FLAG_BEFORE_ARM 
0799    B80107        2497     CJNE R0 , # 1 , ELSE_FLAG_BEFORE_ARM 
                      2498     IF_FLAG_BEFORE_ARM: 
079C    78FF          2499     MOV R0 , # 255 
079E    8859          2500     MOV NEW_RCP , R0 
07A0    020819        2501     	JMP SET_PREV_RCP				; 如果未解锁, 不做后续处理, 直接跳转
                      2502     ELSE_FLAG_BEFORE_ARM: 
                      2503     ; endif_Flag_Before_ARM:
                      2504     
                      2505     
                      2506     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2507     ;
                      2508     ; 例程: 判断是否 PWM_IN_HIGH
                      2509     ; Skypup 2015.05.26
                      2510     ;
                      2511     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2512     ;	mov	Temp1, nPWMIn
                      2513     ;	cjne	Temp1, #PWM_IN_HIGH, else_nPWMIn_pwm_in_high
                      2514     ;if_nPWMIn_pwm_in_high:
                      2515     ;	mov	Temp1, Initial_Arm
                      2516     ;	cjne	Temp1, #1, else_Initial_Arm
                      2517     ;  if_Initial_Arm:
                      2518     ;	mov Temp1, #PWM_FULL
                      2519     ;	mov	New_Rcp, Temp1	
                      2520     ;	jmp set_Prev_Rcp		; 如果未解锁, 不做后续处理, 直接跳转
                      2521     ;  else_Initial_Arm:
                      2522     ;	mov	Temp1,  #RCP_MIN
                      2523     ;  endif_INitial_Arm:
                      2524     ;	mov	New_Rcp, Temp1	
                      2525     ;	jmp	endif_nPWMIn_pwm_in_high
                      2526     ;else_nPWMIn_pwm_in_high:
                      2527     ;	; 最低油门
                      2528     ;	mov	Temp1, #RCP_MIN
                      2529     ;	mov	New_Rcp, Temp1	
                      2530     ;	; jmp	endif_nPWMIn_pwm_in_high
                      2531     ;endif_nPWMIn_pwm_in_high:
                      2532     
                      2533     
                      2534     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2535     ;
                      2536     ; 判断 cState 状态
                      2537     ; Skypup 2015.05.
                      2538     ;
                      2539     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2540     ;
07A3    A878          2541     MOV R0 , CSTATE 
07A5    B81029        2542     CJNE R0 , # 16 , ELES_STATE_FULL 
                      2543     IF_STATE_FULL: 
                      2544      	; STATE_FULL - 全油门
07A8    78FF          2545     MOV R0 , # 255 
07AA    8859          2546     MOV NEW_RCP , R0 
                      2547     	; 计数器 ++
07AC    0576          2548     	INC	NHOLD_L						; nHold_L 低位 ++
07AE    E576          2549     	MOV	A, NHOLD_L
07B0    7002          2550     	JNZ	IF_FULL_NHOLD_L_NOT_ZERO			; nHold_L 不是 0x00
07B2    0577          2551     	INC	NHOLD_H						; nHold_L 是 0x00, nHold_H 高位 ++
                      2552     	IF_FULL_NHOLD_L_NOT_ZERO: 
                      2553     
                      2554     	; 是否超时
07B4    C3            2555     	CLR	C
07B5    E577          2556     	MOV	A, NHOLD_H
07B7    9402          2557     SUBB A , # 2 
07B9    4013          2558     	JC	IF_FULL_NHOLD_NOT_TIMEOUT		; 发生借位, 则 nHold_H < #HOLD_FULL_H, 未超时
07BB    C3            2559     	CLR	C
07BC    E576          2560     	MOV	A, NHOLD_L
07BE    948A          2561     SUBB A , # 138 
07C0    400C          2562     	JC	IF_FULL_NHOLD_NOT_TIMEOUT		; 发生借位, 则 nHold_L < #HOLD_FULL_L, 未超时
                      2563     	IF_FULL_NHOLD_TIMEOUT: 				; 未发生借位, 超时切换至 STATE_CRUISE
                      2564     		; 状态切换为 STATE_CRUISE
07C2    7820          2565     MOV R0 , # 32 
07C4    8878          2566     MOV CSTATE , R0 
                      2567     		; 计数器清零
07C6    E4            2568     		CLR	A
07C7    F576          2569     		MOV	NHOLD_L, A
07C9    F577          2570     		MOV	NHOLD_H, A
07CB    020819        2571     		JMP	ENDIF_STATE_FULL
                      2572     	IF_FULL_NHOLD_NOT_TIMEOUT: 
07CE    020819        2573     	 	JMP ENDIF_STATE_FULL
                      2574      
                      2575     ELES_STATE_FULL: 
07D1    A878          2576     MOV R0 , CSTATE 
07D3    B82029        2577     CJNE R0 , # 32 , ELSE_STATE_CRUISE 
                      2578      
                      2579     	IF_STATE_CRUISE: 
                      2580     	 	; STATE_CRUISE - 巡航油门
07D6    787F          2581     MOV R0 , # 127 
07D8    8859          2582     MOV NEW_RCP , R0 
                      2583     		; 计数器 ++
07DA    0576          2584     		INC	NHOLD_L					; nHold_L 低位 ++
07DC    E576          2585     		MOV	A, NHOLD_L
07DE    7002          2586     		JNZ	IF_CRUISE_NHOLD_L_NOT_ZERO	; nHold_L 不是 0x00
07E0    0577          2587     		INC	NHOLD_H					; nHold_L 是 0x00, nHold_H 高位 ++
                      2588     		IF_CRUISE_NHOLD_L_NOT_ZERO: 
                      2589     
                      2590     		; 是否超时
07E2    C3            2591     		CLR	C
07E3    E577          2592     		MOV	A, NHOLD_H
07E5    9429          2593     SUBB A , # 41 
07E7    4013          2594     		JC	IF_CRUISE_NHOLD_NOT_TIMEOUT	; 发生借位, 则 nHold_H < #HOLD_CRUISE_H, 未超时
07E9    C3            2595     		CLR	C
07EA    E576          2596     		MOV	A, NHOLD_L
07EC    9404          2597     SUBB A , # 4 
07EE    400C          2598     		JC	IF_CRUISE_NHOLD_NOT_TIMEOUT	; 发生借位, 则 nHold_L < #HOLD_CRUISE_L, 未超时
                      2599     		IF_CRUISE_NHOLD_TIMEOUT: 			; 未发生借位, 超时切换至 STATE_WAIT
                      2600     			; 状态切换为 STATE_WAIT
07F0    7800          2601     MOV R0 , # 0 
07F2    8878          2602     MOV CSTATE , R0 
                      2603     			; 计数器清零
07F4    E4            2604     			CLR	A
07F5    F576          2605     			MOV	NHOLD_L, A
07F7    F577          2606     			MOV	NHOLD_H, A
07F9    020819        2607     			JMP	ENDIF_STATE_CRUISE
                      2608     		IF_CRUISE_NHOLD_NOT_TIMEOUT: 
07FC    020819        2609     		 	JMP ENDIF_STATE_CRUISE
                      2610       
                      2611     	ELSE_STATE_CRUISE: 
                      2612     	 	; STATE_WAIT
07FF    7800          2613     MOV R0 , # 0 
0801    8859          2614     MOV NEW_RCP , R0 
                      2615     		;
0803    A830          2616     MOV R0 , INITIAL_ARM 
0805    B80011        2617     CJNE R0 , # 0 , ELSE_INITIAL_ARM 
                      2618     		IF_INITIAL_ARM: 
                      2619     			; 判断是否 PWM_IN_HIGH
0808    A875          2620     MOV R0 , NPWMIN 
080A    B8010C        2621     CJNE R0 , # 1 , ENDIF_STATE_WAIT_PWM_IN_HIGH 
                      2622     			; 状态切换为 STATE_FULL
080D    7810          2623     MOV R0 , # 16 
080F    8878          2624     MOV CSTATE , R0 
                      2625     			; 计数器清零
0811    E4            2626     			CLR	A
0812    F576          2627     			MOV	NHOLD_L, A
0814    F577          2628     			MOV	NHOLD_H, A
0816    020819        2629     		 	JMP	ENDIF_INITIAL_ARM
                      2630     			ENDIF_STATE_WAIT_PWM_IN_HIGH: 
                      2631     		ELSE_INITIAL_ARM: 
                      2632     		ENDIF_INITIAL_ARM: 
                      2633     	ENDIF_STATE_CRUISE:  
                      2634     ENDIF_STATE_FULL: 
                      2635     
                      2636     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2637     ;
                      2638     ; 已经弃用的代码, 供参考.
                      2639     ;
                      2640     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2641     ; skypup_03:
                      2642     ; 
                      2643     ; 	clr C
                      2644     ; 	mov A, Temp1
                      2645     ; 	subb A, Prev_Rcp				; 上一个 Rcp > 当前 Rcp ?
                      2646     ; 	jc skypup_04					; No
                      2647     ; 
                      2648     ; 	subb A, #THR_DELTA				; 油门缓启动增量 > Rcp 增加值 ?
                      2649     ; 	jc skypup_04					; No
                      2650     ; 
                      2651     ; 	clr C						; 这一句能否去掉? Skypup 2015.05.25
                      2652     ; 	mov A, Prev_Rcp
                      2653     ; 	add A, #THR_DELTA
                      2654     ; 	mov Temp1, A
                      2655     ; 	jnc skypup_04					; 没有发生进位溢出
                      2656     ; 
                      2657     ; 	mov Temp1, #0FFh	
                      2658     ; 	
                      2659     ; skypup_04:
                      2660     
                      2661     
                      2662     SET_PREV_RCP: 
                      2663     	; 记录 New_Rcp 值
0819    E559          2664     	MOV A, NEW_RCP
081B    F574          2665     	MOV PREV_RCP, A
                      2666     
                      2667     ;**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** 
                      2668     	; RC pulse value accepted
                      2669     	; mov	New_Rcp, Temp1				; Store new pulse length
081D    D268          2670     SETB FLAGS2 . 0 
081F    205902        2671     JB FLAGS0 . 1 , ( $+5 ) 
0822    012C          2672     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2673     
0824    741F          2674     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0826    F4            2675     	CPL	A
0827    552E          2676     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0829    4B            2677     ORL A , R3 
082A    F52E          2678     	MOV	FLAGS3, A
                      2679     
                      2680     PCA_INT_SET_TIMEOUT: 
082C    752818        2681     MOV RCP_TIMEOUT_CNT , # 24 
082F    741F          2682     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0831    552E          2683     	ANL	A, FLAGS3					; Check pwm frequency flags
0833    7003          2684     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2685     
0835    75280A        2686     MOV RCP_TIMEOUT_CNT , # 10 
                      2687     
                      2688     PCA_INT_PPM_TIMEOUT_SET: 
0838    305902        2689     JNB FLAGS0 . 1 , ( $+5 ) 
083B    0146          2690     	AJMP PCA_INT_EXIT				; Yes - exit
                      2691     
083D    741F          2692     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
083F    552E          2693     	ANL	A, FLAGS3					; Check pwm frequency flags
0841    6003          2694     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2695     
                      2696     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
0843    53DAFE        2696+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2697     
                      2698     PCA_INT_EXIT: 	; Exit interrupt routine	
0846    752906        2699     MOV RCP_SKIP_CNT , # 6 
0849    741F          2700     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
084B    552E          2701     	ANL	A, FLAGS3					; Check pwm frequency flags
084D    7003          2702     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2703     
084F    75290A        2704     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2705     
0852    D0F0          2706     	POP	B			; Restore preserved registers
0854    D0E0          2707     	POP	ACC			
0856    D0D0          2708     	POP	PSW
0858    C2D3          2709     	CLR	PSW.3		; Select register bank 0 for main program routines	
085A    D2AD          2710     	SETB	ET2			; Enable timer2 interrupts
085C    43E610        2711     	ORL	EIE1, #10H	; Enable PCA0 interrupts
085F    32            2712     	RETI
                      2713     
                      2714     
                      2715     
                      2716     
                      2717     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2718     ;
                      2719     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2720     ;
                      2721     ; No assumptions
                      2722     ;
                      2723     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2724     WAIT1MS: 	
0860    7901          2725     MOV R1 , # 1 
0862    02087E        2726     	JMP	WAITXMS_O
                      2727     
                      2728     WAIT3MS: 	
0865    7903          2729     MOV R1 , # 3 
0867    02087E        2730     	JMP	WAITXMS_O
                      2731     
                      2732     WAIT10MS: 	
086A    790A          2733     MOV R1 , # 10 
086C    02087E        2734     	JMP	WAITXMS_O
                      2735     
                      2736     WAIT30MS: 	
086F    791E          2737     MOV R1 , # 30 
0871    02087E        2738     	JMP	WAITXMS_O
                      2739     
                      2740     WAIT100MS: 	
0874    7964          2741     MOV R1 , # 100 
0876    02087E        2742     	JMP	WAITXMS_O
                      2743     
                      2744     WAIT200MS: 	
0879    79C8          2745     MOV R1 , # 200 
087B    02087E        2746     	JMP	WAITXMS_O
                      2747     
                      2748     WAITXMS_O: 	; Outer loop
087E    7817          2749     MOV R0 , # 23 
                      2750     WAITXMS_M: 	; Middle loop
0880    E4            2751     	CLR	A
0881    D5E0FD        2752      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0884    D8FA          2753     DJNZ R0 , WAITXMS_M 
0886    D9F6          2754     DJNZ R1 , WAITXMS_O 
0888    22            2755     	RET
                      2756     
                      2757     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2758     ;
                      2759     ; Wait 1 second routine
                      2760     ;
                      2761     ; No assumptions
                      2762     ;
                      2763     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2764     WAIT1S: 
0889    7C05          2765     MOV R4 , # 5 
                      2766     WAIT1S_LOOP: 
088B    1179          2767     	CALL WAIT200MS
088D    DCFC          2768     DJNZ R4 , WAIT1S_LOOP 
088F    22            2769     	RET
                      2770     
                      2771     
                      2772     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2773     ;
                      2774     ; Beeper routines (4 different entry points) 
                      2775     ;
                      2776     ; No assumptions
                      2777     ;
                      2778     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2779     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
0890    7A14          2780     MOV R2 , # 20 
0892    7B78          2781     MOV R3 , # 120 
0894    0208AC        2782     	JMP	BEEP
                      2783     
                      2784     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0897    7A10          2785     MOV R2 , # 16 
0899    7B8C          2786     MOV R3 , # 140 
089B    0208AC        2787     	JMP	BEEP
                      2788     
                      2789     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
089E    7A0D          2790     MOV R2 , # 13 
08A0    7BB4          2791     MOV R3 , # 180 
08A2    0208AC        2792     	JMP	BEEP
                      2793     
                      2794     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
08A5    7A0B          2795     MOV R2 , # 11 
08A7    7BC8          2796     MOV R3 , # 200 
08A9    0208AC        2797     	JMP	BEEP
                      2798     
                      2799     BEEP: 	; Beep loop start
08AC    AC25          2800     MOV R4 , CURRENT_PWM_LIMITED 
08AE    752501        2801     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
08B1    7902          2802     MOV R1 , # 2 
                      2803     BEEP_ONOFF: 
08B3    B275          2804     CPL FLAGS3 . 5 
08B5    E4            2805     	CLR	A
                      2806     	BPFET_OFF			; BpFET off
08B6    C294          2806+1   CLR P1 . 4 
08B8    D5E0FD        2807     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      2808     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
08BB    E525          2808+1   MOV A , CURRENT_PWM_LIMITED 
08BD    6002          2808+1   JZ ( $+4 ) 
08BF    C295          2808+1   CLR P1 . 5 
08C1    D5E0FD        2809     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      2810     	BNFET_OFF			; BnFET off again
08C4    D295          2810+1   SETB P1 . 5 
08C6    D5E0FD        2811     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      2812     	BPFET_ON			; BpFET on
08C9    D294          2812+1   SETB P1 . 4 
08CB    D5E0FD        2813     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2814     	; Turn on nfet
                      2815     	ANFET_ON			; AnFET on
08CE    E525          2815+1   MOV A , CURRENT_PWM_LIMITED 
08D0    600A          2815+1   JZ ( $+12 ) 
08D2    207502        2815+1   JB FLAGS3 . 5 , ( $+5 ) 
08D5    C297          2815+1   CLR P1 . 7 
08D7    307502        2815+1   JNB FLAGS3 . 5 , ( $+5 ) 
08DA    C293          2815+1   CLR P1 . 3 
08DC    E56F          2816     	MOV	A, BEEP_STRENGTH
08DE    D5E0FD        2817     	DJNZ	ACC, $		
                      2818     	; Turn off nfet
                      2819     	ANFET_OFF			; AnFET off
08E1    207502        2819+1   JB FLAGS3 . 5 , ( $+5 ) 
08E4    D297          2819+1   SETB P1 . 7 
08E6    307502        2819+1   JNB FLAGS3 . 5 , ( $+5 ) 
08E9    D293          2819+1   SETB P1 . 3 
08EB    7496          2820     	MOV	A, #150		; 25s off
08ED    D5E0FD        2821     	DJNZ	ACC, $		
08F0    D9C1          2822     DJNZ R1 , BEEP_ONOFF 
                      2823     	; Copy variable
08F2    EA            2824     MOV A , R2 
08F3    F8            2825     MOV R0 , A 
                      2826     BEEP_OFF: 		; Fets off loop
08F4    D5E0FD        2827     	DJNZ	ACC, $
08F7    D8FB          2828     DJNZ R0 , BEEP_OFF 
08F9    DBB1          2829     DJNZ R3 , BEEP 
                      2830     	BPFET_OFF			; BpFET off
08FB    C294          2830+1   CLR P1 . 4 
08FD    8C25          2831     MOV CURRENT_PWM_LIMITED , R4 
08FF    22            2832     	RET
                      2833     
                      2834     
                      2835     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2836     ;
                      2837     ; Division 16bit unsigned by 16bit unsigned
                      2838     ;
                      2839     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      2840     ; Result will be in Temp2/Temp1
                      2841     ;
                      2842     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2843     DIV_U16_BY_U16: 	
0900    C3            2844     	CLR	C       
0901    7C00          2845     MOV R4 , # 0 
0903    7D00          2846     MOV R5 , # 0 
0905    75F000        2847     	MOV	B, #0
                      2848     DIV_U16_BY_U16_DIV1: 
0908    05F0          2849     	INC	B      			; Increment counter for each left shift
090A    EA            2850     MOV A , R2 
090B    33            2851     	RLC	A      		
090C    FA            2852     MOV R2 , A 
090D    EB            2853     MOV A , R3 
090E    33            2854     	RLC	A      	  	
090F    FB            2855     MOV R3 , A 
0910    50F6          2856     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      2857     DIV_U16_BY_U16_DIV2:         
0912    EB            2858     MOV A , R3 
0913    13            2859     	RRC	A      
0914    FB            2860     MOV R3 , A 
0915    EA            2861     MOV A , R2 
0916    13            2862     	RRC	A      
0917    FA            2863     MOV R2 , A 
0918    C3            2864     	CLR	C      
0919    E9            2865     MOV A , R1 
091A    FF            2866     MOV R7 , A 
091B    E8            2867     MOV A , R0 
091C    FE            2868     MOV R6 , A 
091D    E8            2869     MOV A , R0 
091E    9A            2870     SUBB A , R2 
091F    F8            2871     MOV R0 , A 
0920    E9            2872     MOV A , R1 
0921    9B            2873     SUBB A , R3 
0922    F9            2874     MOV R1 , A 
0923    5004          2875     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
0925    EF            2876     MOV A , R7 
0926    F9            2877     MOV R1 , A 
0927    EE            2878     MOV A , R6 
0928    F8            2879     MOV R0 , A 
                      2880     DIV_U16_BY_U16_DIV3: 
0929    B3            2881     	CPL	C      			; Invert carry, so it can be directly copied into result
092A    EC            2882     MOV A , R4 
092B    33            2883     	RLC	A      			; Shift carry flag into temporary result
092C    FC            2884     MOV R4 , A 
092D    ED            2885     MOV A , R5 
092E    33            2886     	RLC	A
092F    FD            2887     MOV R5 , A 
0930    D5F0DF        2888     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
0933    ED            2889     MOV A , R5 
0934    F9            2890     MOV R1 , A 
0935    EC            2891     MOV A , R4 
0936    F8            2892     MOV R0 , A 
0937    22            2893     	RET
                      2894     
                      2895     
                      2896     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2897     ;
                      2898     ; Multiplication 16bit signed by 8bit unsigned
                      2899     ;
                      2900     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2901     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2902     ;
                      2903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2904     MULT_S16_BY_U8_DIV_16: 
0938    E8            2905     MOV A , R0 
0939    89F0          2906     MOV B , R1 
093B    8A20          2907     MOV BIT_ACCESS , R2 
093D    D2D4          2908     	SETB	PSW.4		; Select register bank 2 for math routines
093F    F8            2909     MOV R0 , A 
0940    A9F0          2910     MOV R1 , B 
0942    7B00          2911     MOV R3 , # 0 
0944    30F70B        2912     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      2913     
0947    7BFF          2914     MOV R3 , # 0FFH 
0949    F4            2915     	CPL	A
094A    2401          2916     	ADD	A, #1
094C    F8            2917     MOV R0 , A 
094D    E9            2918     MOV A , R1 
094E    F4            2919     	CPL	A
094F    3400          2920     	ADDC	A, #0
0951    F9            2921     MOV R1 , A 
                      2922     MULT_S16_BY_U8_POSITIVE: 
0952    E8            2923     MOV A , R0 
0953    8520F0        2924     	MOV	B, BIT_ACCESS
0956    A4            2925     	MUL	AB
0957    ADF0          2926     MOV R5 , B 
0959    F8            2927     MOV R0 , A 
095A    E9            2928     MOV A , R1 
095B    8520F0        2929     	MOV	B, BIT_ACCESS
095E    A4            2930     	MUL	AB
095F    AFF0          2931     MOV R7 , B 
0961    FE            2932     MOV R6 , A 
0962    ED            2933     MOV A , R5 
0963    2E            2934     ADD A , R6 
0964    F9            2935     MOV R1 , A 
0965    7400          2936     	MOV	A, #0
0967    3F            2937     ADDC A , R7 
0968    FA            2938     MOV R2 , A 
0969    7C04          2939     MOV R4 , # 4 
                      2940     MULT_S16_BY_U8_DIV_LOOP: 
096B    C3            2941     	CLR	C			; Rotate right 
096C    EA            2942     MOV A , R2 
096D    13            2943     	RRC	A
096E    FA            2944     MOV R2 , A 
096F    E9            2945     MOV A , R1 
0970    13            2946     	RRC	A
0971    F9            2947     MOV R1 , A 
0972    E8            2948     MOV A , R0 
0973    13            2949     	RRC	A
0974    F8            2950     MOV R0 , A 
0975    DCF4          2951     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      2952     
0977    8BF0          2953     MOV B , R3 
0979    30F70A        2954     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      2955     
097C    E8            2956     MOV A , R0 
097D    F4            2957     	CPL	A
097E    2401          2958     	ADD	A, #1
0980    F8            2959     MOV R0 , A 
0981    E9            2960     MOV A , R1 
0982    F4            2961     	CPL	A
0983    3400          2962     	ADDC	A, #0
0985    F9            2963     MOV R1 , A 
                      2964     
                      2965     MULT_S16_BY_U8_EXIT: 
0986    E8            2966     MOV A , R0 
0987    89F0          2967     MOV B , R1 
0989    C2D4          2968     	CLR	PSW.4		; Select normal register bank
098B    F8            2969     MOV R0 , A 
098C    A9F0          2970     MOV R1 , B 
098E    22            2971     	RET
                      2972     
                      2973     
                      2974     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2975     ;
                      2976     ; Calculate governor routines
                      2977     ;
                      2978     ; No assumptions
                      2979     ;
                      2980     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2981     ; The governor task is split into several routines in order to distribute processing time
                      2982     ;
                      2983     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2984     ; First governor routine - calculate governor target
                      2985     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #(RCP_MAX/10)			; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	MOV	A, FLAGS1
                               	ANL	A, #((1 SHL DIRECT_STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                               	JNZ	GOVERNOR_DEACTIVATE			; Deactivate if any startup phase set
                               
                               	; Skip speed check if governor is already active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2					; Check if high range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If high range - branch
                               
                               	MOV	TEMP1, #0AH				; Middle range activation limit value (~31250 eRPM)
                               	DEC	A
                               	JZ	GOVERNOR_ACT_LIM_SET		; If middle range - branch
                               	
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               GOVERNOR_ACT_LIM_SET:
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high, middle or low range
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_MIDDLE
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_SUBTRACT_025
                               
                               CALC_GOVERNOR_TARGET_MIDDLE:
                               	MOV	A, @TEMP2				; Check middle or low range (Temp2 has #Pgm_Gov_Range)
                               	DEC	A
                               	DEC	A
                               	JNZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	MOV	TEMP2, A				; Now 2 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 6 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #03H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FCH				; Calculate L byte
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 5 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               CALC_GOVERNOR_SUBTRACT_025:
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3125     IF MODE == 2	; Multi
                      3126     CALC_GOVERNOR_TARGET: 
098F    7882          3127     MOV R0 , # PGM_GOV_MODE 
0991    B60403        3128     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
0994    0209EB        3129     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3130     
                      3131     GOVERNOR_TARGET_CALC: 
                      3132     	; Stop governor for stop RC pulse	
0997    C3            3133     	CLR	C
0998    E559          3134     	MOV	A, NEW_RCP				; Check RC pulse against stop value
099A    9401          3135     SUBB A , # 1 
099C    4003          3136     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3137     
099E    0209B4        3138     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3139     
                      3140     GOVERNOR_DEACTIVATE: 
09A1    852224        3141     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
09A4    E4            3142     	CLR	A
09A5    F540          3143     	MOV	GOV_TARGET_L, A			; Set target to zero
09A7    F541          3144     	MOV	GOV_TARGET_H, A
09A9    F542          3145     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
09AB    F543          3146     	MOV	GOV_INTEGRAL_H, A
09AD    F544          3147     	MOV	GOV_INTEGRAL_X, A
09AF    F549          3148     	MOV	GOV_ACTIVE, A
09B1    0209EB        3149     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3150     
                      3151     GOVERNOR_ACTIVATE: 
09B4    7882          3152     MOV R0 , # PGM_GOV_MODE 
09B6    E6            3153     MOV A , @ R0 
09B7    FC            3154     MOV R4 , A 
09B8    754901        3155     	MOV	GOV_ACTIVE, #1
09BB    E522          3156     	MOV	A, REQUESTED_PWM			; Load requested pwm
09BD    F523          3157     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm
                      3158     	; Calculate comm period target 2*(51000/Requested_Pwm)
09BF    7838          3159     MOV R0 , # 38H 
09C1    79C7          3160     MOV R1 , # 0C7H 
09C3    AA3C          3161     MOV R2 , COMM_PERIOD4X_L 
09C5    AB3D          3162     MOV R3 , COMM_PERIOD4X_H 
                      3163     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
09C7    C3            3164     	CLR	C
09C8    EB            3165     MOV A , R3 
09C9    13            3166     	RRC	A
09CA    FB            3167     MOV R3 , A 
09CB    EA            3168     MOV A , R2 
09CC    13            3169     	RRC	A
09CD    FA            3170     MOV R2 , A 
                      3171     	; Check range
09CE    EC            3172     MOV A , R4 
09CF    14            3173     	DEC	A
09D0    6013          3174     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3175     GOVERNOR_ACTIVATE_100K: 
09D2    C3            3176     	CLR	C
09D3    EB            3177     MOV A , R3 
09D4    13            3178     	RRC	A
09D5    FB            3179     MOV R3 , A 
09D6    EA            3180     MOV A , R2 
09D7    13            3181     	RRC	A
09D8    FA            3182     MOV R2 , A 
09D9    EC            3183     MOV A , R4 
09DA    14            3184     	DEC	A
09DB    14            3185     	DEC	A
09DC    6007          3186     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3187     GOVERNOR_ACTIVATE_50K: 
09DE    C3            3188     	CLR	C
09DF    EB            3189     MOV A , R3 
09E0    13            3190     	RRC	A
09E1    FB            3191     MOV R3 , A 
09E2    EA            3192     MOV A , R2 
09E3    13            3193     	RRC	A
09E4    FA            3194     MOV R2 , A 
                      3195     GOVERNOR_ACTIVATE_RANGE_SET: 
09E5    3100          3196     	CALL	DIV_U16_BY_U16
                      3197     	; Store governor target
09E7    8840          3198     MOV GOV_TARGET_L , R0 
09E9    8941          3199     MOV GOV_TARGET_H , R1 
                      3200     CALC_GOVERNOR_TARGET_EXIT: 
09EB    22            3201     	RET						
                      3202     ENDIF
                      3203     
                      3204     
                      3205     ; Second governor routine - calculate governor proportional error
                      3206     CALC_GOVERNOR_PROP_ERROR: 
                      3207     	; Exit if governor is inactive
09EC    E549          3208     	MOV	A, GOV_ACTIVE
09EE    6034          3209     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3210     
                      3211     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3229     IF MODE == 2	; Multi
                      3230     	; Calculate error
09F0    C3            3231     	CLR	C
09F1    E540          3232     	MOV	A, GOV_TARGET_L
09F3    9523          3233     	SUBB	A, GOVERNOR_REQ_PWM
09F5    F8            3234     MOV R0 , A 
09F6    E541          3235     	MOV	A, GOV_TARGET_H
09F8    9400          3236     	SUBB	A, #0
09FA    F9            3237     MOV R1 , A 
                      3238     ENDIF
                      3239     	; Check error and limit
09FB    500C          3240     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3241     
09FD    C3            3242     	CLR	C
09FE    E8            3243     MOV A , R0 
09FF    9480          3244     	SUBB	A, #80H					; Is error too negative?
0A01    E9            3245     MOV A , R1 
0A02    94FF          3246     	SUBB	A, #0FFH
0A04    4016          3247     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0A06    020A20        3248     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3249     
                      3250     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0A09    C3            3251     	CLR	C
0A0A    E8            3252     MOV A , R0 
0A0B    947F          3253     	SUBB	A, #7FH					; Is error too positive?
0A0D    E9            3254     MOV A , R1 
0A0E    9400          3255     	SUBB	A, #00H
0A10    5003          3256     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0A12    020A20        3257     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3258     
                      3259     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0A15    787F          3260     MOV R0 , # 7FH 
0A17    7900          3261     MOV R1 , # 00H 
0A19    020A20        3262     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3263     
                      3264     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0A1C    7880          3265     MOV R0 , # 80H 
0A1E    79FF          3266     MOV R1 , # 0FFH 
                      3267     
                      3268     GOVERNOR_STORE_PROP_ERROR: 
                      3269     	; Store proportional
0A20    8845          3270     MOV GOV_PROPORTIONAL_L , R0 
0A22    8946          3271     MOV GOV_PROPORTIONAL_H , R1 
                      3272     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0A24    22            3273     	RET						
                      3274     
                      3275     
                      3276     ; Third governor routine - calculate governor integral error
                      3277     CALC_GOVERNOR_INT_ERROR: 
                      3278     	; Exit if governor is inactive
0A25    E549          3279     	MOV	A, GOV_ACTIVE
0A27    6058          3280     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3281     
                      3282     	; Add proportional to integral
0A29    E545          3283     	MOV	A, GOV_PROPORTIONAL_L
0A2B    2542          3284     	ADD	A, GOV_INTEGRAL_L
0A2D    F8            3285     MOV R0 , A 
0A2E    E546          3286     	MOV	A, GOV_PROPORTIONAL_H
0A30    3543          3287     	ADDC	A, GOV_INTEGRAL_H
0A32    F9            3288     MOV R1 , A 
0A33    854620        3289     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
0A36    E4            3290     	CLR	A
0A37    300701        3291     	JNB	BIT_ACCESS.7, ($+4)			
0A3A    F4            3292     	CPL	A
0A3B    3544          3293     	ADDC	A, GOV_INTEGRAL_X
0A3D    FA            3294     MOV R2 , A 
                      3295     	; Check integral and limit
0A3E    30E709        3296     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3297     
0A41    C3            3298     	CLR	C
0A42    EA            3299     MOV A , R2 
0A43    94F0          3300     	SUBB	A, #0F0H					; Is error too negative?
0A45    4015          3301     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0A47    020A62        3302     	JMP	GOVERNOR_CHECK_PWM
                      3303     
                      3304     GOVERNOR_CHECK_INT_LIMIT_POS: 
0A4A    C3            3305     	CLR	C
0A4B    EA            3306     MOV A , R2 
0A4C    940F          3307     	SUBB	A, #0FH					; Is error too positive?
0A4E    5003          3308     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0A50    020A62        3309     	JMP	GOVERNOR_CHECK_PWM
                      3310     
                      3311     GOVERNOR_LIMIT_INT_ERROR_POS: 
0A53    78FF          3312     MOV R0 , # 0FFH 
0A55    79FF          3313     MOV R1 , # 0FFH 
0A57    7A0F          3314     MOV R2 , # 0FH 
0A59    020A62        3315     	JMP	GOVERNOR_CHECK_PWM
                      3316     
                      3317     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0A5C    7800          3318     MOV R0 , # 00H 
0A5E    7900          3319     MOV R1 , # 00H 
0A60    7AF0          3320     MOV R2 , # 0F0H 
                      3321     
                      3322     GOVERNOR_CHECK_PWM: 
                      3323     	; Check current pwm
0A62    C3            3324     	CLR	C
0A63    E524          3325     	MOV	A, CURRENT_PWM
0A65    955E          3326     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0A67    5006          3327     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      3328     
0A69    E524          3329     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0A6B    6009          3330     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      3331     
0A6D    417B          3332     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      3333     
                      3334     GOVERNOR_INT_MAX_PWM: 
0A6F    E546          3335     	MOV	A, GOV_PROPORTIONAL_H
0A71    20E70D        3336     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
                      3337     
0A74    417B          3338     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      3339     
                      3340     GOVERNOR_INT_MIN_PWM: 
0A76    E546          3341     	MOV	A, GOV_PROPORTIONAL_H
0A78    30E706        3342     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      3343     
                      3344     GOVERNOR_STORE_INT_ERROR: 
                      3345     	; Store integral
0A7B    8842          3346     MOV GOV_INTEGRAL_L , R0 
0A7D    8943          3347     MOV GOV_INTEGRAL_H , R1 
0A7F    8A44          3348     MOV GOV_INTEGRAL_X , R2 
                      3349     CALC_GOVERNOR_INT_ERROR_EXIT: 
0A81    22            3350     	RET						
                      3351     
                      3352     
                      3353     ; Fourth governor routine - calculate governor proportional correction
                      3354     CALC_GOVERNOR_PROP_CORRECTION: 
                      3355     	; Exit if governor is inactive
0A82    E549          3356     	MOV	A, GOV_ACTIVE
0A84    7003          3357     	JNZ	CALC_GOVERNOR_PROP_CORR
0A86    020AE5        3358     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      3359     
                      3360     CALC_GOVERNOR_PROP_CORR: 
                      3361     	; Load proportional gain
0A89    789F          3362     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0A8B    E6            3363     MOV A , @ R0 
0A8C    FA            3364     MOV R2 , A 
                      3365     	; Load proportional
0A8D    C3            3366     	CLR	C
0A8E    E545          3367     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
0A90    33            3368     	RLC	A
0A91    F8            3369     MOV R0 , A 
0A92    E546          3370     	MOV	A, GOV_PROPORTIONAL_H
0A94    33            3371     	RLC	A
0A95    F9            3372     MOV R1 , A 
                      3373     	; Apply gain
0A96    3138          3374     	CALL	MULT_S16_BY_U8_DIV_16
                      3375     	; Check error and limit (to low byte)
0A98    E9            3376     MOV A , R1 
0A99    30E70B        3377     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3378     
0A9C    C3            3379     	CLR	C
0A9D    E8            3380     MOV A , R0 
0A9E    9480          3381     	SUBB	A, #80H					; Is error too negative?
0AA0    E9            3382     MOV A , R1 
0AA1    94FF          3383     	SUBB	A, #0FFH
0AA3    4013          3384     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0AA5    41BC          3385     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3386     
                      3387     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0AA7    C3            3388     	CLR	C
0AA8    E8            3389     MOV A , R0 
0AA9    947F          3390     	SUBB	A, #7FH					; Is error too positive?
0AAB    E9            3391     MOV A , R1 
0AAC    9400          3392     	SUBB	A, #00H
0AAE    5002          3393     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
0AB0    41BC          3394     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3395     
                      3396     GOVERNOR_LIMIT_PROP_CORR_POS: 
0AB2    787F          3397     MOV R0 , # 7FH 
0AB4    7900          3398     MOV R1 , # 00H 
0AB6    41BC          3399     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3400     
                      3401     GOVERNOR_LIMIT_PROP_CORR_NEG: 
0AB8    7880          3402     MOV R0 , # 80H 
0ABA    79FF          3403     MOV R1 , # 0FFH 
                      3404     
                      3405     GOVERNOR_APPLY_PROP_CORR: 
                      3406     	; Test proportional sign
0ABC    E8            3407     MOV A , R0 
0ABD    20E715        3408     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3409     
                      3410     	; Subtract positive proportional
0AC0    C3            3411     	CLR	C
0AC1    E523          3412     	MOV	A, GOVERNOR_REQ_PWM
0AC3    98            3413     SUBB A , R0 
0AC4    F8            3414     MOV R0 , A 
                      3415     	; Check result
0AC5    4009          3416     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3417     
0AC7    C3            3418     	CLR	C
0AC8    E8            3419     MOV A , R0 
0AC9    9401          3420     	SUBB	A, #1
0ACB    4003          3421     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0ACD    020AE3        3422     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3423     
                      3424     GOVERNOR_CORR_PROP_MIN_PWM: 
0AD0    7801          3425     MOV R0 , # 1 
0AD2    020AE3        3426     	JMP	GOVERNOR_STORE_PROP_CORR
                      3427     
                      3428     GOVERNOR_CORR_NEG_PROP: 
                      3429     	; Add negative proportional
0AD5    E8            3430     MOV A , R0 
0AD6    F4            3431     	CPL	A
0AD7    2401          3432     	ADD	A, #1
0AD9    2523          3433     	ADD	A, GOVERNOR_REQ_PWM
0ADB    F8            3434     MOV R0 , A 
                      3435     	; Check result
0ADC    4003          3436     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0ADE    020AE3        3437     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3438     
                      3439     GOVERNOR_CORR_PROP_MAX_PWM: 
0AE1    78FF          3440     MOV R0 , # 255 
                      3441     GOVERNOR_STORE_PROP_CORR: 
                      3442     	; Store proportional pwm
0AE3    8847          3443     MOV GOV_PROP_PWM , R0 
                      3444     CALC_GOVERNOR_PROP_CORR_EXIT: 
0AE5    22            3445     	RET
                      3446     
                      3447     
                      3448     ; Fifth governor routine - calculate governor integral correction
                      3449     CALC_GOVERNOR_INT_CORRECTION: 
                      3450     	; Exit if governor is inactive
0AE6    E549          3451     	MOV	A, GOV_ACTIVE
0AE8    7003          3452     	JNZ	CALC_GOVERNOR_INT_CORR
0AEA    020B47        3453     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3454     
                      3455     CALC_GOVERNOR_INT_CORR: 
                      3456     	; Load integral gain
0AED    78A0          3457     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0AEF    E6            3458     MOV A , @ R0 
0AF0    FA            3459     MOV R2 , A 
                      3460     	; Load integral
0AF1    A843          3461     MOV R0 , GOV_INTEGRAL_H 
0AF3    A944          3462     MOV R1 , GOV_INTEGRAL_X 
                      3463     	; Apply gain
0AF5    3138          3464     	CALL	MULT_S16_BY_U8_DIV_16
                      3465     	; Check integral and limit
0AF7    E9            3466     MOV A , R1 
0AF8    30E70C        3467     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3468     
0AFB    C3            3469     	CLR	C
0AFC    E8            3470     MOV A , R0 
0AFD    9401          3471     	SUBB	A, #01H					; Is integral too negative?
0AFF    E9            3472     MOV A , R1 
0B00    94FF          3473     	SUBB	A, #0FFH
0B02    4016          3474     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
0B04    020B1E        3475     	JMP	GOVERNOR_APPLY_INT_CORR
                      3476     
                      3477     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
0B07    C3            3478     	CLR	C
0B08    E8            3479     MOV A , R0 
0B09    94FF          3480     	SUBB	A, #0FFH					; Is integral too positive?
0B0B    E9            3481     MOV A , R1 
0B0C    9400          3482     	SUBB	A, #00H
0B0E    5003          3483     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0B10    020B1E        3484     	JMP	GOVERNOR_APPLY_INT_CORR
                      3485     
                      3486     GOVERNOR_LIMIT_INT_CORR_POS: 
0B13    78FF          3487     MOV R0 , # 0FFH 
0B15    7900          3488     MOV R1 , # 00H 
0B17    020B1E        3489     	JMP	GOVERNOR_APPLY_INT_CORR
                      3490     
                      3491     GOVERNOR_LIMIT_INT_CORR_NEG: 
0B1A    7801          3492     MOV R0 , # 01H 
0B1C    79FF          3493     MOV R1 , # 0FFH 
                      3494     
                      3495     GOVERNOR_APPLY_INT_CORR: 
                      3496     	; Test integral sign
0B1E    E9            3497     MOV A , R1 
0B1F    20E715        3498     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3499     
                      3500     	; Subtract positive integral
0B22    C3            3501     	CLR	C
0B23    E547          3502     	MOV	A, GOV_PROP_PWM
0B25    98            3503     SUBB A , R0 
0B26    F8            3504     MOV R0 , A 
                      3505     	; Check result
0B27    4009          3506     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3507     
0B29    C3            3508     	CLR	C
0B2A    E8            3509     MOV A , R0 
0B2B    9401          3510     	SUBB	A, #1
0B2D    4003          3511     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0B2F    020B45        3512     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3513     
                      3514     GOVERNOR_CORR_INT_MIN_PWM: 
0B32    7800          3515     MOV R0 , # 0 
0B34    020B45        3516     	JMP	GOVERNOR_STORE_INT_CORR
                      3517     
                      3518     GOVERNOR_CORR_NEG_INT: 
                      3519     	; Add negative integral
0B37    E8            3520     MOV A , R0 
0B38    F4            3521     	CPL	A
0B39    2401          3522     	ADD	A, #1
0B3B    2547          3523     	ADD	A, GOV_PROP_PWM
0B3D    F8            3524     MOV R0 , A 
                      3525     	; Check result
0B3E    4003          3526     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0B40    020B45        3527     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3528     
                      3529     GOVERNOR_CORR_INT_MAX_PWM: 
0B43    78FF          3530     MOV R0 , # 255 
                      3531     GOVERNOR_STORE_INT_CORR: 
                      3532     	; Store current pwm
0B45    8824          3533     MOV CURRENT_PWM , R0 
                      3534     CALC_GOVERNOR_INT_CORR_EXIT: 
0B47    22            3535     	RET
                      3536     
                      3537     
                      3538     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3539     ;
                      3540     ; Measure lipo cells
                      3541     ;
                      3542     ; No assumptions
                      3543     ;
                      3544     ; Measure voltage and calculate lipo cells
                      3545     ;
                      3546     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3547     MEASURE_LIPO_CELLS: 
                      3548     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3552     MEASURE_LIPO_START: 
                      3553     	; Load programmed low voltage limit
0B48    7883          3554     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0B4A    E6            3555     MOV A , @ R0 
0B4B    F520          3556     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      3557     	; Set commutation to BpFET on
0B4D    1210A9        3558     	CALL	COMM5COMM6			
                      3559     	; Start adc
                      3560     	START_ADC 
0B50    75E890        3560+1   MOV ADC0CN , # 90H  ; ADC START
                      3561     	; Wait for ADC reference to settle, and then start again
0B53    1160          3562     	CALL	WAIT1MS
                      3563     	START_ADC
0B55    75E890        3563+1   MOV ADC0CN , # 90H  ; ADC START
                      3564     	; Wait for ADC conversion to complete
                      3565     MEASURE_LIPO_WAIT_ADC: 
                      3566     	GET_ADC_STATUS 
0B58    E5E8          3566+1   MOV A , ADC0CN 
0B5A    20ECFB        3567     	JB	AD0BUSY, MEASURE_LIPO_WAIT_ADC
                      3568     	; Read ADC result
                      3569     	READ_ADC_RESULT
0B5D    A8BD          3569+1   MOV R0 , ADC0L 
0B5F    A9BE          3569+1   MOV R1 , ADC0H 
                      3570     	; Stop ADC
                      3571     	STOP_ADC
                      3572     	; Switch power off
0B61    121161        3573     	CALL	SWITCH_POWER_OFF		
                      3574     	; Set limit step
0B64    756A55        3575     MOV LIPO_ADC_LIMIT_L , # 85 
0B67    756B00        3576     MOV LIPO_ADC_LIMIT_H , # 0 
0B6A    C3            3577     	CLR	C
0B6B    7400          3578     MOV A , # 0 
0B6D    13            3579     	RRC	A
0B6E    FD            3580     MOV R5 , A 
0B6F    7455          3581     MOV A , # 85 
0B71    13            3582     	RRC	A
0B72    FC            3583     MOV R4 , A 
0B73    7455          3584     MOV A , # 85 
0B75    2C            3585     ADD A , R4 
0B76    FC            3586     MOV R4 , A 
0B77    7400          3587     MOV A , # 0 
0B79    3D            3588     ADDC A , R5 
0B7A    FD            3589     MOV R5 , A 
0B7B    EC            3590     MOV A , R4 
0B7C    FA            3591     MOV R2 , A 
0B7D    ED            3592     MOV A , R5 
0B7E    FB            3593     MOV R3 , A 
                      3594     MEASURE_LIPO_CELL_LOOP: 
                      3595     	; Check voltage against xS lower limit
0B7F    C3            3596     	CLR	C
0B80    E8            3597     MOV A , R0 
0B81    9A            3598     SUBB A , R2 
0B82    E9            3599     MOV A , R1 
0B83    9B            3600     SUBB A , R3 
0B84    4014          3601     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3602     
                      3603     	; Set xS voltage limit
0B86    E56A          3604     	MOV	A, LIPO_ADC_LIMIT_L		
0B88    2455          3605     ADD A , # 85 
0B8A    F56A          3606     	MOV	LIPO_ADC_LIMIT_L, A
0B8C    E56B          3607     	MOV	A, LIPO_ADC_LIMIT_H		
0B8E    3400          3608     ADDC A , # 0 
0B90    F56B          3609     	MOV	LIPO_ADC_LIMIT_H, A
                      3610     	; Set (x+1)S lower limit
0B92    EA            3611     MOV A , R2 
0B93    2C            3612     ADD A , R4 
0B94    FA            3613     MOV R2 , A 
0B95    EB            3614     MOV A , R3 
0B96    3D            3615     ADDC A , R5 
0B97    FB            3616     MOV R3 , A 
0B98    80E5          3617     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      3618     
                      3619     MEASURE_LIPO_ADJUST: 
0B9A    AE6A          3620     MOV R6 , LIPO_ADC_LIMIT_L 
0B9C    AF6B          3621     MOV R7 , LIPO_ADC_LIMIT_H 
                      3622     	; Calculate 3.125%
0B9E    C3            3623     	CLR	C
0B9F    E56B          3624     	MOV	A, LIPO_ADC_LIMIT_H
0BA1    13            3625     	RRC	A
0BA2    F9            3626     MOV R1 , A 
0BA3    E56A          3627     	MOV	A, LIPO_ADC_LIMIT_L	
0BA5    13            3628     	RRC	A
0BA6    F8            3629     MOV R0 , A 
0BA7    C3            3630     	CLR	C
0BA8    E9            3631     MOV A , R1 
0BA9    13            3632     	RRC	A
0BAA    F9            3633     MOV R1 , A 
0BAB    E8            3634     MOV A , R0 
0BAC    13            3635     	RRC	A
0BAD    F8            3636     MOV R0 , A 
0BAE    E56A          3637     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0BB0    28            3638     ADD A , R0 
0BB1    F568          3639     	MOV	LIPO_ADC_REFERENCE_L, A
0BB3    E56B          3640     	MOV	A, LIPO_ADC_LIMIT_H
0BB5    39            3641     ADDC A , R1 
0BB6    F569          3642     	MOV	LIPO_ADC_REFERENCE_H, A
                      3643     	; Divide three times to get to 3.125%
0BB8    7A03          3644     MOV R2 , # 3 
                      3645     MEASURE_LIPO_DIVIDE_LOOP: 
0BBA    C3            3646     	CLR	C
0BBB    E9            3647     MOV A , R1 
0BBC    13            3648     	RRC	A
0BBD    F9            3649     MOV R1 , A 
0BBE    E8            3650     MOV A , R0 
0BBF    13            3651     	RRC	A
0BC0    F8            3652     MOV R0 , A 
0BC1    DAF7          3653     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      3654     
                      3655     	; Add the programmed number of 0.1V (or 3.125% increments)
0BC3    AA20          3656     MOV R2 , BIT_ACCESS 
0BC5    1A            3657     DEC R2 
0BC6    7009          3658     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      3659     
0BC8    756A00        3660     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0BCB    756B00        3661     	MOV	LIPO_ADC_LIMIT_H, #0
0BCE    020BE1        3662     	JMP	MEASURE_LIPO_EXIT	
                      3663     
                      3664     MEASURE_LIPO_LIMIT_ON: 
0BD1    1A            3665     DEC R2 
0BD2    EA            3666     MOV A , R2 
0BD3    6008          3667     	JZ	MEASURE_LIPO_UPDATE
                      3668     
                      3669     MEASURE_LIPO_ADD_LOOP: 
0BD5    EE            3670     MOV A , R6 
0BD6    28            3671     ADD A , R0 
0BD7    FE            3672     MOV R6 , A 
0BD8    EF            3673     MOV A , R7 
0BD9    39            3674     ADDC A , R1 
0BDA    FF            3675     MOV R7 , A 
0BDB    DAF8          3676     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      3677     
                      3678     MEASURE_LIPO_UPDATE: 
                      3679     	; Set ADC limit
0BDD    8E6A          3680     MOV LIPO_ADC_LIMIT_L , R6 
0BDF    8F6B          3681     MOV LIPO_ADC_LIMIT_H , R7 
                      3682     MEASURE_LIPO_EXIT: 
0BE1    22            3683     	RET
                      3684     
                      3685     
                      3686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3687     ;
                      3688     ; Start ADC conversion
                      3689     ;
                      3690     ; No assumptions
                      3691     ;
                      3692     ; Start conversion used for measuring power supply voltage
                      3693     ;
                      3694     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3695     START_ADC_CONVERSION: 
                      3696     	; Start adc
                      3697     	START_ADC 
0BE2    75E890        3697+1   MOV ADC0CN , # 90H  ; ADC START
0BE5    22            3698     	RET
                      3699     
                      3700     
                      3701     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3702     ;
                      3703     ; Check temperature, power supply voltage and limit power
                      3704     ;
                      3705     ; No assumptions
                      3706     ;
                      3707     ; Used to limit main motor power in order to maintain the required voltage
                      3708     ;
                      3709     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3710     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      3711     	; Load programmed low voltage limit
0BE6    7883          3712     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0BE8    E6            3713     MOV A , @ R0 
0BE9    FF            3714     MOV R7 , A 
                      3715     	; Wait for ADC conversion to complete
                      3716     	GET_ADC_STATUS 
0BEA    E5E8          3716+1   MOV A , ADC0CN 
0BEC    20ECF7        3717     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      3718     	; Read ADC result
                      3719     	READ_ADC_RESULT
0BEF    A8BD          3719+1   MOV R0 , ADC0L 
0BF1    A9BE          3719+1   MOV R1 , ADC0H 
                      3720     	; Stop ADC
                      3721     	STOP_ADC
                      3722     
0BF3    056C          3723     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0BF5    C3            3724     	CLR	C
0BF6    E56C          3725     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0BF8    9408          3726     SUBB A , # 8 
0BFA    404B          3727     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      3728     
0BFC    756C00        3729     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0BFF    E9            3730     MOV A , R1 
0C00    7007          3731     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      3732     
0C02    E56D          3733     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0C04    601B          3734     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0C06    020C15        3735     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      3736     
                      3737     TEMP_AVERAGE_INC_DEC: 
0C09    C3            3738     	CLR	C
0C0A    E8            3739     MOV A , R0 
0C0B    956D          3740     	SUBB	A, CURRENT_AVERAGE_TEMP
0C0D    6010          3741     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      3742     
0C0F    E56D          3743     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0C11    5006          3744     	JNC	TEMP_AVERAGE_INC				
                      3745     
0C13    600C          3746     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      3747     TEMP_AVERAGE_DEC: 
0C15    14            3748     	DEC	A						; Decrement average
0C16    020C21        3749     	JMP	TEMP_AVERAGE_UPDATED
                      3750     
                      3751     TEMP_AVERAGE_INC: 
0C19    04            3752     	INC	A						; Increment average
0C1A    60F9          3753     	JZ	TEMP_AVERAGE_DEC
0C1C    020C21        3754     	JMP	TEMP_AVERAGE_UPDATED
                      3755     
                      3756     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0C1F    E56D          3757     	MOV	A, CURRENT_AVERAGE_TEMP
                      3758     TEMP_AVERAGE_UPDATED: 
0C21    F56D          3759     	MOV	CURRENT_AVERAGE_TEMP, A
0C23    C3            3760     	CLR	C
0C24    946D          3761     SUBB A , # 109 
0C26    401B          3762     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3763     
0C28    755EC0        3764     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3765     
0C2B    C3            3766     	CLR	C
0C2C    9404          3767     SUBB A , # 4 
0C2E    4013          3768     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3769     
0C30    755E80        3770     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3771     
0C33    C3            3772     	CLR	C
0C34    9404          3773     SUBB A , # 4 
0C36    400B          3774     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3775     
0C38    755E40        3776     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3777     
0C3B    C3            3778     	CLR	C
0C3C    9404          3779     SUBB A , # 4 
0C3E    4003          3780     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3781     
0C40    755E00        3782     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3783     
                      3784     TEMP_CHECK_EXIT: 
                      3785     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0C43    75BB08        3785+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0C46    22            3786     	RET
                      3787     
                      3788     CHECK_VOLTAGE_START: 
                      3789     IF MODE == 0 OR MODE == 2	; Main or multi
                      3790     	; Check if low voltage limiting is enabled
0C47    EF            3791     MOV A , R7 
0C48    C3            3792     	CLR	C
0C49    9401          3793     	SUBB	A, #1					; Is low voltage limit disabled?
0C4B    601B          3794     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      3795     
                      3796     	; Check if ADC is saturated
0C4D    C3            3797     	CLR	C
0C4E    E8            3798     MOV A , R0 
0C4F    94FF          3799     	SUBB	A, #0FFH
0C51    E9            3800     MOV A , R1 
0C52    9403          3801     	SUBB	A, #03H
0C54    5012          3802     	JNC	CHECK_VOLTAGE_GOOD			; ADC saturated, can not make judgement
                      3803     
                      3804     	; Check voltage against limit
0C56    C3            3805     	CLR	C
0C57    E8            3806     MOV A , R0 
0C58    956A          3807     	SUBB	A, LIPO_ADC_LIMIT_L
0C5A    E9            3808     MOV A , R1 
0C5B    956B          3809     	SUBB	A, LIPO_ADC_LIMIT_H
0C5D    5009          3810     	JNC	CHECK_VOLTAGE_GOOD			; If voltage above limit - branch
                      3811     
                      3812     	; Decrease pwm limit
0C5F    E55E          3813     	MOV  A, PWM_LIMIT
0C61    600C          3814     	JZ	CHECK_VOLTAGE_LIM			; If limit zero - branch
                      3815     
0C63    155E          3816     	DEC	PWM_LIMIT					; Decrement limit
0C65    020C6F        3817     	JMP	CHECK_VOLTAGE_LIM
                      3818     
                      3819     CHECK_VOLTAGE_GOOD: 
                      3820     	; Increase pwm limit
0C68    E55E          3821     	MOV  A, PWM_LIMIT
0C6A    F4            3822     	CPL	A			
0C6B    6002          3823     	JZ	CHECK_VOLTAGE_LIM			; If limit max - branch
                      3824     
0C6D    055E          3825     	INC	PWM_LIMIT					; Increment limit
                      3826     
                      3827     CHECK_VOLTAGE_LIM: 
0C6F    A85E          3828     MOV R0 , PWM_LIMIT 
0C71    C3            3829     	CLR	C
0C72    E524          3830     	MOV	A, CURRENT_PWM
0C74    98            3831     SUBB A , R0 
0C75    5002          3832     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3833     
0C77    A824          3834     MOV R0 , CURRENT_PWM 
                      3835     
                      3836     CHECK_VOLTAGE_SPOOLUP_LIM: 
                      3837     	; Slow spoolup
0C79    C3            3838     	CLR	C
0C7A    E8            3839     MOV A , R0 
0C7B    955F          3840     	SUBB	A, PWM_LIMIT_SPOOLUP
0C7D    400A          3841     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3842     
0C7F    A85F          3843     MOV R0 , PWM_LIMIT_SPOOLUP 
0C81    E55F          3844     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0C83    F4            3845     	CPL	A
0C84    6003          3846     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3847      
0C86    855F5E        3848     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3849     
                      3850     CHECK_VOLTAGE_EXIT: 
0C89    8825          3851     MOV CURRENT_PWM_LIMITED , R0 
                      3852     ENDIF
                      3853     	; Set adc mux for next conversion
0C8B    C3            3854     	CLR	C
0C8C    E56C          3855     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0C8E    B40703        3856     	CJNE	A, #(TEMP_CHECK_RATE-1), CHECK_VOLTAGE_RET
                      3857     
                      3858     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0C91    75BB10        3858+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3859     
                      3860     CHECK_VOLTAGE_RET: 
0C94    22            3861     	RET
                      3862     
                      3863     
                      3864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3865     ;
                      3866     ; Set startup PWM routine
                      3867     ;
                      3868     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                      3869     ;
                      3870     ; Used for pwm control during startup
                      3871     ;
                      3872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3873     SET_STARTUP_PWM: 	
                      3874     	; Set pwm values according to startup phase flags
0C95    306102        3875     JNB FLAGS1 . 1 , ( $+5 ) 
0C98    7832          3876     MOV R0 , # 50 
0C9A    306202        3877     JNB FLAGS1 . 2 , ( $+5 ) 
0C9D    7878          3878     MOV R0 , # 120 
                      3879     
                      3880     	; Update pwm variables if any startup phase flag is set
0C9F    E52C          3881     	MOV	A, FLAGS1
0CA1    5406          3882     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0CA3    601F          3883     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      3884     
                      3885     	; Adjust startup power
0CA5    E8            3886     MOV A , R0 
0CA6    79A2          3887     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0CA8    87F0          3888     MOV B , @ R1 
0CAA    A4            3889     	MUL	AB
0CAB    C5F0          3890     	XCH	A, B
0CAD    A2F7          3891     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0CAF    33            3892     	RLC	A
0CB0    F8            3893     MOV R0 , A 
0CB1    C3            3894     	CLR	C
0CB2    E8            3895     MOV A , R0 
0CB3    955E          3896     	SUBB	A, PWM_LIMIT	
0CB5    4002          3897     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      3898     
0CB7    A85E          3899     MOV R0 , PWM_LIMIT 
                      3900     
                      3901     STARTUP_PWM_SET_PWM: 
                      3902     	; Set pwm variables
0CB9    8822          3903     MOV REQUESTED_PWM , R0 
0CBB    8824          3904     MOV CURRENT_PWM , R0 
0CBD    8825          3905     MOV CURRENT_PWM_LIMITED , R0 
0CBF    306102        3906     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3907     
0CC2    8860          3908     MOV PWM_SPOOLUP_BEG , R0 
                      3909     
                      3910     STARTUP_PWM_EXIT: 
0CC4    22            3911     	RET
                      3912     
                      3913     
                      3914     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3915     ;
                      3916     ; Initialize all timings routine
                      3917     ;
                      3918     ; No assumptions
                      3919     ;
                      3920     ; Part of initialization before motor start
                      3921     ;
                      3922     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3923     INITIALIZE_ALL_TIMINGS:  
                      3924     	; Load programmed startup rpm
0CC5    788F          3925     MOV R0 , # PGM_STARTUP_RPM 
0CC7    E6            3926     MOV A , @ R0 
0CC8    FF            3927     MOV R7 , A 
                      3928     	; Check startup rpm setting and set step accordingly
0CC9    C3            3929     	CLR	C
0CCA    EF            3930     MOV A , R7 
0CCB    9405          3931     	SUBB	A, #5
0CCD    5018          3932     	JNC	STEPPER_STEP_HIGH
0CCF    C3            3933     	CLR	C
0CD0    EF            3934     MOV A , R7 
0CD1    9404          3935     	SUBB	A, #4
0CD3    5020          3936     	JNC	STEPPER_STEP_MED_HIGH
0CD5    C3            3937     	CLR	C
0CD6    EF            3938     MOV A , R7 
0CD7    9403          3939     	SUBB	A, #3
0CD9    5028          3940     	JNC	STEPPER_STEP_MED
0CDB    C3            3941     	CLR	C
0CDC    EF            3942     MOV A , R7 
0CDD    9402          3943     	SUBB	A, #2
0CDF    5030          3944     	JNC	STEPPER_STEP_MED_LOW
0CE1    C3            3945     	CLR	C
0CE2    EF            3946     MOV A , R7 
0CE3    9401          3947     	SUBB	A, #1
0CE5    5038          3948     	JNC	STEPPER_STEP_LOW
                      3949     
                      3950     STEPPER_STEP_HIGH: 
0CE7    7533A0        3951     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0CEA    75340F        3952     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0CED    75353C        3953     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0CF0    753605        3954     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0CF3    A12B          3955     	AJMP	STEPPER_STEP_SET
                      3956     STEPPER_STEP_MED_HIGH: 
0CF5    7533C0        3957     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0CF8    753412        3958     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0CFB    753540        3959     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0CFE    753606        3960     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0D01    A12B          3961     	AJMP	STEPPER_STEP_SET
                      3962     STEPPER_STEP_MED: 
0D03    753370        3963     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0D06    753417        3964     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0D09    7535D0        3965     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0D0C    753607        3966     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0D0F    A12B          3967     	AJMP	STEPPER_STEP_SET
                      3968     STEPPER_STEP_MED_LOW: 
0D11    75334C        3969     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0D14    75341D        3970     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0D17    7535C4        3971     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0D1A    753609        3972     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0D1D    A12B          3973     	AJMP	STEPPER_STEP_SET
                      3974     STEPPER_STEP_LOW: 
0D1F    753328        3975     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0D22    753423        3976     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0D25    7535B8        3977     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0D28    75360B        3978     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
                      3979     
                      3980     STEPPER_STEP_SET: 
0D2B    853350        3981     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0D2E    853451        3982     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0D31    753C00        3983     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0D34    753D08        3984     	MOV	COMM_PERIOD4X_H, #08H
0D37    22            3985     	RET
                      3986     
                      3987     
                      3988     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3989     ;
                      3990     ; Calculate next commutation timing routine
                      3991     ;
                      3992     ; No assumptions
                      3993     ;
                      3994     ; Called immediately after each commutation
                      3995     ; Also sets up timer 3 to wait advance timing
                      3996     ; Two entry points are used
                      3997     ;
                      3998     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3999     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0D38    A850          4000     MOV R0 , WT_STEPPER_STEP_L 
0D3A    A951          4001     MOV R1 , WT_STEPPER_STEP_H 
0D3C    020D43        4002     	JMP	READ_TIMER
                      4003     
                      4004     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0D3F    A84A          4005     MOV R0 , WT_ADVANCE_L 
0D41    A94B          4006     MOV R1 , WT_ADVANCE_H 
                      4007     READ_TIMER: 
                      4008     	; Set up next wait
0D43    759100        4009     	MOV	TMR3CN, #00H		; Timer3 disabled
0D46    C3            4010     	CLR	C
0D47    E4            4011     	CLR	A
0D48    98            4012     SUBB A , R0 
0D49    F594          4013     	MOV	TMR3L, A
0D4B    E4            4014     	CLR	A
0D4C    99            4015     SUBB A , R1 
0D4D    F595          4016     	MOV	TMR3H, A
0D4F    759104        4017     	MOV	TMR3CN, #04H		; Timer3 enabled
0D52    D258          4018     SETB FLAGS0 . 0 
                      4019     	; Read commutation time
0D54    75C820        4020     	MOV	TMR2CN, #20H		; Timer2 disabled
0D57    A8CC          4021     MOV R0 , TMR2L 
0D59    A9CD          4022     MOV R1 , TMR2H 
0D5B    75C824        4023     	MOV	TMR2CN, #24H		; Timer2 enabled
                      4024     	; Calculate this commutation time
0D5E    AA3A          4025     MOV R2 , PREV_COMM_L 
0D60    AB3B          4026     MOV R3 , PREV_COMM_H 
0D62    883A          4027     MOV PREV_COMM_L , R0 
0D64    893B          4028     MOV PREV_COMM_H , R1 
0D66    C3            4029     	CLR	C
0D67    E8            4030     MOV A , R0 
0D68    9A            4031     SUBB A , R2 
0D69    F8            4032     MOV R0 , A 
0D6A    E9            4033     MOV A , R1 
0D6B    9B            4034     SUBB A , R3 
0D6C    F9            4035     MOV R1 , A 
                      4036     	; Calculate next zero cross scan timeout 
0D6D    AA3C          4037     MOV R2 , COMM_PERIOD4X_L 
0D6F    AB3D          4038     MOV R3 , COMM_PERIOD4X_H 
0D71    C3            4039     	CLR	C
0D72    EB            4040     MOV A , R3 
0D73    13            4041     	RRC	A					; Divide by 2
0D74    FD            4042     MOV R5 , A 
0D75    EA            4043     MOV A , R2 
0D76    13            4044     	RRC	A
0D77    FC            4045     MOV R4 , A 
0D78    C3            4046     	CLR	C
0D79    ED            4047     MOV A , R5 
0D7A    13            4048     	RRC	A					; Divide by 2 again
0D7B    FD            4049     MOV R5 , A 
0D7C    EC            4050     MOV A , R4 
0D7D    13            4051     	RRC	A
0D7E    FC            4052     MOV R4 , A 
0D7F    C3            4053     	CLR	C
0D80    EA            4054     MOV A , R2 
0D81    9C            4055     SUBB A , R4 
0D82    FA            4056     MOV R2 , A 
0D83    EB            4057     MOV A , R3 
0D84    9D            4058     SUBB A , R5 
0D85    FB            4059     MOV R3 , A 
                      4060     
0D86    EA            4061     MOV A , R2 
0D87    28            4062     ADD A , R0 
0D88    FA            4063     MOV R2 , A 
0D89    EB            4064     MOV A , R3 
0D8A    39            4065     ADDC A , R1 
0D8B    FB            4066     MOV R3 , A 
0D8C    8A3C          4067     MOV COMM_PERIOD4X_L , R2 
0D8E    8B3D          4068     MOV COMM_PERIOD4X_H , R3 
0D90    4001          4069     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4070     
0D92    22            4071     	RET
                      4072     
                      4073     CALC_NEXT_COMM_SLOW: 
0D93    753CFF        4074     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0D96    753DFF        4075     	MOV	COMM_PERIOD4X_H, #0FFH
0D99    22            4076     	RET
                      4077     
                      4078     
                      4079     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4080     ;
                      4081     ; Setup zero cross scan wait
                      4082     ;
                      4083     ; No assumptions
                      4084     ;
                      4085     ; Sets up timer 3 to wait the zero cross scan wait time
                      4086     ;
                      4087     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4088     SETUP_ZC_SCAN_WAIT: 
0D9A    759100        4089     	MOV	TMR3CN, #00H		; Timer3 disabled
0D9D    C3            4090     	CLR	C
0D9E    E4            4091     	CLR	A
0D9F    954C          4092     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0DA1    F594          4093     	MOV	TMR3L, A
0DA3    E4            4094     	CLR	A
0DA4    954D          4095     	SUBB	A, WT_ZC_SCAN_H		
0DA6    F595          4096     	MOV	TMR3H, A
0DA8    759104        4097     	MOV	TMR3CN, #04H		; Timer3 enabled
0DAB    D258          4098     SETB FLAGS0 . 0 
0DAD    22            4099     	RET
                      4100     
                      4101     
                      4102     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4103     ;
                      4104     ; Wait advance timing routine
                      4105     ;
                      4106     ; No assumptions
                      4107     ;
                      4108     ; Waits for the advance timing to elapse, waits one zero cross
                      4109     ; wait and sets up the next zero cross wait
                      4110     ;
                      4111     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4112     WAIT_ADVANCE_TIMING: 	
0DAE    7F01          4113     MOV R7 , # 1 
0DB0    789C          4114     MOV R0 , # PGM_DEMAG_COMP 
0DB2    E6            4115     MOV A , @ R0 
0DB3    14            4116     	DEC	A
0DB4    6002          4117     	JZ	WAIT_ADVANCE_TIMING_WAIT
                      4118     
0DB6    7F02          4119     MOV R7 , # 2 
                      4120     
                      4121     WAIT_ADVANCE_TIMING_WAIT: 
0DB8    305802        4122     JNB FLAGS0 . 0 , ( $+5 ) 
0DBB    A1B8          4123     	AJMP	WAIT_ADVANCE_TIMING_WAIT
                      4124     
0DBD    B19A          4125     	CALL	SETUP_ZC_SCAN_WAIT					; Setup wait time
0DBF    DFF7          4126     DJNZ R7 , WAIT_ADVANCE_TIMING_WAIT 
                      4127     
0DC1    22            4128     	RET
                      4129     
                      4130     
                      4131     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4132     ;
                      4133     ; Calculate new wait times routine
                      4134     ;
                      4135     ; No assumptions
                      4136     ;
                      4137     ; Calculates new wait times
                      4138     ;
                      4139     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4140     CALC_NEW_WAIT_TIMES: 	
                      4141     	; Load programmed commutation timing
0DC2    7892          4142     MOV R0 , # PGM_COMM_TIMING 
0DC4    E6            4143     MOV A , @ R0 
0DC5    FF            4144     MOV R7 , A 
0DC6    7E14          4145     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
                      4146     IF MODE == 2
0DC8    A83D          4147     MOV R0 , COMM_PERIOD4X_H 
0DCA    C3            4148     	CLR	C					; A COMM_TIME_RED of 6 gives good acceleration performance on pancake motor at high voltage
0DCB    E8            4149     MOV A , R0 
0DCC    9404          4150     	SUBB	A, #4
0DCE    4002          4151     	JC	CALC_NEW_WAIT_RED_SET
                      4152     
0DD0    7804          4153     MOV R0 , # 4 
                      4154     
                      4155     CALC_NEW_WAIT_RED_SET: 
0DD2    C3            4156     	CLR	C
0DD3    E8            4157     MOV A , R0 
0DD4    33            4158     	RLC	A
0DD5    F8            4159     MOV R0 , A 
0DD6    C3            4160     	CLR	C
0DD7    EE            4161     MOV A , R6 
0DD8    98            4162     SUBB A , R0 
0DD9    FE            4163     MOV R6 , A 
                      4164     ENDIF
0DDA    306304        4165     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4166     
0DDD    7F03          4167     MOV R7 , # 3 
0DDF    7E00          4168     MOV R6 , # 0 
                      4169     
                      4170     CALC_NEW_WAIT_DIR_START_SET: 
                      4171     	; Load current commutation timing
0DE1    A93D          4172     MOV R1 , COMM_PERIOD4X_H 
0DE3    A83C          4173     MOV R0 , COMM_PERIOD4X_L 
0DE5    7A04          4174     MOV R2 , # 4 
                      4175     DIVIDE_WAIT_TIMES: 
0DE7    C3            4176     	CLR	C
0DE8    E9            4177     MOV A , R1 
0DE9    13            4178     	RRC	A					; Divide by 2
0DEA    F9            4179     MOV R1 , A 
0DEB    E8            4180     MOV A , R0 
0DEC    13            4181     	RRC	A
0DED    F8            4182     MOV R0 , A 
0DEE    DAF7          4183     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4184     
0DF0    C3            4185     	CLR	C
0DF1    E8            4186     MOV A , R0 
0DF2    9E            4187     SUBB A , R6 
0DF3    F8            4188     MOV R0 , A 
0DF4    E9            4189     MOV A , R1 
0DF5    9400          4190     	SUBB	A, #0
0DF7    F9            4191     MOV R1 , A 
0DF8    4009          4192     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4193     
0DFA    C3            4194     	CLR	C
0DFB    E8            4195     MOV A , R0 
0DFC    9402          4196     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0DFE    E9            4197     MOV A , R1 
0DFF    9400          4198     	SUBB	A, #0
0E01    5004          4199     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4200     
                      4201     LOAD_MIN_TIME: 
0E03    7802          4202     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0E05    E4            4203     	CLR	A
0E06    F9            4204     MOV R1 , A 
                      4205     
                      4206     ADJUST_TIMING: 
0E07    E9            4207     MOV A , R1 
0E08    FB            4208     MOV R3 , A 
0E09    E8            4209     MOV A , R0 
0E0A    FA            4210     MOV R2 , A 
0E0B    C3            4211     	CLR	C
0E0C    E9            4212     MOV A , R1 
0E0D    13            4213     	RRC	A					; Divide by 2
0E0E    FD            4214     MOV R5 , A 
0E0F    E8            4215     MOV A , R0 
0E10    13            4216     	RRC	A
0E11    FC            4217     MOV R4 , A 
0E12    C3            4218     	CLR	C
0E13    EF            4219     MOV A , R7 
0E14    9403          4220     	SUBB	A, #3				; Is timing normal?
0E16    602E          4221     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4222     
0E18    EF            4223     MOV A , R7 
0E19    20E00D        4224     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4225     
0E1C    E8            4226     MOV A , R0 
0E1D    2C            4227     ADD A , R4 
0E1E    F8            4228     MOV R0 , A 
0E1F    E9            4229     MOV A , R1 
0E20    3D            4230     ADDC A , R5 
0E21    F9            4231     MOV R1 , A 
0E22    EC            4232     MOV A , R4 
0E23    FA            4233     MOV R2 , A 
0E24    ED            4234     MOV A , R5 
0E25    FB            4235     MOV R3 , A 
0E26    020E33        4236     	JMP	STORE_TIMES_UP_OR_DOWN
                      4237     
                      4238     ADJUST_TIMING_TWO_STEPS: 
0E29    E8            4239     MOV A , R0 
0E2A    28            4240     ADD A , R0 
0E2B    F8            4241     MOV R0 , A 
0E2C    E9            4242     MOV A , R1 
0E2D    39            4243     ADDC A , R1 
0E2E    F9            4244     MOV R1 , A 
0E2F    7A02          4245     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0E31    E4            4246     	CLR	A
0E32    FB            4247     MOV R3 , A 
                      4248     
                      4249     STORE_TIMES_UP_OR_DOWN: 
0E33    C3            4250     	CLR	C
0E34    EF            4251     MOV A , R7 
0E35    9403          4252     	SUBB	A, #3				; Is timing higher than normal?
0E37    400D          4253     	JC	STORE_TIMES_DECREASE	; No - branch
                      4254     
                      4255     STORE_TIMES_INCREASE: 
0E39    8A4E          4256     MOV WT_COMM_L , R2 
0E3B    8B4F          4257     MOV WT_COMM_H , R3 
0E3D    884A          4258     MOV WT_ADVANCE_L , R0 
0E3F    894B          4259     MOV WT_ADVANCE_H , R1 
0E41    8C4C          4260     MOV WT_ZC_SCAN_L , R4 
0E43    8D4D          4261     MOV WT_ZC_SCAN_H , R5 
0E45    22            4262     	RET
                      4263     
                      4264     STORE_TIMES_DECREASE: 
0E46    884E          4265     MOV WT_COMM_L , R0 
0E48    894F          4266     MOV WT_COMM_H , R1 
0E4A    8A4A          4267     MOV WT_ADVANCE_L , R2 
0E4C    8B4B          4268     MOV WT_ADVANCE_H , R3 
0E4E    8C4C          4269     MOV WT_ZC_SCAN_L , R4 
0E50    8D4D          4270     MOV WT_ZC_SCAN_H , R5 
0E52    22            4271     	RET
                      4272     
                      4273     
                      4274     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4275     ;
                      4276     ; Wait before zero cross scan routine
                      4277     ;
                      4278     ; No assumptions
                      4279     ;
                      4280     ; Waits for the zero cross scan wait time to elapse
                      4281     ; Also sets up timer 3 to wait the zero cross scan timeout time
                      4282     ;
                      4283     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4284     WAIT_BEFORE_ZC_SCAN: 	
0E53    305802        4285     JNB FLAGS0 . 0 , ( $+5 ) 
0E56    C153          4286     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4287     
0E58    759100        4288     	MOV	TMR3CN, #00H		; Timer3 disabled
0E5B    C3            4289     	CLR	C
0E5C    E4            4290     	CLR	A
0E5D    953C          4291     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0E5F    F594          4292     	MOV	TMR3L, A
0E61    E4            4293     	CLR	A
0E62    953D          4294     	SUBB	A, COMM_PERIOD4X_H		
0E64    F595          4295     	MOV	TMR3H, A
0E66    759104        4296     	MOV	TMR3CN, #04H		; Timer3 enabled
0E69    D258          4297     SETB FLAGS0 . 0 
0E6B    22            4298     	RET
                      4299     
                      4300     
                      4301     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4302     ;
                      4303     ; Wait for comparator to go low/high routines
                      4304     ;
                      4305     ; No assumptions
                      4306     ;
                      4307     ; Waits for the zero cross scan wait time to elapse
                      4308     ; Then scans for comparator going low/high
                      4309     ;
                      4310     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4311     WAIT_FOR_COMP_OUT_LOW: 
0E6C    753F00        4312     	MOV	COMP_WAIT_READS, #0
0E6F    752000        4313     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0E72    020E7B        4314     	JMP	WAIT_FOR_COMP_OUT_START
                      4315     
                      4316     WAIT_FOR_COMP_OUT_HIGH: 
0E75    753F00        4317     	MOV	COMP_WAIT_READS, #0
0E78    752040        4318     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4319     
                      4320     WAIT_FOR_COMP_OUT_START: 
0E7B    D2AF          4321     	SETB	EA						; Enable interrupts
0E7D    053F          4322     	INC	COMP_WAIT_READS
0E7F    205801        4323     JB FLAGS0 . 0 , ( $+4 ) 
0E82    22            4324     	RET							; Yes - return
                      4325     
                      4326     	; Set default comparator response times
0E83    759D00        4327     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4328     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4331     	; Select number of comparator readings based upon current rotation speed
0E86    E53D          4332     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0E88    C3            4333     	CLR	C
0E89    13            4334     	RRC	A						; Divide by 4
0E8A    C3            4335     	CLR	C
0E8B    13            4336     	RRC	A
0E8C    F8            4337     MOV R0 , A 
0E8D    08            4338     INC R0 
0E8E    6030          4339     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      4340     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0E90    306A06        4341     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      4342     
0E93    C3            4343     	CLR	C
0E94    13            4344     	RRC	A						; Divide by 4 again
0E95    C3            4345     	CLR	C
0E96    13            4346     	RRC	A
0E97    F8            4347     MOV R0 , A 
0E98    08            4348     INC R0 
                      4349     
                      4350     COMP_WAIT_SET_MAX_READINGS: 
0E99    C3            4351     	CLR	C
0E9A    E8            4352     MOV A , R0 
0E9B    940A          4353     	SUBB	A, #10
0E9D    4002          4354     	JC	($+4)
                      4355     
0E9F    780A          4356     MOV R0 , # 10 
                      4357     
0EA1    306D08        4358     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      4359     
0EA4    C3            4360     	CLR	C
0EA5    E8            4361     MOV A , R0 
0EA6    9404          4362     	SUBB	A, #4
0EA8    4002          4363     	JC	($+4)
                      4364     
0EAA    7804          4365     MOV R0 , # 4 
                      4366     
                      4367     COMP_WAIT_SET_RESPONSE_TIME: 
0EAC    C3            4368     	CLR	C
0EAD    E53D          4369     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0EAF    9408          4370     	SUBB	A, #8
0EB1    400D          4371     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4372     
0EB3    759D02        4373     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      4374     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0EB6    C3            4377     	CLR	C
0EB7    E53D          4378     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0EB9    9410          4379     	SUBB	A, #16
0EBB    4003          4380     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4381     
0EBD    759D03        4382     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4383     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      4386     
                      4387     COMP_WAIT_ON_COMP_ABLE: 
0EC0    205803        4388     JB FLAGS0 . 0 , ( $+6 ) 
0EC3    D2AF          4389     	SETB	EA							; Enable interrupts
0EC5    22            4390     	RET								; Yes - return
                      4391     
0EC6    7918          4392     MOV R1 , # 24 
0EC8    206D02        4393     JB FLAGS2 . 5 , ( $+5 ) 
0ECB    7908          4394     MOV R1 , # 8 
0ECD    D2AF          4395     	SETB	EA							; Enable interrupts
0ECF    00            4396     	NOP								; Allocate only just enough time to capture interrupt
0ED0    00            4397     	NOP
0ED1    C2AF          4398     	CLR	EA							; Disable interrupts
0ED3    205A0A        4399     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      4400     
0ED6    7914          4401     MOV R1 , # 20 
0ED8    206D02        4402     JB FLAGS2 . 5 , ( $+5 ) 
0EDB    7907          4403     MOV R1 , # 7 
0EDD    3066E0        4404     JNB FLAGS1 . 6 , COMP_WAIT_ON_COMP_ABLE 
                      4405     
                      4406     PWM_WAIT_STARTUP: 						
0EE0    306302        4407     JNB FLAGS1 . 3 , PWM_WAIT 
                      4408     
0EE3    7978          4409     MOV R1 , # 120 
                      4410     PWM_WAIT: 						
0EE5    C3            4411     	CLR	C
0EE6    E58B          4412     	MOV	A, TL1
0EE8    99            4413     SUBB A , R1 
                      4414     IF MODE == 1 AND DAMPED_MODE_ENABLE == 1; Assume same pwm cycle for fast tail escs
                               	JB	FLAGS1.DIRECT_STARTUP_PHASE, ($+5)
                               	JC	PWM_WAIT
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                               ELSE
0EE9    40D5          4419     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                      4420     ENDIF
                      4421     
                      4422     COMP_READ: 
                      4423     	READ_COMP_OUT 					; Read comparator output
0EEB    E59B          4423+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0EED    F4            4424     	CPL	A
0EEE    5440          4425     	ANL	A, #40H
0EF0    B52002        4426     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      4427     
0EF3    C17B          4428     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      4429     
0EF5    D8C9          4430     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      4431     
0EF7    D2AF          4432     	SETB	EA						; Enable interrupts
0EF9    22            4433     	RET							
                      4434     
                      4435     
                      4436     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4437     ;
                      4438     ; Evaluate comparator integrity
                      4439     ;
                      4440     ; No assumptions
                      4441     ;
                      4442     ; Checks comparator signal behaviour versus expected behaviour
                      4443     ;
                      4444     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4445     EVALUATE_COMPARATOR_INTEGRITY: 
0EFA    C25B          4446     CLR FLAGS0 . 3 
                      4447     	; Check if demag compensation is enabled
0EFC    789C          4448     MOV R0 , # PGM_DEMAG_COMP 
0EFE    E6            4449     MOV A , @ R0 
0EFF    14            4450     	DEC	A
0F00    600A          4451     	JZ	EVAL_COMP_NO_DEMAG
                      4452     
                      4453     	; Check if a demag situation has occurred
0F02    E53F          4454     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0F04    14            4455     	DEC	A
0F05    7005          4456     	JNZ	EVAL_COMP_NO_DEMAG
                      4457     
0F07    206302        4458     JB FLAGS1 . 3 , EVAL_COMP_NO_DEMAG 
                      4459     
0F0A    D25B          4460     SETB FLAGS0 . 3 
                      4461     
                      4462     EVAL_COMP_NO_DEMAG: 
0F0C    30630B        4463     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      4464     
0F0F    0538          4465     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0F11    205810        4466     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4467     
0F14    753800        4468     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0F17    020F24        4469     	JMP	EVAL_COMP_EXIT
                      4470     
                      4471     EVAL_COMP_CHECK_TIMEOUT: 
0F1A    205807        4472     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0F1D    1581          4473     	DEC	SP							; Routine exit without "ret" command
0F1F    1581          4474     	DEC	SP
0F21    02182A        4475     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4476     
                      4477     EVAL_COMP_EXIT: 
0F24    22            4478     	RET
                      4479     
                      4480     
                      4481     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4482     ;
                      4483     ; Setup commutation timing routine
                      4484     ;
                      4485     ; No assumptions
                      4486     ;
                      4487     ; Sets up and starts wait from commutation to zero cross
                      4488     ;
                      4489     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4490     SETUP_COMM_WAIT:  
0F25    759100        4491     	MOV	TMR3CN, #00H		; Timer3 disabled
0F28    C3            4492     	CLR	C
0F29    E4            4493     	CLR	A
0F2A    954E          4494     	SUBB	A, WT_COMM_L		; Set wait commutation value
0F2C    F594          4495     	MOV	TMR3L, A
0F2E    E4            4496     	CLR	A
0F2F    954F          4497     	SUBB	A, WT_COMM_H		
0F31    F595          4498     	MOV	TMR3H, A
0F33    759104        4499     	MOV	TMR3CN, #04H		; Timer3 enabled
0F36    D258          4500     SETB FLAGS0 . 0 
0F38    22            4501     	RET
                      4502     
                      4503     
                      4504     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4505     ;
                      4506     ; Wait for commutation routine
                      4507     ;
                      4508     ; No assumptions
                      4509     ;
                      4510     ; Waits from zero cross to commutation 
                      4511     ;
                      4512     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4513     WAIT_FOR_COMM:  
                      4514     	; Increment or reset consecutive count
0F39    0539          4515     	INC	DEMAG_CONSECUTIVE_CNT
0F3B    205B03        4516     JB FLAGS0 . 3 , ( $+6 ) 
                      4517     
0F3E    753900        4518     	MOV	DEMAG_CONSECUTIVE_CNT, #0
                      4519     
                      4520     	; Check if a demag situation has occurred
0F41    305B23        4521     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      4522     
                      4523     	; Load programmed demag compensation
0F44    78A3          4524     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0F46    E6            4525     MOV A , @ R0 
0F47    FF            4526     MOV R7 , A 
                      4527     
                      4528     	; Check for power off
0F48    BF0108        4529     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      4530     
0F4B    D25C          4531     SETB FLAGS0 . 4 
                      4532     	ALL_NFETS_OFF
0F4D    D297          4532+1   SETB P1 . 7 
0F4F    D295          4532+1   SETB P1 . 5 
0F51    D293          4532+1   SETB P1 . 3 
                      4533     
                      4534     	; Wait a blind wait
                      4535     WAIT_FOR_COMM_BLIND: 
0F53    B19A          4536     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      4537     WAIT_DEMAG_DEFAULT_ZC: 	
0F55    305802        4538     JNB FLAGS0 . 0 , ( $+5 ) 
0F58    E155          4539     	AJMP	WAIT_DEMAG_DEFAULT_ZC
                      4540     
                      4541     	; Check for power off
0F5A    BF0208        4542     CJNE R7 , # 2 , WAIT_FOR_COMM_SETUP 
                      4543     
0F5D    D25C          4544     SETB FLAGS0 . 4 
                      4545     	ALL_NFETS_OFF
0F5F    D297          4545+1   SETB P1 . 7 
0F61    D295          4545+1   SETB P1 . 5 
0F63    D293          4545+1   SETB P1 . 3 
                      4546     
                      4547     WAIT_FOR_COMM_SETUP: 
0F65    F125          4548     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      4549     WAIT_FOR_COMM_WAIT: 
0F67    305802        4550     JNB FLAGS0 . 0 , ( $+5 ) 
0F6A    E167          4551     	AJMP	WAIT_FOR_COMM_WAIT					
                      4552     
0F6C    22            4553     	RET
                      4554     
                      4555     
                      4556     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4557     ;
                      4558     ; Commutation routines
                      4559     ;
                      4560     ; No assumptions
                      4561     ;
                      4562     ; Performs commutation switching 
                      4563     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4564     ;
                      4565     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4566     COMM1COMM2: 	
0F6D    C2AF          4567     	CLR 	EA					; Disable all interrupts
                      4568     	BPFET_OFF					; Bp off
0F6F    C294          4568+1   CLR P1 . 4 
0F71    206A03        4569     JB FLAGS2 . 2 , COMM12_DAMP 
0F74    020F8C        4570     	JMP	COMM12_NONDAMP
                      4571     COMM12_DAMP: 
                      4572     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      4576     IF DAMPED_MODE_ENABLE == 1
0F77    900347        4577     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      4578     ENDIF
0F7A    30650F        4579     JNB FLAGS1 . 5 , COMM12_NONDAMP 
                      4580     	CPFET_OFF				
0F7D    207502        4580+1   JB FLAGS3 . 5 , ( $+5 ) 
0F80    C292          4580+1   CLR P1 . 2 
0F82    307502        4580+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F85    C296          4580+1   CLR P1 . 6 
0F87    7406          4581     MOV A , # 6 
0F89    D5E0FD        4582     	DJNZ ACC,	$
                      4583     COMM12_NONDAMP: 
                      4584     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4585     	ANFET_ON				
0F8C    E525          4585+1   MOV A , CURRENT_PWM_LIMITED 
0F8E    600A          4585+1   JZ ( $+12 ) 
0F90    207502        4585+1   JB FLAGS3 . 5 , ( $+5 ) 
0F93    C297          4585+1   CLR P1 . 7 
0F95    307502        4585+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F98    C293          4585+1   CLR P1 . 3 
0F9A    740F          4586     MOV A , # 15 
0F9C    D5E0FD        4587     	DJNZ ACC,	$
                      4588     	ANFET_OFF				
0F9F    207502        4588+1   JB FLAGS3 . 5 , ( $+5 ) 
0FA2    D297          4588+1   SETB P1 . 7 
0FA4    307502        4588+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FA7    D293          4588+1   SETB P1 . 3 
0FA9    7406          4589     MOV A , # 6 
0FAB    D5E0FD        4590     	DJNZ ACC,	$
                      4591     ENDIF
                      4592     	APFET_ON					; Ap on
0FAE    207502        4592+1   JB FLAGS3 . 5 , ( $+5 ) 
0FB1    D296          4592+1   SETB P1 . 6 
0FB3    307502        4592+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FB6    D292          4592+1   SETB P1 . 2 
                      4593     	SET_COMP_PHASE_B 			; Set comparator to phase B
0FB8    759F10        4593+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0FBB    753E02        4594     	MOV	COMM_PHASE, #2
0FBE    02114D        4595     	JMP	COMM_EXIT
                      4596     
                      4597     COMM2COMM3: 	
0FC1    C2AF          4598     	CLR 	EA					; Disable all interrupts
0FC3    206A03        4599     JB FLAGS2 . 2 , COMM23_DAMP 
0FC6    020FE3        4600     	JMP	COMM23_NONDAMP
                      4601     COMM23_DAMP: 
                      4602     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      4605     IF DAMPED_MODE_ENABLE == 1
0FC9    9002FE        4606     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      4607     ENDIF
0FCC    306517        4608     JNB FLAGS1 . 5 , COMM23_NFET 
                      4609     	BPFET_OFF				
0FCF    C294          4609+1   CLR P1 . 4 
                      4610     	CPFET_OFF				
0FD1    207502        4610+1   JB FLAGS3 . 5 , ( $+5 ) 
0FD4    C292          4610+1   CLR P1 . 2 
0FD6    307502        4610+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FD9    C296          4610+1   CLR P1 . 6 
0FDB    7406          4611     MOV A , # 6 
0FDD    D5E0FD        4612     	DJNZ ACC,	$
0FE0    020FE6        4613     	JMP	COMM23_NFET
                      4614     COMM23_NONDAMP: 
0FE3    9001E1        4615     	MOV	DPTR, #PWM_BFET_ON	
                      4616     COMM23_NFET: 
                      4617     	CNFET_OFF					; Cn off
0FE6    207502        4617+1   JB FLAGS3 . 5 , ( $+5 ) 
0FE9    D293          4617+1   SETB P1 . 3 
0FEB    307502        4617+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FEE    D297          4617+1   SETB P1 . 7 
0FF0    305A06        4618     JNB FLAGS0 . 2 , COMM23_CP 
                      4619     	BNFET_ON					; Yes - Bn on
0FF3    E525          4619+1   MOV A , CURRENT_PWM_LIMITED 
0FF5    6002          4619+1   JZ ( $+4 ) 
0FF7    C295          4619+1   CLR P1 . 5 
                      4620     COMM23_CP: 
                      4621     	SET_COMP_PHASE_C 			; Set comparator to phase C
0FF9    207503        4621+1   JB FLAGS3 . 5 , ( $+6 ) 
0FFC    759F13        4621+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0FFF    307503        4621+1   JNB FLAGS3 . 5 , ( $+6 ) 
1002    759F11        4621+1   MOV CPT0MX , # 11H 
1005    753E03        4622     	MOV	COMM_PHASE, #3
1008    02114D        4623     	JMP	COMM_EXIT
                      4624     
                      4625     COMM3COMM4: 	
100B    C2AF          4626     	CLR 	EA					; Disable all interrupts
                      4627     	APFET_OFF					; Ap off
100D    207502        4627+1   JB FLAGS3 . 5 , ( $+5 ) 
1010    C296          4627+1   CLR P1 . 6 
1012    307502        4627+1   JNB FLAGS3 . 5 , ( $+5 ) 
1015    C292          4627+1   CLR P1 . 2 
1017    206A03        4628     JB FLAGS2 . 2 , COMM34_DAMP 
101A    02102A        4629     	JMP	COMM34_NONDAMP
                      4630     COMM34_DAMP: 
                      4631     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      4635     IF DAMPED_MODE_ENABLE == 1
101D    9002BD        4636     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      4637     ENDIF
1020    306507        4638     JNB FLAGS1 . 5 , COMM34_NONDAMP 
                      4639     	BPFET_OFF				
1023    C294          4639+1   CLR P1 . 4 
1025    7406          4640     MOV A , # 6 
1027    D5E0FD        4641     	DJNZ ACC,	$
                      4642     COMM34_NONDAMP: 
                      4643     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4644     	CNFET_ON				
102A    E525          4644+1   MOV A , CURRENT_PWM_LIMITED 
102C    600A          4644+1   JZ ( $+12 ) 
102E    207502        4644+1   JB FLAGS3 . 5 , ( $+5 ) 
1031    C293          4644+1   CLR P1 . 3 
1033    307502        4644+1   JNB FLAGS3 . 5 , ( $+5 ) 
1036    C297          4644+1   CLR P1 . 7 
1038    740F          4645     MOV A , # 15 
103A    D5E0FD        4646     	DJNZ ACC,	$
                      4647     	CNFET_OFF				
103D    207502        4647+1   JB FLAGS3 . 5 , ( $+5 ) 
1040    D293          4647+1   SETB P1 . 3 
1042    307502        4647+1   JNB FLAGS3 . 5 , ( $+5 ) 
1045    D297          4647+1   SETB P1 . 7 
1047    7406          4648     MOV A , # 6 
1049    D5E0FD        4649     	DJNZ ACC,	$
                      4650     ENDIF
                      4651     	CPFET_ON					; Cp on
104C    207502        4651+1   JB FLAGS3 . 5 , ( $+5 ) 
104F    D292          4651+1   SETB P1 . 2 
1051    307502        4651+1   JNB FLAGS3 . 5 , ( $+5 ) 
1054    D296          4651+1   SETB P1 . 6 
                      4652     	SET_COMP_PHASE_A 			; Set comparator to phase A
1056    207503        4652+1   JB FLAGS3 . 5 , ( $+6 ) 
1059    759F11        4652+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
105C    307503        4652+1   JNB FLAGS3 . 5 , ( $+6 ) 
105F    759F13        4652+1   MOV CPT0MX , # 13H 
1062    753E04        4653     	MOV	COMM_PHASE, #4
1065    02114D        4654     	JMP	COMM_EXIT
                      4655     
                      4656     COMM4COMM5: 	
1068    C2AF          4657     	CLR 	EA					; Disable all interrupts
106A    206A03        4658     JB FLAGS2 . 2 , COMM45_DAMP 
106D    02108A        4659     	JMP	COMM45_NONDAMP
                      4660     COMM45_DAMP: 
                      4661     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      4664     IF DAMPED_MODE_ENABLE == 1
1070    90027C        4665     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4666     ENDIF
1073    306517        4667     JNB FLAGS1 . 5 , COMM45_NFET 
                      4668     	APFET_OFF				
1076    207502        4668+1   JB FLAGS3 . 5 , ( $+5 ) 
1079    C296          4668+1   CLR P1 . 6 
107B    307502        4668+1   JNB FLAGS3 . 5 , ( $+5 ) 
107E    C292          4668+1   CLR P1 . 2 
                      4669     	BPFET_OFF				
1080    C294          4669+1   CLR P1 . 4 
1082    7406          4670     MOV A , # 6 
1084    D5E0FD        4671     	DJNZ ACC,	$
1087    02108D        4672     	JMP	COMM45_NFET
                      4673     COMM45_NONDAMP: 
108A    9001CF        4674     	MOV	DPTR, #PWM_AFET_ON
                      4675     COMM45_NFET: 
                      4676     	BNFET_OFF					; Bn off
108D    D295          4676+1   SETB P1 . 5 
108F    305A0E        4677     JNB FLAGS0 . 2 , COMM45_CP 
                      4678     	ANFET_ON					; Yes - An on
1092    E525          4678+1   MOV A , CURRENT_PWM_LIMITED 
1094    600A          4678+1   JZ ( $+12 ) 
1096    207502        4678+1   JB FLAGS3 . 5 , ( $+5 ) 
1099    C297          4678+1   CLR P1 . 7 
109B    307502        4678+1   JNB FLAGS3 . 5 , ( $+5 ) 
109E    C293          4678+1   CLR P1 . 3 
                      4679     COMM45_CP: 
                      4680     	SET_COMP_PHASE_B 			; Set comparator to phase B
10A0    759F10        4680+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
10A3    753E05        4681     	MOV	COMM_PHASE, #5
10A6    02114D        4682     	JMP	COMM_EXIT
                      4683     
                      4684     COMM5COMM6: 	
10A9    C2AF          4685     	CLR 	EA					; Disable all interrupts
                      4686     	CPFET_OFF					; Cp off
10AB    207502        4686+1   JB FLAGS3 . 5 , ( $+5 ) 
10AE    C292          4686+1   CLR P1 . 2 
10B0    307502        4686+1   JNB FLAGS3 . 5 , ( $+5 ) 
10B3    C296          4686+1   CLR P1 . 6 
10B5    206A03        4687     JB FLAGS2 . 2 , COMM56_DAMP 
10B8    0210D0        4688     	JMP	COMM56_NONDAMP
                      4689     COMM56_DAMP: 
                      4690     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      4694     IF DAMPED_MODE_ENABLE == 1
10BB    900233        4695     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      4696     ENDIF
10BE    30650F        4697     JNB FLAGS1 . 5 , COMM56_NONDAMP 
                      4698     	APFET_OFF				
10C1    207502        4698+1   JB FLAGS3 . 5 , ( $+5 ) 
10C4    C296          4698+1   CLR P1 . 6 
10C6    307502        4698+1   JNB FLAGS3 . 5 , ( $+5 ) 
10C9    C292          4698+1   CLR P1 . 2 
10CB    7406          4699     MOV A , # 6 
10CD    D5E0FD        4700     	DJNZ ACC,	$
                      4701     COMM56_NONDAMP: 
                      4702     IF HIGH_DRIVER_PRECHG_TIME NE 0	; Precharge high side gate driver
                      4703     	BNFET_ON				
10D0    E525          4703+1   MOV A , CURRENT_PWM_LIMITED 
10D2    6002          4703+1   JZ ( $+4 ) 
10D4    C295          4703+1   CLR P1 . 5 
10D6    740F          4704     MOV A , # 15 
10D8    D5E0FD        4705     	DJNZ ACC,	$
                      4706     	BNFET_OFF				
10DB    D295          4706+1   SETB P1 . 5 
10DD    7406          4707     MOV A , # 6 
10DF    D5E0FD        4708     	DJNZ ACC,	$
                      4709     ENDIF
                      4710     	BPFET_ON					; Bp on
10E2    D294          4710+1   SETB P1 . 4 
                      4711     	SET_COMP_PHASE_C 			; Set comparator to phase C
10E4    207503        4711+1   JB FLAGS3 . 5 , ( $+6 ) 
10E7    759F13        4711+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
10EA    307503        4711+1   JNB FLAGS3 . 5 , ( $+6 ) 
10ED    759F11        4711+1   MOV CPT0MX , # 11H 
10F0    753E06        4712     	MOV	COMM_PHASE, #6
10F3    02114D        4713     	JMP	COMM_EXIT
                      4714     
                      4715     COMM6COMM1: 	
10F6    C2AF          4716     	CLR 	EA					; Disable all interrupts
10F8    206A03        4717     JB FLAGS2 . 2 , COMM61_DAMP 
10FB    021120        4718     	JMP	COMM61_NONDAMP
                      4719     COMM61_DAMP: 
                      4720     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      4723     IF DAMPED_MODE_ENABLE == 1
10FE    9003A0        4724     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4725     ENDIF
1101    30651F        4726     JNB FLAGS1 . 5 , COMM61_NFET 
                      4727     	APFET_OFF				
1104    207502        4727+1   JB FLAGS3 . 5 , ( $+5 ) 
1107    C296          4727+1   CLR P1 . 6 
1109    307502        4727+1   JNB FLAGS3 . 5 , ( $+5 ) 
110C    C292          4727+1   CLR P1 . 2 
                      4728     	CPFET_OFF				
110E    207502        4728+1   JB FLAGS3 . 5 , ( $+5 ) 
1111    C292          4728+1   CLR P1 . 2 
1113    307502        4728+1   JNB FLAGS3 . 5 , ( $+5 ) 
1116    C296          4728+1   CLR P1 . 6 
1118    7406          4729     MOV A , # 6 
111A    D5E0FD        4730     	DJNZ ACC,	$
111D    021123        4731     	JMP	COMM61_NFET
                      4732     COMM61_NONDAMP: 
1120    9001F3        4733     	MOV	DPTR, #PWM_CFET_ON
                      4734     COMM61_NFET: 
                      4735     	ANFET_OFF					; An off
1123    207502        4735+1   JB FLAGS3 . 5 , ( $+5 ) 
1126    D297          4735+1   SETB P1 . 7 
1128    307502        4735+1   JNB FLAGS3 . 5 , ( $+5 ) 
112B    D293          4735+1   SETB P1 . 3 
112D    305A0E        4736     JNB FLAGS0 . 2 , COMM61_CP 
                      4737     	CNFET_ON					; Yes - Cn on
1130    E525          4737+1   MOV A , CURRENT_PWM_LIMITED 
1132    600A          4737+1   JZ ( $+12 ) 
1134    207502        4737+1   JB FLAGS3 . 5 , ( $+5 ) 
1137    C293          4737+1   CLR P1 . 3 
1139    307502        4737+1   JNB FLAGS3 . 5 , ( $+5 ) 
113C    C297          4737+1   CLR P1 . 7 
                      4738     COMM61_CP: 
                      4739     	SET_COMP_PHASE_A 			; Set comparator to phase A
113E    207503        4739+1   JB FLAGS3 . 5 , ( $+6 ) 
1141    759F11        4739+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
1144    307503        4739+1   JNB FLAGS3 . 5 , ( $+6 ) 
1147    759F13        4739+1   MOV CPT0MX , # 13H 
114A    753E01        4740     	MOV	COMM_PHASE, #1
                      4741     
                      4742     COMM_EXIT: 
114D    D2AF          4743     	SETB	EA					; Enable all interrupts
114F    789C          4744     MOV R0 , # PGM_DEMAG_COMP 
1151    E6            4745     MOV A , @ R0 
1152    C3            4746     	CLR	C
1153    9402          4747     	SUBB	A, #2				; Check whether power shall be kept off upon consecutive demgs			
1155    4007          4748     	JC	COMM_RESTORE_POWER		; Less than value - branch
                      4749     
1157    C3            4750     	CLR	C
1158    E539          4751     	MOV	A, DEMAG_CONSECUTIVE_CNT	; Check consecutive demags
115A    9403          4752     	SUBB	A, #3
115C    5002          4753     	JNC	COMM_RETURN			; Do not reapply power if many consecutive demags. This will help retain sync during hard accelerations
                      4754     
                      4755     COMM_RESTORE_POWER: 
115E    C25C          4756     CLR FLAGS0 . 4 
                      4757     
                      4758     COMM_RETURN: 
1160    22            4759     	RET
                      4760     
                      4761     
                      4762     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4763     ;
                      4764     ; Switch power off routine
                      4765     ;
                      4766     ; No assumptions
                      4767     ;
                      4768     ; Switches all fets off 
                      4769     ;
                      4770     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4771     SWITCH_POWER_OFF: 
1161    9001CD        4772     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4773     	ALL_NFETS_OFF			; Turn off all nfets
1164    D297          4773+1   SETB P1 . 7 
1166    D295          4773+1   SETB P1 . 5 
1168    D293          4773+1   SETB P1 . 3 
                      4774     	ALL_PFETS_OFF			; Turn off all pfets
116A    C296          4774+1   CLR P1 . 6 
116C    C294          4774+1   CLR P1 . 4 
116E    C292          4774+1   CLR P1 . 2 
1170    C25A          4775     CLR FLAGS0 . 2 
1172    22            4776     	RET			
                      4777     
                      4778     
                      4779     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4780     ;
                      4781     ; Decrement stepper step routine
                      4782     ;
                      4783     ; No assumptions
                      4784     ;
                      4785     ; Decrements the stepper step 
                      4786     ;
                      4787     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4788     DECREMENT_STEPPER_STEP: 
1173    C3            4789     	CLR	C
1174    E550          4790     	MOV	A, WT_STEPPER_STEP_L
1176    9535          4791     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1178    E551          4792     	MOV	A, WT_STEPPER_STEP_H
117A    9536          4793     	SUBB	A, STEPPER_STEP_END_H	
117C    5001          4794     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
117E    22            4795     	RET
                      4796     
                      4797     DECREMENT_STEP: 
                      4798     	; Load programmed startup acceleration
117F    7890          4799     MOV R0 , # PGM_STARTUP_ACCEL 
1181    E6            4800     MOV A , @ R0 
1182    FF            4801     MOV R7 , A 
                      4802     	; Check acceleration setting and set step size accordingly
1183    C3            4803     	CLR	C
1184    EF            4804     MOV A , R7 
1185    9405          4805     	SUBB	A, #5
1187    5018          4806     	JNC	DEC_STEP_HIGH
1189    C3            4807     	CLR	C
118A    EF            4808     MOV A , R7 
118B    9404          4809     	SUBB	A, #4
118D    501B          4810     	JNC	DEC_STEP_MED_HIGH
118F    C3            4811     	CLR	C
1190    EF            4812     MOV A , R7 
1191    9403          4813     	SUBB	A, #3
1193    501E          4814     	JNC	DEC_STEP_MED
1195    C3            4815     	CLR	C
1196    EF            4816     MOV A , R7 
1197    9402          4817     	SUBB	A, #2
1199    5021          4818     	JNC	DEC_STEP_MED_LOW
119B    C3            4819     	CLR	C
119C    EF            4820     MOV A , R7 
119D    9401          4821     	SUBB	A, #1
119F    5024          4822     	JNC	DEC_STEP_LOW
                      4823     
                      4824     DEC_STEP_HIGH: 
11A1    C3            4825     	CLR	C
11A2    E550          4826     	MOV	A, WT_STEPPER_STEP_L
11A4    943C          4827     	SUBB	A, #LOW(30 SHL 1)		
11A6    F8            4828     MOV R0 , A 
11A7    0211CE        4829     	JMP	DECREMENT_STEP_EXIT
                      4830     DEC_STEP_MED_HIGH: 
11AA    C3            4831     	CLR	C
11AB    E550          4832     	MOV	A, WT_STEPPER_STEP_L
11AD    9428          4833     	SUBB	A, #LOW(20 SHL 1)		
11AF    F8            4834     MOV R0 , A 
11B0    0211CE        4835     	JMP	DECREMENT_STEP_EXIT
                      4836     DEC_STEP_MED: 
11B3    C3            4837     	CLR	C
11B4    E550          4838     	MOV	A, WT_STEPPER_STEP_L
11B6    941A          4839     	SUBB	A, #LOW(13 SHL 1)		
11B8    F8            4840     MOV R0 , A 
11B9    0211CE        4841     	JMP	DECREMENT_STEP_EXIT
                      4842     DEC_STEP_MED_LOW: 
11BC    C3            4843     	CLR	C
11BD    E550          4844     	MOV	A, WT_STEPPER_STEP_L
11BF    9412          4845     	SUBB	A, #LOW(9 SHL 1)		
11C1    F8            4846     MOV R0 , A 
11C2    0211CE        4847     	JMP	DECREMENT_STEP_EXIT
                      4848     DEC_STEP_LOW: 
11C5    C3            4849     	CLR	C
11C6    E550          4850     	MOV	A, WT_STEPPER_STEP_L
11C8    940A          4851     	SUBB	A, #LOW(5 SHL 1)		
11CA    F8            4852     MOV R0 , A 
11CB    0211CE        4853     	JMP	DECREMENT_STEP_EXIT
                      4854     
                      4855     DECREMENT_STEP_EXIT: 
11CE    E551          4856     	MOV	A, WT_STEPPER_STEP_H
11D0    9400          4857     	SUBB	A, #0		
11D2    F9            4858     MOV R1 , A 
11D3    8850          4859     MOV WT_STEPPER_STEP_L , R0 
11D5    8951          4860     MOV WT_STEPPER_STEP_H , R1 
11D7    22            4861     	RET
                      4862     
                      4863     
                      4864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4865     ;
                      4866     ; Stepper timer wait
                      4867     ;
                      4868     ; No assumptions
                      4869     ;
                      4870     ; Waits for the stepper step timer to elapse
                      4871     ;
                      4872     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4873     STEPPER_TIMER_WAIT: 
11D8    305802        4874     JNB FLAGS0 . 0 , ( $+5 ) 
11DB    21D8          4875     	AJMP	STEPPER_TIMER_WAIT		; Yes, go back
11DD    22            4876     	RET
                      4877     
                      4878     
                      4879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4880     ;
                      4881     ; Set default parameters
                      4882     ;
                      4883     ; No assumptions
                      4884     ;
                      4885     ; Sets default programming parameters
                      4886     ;
                      4887     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4888     SET_DEFAULT_PARAMETERS: 
                      4889     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Motor idle
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_REARM_START
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      4950     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #0XFF	; Governor P gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor I gain
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor mode
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Low voltage limit
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               
                               	MOV	TEMP1, #PGM_ENABLE_TX_PROGRAM
                               	MOV	@TEMP1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Main rearm start
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor setup target
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Voltage comp
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	INC	TEMP1
                               	MOV	@TEMP1, #0XFF	; Governor range
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                               	INC	TEMP1
                               	MOV	@TEMP1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                               ENDIF
                      5011     IF MODE == 2	; Multi
11DE    7880          5012     MOV R0 , # PGM_GOV_P_GAIN 
11E0    7609          5013     MOV @ R0 , # 9 
11E2    08            5014     INC R0 
11E3    7609          5015     MOV @ R0 , # 9 
11E5    08            5016     INC R0 
11E6    7604          5017     MOV @ R0 , # 4 
11E8    08            5018     INC R0 
11E9    7601          5019     MOV @ R0 , # 1 
11EB    08            5020     INC R0 
11EC    7603          5021     MOV @ R0 , # 3 
11EE    08            5022     INC R0 
11EF    76FF          5023     MOV @ R0 , # 0XFF 
11F1    08            5024     INC R0 
11F2    7609          5025     MOV @ R0 , # 9 
11F4    08            5026     INC R0 
11F5    7601          5027     MOV @ R0 , # 1 
11F7    08            5028     INC R0 
11F8    7601          5029     MOV @ R0 , # 1 
11FA    08            5030     INC R0 
11FB    7601          5031     MOV @ R0 , # 1 
                      5032     
11FD    788C          5033     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
11FF    7600          5034     MOV @ R0 , # 0 
1201    08            5035     INC R0 
1202    76FF          5036     MOV @ R0 , # 0XFF 
1204    08            5037     INC R0 
1205    76FF          5038     MOV @ R0 , # 0XFF 
1207    08            5039     INC R0 
1208    7601          5040     MOV @ R0 , # 1 
120A    08            5041     INC R0 
120B    7605          5042     MOV @ R0 , # 5 
120D    08            5043     INC R0 
120E    76FF          5044     MOV @ R0 , # 0XFF 
1210    08            5045     INC R0 
1211    7603          5046     MOV @ R0 , # 3 
1213    08            5047     INC R0 
1214    7606          5048     MOV @ R0 , # 6 
1216    08            5049     INC R0 
1217    76FF          5050     MOV @ R0 , # 0XFF 
1219    08            5051     INC R0 
121A    7602          5052     MOV @ R0 , # 2 
121C    08            5053     INC R0 
121D    7603          5054     MOV @ R0 , # 3 
121F    08            5055     INC R0 
1220    76FA          5056     MOV @ R0 , # 250 
1222    08            5057     INC R0 
1223    7614          5058     MOV @ R0 , # 20 
1225    08            5059     INC R0 
1226    7614          5060     MOV @ R0 , # 20 
1228    08            5061     INC R0 
1229    7605          5062     MOV @ R0 , # 5 
122B    08            5063     INC R0 
122C    7601          5064     MOV @ R0 , # 1 
122E    08            5065     INC R0 
122F    7602          5066     MOV @ R0 , # 2 
1231    08            5067     INC R0 
1232    7600          5068     MOV @ R0 , # 0 
1234    08            5069     INC R0 
1235    767D          5070     MOV @ R0 , # 125 
                      5071     ENDIF
                      5072     
                      5073     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5074     ;
                      5075     ; 初始化变量 
                      5076     ; Skypup 2015.05.25
1237    757400        5077     	MOV	PREV_RCP,	#0
123A    757600        5078     	MOV	NHOLD_L,	#0
123D    757700        5079     	MOV	NHOLD_H,	#0
1240    757800        5080     MOV CSTATE , # 0 
                      5081     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1243    22            5082     	RET
                      5083     
                      5084     
                      5085     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5086     ;
                      5087     ; Decode parameters
                      5088     ;
                      5089     ; No assumptions
                      5090     ;
                      5091     ; Decodes programming parameters
                      5092     ;
                      5093     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5094     DECODE_PARAMETERS: 
                      5095     	; Load programmed damping force
1244    7893          5096     MOV R0 , # PGM_DAMPING_FORCE 
1246    E6            5097     MOV A , @ R0 
1247    FF            5098     MOV R7 , A 
                      5099     	; Decode damping
1248    756609        5100     	MOV	DAMPING_PERIOD, #9		; Set default
124B    756701        5101     	MOV	DAMPING_ON, #1
124E    C3            5102     	CLR	C
124F    BF0206        5103     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5104     
1252    756605        5105     	MOV	DAMPING_PERIOD, #5
1255    756701        5106     	MOV	DAMPING_ON, #1
                      5107     
                      5108     DECODE_DAMPING_3: 
1258    C3            5109     	CLR	C
1259    BF0306        5110     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5111     
125C    756605        5112     	MOV	DAMPING_PERIOD, #5
125F    756702        5113     	MOV	DAMPING_ON, #2
                      5114     
                      5115     DECODE_DAMPING_4: 
1262    C3            5116     	CLR	C
1263    BF0406        5117     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5118     
1266    756605        5119     	MOV	DAMPING_PERIOD, #5
1269    756703        5120     	MOV	DAMPING_ON, #3
                      5121     
                      5122     DECODE_DAMPING_5: 
126C    C3            5123     	CLR	C
126D    BF0506        5124     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5125     
1270    756609        5126     	MOV	DAMPING_PERIOD, #9
1273    756707        5127     	MOV	DAMPING_ON, #7
                      5128     
                      5129     DECODE_DAMPING_6: 
1276    C3            5130     	CLR	C
1277    BF0606        5131     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5132     
127A    756600        5133     	MOV	DAMPING_PERIOD, #0
127D    756700        5134     	MOV	DAMPING_ON, #0
                      5135     
                      5136     DECODE_DAMPING_DONE: 
                      5137     	; Load programmed pwm frequency
1280    7887          5138     MOV R0 , # PGM_PWM_FREQ 
1282    E6            5139     MOV A , @ R0 
1283    FF            5140     MOV R7 , A 
                      5141     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5148     IF MODE >= 1	; Tail or multi
1284    C26C          5149     CLR FLAGS2 . 4 
1286    C3            5150     	CLR	C
1287    BF0302        5151     CJNE R7 , # 3 , ( $+5 ) 
128A    D26C          5152     SETB FLAGS2 . 4 
128C    C26B          5153     CLR FLAGS2 . 3 
128E    C3            5154     	CLR	C
128F    BF0402        5155     CJNE R7 , # 4 , ( $+5 ) 
1292    D26B          5156     SETB FLAGS2 . 3 
                      5157     ENDIF
1294    C26A          5158     CLR FLAGS2 . 2 
1296    7418          5159     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
1298    552D          5160     	ANL	A, FLAGS2					; Check if any damped mode is set
129A    6002          5161     	JZ	($+4)
129C    D26A          5162     SETB FLAGS2 . 2 
129E    C265          5163     CLR FLAGS1 . 5 
12A0    6002          5164     	JZ	($+4)
12A2    D265          5165     SETB FLAGS1 . 5 
12A4    D266          5166     SETB FLAGS1 . 6 
12A6    6002          5167     	JZ	($+4)
12A8    C266          5168     CLR FLAGS1 . 6 
                      5169     	; Load programmed direction
12AA    7888          5170     MOV R0 , # PGM_DIRECTION 
                      5171     IF MODE >= 1	; Tail or multi
12AC    E6            5172     MOV A , @ R0 
12AD    C3            5173     	CLR	C
12AE    9403          5174     	SUBB	A, #3
12B0    6008          5175     	JZ	DECODE_PARAMS_DIR_SET
                      5176     ENDIF
                      5177     
12B2    C275          5178     CLR FLAGS3 . 5 
12B4    E6            5179     MOV A , @ R0 
12B5    30E102        5180     	JNB	ACC.1, ($+5)
12B8    D275          5181     SETB FLAGS3 . 5 
                      5182     DECODE_PARAMS_DIR_SET: 
12BA    C276          5183     CLR FLAGS3 . 6 
12BC    7889          5184     MOV R0 , # PGM_INPUT_POL 
12BE    E6            5185     MOV A , @ R0 
12BF    30E102        5186     	JNB	ACC.1, ($+5)
12C2    D276          5187     SETB FLAGS3 . 6 
12C4    C3            5188     	CLR	C
12C5    EF            5189     MOV A , R7 
12C6    9402          5190     	SUBB	A, #2
12C8    6008          5191     	JZ	DECODE_PWM_FREQ_LOW
                      5192     
12CA    758E01        5193     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
12CD    D26D          5194     SETB FLAGS2 . 5 
12CF    0212D7        5195     	JMP	DECODE_PWM_FREQ_END
                      5196     
                      5197     DECODE_PWM_FREQ_LOW: 
12D2    758E00        5198     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
12D5    C26D          5199     CLR FLAGS2 . 5 
                      5200     
                      5201     DECODE_PWM_FREQ_END: 
12D7    22            5202     	RET
                      5203     
                      5204     
                      5205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5206     ;
                      5207     ; Decode governor gain
                      5208     ;
                      5209     ; No assumptions
                      5210     ;
                      5211     ; Decodes governor gains
                      5212     ;
                      5213     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5214     DECODE_GOVERNOR_GAINS: 
                      5215     	; Decode governor gains
12D8    7880          5216     MOV R0 , # PGM_GOV_P_GAIN 
12DA    E6            5217     MOV A , @ R0 
12DB    14            5218     	DEC	A	
12DC    900080        5219     	MOV	DPTR, #GOV_GAIN_TABLE
12DF    93            5220     	MOVC A, @A+DPTR	
12E0    789F          5221     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
12E2    F6            5222     MOV @ R0 , A 
12E3    7881          5223     MOV R0 , # PGM_GOV_I_GAIN 
12E5    E6            5224     MOV A , @ R0 
12E6    14            5225     	DEC	A	
12E7    900080        5226     	MOV	DPTR, #GOV_GAIN_TABLE
12EA    93            5227     	MOVC A, @A+DPTR	
12EB    78A0          5228     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
12ED    F6            5229     MOV @ R0 , A 
12EE    3161          5230     	CALL	SWITCH_POWER_OFF		; Reset DPTR
12F0    22            5231     	RET
                      5232     
                      5233     
                      5234     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5235     ;
                      5236     ; Decode throttle rate
                      5237     ;
                      5238     ; No assumptions
                      5239     ;
                      5240     ; Decodes throttle rate
                      5241     ;
                      5242     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5243     DECODE_THROTTLE_RATE: 
                      5244     	; Decode throttle rate
12F1    789B          5245     MOV R0 , # PGM_THROTTLE_RATE 
12F3    E6            5246     MOV A , @ R0 
12F4    14            5247     	DEC	A	
12F5    90008D        5248     	MOV	DPTR, #THROTTLE_RATE_TABLE
12F8    93            5249     	MOVC A, @A+DPTR	
12F9    78A1          5250     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
12FB    F6            5251     MOV @ R0 , A 
12FC    3161          5252     	CALL	SWITCH_POWER_OFF			; Reset DPTR
12FE    22            5253     	RET
                      5254     
                      5255     
                      5256     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5257     ;
                      5258     ; Decode startup power
                      5259     ;
                      5260     ; No assumptions
                      5261     ;
                      5262     ; Decodes startup power
                      5263     ;
                      5264     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5265     DECODE_STARTUP_POWER: 
                      5266     	; Decode startup power
12FF    7886          5267     MOV R0 , # PGM_STARTUP_PWR 
1301    E6            5268     MOV A , @ R0 
1302    14            5269     	DEC	A	
1303    90009A        5270     	MOV	DPTR, #STARTUP_POWER_TABLE
1306    93            5271     	MOVC A, @A+DPTR	
1307    78A2          5272     MOV R0 , # PGM_STARTUP_PWR_DECODED 
1309    F6            5273     MOV @ R0 , A 
130A    3161          5274     	CALL	SWITCH_POWER_OFF			; Reset DPTR
130C    22            5275     	RET
                      5276     
                      5277     
                      5278     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5279     ;
                      5280     ; Decode demag compensation
                      5281     ;
                      5282     ; No assumptions
                      5283     ;
                      5284     ; Decodes throttle rate
                      5285     ;
                      5286     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5287     DECODE_DEMAG_COMP: 
                      5288     	; Decode demag compensation
130D    789C          5289     MOV R0 , # PGM_DEMAG_COMP 
130F    E6            5290     MOV A , @ R0 
1310    14            5291     	DEC	A	
1311    9000A7        5292     	MOV	DPTR, #DEMAG_POWER_TABLE
1314    93            5293     	MOVC A, @A+DPTR	
1315    78A3          5294     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
1317    F6            5295     MOV @ R0 , A 
1318    3161          5296     	CALL	SWITCH_POWER_OFF			; Reset DPTR
131A    22            5297     	RET
                      5298     
                      5299     
                      5300     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5301     ;
                      5302     ; Set BEC voltage
                      5303     ;
                      5304     ; No assumptions
                      5305     ;
                      5306     ; Sets the BEC output voltage low or high
                      5307     ;
                      5308     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5309     SET_BEC_VOLTAGE: 
                      5310     	; Set bec voltage
                      5311     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
131B    22            5321     	RET
                      5322     
                      5323     
                      5324     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5325     ;
                      5326     ; Find throttle gain
                      5327     ;
                      5328     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5329     ;
                      5330     ; Finds throttle gain from throttle calibration values
                      5331     ;
                      5332     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5333     FIND_THROTTLE_GAIN: 
                      5334     	; Load programmed minimum and maximum throttle
131C    7896          5335     MOV R0 , # PGM_PPM_MIN_THROTTLE 
131E    E6            5336     MOV A , @ R0 
131F    FA            5337     MOV R2 , A 
1320    7897          5338     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1322    E6            5339     MOV A , @ R0 
1323    FB            5340     MOV R3 , A 
                      5341     	; Check if full range is chosen
1324    307704        5342     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5343     
1327    7A00          5344     MOV R2 , # 0 
1329    7BFF          5345     MOV R3 , # 255 
                      5346     
                      5347     FIND_THROTTLE_GAIN_CALCULATE: 
                      5348     	; Calculate difference
132B    C3            5349     	CLR	C
132C    EB            5350     MOV A , R3 
132D    9A            5351     SUBB A , R2 
132E    FC            5352     MOV R4 , A 
                      5353     	; Check that difference is minimum 130
132F    C3            5354     	CLR	C
1330    9482          5355     	SUBB	A, #130
1332    5002          5356     	JNC	($+4)
                      5357     
1334    7C82          5358     MOV R4 , # 130 
                      5359     
                      5360     	; Find gain
1336    756E00        5361     	MOV	PPM_THROTTLE_GAIN, #0
                      5362     TEST_THROTTLE_GAIN: 
1339    056E          5363     	INC	PPM_THROTTLE_GAIN
133B    EC            5364     MOV A , R4 
133C    856EF0        5365     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
133F    A4            5366     	MUL	AB
1340    C3            5367     	CLR	C
1341    E5F0          5368     	MOV	A, B
1343    9480          5369     	SUBB	A, #128
1345    40F2          5370     	JC	TEST_THROTTLE_GAIN
1347    22            5371     	RET
                      5372     
                      5373     
                      5374     
                      5375     
                      5376     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5377     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5378     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5379     ;
                      5380     ; Main program start
                      5381     ;
                      5382     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5383     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5384     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5385     
                      5386     RESET: 
                      5387     	; Check flash lock byte
1348    E5EF          5388     	MOV	A, RSTSRC			
134A    20E603        5389     	JB	ACC.6, ($+6)		; Check if flash access error was reset source 
                      5390     
134D    752000        5391     	MOV	BIT_ACCESS, #0		; No - then this is the first try
                      5392     
1350    0520          5393     	INC	BIT_ACCESS
1352    903FFF        5394     MOV DPTR , # 16383 
1355    E520          5395     	MOV	A, BIT_ACCESS
1357    14            5396     	DEC	A
1358    6006          5397     	JZ	LOCK_BYTE_TEST
                      5398     
135A    901DFF        5399     MOV DPTR , # 7679 
135D    14            5400     	DEC	A
135E    6000          5401     	JZ	LOCK_BYTE_TEST
                      5402     
                      5403     LOCK_BYTE_TEST: 
1360    93            5404     	MOVC A, @A+DPTR		; Read lock byte
1361    04            5405     	INC	A				
1362    6003          5406     	JZ	LOCK_BYTE_OK		; If lock byte is 0xFF, then start code execution
                      5407     
                      5408     IF ONE_S_CAPABLE == 0		
1364    75EF12        5409     	MOV	RSTSRC, #12H		; Generate hardware reset and set VDD monitor
                      5410     ELSE
                               	MOV	RSTSRC, #10H		; Generate hardware reset and disable VDD monitor
                               ENDIF
                      5413     
                      5414     LOCK_BYTE_OK: 
                      5415     	; Select register bank 0 for main program routines
1367    C2D3          5416     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5417     	; Disable the WDT.
1369    53D9BF        5418     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5419     	; Initialize stack
136C    7581C0        5420     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5421     	; Initialize VDD monitor
136F    43FF80        5422     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1372    120860        5423     	CALL	WAIT1MS			; Wait at least 100us
                      5424     IF ONE_S_CAPABLE == 0		
1375    75EF02        5425     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5426     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5429     	; Set clock frequency
1378    43B203        5430     	ORL	OSCICN, #03H		; Set clock divider to 1
137B    E5B3          5431     	MOV	A, OSCICL				
137D    2404          5432     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
137F    4002          5433     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5434     
1381    F5B3          5435     	MOV	OSCICL, A
                      5436     
                      5437     RESET_CAL_DONE: 
                      5438     	; Switch power off
1383    3161          5439     	CALL	SWITCH_POWER_OFF
                      5440     	; Ports initialization
1385    7580FF        5441     MOV P0 , # 255 
1388    75A400        5442     MOV P0MDOUT , # 0 
138B    75F1B2        5443     MOV P0MDIN , # -78 
138E    75D4DF        5444     MOV P0SKIP , # 223 
1391    7590A9        5445     MOV P1 , # 169 
1394    75A5FC        5446     MOV P1MDOUT , # 252 
1397    75F2FC        5447     MOV P1MDIN , # 252 
139A    75D501        5448     MOV P1SKIP , # 1 
                      5449     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
139D    75A601        5452     MOV P2MDOUT , # 1 
                      5453     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      5460     	; Initialize the XBAR and related functionality
                      5461     	INITIALIZE_XBAR		
13A0    75E241        5461+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      5462     	; Clear RAM
13A3    E4            5463     	CLR	A				; Clear accumulator
13A4    F8            5464     MOV R0 , A 
                      5465     CLEAR_RAM: 	
13A5    F6            5466     MOV @ R0 , A 
13A6    D8FD          5467     DJNZ R0 , CLEAR_RAM 
                      5468     	; Set default programmed parameters
13A8    31DE          5469     	CALL	SET_DEFAULT_PARAMETERS
                      5470     	; Decode parameters
13AA    5144          5471     	CALL	DECODE_PARAMETERS
                      5472     	; Decode governor gains
13AC    51D8          5473     	CALL	DECODE_GOVERNOR_GAINS
                      5474     	; Decode throttle rate
13AE    51F1          5475     	CALL	DECODE_THROTTLE_RATE
                      5476     	; Decode startup power
13B0    51FF          5477     	CALL	DECODE_STARTUP_POWER
                      5478     	; Decode demag compensation
13B2    710D          5479     	CALL	DECODE_DEMAG_COMP
                      5480     	; Set BEC voltage
13B4    711B          5481     	CALL	SET_BEC_VOLTAGE
                      5482     	; Find throttle gain from stored min and max settings
13B6    711C          5483     	CALL	FIND_THROTTLE_GAIN
                      5484     	; Set beep strength
13B8    7898          5485     MOV R0 , # PGM_BEEP_STRENGTH 
13BA    866F          5486     MOV BEEP_STRENGTH , @ R0 
                      5487     	; Switch power off
13BC    3161          5488     	CALL	SWITCH_POWER_OFF
                      5489     	; Timer control
13BE    758850        5490     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      5491     	; Timer mode
13C1    758902        5492     	MOV	TMOD, #02H		; Timer0 as 8bit
                      5493     	; Timer2: clk/12 for 128us and 32ms interrupts
13C4    75C824        5494     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      5495     	; Timer3: clk/12 for commutation timing
13C7    759104        5496     	MOV	TMR3CN, #04H		; Timer3 enabled
                      5497     	; PCA
13CA    75D840        5498     	MOV	PCA0CN, #40H		; PCA enabled
                      5499     	; Initializing beep
13CD    C2AF          5500     	CLR	EA				; Disable interrupts explicitly
13CF    120879        5501     	CALL WAIT200MS	
13D2    120890        5502     	CALL BEEP_F1
13D5    12086A        5503     	CALL WAIT10MS
13D8    120897        5504     	CALL BEEP_F2
13DB    12086A        5505     	CALL WAIT10MS
13DE    12089E        5506     	CALL BEEP_F3
13E1    12086A        5507     	CALL WAIT10MS
13E4    1208A5        5508     	CALL BEEP_F4
13E7    12086A        5509     	CALL WAIT10MS
                      5510     
                      5511     	; Wait for receiver to initialize
13EA    120889        5512     	CALL	WAIT1S
13ED    120879        5513     	CALL	WAIT200MS
13F0    120879        5514     	CALL	WAIT200MS
13F3    120874        5515     	CALL	WAIT100MS
                      5516     
                      5517     
                      5518     	; Enable interrupts
13F6    75A822        5519     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
13F9    75B802        5520     	MOV	IP, #02H			; High priority to timer0 interrupts
13FC    75E690        5521     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
                      5522     	; Initialize comparator
13FF    759B80        5523     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
1402    759D03        5524     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      5525     IF COMP1_USED == 1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      5529     	; Initialize ADC
                      5530     	INITIALIZE_ADC			; Initialize ADC operation
1405    75D10E        5530+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1408    75BC58        5530+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
140B    75BB08        5530+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
140E    75BA11        5530+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
1411    75E880        5530+1   MOV ADC0CN , # 80H  ; ADC ENABLED
1414    120860        5531     	CALL	WAIT1MS
1417    D2AF          5532     	SETB	EA				; Enable all interrupts
                      5533     
                      5534     	; Measure number of lipo cells
1419    120B48        5535     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      5536     	; Initialize rc pulse
                      5537     	RCP_INT_ENABLE		 			; Enable interrupt
141C    43DA01        5537+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5538     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
141F    C2D8          5538+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1421    C269          5539     CLR FLAGS2 . 1 
1423    120879        5540     	CALL WAIT200MS
                      5541     	; Set initial arm variable
1426    753001        5542     	MOV	INITIAL_ARM, #1
1429    757301        5543     	MOV	FLAG_BEFORE_ARM, #1
                      5544     
                      5545     	; Measure PWM frequency
                      5546     MEASURE_PWM_FREQ_INIT: 	
142C    D259          5547     SETB FLAGS0 . 1 
                      5548     MEASURE_PWM_FREQ_START: 	
142E    7A05          5549     MOV R2 , # 5 
                      5550     MEASURE_PWM_FREQ_LOOP: 	
                      5551     	; Check if period diff was accepted
1430    E558          5552     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1432    7002          5553     	JNZ	($+4)
                      5554     
1434    7A05          5555     MOV R2 , # 5 
                      5556     
1436    120865        5557     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1439    E559          5558     	MOV	A, NEW_RCP					; Load value
143B    C3            5559     	CLR	C
143C    9402          5560     SUBB A , # 2 
143E    40EE          5561     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5562     
1440    E52E          5563     	MOV	A, FLAGS3						; Check pwm frequency flags
1442    541F          5564     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1444    855B5A        5565     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
1447    F55B          5566     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1449    B55AE2        5567     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5568     
144C    DAE2          5569     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5570     
                      5571     	; Clear measure pwm frequency flag
144E    C259          5572     CLR FLAGS0 . 1 
                      5573     	; Set up RC pulse interrupts after pwm frequency measurement
                      5574     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1450    53DACF        5574+1   ANL PCA0CPM0 , # 0CFH 
1453    207603        5574+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
1456    43DA20        5574+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1459    307603        5574+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
145C    43DA10        5574+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5575     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
145F    C2D8          5575+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1461    C269          5576     CLR FLAGS2 . 1 
1463    120874        5577     	CALL WAIT100MS						; Wait for new RC pulse
                      5578     
                      5579     	; Validate RC pulse
                      5580     VALIDATE_RCP_START: 	
1466    120865        5581     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1469    7802          5582     MOV R0 , # 2 
146B    741F          5583     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
146D    552E          5584     	ANL	A, FLAGS3						; Check pwm frequency flags
146F    7002          5585     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5586     
1471    7800          5587     MOV R0 , # 0 
                      5588     
1473    C3            5589     	CLR	C
1474    E559          5590     	MOV	A, NEW_RCP					; Load value
1476    98            5591     SUBB A , R0 
1477    40ED          5592     	JC	VALIDATE_RCP_START				; No - start over
                      5593     
                      5594     	; Beep arm sequence start signal
1479    C2AF          5595     	CLR 	EA							; Disable all interrupts
147B    120890        5596     	CALL BEEP_F1
147E    12086A        5597     	CALL WAIT10MS
1481    120890        5598     	CALL BEEP_F1
1484    12086A        5599     	CALL WAIT10MS
1487    120897        5600     	CALL BEEP_F2
148A    12086A        5601     	CALL WAIT10MS
148D    120897        5602     	CALL BEEP_F2
1490    12086A        5603     	CALL WAIT10MS
1493    D2AF          5604     	SETB	EA							; Enable all interrupts
1495    120879        5605     	CALL WAIT200MS	
                      5606     
1498    757300        5607     	MOV	FLAG_BEFORE_ARM, #0		; 为了让定制的程序输出最低油门. Skypup 2015.05.26
                      5608     
                      5609     	; Arming sequence start
149B    754800        5610     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5611     ARMING_START: 
149E    C3            5612     	CLR	C
149F    E559          5613     	MOV	A, NEW_RCP			; Load new RC pulse value
14A1    9548          5614     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
14A3    4003          5615     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5616     
14A5    855948        5617     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5618     
                      5619     ARM_TARGET_UPDATED: 
14A8    120874        5620     	CALL WAIT100MS				; Wait for new throttle value
14AB    C3            5621     	CLR	C
14AC    E559          5622     	MOV	A, NEW_RCP			; Load new RC pulse value
14AE    9401          5623     SUBB A , # 1 
14B0    4002          5624     	JC	ARM_END_BEEP			; Yes - proceed
                      5625     
14B2    80EA          5626     	JMP	ARMING_START			; No - start over
                      5627     
                      5628     ARM_END_BEEP: 
                      5629     	; Beep arm sequence end signal
14B4    C2AF          5630     	CLR 	EA					; Disable all interrupts
14B6    1208A5        5631     	CALL BEEP_F4
14B9    12086A        5632     	CALL WAIT10MS
14BC    1208A5        5633     	CALL BEEP_F4
14BF    12086A        5634     	CALL WAIT10MS
14C2    12089E        5635     	CALL BEEP_F3
14C5    12086A        5636     	CALL WAIT10MS
14C8    12089E        5637     	CALL BEEP_F3
14CB    12086A        5638     	CALL WAIT10MS
14CE    D2AF          5639     	SETB	EA					; Enable all interrupts
14D0    120879        5640     	CALL WAIT200MS
                      5641     
                      5642     	; Clear initial arm variable
14D3    753000        5643     	MOV	INITIAL_ARM, #0
                      5644     
                      5645     	; Armed and waiting for power on
                      5646     WAIT_FOR_POWER_ON: 
14D6    E4            5647     	CLR	A
14D7    F531          5648     	MOV	POWER_ON_WAIT_CNT_L, A	; 清零
14D9    F532          5649     	MOV	POWER_ON_WAIT_CNT_H, A	; 清零
                      5650     WAIT_FOR_POWER_ON_LOOP: 
14DB    0531          5651     	INC	POWER_ON_WAIT_CNT_L		; 低位 ++
14DD    E531          5652     	MOV	A, POWER_ON_WAIT_CNT_L
14DF    F4            5653     	CPL	A					; 取反
14E0    7039          5654     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Power_On_Wait_Cnt_L 不是 0xFF 则跳转, 进入下一个循环, Counter wrapping (about 1 sec)?
                      5655     
14E2    0532          5656     	INC	POWER_ON_WAIT_CNT_H		; Power_On_Wait_Cnt_L == 0xFF, 高位 ++
14E4    789A          5657     MOV R0 , # PGM_BEACON_DELAY 
14E6    E6            5658     MOV A , @ R0 
14E7    7819          5659     MOV R0 , # 25 
14E9    14            5660     	DEC	A
14EA    6012          5661     	JZ	BEEP_DELAY_SET
                      5662     
14EC    7832          5663     MOV R0 , # 50 
14EE    14            5664     	DEC	A
14EF    600D          5665     	JZ	BEEP_DELAY_SET
                      5666     
14F1    787D          5667     MOV R0 , # 125 
14F3    14            5668     	DEC	A
14F4    6008          5669     	JZ	BEEP_DELAY_SET
                      5670     
14F6    78FA          5671     MOV R0 , # 250 
14F8    14            5672     	DEC	A
14F9    6003          5673     	JZ	BEEP_DELAY_SET
                      5674     
14FB    753200        5675     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5676     
                      5677     BEEP_DELAY_SET: 
14FE    C3            5678     	CLR	C
14FF    E532          5679     	MOV	A, POWER_ON_WAIT_CNT_H
1501    98            5680     SUBB A , R0 
1502    4017          5681     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5682     
1504    1532          5683     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1506    7531B4        5684     	MOV	POWER_ON_WAIT_CNT_L, #180; Set low wait counter
1509    7899          5685     MOV R0 , # PGM_BEACON_STRENGTH 
150B    866F          5686     MOV BEEP_STRENGTH , @ R0 
150D    C2AF          5687     	CLR 	EA					; Disable all interrupts
150F    1208A5        5688     	CALL BEEP_F4				; Signal that there is no signal
1512    D2AF          5689     	SETB	EA					; Enable all interrupts
1514    7898          5690     MOV R0 , # PGM_BEEP_STRENGTH 
1516    866F          5691     MOV BEEP_STRENGTH , @ R0 
1518    120874        5692     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5693     
                      5694     WAIT_FOR_POWER_ON_NO_BEEP: 
151B    12086A        5695     	CALL WAIT10MS
151E    E528          5696     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
1520    7008          5697     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      5698     
1522    741F          5699     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1524    552E          5700     	ANL	A, FLAGS3						; Check pwm frequency flags
1526    7002          5701     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      5702     
1528    812C          5703     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      5704     
                      5705     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
152A    C3            5706     	CLR	C
152B    E559          5707     	MOV	A, NEW_RCP			; Load new RC pulse value
152D    9406          5708     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
152F    40AA          5709     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5710     
                      5711     IF MODE >= 1	; Tail or multi
1531    7888          5712     MOV R0 , # PGM_DIRECTION 
1533    E6            5713     MOV A , @ R0 
1534    C3            5714     	CLR	C
1535    9403          5715     	SUBB	A, #3
1537    6003          5716     	JZ 	($+5)				; Do not wait if bidirectional operation
                      5717     ENDIF
                      5718     
1539    120874        5719     	LCALL WAIT100MS			; Wait to see if start pulse was only a glitch
                      5720     
153C    E528          5721     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
153E    7003          5722     	JNZ	($+5)				; If it is not zero - proceed
                      5723     
1540    02142C        5724     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5725     
                      5726     
                      5727     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5728     ;
                      5729     ; Start entry point
                      5730     ;
                      5731     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5732     INIT_START: 
1543    C2AF          5733     	CLR	EA
1545    3161          5734     	CALL SWITCH_POWER_OFF
1547    E4            5735     	CLR	A
1548    F522          5736     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
154A    F523          5737     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
154C    F524          5738     	MOV	CURRENT_PWM, A			; Set current pwm to zero
154E    F525          5739     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1550    D2AF          5740     	SETB	EA
1552    7885          5741     MOV R0 , # PGM_MOTOR_IDLE 
1554    8661          5742     MOV PWM_MOTOR_IDLE , @ R0 
1556    F540          5743     	MOV	GOV_TARGET_L, A		; Set target to zero
1558    F541          5744     	MOV	GOV_TARGET_H, A
155A    F542          5745     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
155C    F543          5746     	MOV	GOV_INTEGRAL_H, A
155E    F544          5747     	MOV	GOV_INTEGRAL_X, A
1560    F56C          5748     	MOV	ADC_CONVERSION_CNT, A
1562    F549          5749     	MOV	GOV_ACTIVE, A
1564    F52B          5750     	MOV	FLAGS0, A				; Clear flags0
1566    F52C          5751     	MOV	FLAGS1, A				; Clear flags1
1568    F539          5752     	MOV	DEMAG_CONSECUTIVE_CNT, A
156A    120CC5        5753     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5754     	;**** **** **** **** ****
                      5755     	; Motor start beginning
                      5756     	;**** **** **** **** **** 
156D    756C08        5757     MOV ADC_CONVERSION_CNT , # 8 
                      5758     	SET_ADC_IP_TEMP
1570    75BB10        5758+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1573    120860        5759     	CALL WAIT1MS
1576    120BE2        5760     	CALL START_ADC_CONVERSION
                      5761     READ_INITIAL_TEMP: 
                      5762     	GET_ADC_STATUS 
1579    E5E8          5762+1   MOV A , ADC0CN 
157B    20ECFB        5763     	JB	AD0BUSY, READ_INITIAL_TEMP
                      5764     	READ_ADC_RESULT						; Read initial temperature
157E    A8BD          5764+1   MOV R0 , ADC0L 
1580    A9BE          5764+1   MOV R1 , ADC0H 
1582    E9            5765     MOV A , R1 
1583    7001          5766     	JNZ	($+3)							; Is reading below 256?
                      5767     
1585    F8            5768     MOV R0 , A 
                      5769     
1586    886D          5770     MOV CURRENT_AVERAGE_TEMP , R0 
1588    120BE6        5771     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
158B    756C08        5772     MOV ADC_CONVERSION_CNT , # 8 
                      5773     	SET_ADC_IP_TEMP
158E    75BB10        5773+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5774     
                      5775     	; Go to the desired startup mode
1591    7895          5776     MOV R0 , # PGM_STARTUP_METHOD 
1593    E6            5777     MOV A , @ R0 
1594    30E003        5778     	JNB	ACC.0, DIRECT_METHOD_START
                      5779     
1597    0215DA        5780     	JMP	STEPPER_METHOD_START
                      5781     
                      5782     DIRECT_METHOD_START: 
                      5783     	; Set up start operating conditions
159A    7887          5784     MOV R0 , # PGM_PWM_FREQ 
159C    E6            5785     MOV A , @ R0 
159D    FE            5786     MOV R6 , A 
159E    7602          5787     MOV @ R0 , # 2 
15A0    5144          5788     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15A2    7887          5789     MOV R0 , # PGM_PWM_FREQ 
15A4    EE            5790     MOV A , R6 
15A5    F6            5791     MOV @ R0 , A 
                      5792     	; Set max allowed power
15A6    D261          5793     SETB FLAGS1 . 1 
15A8    C2AF          5794     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
15AA    755EFF        5795     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15AD    120C95        5796     	CALL SET_STARTUP_PWM
15B0    85225E        5797     	MOV	PWM_LIMIT, REQUESTED_PWM
15B3    85225F        5798     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
15B6    D2AF          5799     	SETB	EA
15B8    C261          5800     CLR FLAGS1 . 1 
15BA    752501        5801     	MOV	CURRENT_PWM_LIMITED, #1		; Set low pwm again after calling set_startup_pwm
15BD    855D64        5802     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
15C0    756501        5803     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5804     	; Begin startup sequence
15C3    D260          5805     SETB FLAGS1 . 0 
15C5    D263          5806     SETB FLAGS1 . 3 
15C7    753800        5807     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15CA    11A9          5808     	CALL COMM5COMM6				; Initialize commutation
15CC    11F6          5809     	CALL COMM6COMM1				
15CE    120D3F        5810     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
15D1    120CC5        5811     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
15D4    120DC2        5812     	CALL CALC_NEW_WAIT_TIMES			; Calculate new wait times
15D7    0216FB        5813     	JMP	RUN1
                      5814     
                      5815     
                      5816     STEPPER_METHOD_START: 
                      5817     	; Set up start operating conditions
15DA    7887          5818     MOV R0 , # PGM_PWM_FREQ 
15DC    E6            5819     MOV A , @ R0 
15DD    FE            5820     MOV R6 , A 
15DE    7603          5821     MOV @ R0 , # 3 
15E0    7893          5822     MOV R0 , # PGM_DAMPING_FORCE 
15E2    E6            5823     MOV A , @ R0 
15E3    FD            5824     MOV R5 , A 
15E4    7605          5825     MOV @ R0 , # 5 
15E6    5144          5826     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15E8    7887          5827     MOV R0 , # PGM_PWM_FREQ 
15EA    EE            5828     MOV A , R6 
15EB    F6            5829     MOV @ R0 , A 
15EC    7893          5830     MOV R0 , # PGM_DAMPING_FORCE 
15EE    ED            5831     MOV A , R5 
15EF    F6            5832     MOV @ R0 , A 
                      5833     	; Begin startup sequence
15F0    D260          5834     SETB FLAGS1 . 0 
15F2    D261          5835     SETB FLAGS1 . 1 
15F4    D265          5836     SETB FLAGS1 . 5 
15F6    11A9          5837     	CALL COMM5COMM6			; Initialize commutation
15F8    11F6          5838     	CALL COMM6COMM1			
15FA    755EFF        5839     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
15FD    120C95        5840     	CALL SET_STARTUP_PWM
1600    120860        5841     	CALL WAIT1MS
1603    120F6D        5842     	CALL COMM1COMM2
1606    120860        5843     	CALL WAIT1MS
1609    120860        5844     	CALL WAIT1MS
160C    120FC1        5845     	CALL COMM2COMM3
160F    120865        5846     	CALL WAIT3MS			
1612    110B          5847     	CALL COMM3COMM4
1614    120865        5848     	CALL WAIT3MS			
1617    120865        5849     	CALL WAIT3MS			
161A    1168          5850     	CALL COMM4COMM5
161C    12086A        5851     	CALL WAIT10MS				; Settle rotor
161F    11A9          5852     	CALL COMM5COMM6
1621    120865        5853     	CALL WAIT3MS				
1624    120860        5854     	CALL WAIT1MS			
1627    C261          5855     CLR FLAGS1 . 1 
1629    D262          5856     SETB FLAGS1 . 2 
                      5857     
                      5858     	;**** **** **** **** ****
                      5859     	; Stepper phase beginning
                      5860     	;**** **** **** **** **** 
                      5861     STEPPER_ROT_BEG: 
162B    120BE2        5862     	CALL START_ADC_CONVERSION
162E    120BE6        5863     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1631    120C95        5864     	CALL SET_STARTUP_PWM
1634    756C08        5865     MOV ADC_CONVERSION_CNT , # 8 
                      5866     	SET_ADC_IP_TEMP
1637    75BB10        5866+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5867     
163A    11F6          5868     	CALL COMM6COMM1				; Commutate
163C    120D38        5869     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
163F    120DC2        5870     	CALL CALC_NEW_WAIT_TIMES
1642    3173          5871     	CALL DECREMENT_STEPPER_STEP
1644    31D8          5872     	CALL STEPPER_TIMER_WAIT
                      5873     
1646    120F6D        5874     	CALL COMM1COMM2			
1649    120D38        5875     	CALL CALC_NEXT_COMM_TIMING_START	
164C    120DC2        5876     	CALL CALC_NEW_WAIT_TIMES
164F    3173          5877     	CALL DECREMENT_STEPPER_STEP
1651    31D8          5878     	CALL STEPPER_TIMER_WAIT
                      5879     
1653    120FC1        5880     	CALL COMM2COMM3			
1656    120D38        5881     	CALL CALC_NEXT_COMM_TIMING_START	
1659    120DC2        5882     	CALL CALC_NEW_WAIT_TIMES
165C    3173          5883     	CALL DECREMENT_STEPPER_STEP
165E    31D8          5884     	CALL STEPPER_TIMER_WAIT
                      5885     
1660    110B          5886     	CALL COMM3COMM4			
1662    120D38        5887     	CALL CALC_NEXT_COMM_TIMING_START	
1665    120DC2        5888     	CALL CALC_NEW_WAIT_TIMES
1668    3173          5889     	CALL DECREMENT_STEPPER_STEP
166A    31D8          5890     	CALL STEPPER_TIMER_WAIT
                      5891     
166C    1168          5892     	CALL COMM4COMM5			
166E    120D38        5893     	CALL CALC_NEXT_COMM_TIMING_START	
1671    120DC2        5894     	CALL CALC_NEW_WAIT_TIMES
1674    3173          5895     	CALL DECREMENT_STEPPER_STEP
1676    31D8          5896     	CALL STEPPER_TIMER_WAIT
                      5897     
1678    11A9          5898     	CALL COMM5COMM6			
167A    120D38        5899     	CALL CALC_NEXT_COMM_TIMING_START	
167D    120DC2        5900     	CALL CALC_NEW_WAIT_TIMES
1680    3173          5901     	CALL DECREMENT_STEPPER_STEP	
                      5902     	; Check stepper step versus end criteria
1682    C3            5903     	CLR	C
1683    E550          5904     	MOV	A, WT_STEPPER_STEP_L
1685    9535          5905     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1687    E551          5906     	MOV	A, WT_STEPPER_STEP_H
1689    9536          5907     	SUBB	A, STEPPER_STEP_END_H
168B    400C          5908     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5909     
                      5910     	; Wait for step
168D    31D8          5911     	CALL STEPPER_TIMER_WAIT
168F    C3            5912     	CLR	C
1690    E559          5913     	MOV	A, NEW_RCP				; Load new pulse value
1692    9401          5914     SUBB A , # 1 
1694    5095          5915     	JNC	STEPPER_ROT_BEG
                      5916     
1696    02182A        5917     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5918     
                      5919     STEPPER_ROT_EXIT: 
                      5920     	; Wait for step
1699    31D8          5921     	CALL STEPPER_TIMER_WAIT
                      5922     	; Clear stepper phase
169B    C262          5923     CLR FLAGS1 . 2 
                      5924     	; Set dondamped low pwm frequency
169D    7887          5925     MOV R0 , # PGM_PWM_FREQ 
169F    E6            5926     MOV A , @ R0 
16A0    FE            5927     MOV R6 , A 
16A1    7602          5928     MOV @ R0 , # 2 
16A3    5144          5929     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
16A5    7887          5930     MOV R0 , # PGM_PWM_FREQ 
16A7    EE            5931     MOV A , R6 
16A8    F6            5932     MOV @ R0 , A 
                      5933     	; Set spoolup power variables (power is now controlled from RCP)
16A9    85225E        5934     	MOV	PWM_LIMIT, REQUESTED_PWM
16AC    85605F        5935     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
16AF    856025        5936     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
16B2    855D64        5937     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
16B5    756501        5938     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      5939     	; Set direct startup phase to acquire sync quickly
16B8    D263          5940     SETB FLAGS1 . 3 
16BA    753800        5941     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
16BD    C2AF          5942     	CLR	EA						; Disable interrupts
                      5943     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
16BF    207502        5943+1   JB FLAGS3 . 5 , ( $+5 ) 
16C2    C296          5943+1   CLR P1 . 6 
16C4    307502        5943+1   JNB FLAGS3 . 5 , ( $+5 ) 
16C7    C292          5943+1   CLR P1 . 2 
                      5944     	CPFET_OFF						; Cp off
16C9    207502        5944+1   JB FLAGS3 . 5 , ( $+5 ) 
16CC    C292          5944+1   CLR P1 . 2 
16CE    307502        5944+1   JNB FLAGS3 . 5 , ( $+5 ) 
16D1    C296          5944+1   CLR P1 . 6 
16D3    742D          5945     	MOV	A, #45					; 8us delay for pfets to go off
16D5    D5E0FD        5946     	DJNZ	ACC, $
16D8    D2AF          5947     	SETB	EA						; Enable interrupts
16DA    11F6          5948     	CALL COMM6COMM1				
16DC    120D3F        5949     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
16DF    120DAE        5950     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
16E2    120DC2        5951     	CALL CALC_NEW_WAIT_TIMES
16E5    120E53        5952     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
16E8    756C00        5953     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      5954     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
16EB    75BB08        5954+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
16EE    0216FB        5955     	JMP	RUN1
                      5956     
                      5957     
                      5958     
                      5959     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5960     ;
                      5961     ; Run entry point
                      5962     ;
                      5963     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5964     DAMPED_TRANSITION: 
                      5965     	; Transition from nondamped to damped if applicable
16F1    5144          5966     	CALL	DECODE_PARAMETERS		; Set programmed parameters
16F3    11F6          5967     	CALL	COMM6COMM1
16F5    756C00        5968     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5969     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
16F8    75BB08        5969+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5970     
                      5971     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5972     ; Out_cA changes from low to high
                      5973     RUN1: 
16FB    120E75        5974     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
16FE    120EFA        5975     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1701    120F25        5976     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1704    12098F        5977     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1707    120F39        5978     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
170A    120F6D        5979     	CALL COMM1COMM2			; Commutate
170D    120D3F        5980     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1710    120DAE        5981     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1713    120DC2        5982     	CALL CALC_NEW_WAIT_TIMES
1716    120E53        5983     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5984     
                      5985     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5986     ; Out_cB changes from high to low
                      5987     RUN2: 
1719    120E6C        5988     	CALL WAIT_FOR_COMP_OUT_LOW
171C    120EFA        5989     	CALL	EVALUATE_COMPARATOR_INTEGRITY
171F    120F25        5990     	CALL SETUP_COMM_WAIT	
1722    1209EC        5991     	CALL CALC_GOVERNOR_PROP_ERROR
1725    120F39        5992     	CALL WAIT_FOR_COMM
1728    120FC1        5993     	CALL COMM2COMM3
172B    120D3F        5994     	CALL CALC_NEXT_COMM_TIMING
172E    120DAE        5995     	CALL WAIT_ADVANCE_TIMING
1731    120DC2        5996     	CALL CALC_NEW_WAIT_TIMES
1734    120E53        5997     	CALL WAIT_BEFORE_ZC_SCAN	
                      5998     
                      5999     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6000     ; Out_cC changes from low to high
                      6001     RUN3: 
1737    120E75        6002     	CALL WAIT_FOR_COMP_OUT_HIGH
173A    120EFA        6003     	CALL	EVALUATE_COMPARATOR_INTEGRITY
173D    120F25        6004     	CALL SETUP_COMM_WAIT	
1740    120A25        6005     	CALL CALC_GOVERNOR_INT_ERROR
1743    120F39        6006     	CALL WAIT_FOR_COMM
1746    110B          6007     	CALL COMM3COMM4
1748    120D3F        6008     	CALL CALC_NEXT_COMM_TIMING
174B    120DAE        6009     	CALL WAIT_ADVANCE_TIMING
174E    120DC2        6010     	CALL CALC_NEW_WAIT_TIMES
1751    120E53        6011     	CALL WAIT_BEFORE_ZC_SCAN	
                      6012     
                      6013     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6014     ; Out_cA changes from high to low
                      6015     RUN4: 
1754    120E6C        6016     	CALL WAIT_FOR_COMP_OUT_LOW
1757    120EFA        6017     	CALL	EVALUATE_COMPARATOR_INTEGRITY
175A    120F25        6018     	CALL SETUP_COMM_WAIT	
175D    120A82        6019     	CALL CALC_GOVERNOR_PROP_CORRECTION
1760    120F39        6020     	CALL WAIT_FOR_COMM
1763    1168          6021     	CALL COMM4COMM5
1765    120D3F        6022     	CALL CALC_NEXT_COMM_TIMING
1768    120DAE        6023     	CALL WAIT_ADVANCE_TIMING
176B    120DC2        6024     	CALL CALC_NEW_WAIT_TIMES
176E    120E53        6025     	CALL WAIT_BEFORE_ZC_SCAN	
                      6026     
                      6027     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6028     ; Out_cB changes from low to high
                      6029     RUN5: 
1771    120E75        6030     	CALL WAIT_FOR_COMP_OUT_HIGH
1774    120EFA        6031     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1777    120F25        6032     	CALL SETUP_COMM_WAIT	
177A    120AE6        6033     	CALL CALC_GOVERNOR_INT_CORRECTION
177D    120F39        6034     	CALL WAIT_FOR_COMM
1780    11A9          6035     	CALL COMM5COMM6
1782    120D3F        6036     	CALL CALC_NEXT_COMM_TIMING
1785    120DAE        6037     	CALL WAIT_ADVANCE_TIMING
1788    120DC2        6038     	CALL CALC_NEW_WAIT_TIMES
178B    120E53        6039     	CALL WAIT_BEFORE_ZC_SCAN	
                      6040     
                      6041     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6042     ; Out_cC changes from high to low
                      6043     RUN6: 
178E    120E6C        6044     	CALL WAIT_FOR_COMP_OUT_LOW
1791    120BE2        6045     	CALL START_ADC_CONVERSION
1794    120EFA        6046     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1797    120F25        6047     	CALL SETUP_COMM_WAIT	
179A    120BE6        6048     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
179D    120F39        6049     	CALL WAIT_FOR_COMM
17A0    11F6          6050     	CALL COMM6COMM1
17A2    120D3F        6051     	CALL CALC_NEXT_COMM_TIMING
17A5    120DAE        6052     	CALL WAIT_ADVANCE_TIMING
17A8    120DC2        6053     	CALL CALC_NEW_WAIT_TIMES
17AB    120E53        6054     	CALL WAIT_BEFORE_ZC_SCAN	
                      6055     
                      6056     	; Check if it is direct startup
17AE    306342        6057     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6058     
                      6059     	; Set spoolup power variables
17B1    85605E        6060     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
17B4    85605F        6061     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
17B7    855D64        6062     	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED
17BA    756501        6063     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6064     	; Check startup ok counter
17BD    7964          6065     MOV R1 , # 100 
17BF    7A14          6066     MOV R2 , # 20 
                      6067     IF MODE >= 1	; Tail or multi
17C1    7888          6068     MOV R0 , # PGM_DIRECTION 
17C3    E6            6069     MOV A , @ R0 
17C4    B40304        6070     	CJNE	A, #3, DIRECT_START_PARAMS_SET; No - branch
                      6071     
17C7    791E          6072     MOV R1 , # 30 
17C9    7A05          6073     MOV R2 , # 5 
                      6074     
                      6075     DIRECT_START_PARAMS_SET: 
                      6076     ENDIF
17CB    C3            6077     	CLR	C
17CC    E538          6078     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
17CE    99            6079     SUBB A , R1 
17CF    4015          6080     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6081     
17D1    C263          6082     CLR FLAGS1 . 3 
17D3    D264          6083     SETB FLAGS1 . 4 
17D5    8A37          6084     MOV STARTUP_ROT_CNT , R2 
                      6085     IF MODE == 1	; Tail
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
                      6089     IF MODE == 2	; Multi
17D7    7888          6090     MOV R0 , # PGM_DIRECTION 
17D9    E6            6091     MOV A , @ R0 
17DA    B40306        6092     	CJNE	A, #3, DIRECT_START_PWM_LIM_SET
                      6093     
17DD    755EFF        6094     	MOV	PWM_LIMIT, #0FFH			; Allow full power in bidirectional operation
17E0    755FFF        6095     	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                      6096     
                      6097     DIRECT_START_PWM_LIM_SET: 
                      6098     ENDIF
17E3    0217F3        6099     	JMP	NORMAL_RUN_CHECKS
                      6100     
                      6101     DIRECT_START_CHECK_RCP: 
17E6    C3            6102     	CLR	C
17E7    E559          6103     	MOV	A, NEW_RCP				; Load new pulse value
17E9    9401          6104     SUBB A , # 1 
17EB    4003          6105     	JC	($+5)
                      6106     
17ED    0216FB        6107     	LJMP	RUN1						; Continue to run 
                      6108     
17F0    02182A        6109     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6110     
                      6111     
                      6112     NORMAL_RUN_CHECKS: 
                      6113     	; Check if it is initial run phase
17F3    306419        6114     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6115     
                      6116     	; Decrement startup rotaton count
17F6    E537          6117     	MOV	A, STARTUP_ROT_CNT
17F8    14            6118     	DEC	A
                      6119     	; Check number of nondamped rotations
17F9    7005          6120     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6121     
17FB    C264          6122     CLR FLAGS1 . 4 
17FD    0216F1        6123     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6124     
                      6125     NORMAL_RUN_CHECK_STARTUP_ROT: 
1800    F537          6126     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6127     
1802    C3            6128     	CLR	C
1803    E559          6129     	MOV	A, NEW_RCP				; Load new pulse value
1805    9401          6130     SUBB A , # 1 
1807    4003          6131     	JC	($+5)
                      6132     
1809    0216FB        6133     	LJMP	RUN1						; Continue to run 
                      6134     
180C    02182A        6135     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6136     
                      6137     
                      6138     INITIAL_RUN_PHASE_DONE: 
                      6139     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG		; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, AUTO_BAILOUT_ARMED	; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6152     	; Exit run loop after a given time
180F    C3            6153     	CLR	C
1810    E55C          6154     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter low byte value
1812    94FA          6155     SUBB A , # 250 
1814    5014          6156     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6157     
                      6158     RUN6_CHECK_RCP_TIMEOUT: 
1816    741F          6159     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1818    552E          6160     	ANL	A, FLAGS3					; Check pwm frequency flags
181A    7004          6161     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6162     
181C    E528          6163     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
181E    600A          6164     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6165     
                      6166     RUN6_CHECK_SPEED: 
1820    C3            6167     	CLR	C
1821    E53D          6168     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1823    94F0          6169     	SUBB	A, #0F0H
1825    5003          6170     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
1827    0216FB        6171     	JMP	RUN1						; Go back to run 1
                      6172     
                      6173     
                      6174     RUN_TO_WAIT_FOR_POWER_ON: 	
182A    C2AF          6175     	CLR	EA
182C    121161        6176     	CALL SWITCH_POWER_OFF
182F    7887          6177     MOV R0 , # PGM_PWM_FREQ 
1831    E6            6178     MOV A , @ R0 
1832    FE            6179     MOV R6 , A 
1833    7602          6180     MOV @ R0 , # 2 
1835    121244        6181     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
1838    7887          6182     MOV R0 , # PGM_PWM_FREQ 
183A    EE            6183     MOV A , R6 
183B    F6            6184     MOV @ R0 , A 
183C    E4            6185     	CLR	A
183D    F522          6186     	MOV	REQUESTED_PWM, A			; Set requested pwm to zero
183F    F523          6187     	MOV	GOVERNOR_REQ_PWM, A			; Set governor requested pwm to zero
1841    F524          6188     	MOV	CURRENT_PWM, A				; Set current pwm to zero
1843    F525          6189     	MOV	CURRENT_PWM_LIMITED, A		; Set limited current pwm to zero
1845    F561          6190     	MOV	PWM_MOTOR_IDLE, A			; Set motor idle to zero
1847    C260          6191     CLR FLAGS1 . 0 
1849    D2AF          6192     	SETB	EA
184B    120860        6193     	CALL	WAIT1MS					; Wait for pwm to be stopped
184E    121161        6194     	CALL SWITCH_POWER_OFF
                      6195     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3					; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN		; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1					; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON		; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START			; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                               ENDIF
                      6226     IF MODE >= 1	; Tail or multi
1851    741F          6227     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1853    552E          6228     	ANL	A, FLAGS3					; Check pwm frequency flags
1855    7007          6229     	JNZ	JMP_WAIT_FOR_POWER_ON		; If a flag is set (PWM) - branch
                      6230     
1857    E528          6231     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1859    7003          6232     	JNZ	JMP_WAIT_FOR_POWER_ON		; If it is not zero - go back to wait for poweron
                      6233     
185B    02142C        6234     	JMP	MEASURE_PWM_FREQ_INIT		; If it is zero (pulses missing) - go back to measure pwm frequency
                      6235     
                      6236     JMP_WAIT_FOR_POWER_ON: 
185E    0214D6        6237     	JMP	WAIT_FOR_POWER_ON			; Go back to wait for power on
                      6238     ENDIF
                      6239     
                      6240     
                      6241     END
MACRO ASSEMBLER BLHELI                                      05/26/15 15:16:12 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1800H   A 
COMP_WAIT_ON_COMP~  C ADDR   0EC0H   A 
CALC_NEXT_COMM_SL~  C ADDR   0D93H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0BE6H   A 
MEASURE_LIPO_WAIT~  C ADDR   0B58H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0B13H   A 
GOVERNOR_CORR_NEG~  C ADDR   0AD5H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
NHOLD_L. . . . . .  D ADDR   0076H   A 
HOLD_FULL_H. . . .  N NUMB   0002h            
PPM_THROTTLE_GAIN.  D ADDR   006EH   A 
LIPO_ADC_LIMIT_H .  D ADDR   006BH   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0000h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
INIT_START . . . .  C ADDR   1543H   A 
FIND_THROTTLE_GAI~  C ADDR   132BH   A 
COMM45_NFET. . . .  C ADDR   108DH   A 
COMM45_NONDAMP . .  C ADDR   108AH   A 
COMM4COMM5 . . . .  C ADDR   1068H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0DB8H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0C79H   A 
IF_STATE_FULL. . .  C ADDR   07A8H   A 
T2H_INT_RCP_STOP .  C ADDR   0512H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CEH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PREV_RCP . . . . .  D ADDR   0074H   A 
PWM_MOTOR_IDLE . .  D ADDR   0061H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PLATINUM_PRO_30A_~  N NUMB   009Dh            
DECODE_STARTUP_PO~  C ADDR   12FFH   A 
GOVERNOR_CHECK_PWM  C ADDR   0A62H   A 
GOVERNOR_ACTIVATE.  C ADDR   09B4H   A 
ENDIF_STATE_WAIT_~  C ADDR   0819H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0185H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0066H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
WAIT_FOR_POWER_ON.  C ADDR   14D6H   A 
SET_DEFAULT_PARAM~  C ADDR   11DEH   A 
COMM56_NONDAMP . .  C ADDR   10D0H   A 
COMM23_CP. . . . .  C ADDR   0FF9H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D3FH   A 
COMM5COMM6 . . . .  C ADDR   10A9H   A 
CALC_GOVERNOR_INT~  C ADDR   0AEDH   A 
CALC_GOVERNOR_TAR~  C ADDR   09EBH   A 
IF_CRUISE_NHOLD_N~  C ADDR   07FCH   A 
PCA_INT_STORE_DATA  C ADDR   0661H   A 
T2_INT_RCP_GAIN_P~  C ADDR   049DH   A 
T2_INT_RCP_UPDATE~  C ADDR   045EH   A 
RESET. . . . . . .  C ADDR   1348H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009FH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005FH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   1DFFh            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
SKYWALKER_20A_MAIN  N NUMB   005Bh            
STEPPER_ROT_BEG. .  C ADDR   162BH   A 
DECODE_THROTTLE_R~  C ADDR   12F1H   A 
STEPPER_STEP_MED_~  C ADDR   0D11H   A 
INITIALIZE_ALL_TI~  C ADDR   0CC5H   A 
STARTUP_PWM_SET_P~  C ADDR   0CB9H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_DIRECTION. . .  I ADDR   0088H   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
CSTATE . . . . . .  D ADDR   0078H   A 
HOLD_FULL_L. . . .  N NUMB   008Ah            
LIPO_ADC_LIMIT_L .  D ADDR   006AH   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
TURNIGY_PLUSH_12A~  N NUMB   0022h            
MEASURE_PWM_FREQ_~  C ADDR   142CH   A 
COMM61_CP. . . . .  C ADDR   113EH   A 
COMM_EXIT. . . . .  C ADDR   114DH   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0D9AH   A 
CALC_GOVERNOR_INT~  C ADDR   0AE6H   A 
PCA_INT_PPM_CHECK~  C ADDR   06BFH   A 
PCA_INT_PWM_DIVIDE  C ADDR   0765H   A 
PCA_INT_LIMITED. .  C ADDR   0788H   A 
T2_INT_PWM_UPDATE.  C ADDR   04A4H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0109H   A 
EEP_DUMMY. . . . .  C ADDR   1A22H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_PPM_CENTER_TH~  I ADDR   009EH   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   005Eh            
RUN1 . . . . . . .  C ADDR   16FBH   A 
CLEAR_RAM. . . . .  C ADDR   13A5H   A 
SET_BEC_VOLTAGE. .  C ADDR   131BH   A 
DECODE_GOVERNOR_G~  C ADDR   12D8H   A 
DEC_STEP_HIGH. . .  C ADDR   11A1H   A 
WAIT_FOR_COMM. . .  C ADDR   0F39H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0DE1H   A 
MEASURE_LIPO_ADD_~  C ADDR   0BD5H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A24H   A 
DIV_U16_BY_U16_DI~  C ADDR   0908H   A 
WAIT100MS. . . . .  C ADDR   0874H   A 
WAIT1MS. . . . . .  C ADDR   0860H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
PWM_FULL . . . . .  N NUMB   00FFh            
TX_PGM_BEEP_NO . .  D ADDR   0072H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0065H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
PLATINUM_PRO_30A_~  N NUMB   009Eh            
DIRECT_START_PWM_~  C ADDR   17E3H   A 
RUN2 . . . . . . .  C ADDR   1719H   A 
COMM45_CP. . . . .  C ADDR   10A0H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0E53H   A 
MEASURE_LIPO_UPDA~  C ADDR   0BDDH   A 
GOVERNOR_CORR_INT~  C ADDR   0B32H   A 
GOVERNOR_STORE_PR~  C ADDR   0A20H   A 
DIV_U16_BY_U16_DI~  C ADDR   0912H   A 
WAIT200MS. . . . .  C ADDR   0879H   A 
IF_CRUISE_NHOLD_L~  C ADDR   07E2H   A 
T2_INT_CURRENT_PW~  C ADDR   04B9H   A 
T2_INT_RCP_GAIN_C~  C ADDR   0494H   A 
T2_INT_PULSES_ABS~  C ADDR   0406H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   009Fh            
RUN3 . . . . . . .  C ADDR   1737H   A 
DIRECT_METHOD_STA~  C ADDR   159AH   A 
DECODE_DAMPING_DO~  C ADDR   1280H   A 
PWM_WAIT . . . . .  C ADDR   0EE5H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0C89H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0B1AH   A 
GOVERNOR_CHECK_IN~  C ADDR   0A4AH   A 
DIV_U16_BY_U16_DI~  C ADDR   0929H   A 
WAIT3MS. . . . . .  C ADDR   0865H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   005Ch            
JMP_WAIT_FOR_POWE~  C ADDR   185EH   A 
DIRECT_START_CHEC~  C ADDR   17E6H   A 
RUN4 . . . . . . .  C ADDR   1754H   A 
STORE_TIMES_UP_OR~  C ADDR   0E33H   A 
STORE_TIMES_DECRE~  C ADDR   0E46H   A 
STEPPER_STEP_SET .  C ADDR   0D2BH   A 
TEMP_AVERAGE_INC .  C ADDR   0C19H   A 
GOVERNOR_CORR_INT~  C ADDR   0B43H   A 
MULT_S16_BY_U8_DI~  C ADDR   0938H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0722H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0166H   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
PWM_IN_HIGH. . . .  N NUMB   0001h            
DEMAG_CONSECUTIVE~  D ADDR   0039H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_PPM_C~  N NUMB   007Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   0014h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   005Dh            
TURNIGY_PLUSH_12A~  N NUMB   0023h            
RUN5 . . . . . . .  C ADDR   1771H   A 
COMP_READ. . . . .  C ADDR   0EEBH   A 
COMP_WAIT_SET_RES~  C ADDR   0EACH   A 
DIVIDE_WAIT_TIMES.  C ADDR   0DE7H   A 
GOVERNOR_CORR_NEG~  C ADDR   0B37H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A15H   A 
GOVERNOR_TARGET_C~  C ADDR   0997H   A 
CALC_GOVERNOR_TAR~  C ADDR   098FH   A 
PCA_INT_PWM_DIVID~  C ADDR   076CH   A 
T2_INT_CURRENT_PW~  C ADDR   04DAH   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006FH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   005Fh            
TURNIGY_PLUSH_12A~  N NUMB   0024h            
RUN6 . . . . . . .  C ADDR   178EH   A 
ARMING_START . . .  C ADDR   149EH   A 
MEASURE_PWM_FREQ_~  C ADDR   1430H   A 
DECREMENT_STEP_EX~  C ADDR   11CEH   A 
COMM_RETURN. . . .  C ADDR   1160H   A 
GOVERNOR_DEACTIVA~  C ADDR   09A1H   A 
IF_FULL_NHOLD_NOT~  C ADDR   07CEH   A 
PCA_INT_CHECK_LEG~  C ADDR   077DH   A 
PWM_BNFET_APFET_O~  C ADDR   02FEH   A 
PWM_ANFET_BPFET_O~  C ADDR   0233H   A 
PWM_NOFET_ON . . .  C ADDR   01CDH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A1H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STATE_CRUISE . . .  N NUMB   0020h            
FLAG_BEFORE_ARM. .  D ADDR   0073H   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
RCP_UPDATED. . . .  N NUMB   0000h            
CURR_PWMOFF_COMP_~  N NUMB   0006h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
COMP_PWM_HIGH_ON_~  N NUMB   0018h            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYWALKER_40A_MUL~  N NUMB   0060h            
DP_3A_MAIN . . . .  N NUMB   0016h            
ARM_TARGET_UPDATED  C ADDR   14A8H   A 
EVALUATE_COMPARAT~  C ADDR   0EFAH   A 
TEMP_CHECK_EXIT. .  C ADDR   0C43H   A 
GOVERNOR_APPLY_PR~  C ADDR   0ABCH   A 
SET_PREV_RCP . . .  C ADDR   0819H   A 
PWM_CNFET_APFET_O~  C ADDR   0347H   A 
PWM_ANFET_CPFET_O~  C ADDR   027CH   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
NORMAL_RUN_CHECKS.  C ADDR   17F3H   A 
DEC_STEP_MED_LOW .  C ADDR   11BCH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E7BH   A 
WAIT_ADVANCE_TIMI~  C ADDR   0DAEH   A 
CALC_GOVERNOR_PRO~  C ADDR   09ECH   A 
PCA_INT_PPM_UNIDI~  C ADDR   071CH   A 
T2_INT_PPM_TIMEOU~  C ADDR   0447H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A0H   A 
PWM_BNFET_CPFET_O~  C ADDR   02BDH   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
WAIT_FOR_COMM_BLI~  C ADDR   0F53H   A 
ENDIF_INITIAL_ARM.  C ADDR   0819H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00DCH   A 
T0_INT . . . . . .  C ADDR   00BAH   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00FAh            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0007h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
DECODE_DEMAG_COMP.  C ADDR   130DH   A 
EVAL_COMP_EXIT . .  C ADDR   0F24H   A 
EVAL_COMP_NO_DEMAG  C ADDR   0F0CH   A 
STEPPER_STEP_LOW .  C ADDR   0D1FH   A 
MEASURE_LIPO_ADJU~  C ADDR   0B9AH   A 
IF_FULL_NHOLD_L_N~  C ADDR   07B4H   A 
PCA_INT_SET_TIMEO~  C ADDR   082CH   A 
PWM_AFET_ON. . . .  C ADDR   01CFH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CCH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
STEPPER_ROT_EXIT .  C ADDR   1699H   A 
STEPPER_METHOD_ST~  C ADDR   15DAH   A 
DECODE_PARAMS_DIR~  C ADDR   12BAH   A 
COMM12_DAMP. . . .  C ADDR   0F77H   A 
SETUP_COMM_WAIT. .  C ADDR   0F25H   A 
CALC_NEXT_COMM_TI~  C ADDR   0D38H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0C6FH   A 
CALC_GOVERNOR_INT~  C ADDR   0A81H   A 
ENDIF_STATE_CRUISE  C ADDR   0819H   A 
T2_INT_SET_CURREN~  C ADDR   04D7H   A 
PWM_BFET_ON. . . .  C ADDR   01E1H   A 
T2_INT . . . . . .  C ADDR   03E7H   A 
LIPO_ADC_REFERENC~  D ADDR   0069H   A 
AUTO_BAILOUT_ARMED  D ADDR   005DH   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
DP_3A_TAIL . . . .  N NUMB   0017h            
ARM_END_BEEP . . .  C ADDR   14B4H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E6CH   A 
LOAD_MIN_TIME. . .  C ADDR   0E03H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0DC2H   A 
SET_STARTUP_PWM. .  C ADDR   0C95H   A 
GOVERNOR_STORE_IN~  C ADDR   0A7BH   A 
GOVERNOR_ACTIVATE~  C ADDR   09DEH   A 
ELSE_INITIAL_ARM .  C ADDR   0819H   A 
PWM_CFET_ON. . . .  C ADDR   01F3H   A 
DEMAG_POWER_TABLE.  C ADDR   00A7H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   053CH   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   0071H   A 
ADC_CONVERSION_CNT  D ADDR   006CH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
HIGH_DRIVER_PRECH~  N NUMB   000Fh            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
DP_3A_MULTI. . . .  N NUMB   0018h            
RUN6_CHECK_RCP_TI~  C ADDR   1816H   A 
DECREMENT_STEP . .  C ADDR   117FH   A 
COMM23_DAMP. . . .  C ADDR   0FC9H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0F55H   A 
ADJUST_TIMING. . .  C ADDR   0E07H   A 
STEPPER_STEP_MED_~  C ADDR   0CF5H   A 
MEASURE_LIPO_DIVI~  C ADDR   0BBAH   A 
MEASURE_LIPO_START  C ADDR   0B48H   A 
CALC_GOVERNOR_PRO~  C ADDR   0AE5H   A 
GOVERNOR_INT_MIN_~  C ADDR   0A76H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0A1CH   A 
BEEP_F1. . . . . .  C ADDR   0890H   A 
WAIT1S_LOOP. . . .  C ADDR   088BH   A 
END_PROCEDURE_GET~  C ADDR   0797H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006DH   A 
PWM_OFF_CNT. . . .  D ADDR   0063H   A 
PWM_SPOOLUP_BEG. .  D ADDR   0060H   A 
PWM_LIMIT. . . . .  D ADDR   005EH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
LOCK_BYTE_ADDRESS~  N NUMB   3FFFh            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
INITIAL_RUN_PHASE~  C ADDR   180FH   A 
TEST_THROTTLE_GAIN  C ADDR   1339H   A 
STEPPER_STEP_MED .  C ADDR   0D03H   A 
GOVERNOR_STORE_PR~  C ADDR   0AE3H   A 
GOVERNOR_CHECK_PR~  C ADDR   0AA7H   A 
MULT_S16_BY_U8_PO~  C ADDR   0952H   A 
DIV_U16_BY_U16 . .  C ADDR   0900H   A 
BEEP_ONOFF . . . .  C ADDR   08B3H   A 
BEEP_F2. . . . . .  C ADDR   0897H   A 
IF_CRUISE_NHOLD_T~  C ADDR   07F0H   A 
ELSE_STATE_CRUISE.  C ADDR   07FFH   A 
ELSE_FLAG_BEFORE_~  C ADDR   07A3H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F2H   A 
PCA_INT_CHECK_DIFF  C ADDR   0654H   A 
T2_INT_SKIP_START.  C ADDR   044BH   A 
T0_INT_PWM_OFF_FU~  C ADDR   01C6H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0011h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
STATE_FULL . . . .  N NUMB   0010h            
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
TURNIGY_KFORCE_40~  N NUMB   004Ch            
FIND_THROTTLE_GAIN  C ADDR   131CH   A 
DECREMENT_STEPPER~  C ADDR   1173H   A 
COMM61_DAMP. . . .  C ADDR   10FEH   A 
COMM34_DAMP. . . .  C ADDR   101DH   A 
TEMP_AVERAGE_INC_~  C ADDR   0C09H   A 
GOVERNOR_INT_MAX_~  C ADDR   0A6FH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A53H   A 
BEEP_F3. . . . . .  C ADDR   089EH   A 
SET_PWM_IN_HIGH. .  C ADDR   0793H   A 
PCA_INT_FAIL_MINI~  C ADDR   0585H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E0H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01B6H   A 
LIPO_ADC_REFERENC~  D ADDR   0068H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0064H   A 
PWM_ON_CNT . . . .  D ADDR   0062H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0005h            
COMM_TIME_RED. . .  N NUMB   000Ah            
P1_INIT. . . . . .  N NUMB   00A9h            
TEMP_LIMIT . . . .  N NUMB   006Dh            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
DAMPED_TRANSITION.  C ADDR   16F1H   A 
BEEP_DELAY_SET . .  C ADDR   14FEH   A 
LOCK_BYTE_OK . . .  C ADDR   1367H   A 
DECODE_PWM_FREQ_L~  C ADDR   12D2H   A 
DECODE_DAMPING_3 .  C ADDR   1258H   A 
CALC_NEW_WAIT_RED~  C ADDR   0DD2H   A 
BEEP_F4. . . . . .  C ADDR   08A5H   A 
SET_PWM_IN . . . .  C ADDR   0795H   A 
PCA_INT_PPM_MAX_C~  C ADDR   074CH   A 
PCA_INT_RESTORE_E~  C ADDR   0640H   A 
T2H_INT_RCP_EXIT .  C ADDR   0530H   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A2H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
STATE_WAIT . . . .  N NUMB   0000h            
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
DIRECT_START_PARA~  C ADDR   17CBH   A 
DECODE_DAMPING_4 .  C ADDR   1262H   A 
COMM45_DAMP. . . .  C ADDR   1070H   A 
WAIT_FOR_COMM_SET~  C ADDR   0F65H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0C21H   A 
GOVERNOR_APPLY_IN~  C ADDR   0B1EH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0AB2H   A 
BEEP_OFF . . . . .  C ADDR   08F4H   A 
WAIT10MS . . . . .  C ADDR   086AH   A 
PCA_INT_PPM_BIDIR~  C ADDR   06F9H   A 
T2H_INT_RCP_NO_LI~  C ADDR   052EH   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D3H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Bh            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   0070H   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   00DFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
RESET_CAL_DONE . .  C ADDR   1383H   A 
DECODE_DAMPING_5 .  C ADDR   126CH   A 
DECODE_PARAMETERS.  C ADDR   1244H   A 
STEPPER_TIMER_WAIT  C ADDR   11D8H   A 
STORE_TIMES_INCRE~  C ADDR   0E39H   A 
CHECK_VOLTAGE_GOOD  C ADDR   0C68H   A 
MEASURE_LIPO_CELLS  C ADDR   0B48H   A 
CALC_GOVERNOR_INT~  C ADDR   0A25H   A 
IF_INITIAL_ARM . .  C ADDR   0808H   A 
PCA_INT_PPM_CALCU~  C ADDR   06CFH   A 
PCA_INT_EXIT . . .  C ADDR   0846H   A 
T2_INT_RCP_UPDATE~  C ADDR   047CH   A 
T0_INT_PWM_OFF_DO~  C ADDR   012DH   A 
THR_DELTA. . . . .  N NUMB   0002h            
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
RUN6_CHECK_SPEED .  C ADDR   1820H   A 
WAIT_FOR_POWER_ON~  C ADDR   152AH   A 
DECODE_DAMPING_6 .  C ADDR   1276H   A 
DEC_STEP_LOW . . .  C ADDR   11C5H   A 
COMM56_DAMP. . . .  C ADDR   10BBH   A 
SWITCH_POWER_OFF .  C ADDR   1161H   A 
WAIT30MS . . . . .  C ADDR   086FH   A 
ENDIF_STATE_FULL .  C ADDR   0819H   A 
PCA_INT_PPM_BIDIR~  C ADDR   073DH   A 
PCA_INT_CHECK_1KHZ  C ADDR   0631H   A 
T2H_INT. . . . . .  C ADDR   04F6H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017BH   A 
HOLD_CRUISE_H. . .  N NUMB   0029h            
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
TURNIGY_KFORCE_40~  N NUMB   004Dh            
RUN_TO_WAIT_FOR_P~  C ADDR   182AH   A 
EVAL_COMP_CHECK_T~  C ADDR   0F1AH   A 
ADJUST_TIMING_TWO~  C ADDR   0E29H   A 
CHECK_VOLTAGE_RET.  C ADDR   0C94H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A89H   A 
GOVERNOR_ACTIVATE~  C ADDR   09E5H   A 
WAIT1S . . . . . .  C ADDR   0889H   A 
WAITXMS_M. . . . .  C ADDR   0880H   A 
IF_STATE_CRUISE. .  C ADDR   07D6H   A 
IF_FLAG_BEFORE_ARM  C ADDR   079CH   A 
PCA_INT_CHECK_2KHZ  C ADDR   0620H   A 
T0_INT_PWM_OFF_ST~  C ADDR   0100H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
NPWMIN . . . . . .  D ADDR   0075H   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
TURNIGY_KFORCE_40~  N NUMB   004Eh            
READ_INITIAL_TEMP.  C ADDR   1579H   A 
WAIT_FOR_POWER_ON~  C ADDR   151BH   A 
DECODE_PWM_FREQ_E~  C ADDR   12D7H   A 
WAIT_FOR_COMM_WAIT  C ADDR   0F67H   A 
PWM_WAIT_STARTUP .  C ADDR   0EE0H   A 
START_ADC_CONVERS~  C ADDR   0BE2H   A 
MULT_S16_BY_U8_EX~  C ADDR   0986H   A 
PCA_INT_PPM_LIMIT~  C ADDR   075EH   A 
T2H_INT_RCP_GOV_P~  C ADDR   0523H   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A4H   A 
PWM_BNFET_APFET_O~  C ADDR   02E0H   A 
PWM_ANFET_BPFET_O~  C ADDR   020DH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0195H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
MUX_A. . . . . . .  N NUMB   0002h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
VALIDATE_RCP_START  C ADDR   1466H   A 
LOCK_BYTE_TEST . .  C ADDR   1360H   A 
DEC_STEP_MED_HIGH.  C ADDR   11AAH   A 
COMM_RESTORE_POWER  C ADDR   115EH   A 
COMM12_NONDAMP . .  C ADDR   0F8CH   A 
COMM1COMM2 . . . .  C ADDR   0F6DH   A 
TEMP_AVERAGE_UPDA~  C ADDR   0C1FH   A 
TEMP_AVERAGE_DEC .  C ADDR   0C15H   A 
CALC_GOVERNOR_PRO~  C ADDR   0A82H   A 
WAITXMS_O. . . . .  C ADDR   087EH   A 
PCA_INT_PPM_TIMEO~  C ADDR   0838H   A 
IF_FULL_NHOLD_TIM~  C ADDR   07C2H   A 
ELES_STATE_FULL. .  C ADDR   07D1H   A 
PCA_INT_CHECK_4KHZ  C ADDR   060FH   A 
PWM_CNFET_APFET_O~  C ADDR   0321H   A 
PWM_ANFET_CPFET_O~  C ADDR   025EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   01A7H   A 
T0_INT_PWM_ON_STO~  C ADDR   00D0H   A 
T0_INT_PWM_OFF . .  C ADDR   00D3H   A 
EEPROM_FW_SUB_REV~  N NUMB   0002h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
PWM_IN_LOW . . . .  N NUMB   0000h            
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0014h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
MUX_B. . . . . . .  N NUMB   0000h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0007h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
WAIT_FOR_POWER_ON~  C ADDR   14DBH   A 
DEC_STEP_MED . . .  C ADDR   11B3H   A 
READ_TIMER . . . .  C ADDR   0D43H   A 
CHECK_VOLTAGE_STA~  C ADDR   0C47H   A 
CALC_GOVERNOR_INT~  C ADDR   0B47H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A5CH   A 
MULT_S16_BY_U8_DI~  C ADDR   096BH   A 
BEEP . . . . . . .  C ADDR   08ACH   A 
PROCEDURE_GETPWM .  C ADDR   0788H   A 
PCA_INT_PPM_BIDIR~  C ADDR   0707H   A 
PCA_INT_FALL . . .  C ADDR   066DH   A 
T2_INT_PWM_EXIT. .  C ADDR   04E7H   A 
T2_INT_SKIP_END. .  C ADDR   0453H   A 
PWM_CNFET_BPFET_O~  C ADDR   0372H   A 
PWM_BNFET_CPFET_O~  C ADDR   029FH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0144H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00AAH   A 
PGM_GOV_I_GAIN_DE~  I ADDR   00A0H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
NHOLD_H. . . . . .  D ADDR   0077H   A 
HOLD_CRUISE_L. . .  N NUMB   0004h            
DAMPING_ON . . . .  D ADDR   0067H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
COMM23_NFET. . . .  C ADDR   0FE6H   A 
COMM23_NONDAMP . .  C ADDR   0FE3H   A 
COMM2COMM3 . . . .  C ADDR   0FC1H   A 
STEPPER_STEP_HIGH.  C ADDR   0CE7H   A 
MEASURE_LIPO_CELL~  C ADDR   0B7FH   A 
GOVERNOR_STORE_IN~  C ADDR   0B45H   A 
GOVERNOR_CHECK_IN~  C ADDR   0B07H   A 
GOVERNOR_CORR_PRO~  C ADDR   0AD0H   A 
GOVERNOR_ACTIVATE~  C ADDR   09D2H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_DIRECTION.  C ADDR   1A0BH   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
COMP_PWM_LOW_ON_D~  N NUMB   0008h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
MEASURE_LIPO_EXIT.  C ADDR   0BE1H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0AB8H   A 
GOVERNOR_CHECK_PR~  C ADDR   0A09H   A 
LINE_TEMP01. . . .  C ADDR   05A1H   A 
PCA_INT_SECOND_ME~  C ADDR   05B3H   A 
T2H_INT_RCP_STOP_~  C ADDR   0506H   A 
PCA_INT. . . . . .  C ADDR   0546H   A 
EEP_PGM_PPM_CENTE~  C ADDR   1A21H   A 
PWM_CRUISE . . . .  N NUMB   007Fh            
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   00FCh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
MEASURE_PWM_FREQ_~  C ADDR   142EH   A 
COMM61_NFET. . . .  C ADDR   1123H   A 
COMM61_NONDAMP . .  C ADDR   1120H   A 
COMM6COMM1 . . . .  C ADDR   10F6H   A 
COMM34_NONDAMP . .  C ADDR   102AH   A 
COMM3COMM4 . . . .  C ADDR   100BH   A 
COMP_WAIT_SET_MAX~  C ADDR   0E99H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0E75H   A 
STARTUP_PWM_EXIT .  C ADDR   0CC4H   A 
MEASURE_LIPO_LIMI~  C ADDR   0BD1H   A 
GOVERNOR_CORR_PRO~  C ADDR   0AE1H   A 
PCA_INT_PPM_BIDIR~  C ADDR   06E9H   A 
PCA_INT_CHECK_8KHZ  C ADDR   05FEH   A 
LINE_TEMP02. . . .  C ADDR   05AFH   A 
T0_INT_PWM_OFF_CL~  C ADDR   0127H   A 
THR_SWITCH . . . .  N NUMB   00A0h            
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6211    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     88    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
